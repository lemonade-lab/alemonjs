var ActionsEventEnum = /* @__PURE__ */ ((e) => (e.MessageRecall = "message.recall", e.MessageDelete = "message.delete", e.MessageCreate = "message.create", e.MessageEdit = "message.edit", e.MessageList = "message.list", e.MessageTop = "message.top", e.MessageUntop = "message.untop", e.MessageLike = "message.like", e.MessageUnlike = "message.unlike", e.GuildCreate = "guild.create", e.GuildDelete = "guild.delete", e.GuildEdit = "guild.edit", e.GuildQuit = "guild.quit", e.GuildJoin = "guild.join", e.MemberList = "member.list", e.MemberAdd = "member.add", e.MemberDelete = "member.delete", e.MemberEdit = "member.edit", e.RoleAdd = "role.add", e.RoleDelete = "role.delete", e.RoleEdit = "role.edit", e.RoleList = "role.list", e.ChannelCreate = "channel.create", e.ChannelDelete = "channel.delete", e.ChannelEdit = "channel.edit", e.ChannelList = "channel.list", e.CategoryCreate = "category.create", e.CategoryDelete = "category.delete", e.CategoryEdit = "category.edit", e.CategoryList = "category.list", e.MemberKickOut = "member.kickOut", e.MemberBan = "member.ban", e.MemberUnban = "member.unban", e))(ActionsEventEnum || {});
const processorRepeatedEventTime = 1e3 * 60, processorRepeatedUserTime = 1e3 * 1, processorRepeatedClearTimeMin = 1e3 * 3, processorRepeatedClearTimeMax = 1e3 * 10, processorPepeatedClearSize = 37, fileSuffixMiddleware = /^mw(\.|\..*\.)(js|ts|jsx|tsx)$/, fileSuffixResponse = /^res(\.|\..*\.)(js|ts|jsx|tsx)$/, filePrefixCommon = /^(@alemonjs\/|alemonjs-)/, defaultPort = 17117, defaultPlatformCommonPrefix = "@alemonjs/", Ok = 2e3, Warn = 2100, Fail = 4e3, FailParams = 4001, FailAuth = 4002, FailInternal = 5e3, EventMessageText = ["message.create", "private.message.create", "interaction.create", "private.interaction.create"], ResultCode = {
  Ok,
  Fail,
  FailParams,
  Warn,
  FailAuth,
  FailInternal
};
function getDefaultExportFromCjs$1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var browser$j = { exports: {} }, process = browser$j.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var t = queue.length; t; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < t; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, t = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  queue.push(new Item(e, t)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, t) {
  this.fun = e, this.array = t;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {
}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(e) {
  return [];
};
process.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$j.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1), existsSync = (e) => (console.warn(`[AlemonJS Browser] fs.existsSync('${e}') is not available in browser, returning false`), !1), readFileSync = (e, t) => (console.warn(`[AlemonJS Browser] fs.readFileSync('${e}') is not available in browser, returning empty string`), ""), writeFileSync = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.writeFileSync('${e}') is not available in browser, operation skipped`);
}, mkdirSync = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.mkdirSync('${e}') is not available in browser, operation skipped`);
}, watch = (e, t) => (console.warn(`[AlemonJS Browser] fs.watch('${e}') is not available in browser, returning mock watcher`), {
  close: () => {
    console.warn("[AlemonJS Browser] Mock fs.watch close() called");
  },
  on: (r, a) => {
    console.warn(`[AlemonJS Browser] Mock fs.watch on('${r}') called`);
  },
  ref: () => {
    console.warn("[AlemonJS Browser] Mock fs.watch ref() called");
  },
  unref: () => {
    console.warn("[AlemonJS Browser] Mock fs.watch unref() called");
  }
}), readdirSync = (e) => (console.warn(`[AlemonJS Browser] fs.readdirSync('${e}') is not available in browser, returning empty array`), []), statSync = (e) => (console.warn(`[AlemonJS Browser] fs.statSync('${e}') is not available in browser, returning mock stats`), {
  isDirectory: () => !1,
  isFile: () => !1,
  isBlockDevice: () => !1,
  isCharacterDevice: () => !1,
  isSymbolicLink: () => !1,
  isFIFO: () => !1,
  isSocket: () => !1,
  dev: 0,
  ino: 0,
  mode: 0,
  nlink: 0,
  uid: 0,
  gid: 0,
  rdev: 0,
  size: 0,
  blksize: 0,
  blocks: 0,
  atimeMs: 0,
  mtimeMs: 0,
  ctimeMs: 0,
  birthtimeMs: 0,
  atime: /* @__PURE__ */ new Date(),
  mtime: /* @__PURE__ */ new Date(),
  ctime: /* @__PURE__ */ new Date(),
  birthtime: /* @__PURE__ */ new Date()
}), unlinkSync = (e) => {
  console.warn(`[AlemonJS Browser] fs.unlinkSync('${e}') is not available in browser, operation skipped`);
}, rmdirSync = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.rmdirSync('${e}') is not available in browser, operation skipped`);
}, renameSync = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.renameSync('${e}', '${t}') is not available in browser, operation skipped`);
}, copyFileSync = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.copyFileSync('${e}', '${t}') is not available in browser, operation skipped`);
}, appendFileSync = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.appendFileSync('${e}') is not available in browser, operation skipped`);
}, writeFile = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.writeFile('${e}') is not available in browser, operation skipped`), r && setTimeout(() => r(null), 0);
}, readFile = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.readFile('${e}') is not available in browser, returning empty data`), r && setTimeout(() => r(null, ""), 0);
}, mkdir = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.mkdir('${e}') is not available in browser, operation skipped`), r && setTimeout(() => r(null), 0);
}, unlink = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.unlink('${e}') is not available in browser, operation skipped`), t && setTimeout(() => t(null), 0);
}, rmdir = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.rmdir('${e}') is not available in browser, operation skipped`), t && setTimeout(() => t(null), 0);
}, rename = (e, t, r) => {
  console.warn(`[AlemonJS Browser] fs.rename('${e}', '${t}') is not available in browser, operation skipped`), r && setTimeout(() => r(null), 0);
}, promises = {
  writeFile: async (e, t) => (console.warn(`[AlemonJS Browser] fs.promises.writeFile('${e}') is not available in browser, operation skipped`), Promise.resolve()),
  readFile: async (e, t) => (console.warn(`[AlemonJS Browser] fs.promises.readFile('${e}') is not available in browser, returning empty string`), Promise.resolve("")),
  mkdir: async (e, t) => (console.warn(`[AlemonJS Browser] fs.promises.mkdir('${e}') is not available in browser, operation skipped`), Promise.resolve()),
  readdir: async (e) => (console.warn(`[AlemonJS Browser] fs.promises.readdir('${e}') is not available in browser, returning empty array`), Promise.resolve([])),
  stat: async (e) => (console.warn(`[AlemonJS Browser] fs.promises.stat('${e}') is not available in browser, returning mock stats`), Promise.resolve(statSync(e))),
  unlink: async (e) => (console.warn(`[AlemonJS Browser] fs.promises.unlink('${e}') is not available in browser, operation skipped`), Promise.resolve()),
  rmdir: async (e) => (console.warn(`[AlemonJS Browser] fs.promises.rmdir('${e}') is not available in browser, operation skipped`), Promise.resolve())
}, createReadStream = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.createReadStream('${e}') is not available in browser, returning mock stream`);
  const r = {
    on: (a, u) => (a === "error" && setTimeout(() => u(new Error(`Cannot create read stream for ${e} in browser`)), 0), r),
    pipe: () => r,
    destroy: () => {
    },
    pause: () => r,
    resume: () => r
  };
  return r;
}, createWriteStream = (e, t) => {
  console.warn(`[AlemonJS Browser] fs.createWriteStream('${e}') is not available in browser, returning mock stream`);
  const r = {
    write: (a) => (console.warn(`[AlemonJS Browser] Mock write stream write() called for ${e}`), !0),
    end: () => {
      console.warn(`[AlemonJS Browser] Mock write stream end() called for ${e}`);
    },
    on: (a, u) => r,
    destroy: () => {
    },
    pipe: () => r
  };
  return r;
}, constants$2 = {
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_DSYNC: 4096,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048
}, fs = {
  existsSync,
  readFileSync,
  writeFileSync,
  mkdirSync,
  watch,
  readdirSync,
  statSync,
  unlinkSync,
  rmdirSync,
  renameSync,
  copyFileSync,
  appendFileSync,
  writeFile,
  readFile,
  mkdir,
  unlink,
  rmdir,
  rename,
  promises,
  createReadStream,
  createWriteStream,
  constants: constants$2
}, fs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  appendFileSync,
  constants: constants$2,
  copyFileSync,
  createReadStream,
  createWriteStream,
  default: fs,
  existsSync,
  mkdir,
  mkdirSync,
  promises,
  readFile,
  readFileSync,
  readdirSync,
  rename,
  renameSync,
  rmdir,
  rmdirSync,
  statSync,
  unlink,
  unlinkSync,
  watch,
  writeFile,
  writeFileSync
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function a() {
      var u = !1;
      try {
        u = this instanceof a;
      } catch {
      }
      return u ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(a) {
    var u = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(r, a, u.get ? u : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), r;
}
var pathBrowserify, hasRequiredPathBrowserify;
function requirePathBrowserify() {
  if (hasRequiredPathBrowserify) return pathBrowserify;
  hasRequiredPathBrowserify = 1;
  function e(u) {
    if (typeof u != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(u));
  }
  function t(u, n) {
    for (var o = "", c = 0, f = -1, l = 0, s, p = 0; p <= u.length; ++p) {
      if (p < u.length)
        s = u.charCodeAt(p);
      else {
        if (s === 47)
          break;
        s = 47;
      }
      if (s === 47) {
        if (!(f === p - 1 || l === 1)) if (f !== p - 1 && l === 2) {
          if (o.length < 2 || c !== 2 || o.charCodeAt(o.length - 1) !== 46 || o.charCodeAt(o.length - 2) !== 46) {
            if (o.length > 2) {
              var m = o.lastIndexOf("/");
              if (m !== o.length - 1) {
                m === -1 ? (o = "", c = 0) : (o = o.slice(0, m), c = o.length - 1 - o.lastIndexOf("/")), f = p, l = 0;
                continue;
              }
            } else if (o.length === 2 || o.length === 1) {
              o = "", c = 0, f = p, l = 0;
              continue;
            }
          }
          n && (o.length > 0 ? o += "/.." : o = "..", c = 2);
        } else
          o.length > 0 ? o += "/" + u.slice(f + 1, p) : o = u.slice(f + 1, p), c = p - f - 1;
        f = p, l = 0;
      } else s === 46 && l !== -1 ? ++l : l = -1;
    }
    return o;
  }
  function r(u, n) {
    var o = n.dir || n.root, c = n.base || (n.name || "") + (n.ext || "");
    return o ? o === n.root ? o + c : o + u + c : c;
  }
  var a = {
    // path.resolve([from ...], to)
    resolve: function() {
      for (var n = "", o = !1, c, f = arguments.length - 1; f >= -1 && !o; f--) {
        var l;
        f >= 0 ? l = arguments[f] : (c === void 0 && (c = process$1.cwd()), l = c), e(l), l.length !== 0 && (n = l + "/" + n, o = l.charCodeAt(0) === 47);
      }
      return n = t(n, !o), o ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
    },
    normalize: function(n) {
      if (e(n), n.length === 0) return ".";
      var o = n.charCodeAt(0) === 47, c = n.charCodeAt(n.length - 1) === 47;
      return n = t(n, !o), n.length === 0 && !o && (n = "."), n.length > 0 && c && (n += "/"), o ? "/" + n : n;
    },
    isAbsolute: function(n) {
      return e(n), n.length > 0 && n.charCodeAt(0) === 47;
    },
    join: function() {
      if (arguments.length === 0)
        return ".";
      for (var n, o = 0; o < arguments.length; ++o) {
        var c = arguments[o];
        e(c), c.length > 0 && (n === void 0 ? n = c : n += "/" + c);
      }
      return n === void 0 ? "." : a.normalize(n);
    },
    relative: function(n, o) {
      if (e(n), e(o), n === o || (n = a.resolve(n), o = a.resolve(o), n === o)) return "";
      for (var c = 1; c < n.length && n.charCodeAt(c) === 47; ++c)
        ;
      for (var f = n.length, l = f - c, s = 1; s < o.length && o.charCodeAt(s) === 47; ++s)
        ;
      for (var p = o.length, m = p - s, g = l < m ? l : m, y = -1, v = 0; v <= g; ++v) {
        if (v === g) {
          if (m > g) {
            if (o.charCodeAt(s + v) === 47)
              return o.slice(s + v + 1);
            if (v === 0)
              return o.slice(s + v);
          } else l > g && (n.charCodeAt(c + v) === 47 ? y = v : v === 0 && (y = 0));
          break;
        }
        var E = n.charCodeAt(c + v), b = o.charCodeAt(s + v);
        if (E !== b)
          break;
        E === 47 && (y = v);
      }
      var q = "";
      for (v = c + y + 1; v <= f; ++v)
        (v === f || n.charCodeAt(v) === 47) && (q.length === 0 ? q += ".." : q += "/..");
      return q.length > 0 ? q + o.slice(s + y) : (s += y, o.charCodeAt(s) === 47 && ++s, o.slice(s));
    },
    _makeLong: function(n) {
      return n;
    },
    dirname: function(n) {
      if (e(n), n.length === 0) return ".";
      for (var o = n.charCodeAt(0), c = o === 47, f = -1, l = !0, s = n.length - 1; s >= 1; --s)
        if (o = n.charCodeAt(s), o === 47) {
          if (!l) {
            f = s;
            break;
          }
        } else
          l = !1;
      return f === -1 ? c ? "/" : "." : c && f === 1 ? "//" : n.slice(0, f);
    },
    basename: function(n, o) {
      if (o !== void 0 && typeof o != "string") throw new TypeError('"ext" argument must be a string');
      e(n);
      var c = 0, f = -1, l = !0, s;
      if (o !== void 0 && o.length > 0 && o.length <= n.length) {
        if (o.length === n.length && o === n) return "";
        var p = o.length - 1, m = -1;
        for (s = n.length - 1; s >= 0; --s) {
          var g = n.charCodeAt(s);
          if (g === 47) {
            if (!l) {
              c = s + 1;
              break;
            }
          } else
            m === -1 && (l = !1, m = s + 1), p >= 0 && (g === o.charCodeAt(p) ? --p === -1 && (f = s) : (p = -1, f = m));
        }
        return c === f ? f = m : f === -1 && (f = n.length), n.slice(c, f);
      } else {
        for (s = n.length - 1; s >= 0; --s)
          if (n.charCodeAt(s) === 47) {
            if (!l) {
              c = s + 1;
              break;
            }
          } else f === -1 && (l = !1, f = s + 1);
        return f === -1 ? "" : n.slice(c, f);
      }
    },
    extname: function(n) {
      e(n);
      for (var o = -1, c = 0, f = -1, l = !0, s = 0, p = n.length - 1; p >= 0; --p) {
        var m = n.charCodeAt(p);
        if (m === 47) {
          if (!l) {
            c = p + 1;
            break;
          }
          continue;
        }
        f === -1 && (l = !1, f = p + 1), m === 46 ? o === -1 ? o = p : s !== 1 && (s = 1) : o !== -1 && (s = -1);
      }
      return o === -1 || f === -1 || // We saw a non-dot character immediately before the dot
      s === 0 || // The (right-most) trimmed path component is exactly '..'
      s === 1 && o === f - 1 && o === c + 1 ? "" : n.slice(o, f);
    },
    format: function(n) {
      if (n === null || typeof n != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof n);
      return r("/", n);
    },
    parse: function(n) {
      e(n);
      var o = { root: "", dir: "", base: "", ext: "", name: "" };
      if (n.length === 0) return o;
      var c = n.charCodeAt(0), f = c === 47, l;
      f ? (o.root = "/", l = 1) : l = 0;
      for (var s = -1, p = 0, m = -1, g = !0, y = n.length - 1, v = 0; y >= l; --y) {
        if (c = n.charCodeAt(y), c === 47) {
          if (!g) {
            p = y + 1;
            break;
          }
          continue;
        }
        m === -1 && (g = !1, m = y + 1), c === 46 ? s === -1 ? s = y : v !== 1 && (v = 1) : s !== -1 && (v = -1);
      }
      return s === -1 || m === -1 || // We saw a non-dot character immediately before the dot
      v === 0 || // The (right-most) trimmed path component is exactly '..'
      v === 1 && s === m - 1 && s === p + 1 ? m !== -1 && (p === 0 && f ? o.base = o.name = n.slice(1, m) : o.base = o.name = n.slice(p, m)) : (p === 0 && f ? (o.name = n.slice(1, s), o.base = n.slice(1, m)) : (o.name = n.slice(p, s), o.base = n.slice(p, m)), o.ext = n.slice(s, m)), p > 0 ? o.dir = n.slice(0, p - 1) : f && (o.dir = "/"), o;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  return a.posix = a, pathBrowserify = a, pathBrowserify;
}
var pathBrowserifyExports = requirePathBrowserify();
const path = /* @__PURE__ */ getDefaultExportFromCjs(pathBrowserifyExports), ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR$1 = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isAlias = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === ALIAS, isDocument = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === DOC, isMap = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === MAP, isPair = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === PAIR, isScalar$1 = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === SCALAR$1, isSeq = (e) => !!e && typeof e == "object" && e[NODE_TYPE] === SEQ;
function isCollection$1(e) {
  if (e && typeof e == "object")
    switch (e[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return !0;
    }
  return !1;
}
function isNode(e) {
  if (e && typeof e == "object")
    switch (e[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return !0;
    }
  return !1;
}
const hasAnchor = (e) => (isScalar$1(e) || isCollection$1(e)) && !!e.anchor, BREAK$1 = Symbol("break visit"), SKIP$1 = Symbol("skip children"), REMOVE$1 = Symbol("remove node");
function visit$1(e, t) {
  const r = initVisitor(t);
  isDocument(e) ? visit_(null, e.contents, r, Object.freeze([e])) === REMOVE$1 && (e.contents = null) : visit_(null, e, r, Object.freeze([]));
}
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(e, t, r, a) {
  const u = callVisitor(e, t, r, a);
  if (isNode(u) || isPair(u))
    return replaceNode(e, a, u), visit_(e, u, r, a);
  if (typeof u != "symbol") {
    if (isCollection$1(t)) {
      a = Object.freeze(a.concat(t));
      for (let n = 0; n < t.items.length; ++n) {
        const o = visit_(n, t.items[n], r, a);
        if (typeof o == "number")
          n = o - 1;
        else {
          if (o === BREAK$1)
            return BREAK$1;
          o === REMOVE$1 && (t.items.splice(n, 1), n -= 1);
        }
      }
    } else if (isPair(t)) {
      a = Object.freeze(a.concat(t));
      const n = visit_("key", t.key, r, a);
      if (n === BREAK$1)
        return BREAK$1;
      n === REMOVE$1 && (t.key = null);
      const o = visit_("value", t.value, r, a);
      if (o === BREAK$1)
        return BREAK$1;
      o === REMOVE$1 && (t.value = null);
    }
  }
  return u;
}
async function visitAsync(e, t) {
  const r = initVisitor(t);
  isDocument(e) ? await visitAsync_(null, e.contents, r, Object.freeze([e])) === REMOVE$1 && (e.contents = null) : await visitAsync_(null, e, r, Object.freeze([]));
}
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(e, t, r, a) {
  const u = await callVisitor(e, t, r, a);
  if (isNode(u) || isPair(u))
    return replaceNode(e, a, u), visitAsync_(e, u, r, a);
  if (typeof u != "symbol") {
    if (isCollection$1(t)) {
      a = Object.freeze(a.concat(t));
      for (let n = 0; n < t.items.length; ++n) {
        const o = await visitAsync_(n, t.items[n], r, a);
        if (typeof o == "number")
          n = o - 1;
        else {
          if (o === BREAK$1)
            return BREAK$1;
          o === REMOVE$1 && (t.items.splice(n, 1), n -= 1);
        }
      }
    } else if (isPair(t)) {
      a = Object.freeze(a.concat(t));
      const n = await visitAsync_("key", t.key, r, a);
      if (n === BREAK$1)
        return BREAK$1;
      n === REMOVE$1 && (t.key = null);
      const o = await visitAsync_("value", t.value, r, a);
      if (o === BREAK$1)
        return BREAK$1;
      o === REMOVE$1 && (t.value = null);
    }
  }
  return u;
}
function initVisitor(e) {
  return typeof e == "object" && (e.Collection || e.Node || e.Value) ? Object.assign({
    Alias: e.Node,
    Map: e.Node,
    Scalar: e.Node,
    Seq: e.Node
  }, e.Value && {
    Map: e.Value,
    Scalar: e.Value,
    Seq: e.Value
  }, e.Collection && {
    Map: e.Collection,
    Seq: e.Collection
  }, e) : e;
}
function callVisitor(e, t, r, a) {
  if (typeof r == "function")
    return r(e, t, a);
  if (isMap(t))
    return r.Map?.(e, t, a);
  if (isSeq(t))
    return r.Seq?.(e, t, a);
  if (isPair(t))
    return r.Pair?.(e, t, a);
  if (isScalar$1(t))
    return r.Scalar?.(e, t, a);
  if (isAlias(t))
    return r.Alias?.(e, t, a);
}
function replaceNode(e, t, r) {
  const a = t[t.length - 1];
  if (isCollection$1(a))
    a.items[e] = r;
  else if (isPair(a))
    e === "key" ? a.key = r : a.value = r;
  else if (isDocument(a))
    a.contents = r;
  else {
    const u = isAlias(a) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${u} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, escapeTagName = (e) => e.replace(/[!,[\]{}]/g, (t) => escapeChars[t]);
class Directives {
  constructor(t, r) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Directives.defaultYaml, t), this.tags = Object.assign({}, Directives.defaultTags, r);
  }
  clone() {
    const t = new Directives(this.yaml, this.tags);
    return t.docStart = this.docStart, t;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const t = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return t;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(t, r) {
    this.atNextDocument && (this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Directives.defaultTags), this.atNextDocument = !1);
    const a = t.trim().split(/[ \t]+/), u = a.shift();
    switch (u) {
      case "%TAG": {
        if (a.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), a.length < 2))
          return !1;
        const [n, o] = a;
        return this.tags[n] = o, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, a.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), !1;
        const [n] = a;
        if (n === "1.1" || n === "1.2")
          return this.yaml.version = n, !0;
        {
          const o = /^\d+\.\d+$/.test(n);
          return r(6, `Unsupported YAML version ${n}`, o), !1;
        }
      }
      default:
        return r(0, `Unknown directive ${u}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(t, r) {
    if (t === "!")
      return "!";
    if (t[0] !== "!")
      return r(`Not a valid tag: ${t}`), null;
    if (t[1] === "<") {
      const o = t.slice(2, -1);
      return o === "!" || o === "!!" ? (r(`Verbatim tags aren't resolved, so ${t} is invalid.`), null) : (t[t.length - 1] !== ">" && r("Verbatim tags must end with a >"), o);
    }
    const [, a, u] = t.match(/^(.*!)([^!]*)$/s);
    u || r(`The ${t} tag has no suffix`);
    const n = this.tags[a];
    if (n)
      try {
        return n + decodeURIComponent(u);
      } catch (o) {
        return r(String(o)), null;
      }
    return a === "!" ? t : (r(`Could not resolve tag: ${t}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(t) {
    for (const [r, a] of Object.entries(this.tags))
      if (t.startsWith(a))
        return r + escapeTagName(t.substring(a.length));
    return t[0] === "!" ? t : `!<${t}>`;
  }
  toString(t) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], a = Object.entries(this.tags);
    let u;
    if (t && a.length > 0 && isNode(t.contents)) {
      const n = {};
      visit$1(t.contents, (o, c) => {
        isNode(c) && c.tag && (n[c.tag] = !0);
      }), u = Object.keys(n);
    } else
      u = [];
    for (const [n, o] of a)
      n === "!!" && o === "tag:yaml.org,2002:" || (!t || u.some((c) => c.startsWith(o))) && r.push(`%TAG ${n} ${o}`);
    return r.join(`
`);
  }
}
Directives.defaultYaml = { explicit: !1, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(e) {
  if (/[\x00-\x19\s,[\]{}]/.test(e)) {
    const r = `Anchor must not contain whitespace or control characters: ${JSON.stringify(e)}`;
    throw new Error(r);
  }
  return !0;
}
function anchorNames(e) {
  const t = /* @__PURE__ */ new Set();
  return visit$1(e, {
    Value(r, a) {
      a.anchor && t.add(a.anchor);
    }
  }), t;
}
function findNewAnchor(e, t) {
  for (let r = 1; ; ++r) {
    const a = `${e}${r}`;
    if (!t.has(a))
      return a;
  }
}
function createNodeAnchors(e, t) {
  const r = [], a = /* @__PURE__ */ new Map();
  let u = null;
  return {
    onAnchor: (n) => {
      r.push(n), u || (u = anchorNames(e));
      const o = findNewAnchor(t, u);
      return u.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const n of r) {
        const o = a.get(n);
        if (typeof o == "object" && o.anchor && (isScalar$1(o.node) || isCollection$1(o.node)))
          o.node.anchor = o.anchor;
        else {
          const c = new Error("Failed to resolve repeated object (this should not happen)");
          throw c.source = n, c;
        }
      }
    },
    sourceObjects: a
  };
}
function applyReviver(e, t, r, a) {
  if (a && typeof a == "object")
    if (Array.isArray(a))
      for (let u = 0, n = a.length; u < n; ++u) {
        const o = a[u], c = applyReviver(e, a, String(u), o);
        c === void 0 ? delete a[u] : c !== o && (a[u] = c);
      }
    else if (a instanceof Map)
      for (const u of Array.from(a.keys())) {
        const n = a.get(u), o = applyReviver(e, a, u, n);
        o === void 0 ? a.delete(u) : o !== n && a.set(u, o);
      }
    else if (a instanceof Set)
      for (const u of Array.from(a)) {
        const n = applyReviver(e, a, u, u);
        n === void 0 ? a.delete(u) : n !== u && (a.delete(u), a.add(n));
      }
    else
      for (const [u, n] of Object.entries(a)) {
        const o = applyReviver(e, a, u, n);
        o === void 0 ? delete a[u] : o !== n && (a[u] = o);
      }
  return e.call(t, r, a);
}
function toJS(e, t, r) {
  if (Array.isArray(e))
    return e.map((a, u) => toJS(a, String(u), r));
  if (e && typeof e.toJSON == "function") {
    if (!r || !hasAnchor(e))
      return e.toJSON(t, r);
    const a = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(e, a), r.onCreate = (n) => {
      a.res = n, delete r.onCreate;
    };
    const u = e.toJSON(t, r);
    return r.onCreate && r.onCreate(u), u;
  }
  return typeof e == "bigint" && !r?.keep ? Number(e) : e;
}
class NodeBase {
  constructor(t) {
    Object.defineProperty(this, NODE_TYPE, { value: t });
  }
  /** Create a copy of this node.  */
  clone() {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (t.range = this.range.slice()), t;
  }
  /** A plain JavaScript representation of this node. */
  toJS(t, { mapAsMap: r, maxAliasCount: a, onAnchor: u, reviver: n } = {}) {
    if (!isDocument(t))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: t,
      keep: !0,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof a == "number" ? a : 100
    }, c = toJS(this, "", o);
    if (typeof u == "function")
      for (const { count: f, res: l } of o.anchors.values())
        u(l, f);
    return typeof n == "function" ? applyReviver(n, { "": c }, "", c) : c;
  }
}
class Alias extends NodeBase {
  constructor(t) {
    super(ALIAS), this.source = t, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(t) {
    let r;
    return visit$1(t, {
      Node: (a, u) => {
        if (u === this)
          return visit$1.BREAK;
        u.anchor === this.source && (r = u);
      }
    }), r;
  }
  toJSON(t, r) {
    if (!r)
      return { source: this.source };
    const { anchors: a, doc: u, maxAliasCount: n } = r, o = this.resolve(u);
    if (!o) {
      const f = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(f);
    }
    let c = a.get(o);
    if (c || (toJS(o, null, r), c = a.get(o)), !c || c.res === void 0) {
      const f = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(f);
    }
    if (n >= 0 && (c.count += 1, c.aliasCount === 0 && (c.aliasCount = getAliasCount(u, o, a)), c.count * c.aliasCount > n)) {
      const f = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(f);
    }
    return c.res;
  }
  toString(t, r, a) {
    const u = `*${this.source}`;
    if (t) {
      if (anchorIsValid(this.source), t.options.verifyAliasOrder && !t.anchors.has(this.source)) {
        const n = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(n);
      }
      if (t.implicitKey)
        return `${u} `;
    }
    return u;
  }
}
function getAliasCount(e, t, r) {
  if (isAlias(t)) {
    const a = t.resolve(e), u = r && a && r.get(a);
    return u ? u.count * u.aliasCount : 0;
  } else if (isCollection$1(t)) {
    let a = 0;
    for (const u of t.items) {
      const n = getAliasCount(e, u, r);
      n > a && (a = n);
    }
    return a;
  } else if (isPair(t)) {
    const a = getAliasCount(e, t.key, r), u = getAliasCount(e, t.value, r);
    return Math.max(a, u);
  }
  return 1;
}
const isScalarValue = (e) => !e || typeof e != "function" && typeof e != "object";
class Scalar extends NodeBase {
  constructor(t) {
    super(SCALAR$1), this.value = t;
  }
  toJSON(t, r) {
    return r?.keep ? this.value : toJS(this.value, t, r);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(e, t, r) {
  if (t) {
    const a = r.filter((n) => n.tag === t), u = a.find((n) => !n.format) ?? a[0];
    if (!u)
      throw new Error(`Tag ${t} not found`);
    return u;
  }
  return r.find((a) => a.identify?.(e) && !a.format);
}
function createNode(e, t, r) {
  if (isDocument(e) && (e = e.contents), isNode(e))
    return e;
  if (isPair(e)) {
    const p = r.schema[MAP].createNode?.(r.schema, null, r);
    return p.items.push(e), p;
  }
  (e instanceof String || e instanceof Number || e instanceof Boolean || typeof BigInt < "u" && e instanceof BigInt) && (e = e.valueOf());
  const { aliasDuplicateObjects: a, onAnchor: u, onTagObj: n, schema: o, sourceObjects: c } = r;
  let f;
  if (a && e && typeof e == "object") {
    if (f = c.get(e), f)
      return f.anchor || (f.anchor = u(e)), new Alias(f.anchor);
    f = { anchor: null, node: null }, c.set(e, f);
  }
  t?.startsWith("!!") && (t = defaultTagPrefix + t.slice(2));
  let l = findTagObject(e, t, o.tags);
  if (!l) {
    if (e && typeof e.toJSON == "function" && (e = e.toJSON()), !e || typeof e != "object") {
      const p = new Scalar(e);
      return f && (f.node = p), p;
    }
    l = e instanceof Map ? o[MAP] : Symbol.iterator in Object(e) ? o[SEQ] : o[MAP];
  }
  n && (n(l), delete r.onTagObj);
  const s = l?.createNode ? l.createNode(r.schema, e, r) : typeof l?.nodeClass?.from == "function" ? l.nodeClass.from(r.schema, e, r) : new Scalar(e);
  return t ? s.tag = t : l.default || (s.tag = l.tag), f && (f.node = s), s;
}
function collectionFromPath(e, t, r) {
  let a = r;
  for (let u = t.length - 1; u >= 0; --u) {
    const n = t[u];
    if (typeof n == "number" && Number.isInteger(n) && n >= 0) {
      const o = [];
      o[n] = a, a = o;
    } else
      a = /* @__PURE__ */ new Map([[n, a]]);
  }
  return createNode(a, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: e,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath = (e) => e == null || typeof e == "object" && !!e[Symbol.iterator]().next().done;
class Collection extends NodeBase {
  constructor(t, r) {
    super(t), Object.defineProperty(this, "schema", {
      value: r,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(t) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return t && (r.schema = t), r.items = r.items.map((a) => isNode(a) || isPair(a) ? a.clone(t) : a), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(t, r) {
    if (isEmptyPath(t))
      this.add(r);
    else {
      const [a, ...u] = t, n = this.get(a, !0);
      if (isCollection$1(n))
        n.addIn(u, r);
      else if (n === void 0 && this.schema)
        this.set(a, collectionFromPath(this.schema, u, r));
      else
        throw new Error(`Expected YAML collection at ${a}. Remaining path: ${u}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    const [r, ...a] = t;
    if (a.length === 0)
      return this.delete(r);
    const u = this.get(r, !0);
    if (isCollection$1(u))
      return u.deleteIn(a);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${a}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, r) {
    const [a, ...u] = t, n = this.get(a, !0);
    return u.length === 0 ? !r && isScalar$1(n) ? n.value : n : isCollection$1(n) ? n.getIn(u, r) : void 0;
  }
  hasAllNullValues(t) {
    return this.items.every((r) => {
      if (!isPair(r))
        return !1;
      const a = r.value;
      return a == null || t && isScalar$1(a) && a.value == null && !a.commentBefore && !a.comment && !a.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(t) {
    const [r, ...a] = t;
    if (a.length === 0)
      return this.has(r);
    const u = this.get(r, !0);
    return isCollection$1(u) ? u.hasIn(a) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, r) {
    const [a, ...u] = t;
    if (u.length === 0)
      this.set(a, r);
    else {
      const n = this.get(a, !0);
      if (isCollection$1(n))
        n.setIn(u, r);
      else if (n === void 0 && this.schema)
        this.set(a, collectionFromPath(this.schema, u, r));
      else
        throw new Error(`Expected YAML collection at ${a}. Remaining path: ${u}`);
    }
  }
}
const stringifyComment = (e) => e.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(e, t) {
  return /^\n+$/.test(e) ? e.substring(1) : t ? e.replace(/^(?! *$)/gm, t) : e;
}
const lineComment = (e, t, r) => e.endsWith(`
`) ? indentComment(r, t) : r.includes(`
`) ? `
` + indentComment(r, t) : (e.endsWith(" ") ? "" : " ") + r, FOLD_FLOW = "flow", FOLD_BLOCK = "block", FOLD_QUOTED = "quoted";
function foldFlowLines(e, t, r = "flow", { indentAtStart: a, lineWidth: u = 80, minContentWidth: n = 20, onFold: o, onOverflow: c } = {}) {
  if (!u || u < 0)
    return e;
  u < n && (n = 0);
  const f = Math.max(1 + n, 1 + u - t.length);
  if (e.length <= f)
    return e;
  const l = [], s = {};
  let p = u - t.length;
  typeof a == "number" && (a > u - Math.max(2, n) ? l.push(0) : p = u - a);
  let m, g, y = !1, v = -1, E = -1, b = -1;
  r === FOLD_BLOCK && (v = consumeMoreIndentedLines(e, v, t.length), v !== -1 && (p = v + f));
  for (let O; O = e[v += 1]; ) {
    if (r === FOLD_QUOTED && O === "\\") {
      switch (E = v, e[v + 1]) {
        case "x":
          v += 3;
          break;
        case "u":
          v += 5;
          break;
        case "U":
          v += 9;
          break;
        default:
          v += 1;
      }
      b = v;
    }
    if (O === `
`)
      r === FOLD_BLOCK && (v = consumeMoreIndentedLines(e, v, t.length)), p = v + t.length + f, m = void 0;
    else {
      if (O === " " && g && g !== " " && g !== `
` && g !== "	") {
        const j = e[v + 1];
        j && j !== " " && j !== `
` && j !== "	" && (m = v);
      }
      if (v >= p)
        if (m)
          l.push(m), p = m + f, m = void 0;
        else if (r === FOLD_QUOTED) {
          for (; g === " " || g === "	"; )
            g = O, O = e[v += 1], y = !0;
          const j = v > b + 1 ? v - 2 : E - 1;
          if (s[j])
            return e;
          l.push(j), s[j] = !0, p = j + f, m = void 0;
        } else
          y = !0;
    }
    g = O;
  }
  if (y && c && c(), l.length === 0)
    return e;
  o && o();
  let q = e.slice(0, l[0]);
  for (let O = 0; O < l.length; ++O) {
    const j = l[O], D = l[O + 1] || e.length;
    j === 0 ? q = `
${t}${e.slice(0, D)}` : (r === FOLD_QUOTED && s[j] && (q += `${e[j]}\\`), q += `
${t}${e.slice(j + 1, D)}`);
  }
  return q;
}
function consumeMoreIndentedLines(e, t, r) {
  let a = t, u = t + 1, n = e[u];
  for (; n === " " || n === "	"; )
    if (t < u + r)
      n = e[++t];
    else {
      do
        n = e[++t];
      while (n && n !== `
`);
      a = t, u = t + 1, n = e[u];
    }
  return a;
}
const getFoldOptions = (e, t) => ({
  indentAtStart: t ? e.indent.length : e.indentAtStart,
  lineWidth: e.options.lineWidth,
  minContentWidth: e.options.minContentWidth
}), containsDocumentMarker = (e) => /^(%|---|\.\.\.)/m.test(e);
function lineLengthOverLimit(e, t, r) {
  if (!t || t < 0)
    return !1;
  const a = t - r, u = e.length;
  if (u <= a)
    return !1;
  for (let n = 0, o = 0; n < u; ++n)
    if (e[n] === `
`) {
      if (n - o > a)
        return !0;
      if (o = n + 1, u - o <= a)
        return !1;
    }
  return !0;
}
function doubleQuotedString(e, t) {
  const r = JSON.stringify(e);
  if (t.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: a } = t, u = t.options.doubleQuotedMinMultiLineLength, n = t.indent || (containsDocumentMarker(e) ? "  " : "");
  let o = "", c = 0;
  for (let f = 0, l = r[f]; l; l = r[++f])
    if (l === " " && r[f + 1] === "\\" && r[f + 2] === "n" && (o += r.slice(c, f) + "\\ ", f += 1, c = f, l = "\\"), l === "\\")
      switch (r[f + 1]) {
        case "u":
          {
            o += r.slice(c, f);
            const s = r.substr(f + 2, 4);
            switch (s) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                s.substr(0, 2) === "00" ? o += "\\x" + s.substr(2) : o += r.substr(f, 6);
            }
            f += 5, c = f + 1;
          }
          break;
        case "n":
          if (a || r[f + 2] === '"' || r.length < u)
            f += 1;
          else {
            for (o += r.slice(c, f) + `

`; r[f + 2] === "\\" && r[f + 3] === "n" && r[f + 4] !== '"'; )
              o += `
`, f += 2;
            o += n, r[f + 2] === " " && (o += "\\"), f += 1, c = f + 1;
          }
          break;
        default:
          f += 1;
      }
  return o = c ? o + r.slice(c) : r, a ? o : foldFlowLines(o, n, FOLD_QUOTED, getFoldOptions(t, !1));
}
function singleQuotedString(e, t) {
  if (t.options.singleQuote === !1 || t.implicitKey && e.includes(`
`) || /[ \t]\n|\n[ \t]/.test(e))
    return doubleQuotedString(e, t);
  const r = t.indent || (containsDocumentMarker(e) ? "  " : ""), a = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return t.implicitKey ? a : foldFlowLines(a, r, FOLD_FLOW, getFoldOptions(t, !1));
}
function quotedString(e, t) {
  const { singleQuote: r } = t.options;
  let a;
  if (r === !1)
    a = doubleQuotedString;
  else {
    const u = e.includes('"'), n = e.includes("'");
    u && !n ? a = singleQuotedString : n && !u ? a = doubleQuotedString : a = r ? singleQuotedString : doubleQuotedString;
  }
  return a(e, t);
}
let blockEndNewlines;
try {
  blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: e, type: t, value: r }, a, u, n) {
  const { blockQuote: o, commentString: c, lineWidth: f } = a.options;
  if (!o || /\n[\t ]+$/.test(r) || /^\s*$/.test(r))
    return quotedString(r, a);
  const l = a.indent || (a.forceBlockIndent || containsDocumentMarker(r) ? "  " : ""), s = o === "literal" ? !0 : o === "folded" || t === Scalar.BLOCK_FOLDED ? !1 : t === Scalar.BLOCK_LITERAL ? !0 : !lineLengthOverLimit(r, f, l.length);
  if (!r)
    return s ? `|
` : `>
`;
  let p, m;
  for (m = r.length; m > 0; --m) {
    const D = r[m - 1];
    if (D !== `
` && D !== "	" && D !== " ")
      break;
  }
  let g = r.substring(m);
  const y = g.indexOf(`
`);
  y === -1 ? p = "-" : r === g || y !== g.length - 1 ? (p = "+", n && n()) : p = "", g && (r = r.slice(0, -g.length), g[g.length - 1] === `
` && (g = g.slice(0, -1)), g = g.replace(blockEndNewlines, `$&${l}`));
  let v = !1, E, b = -1;
  for (E = 0; E < r.length; ++E) {
    const D = r[E];
    if (D === " ")
      v = !0;
    else if (D === `
`)
      b = E;
    else
      break;
  }
  let q = r.substring(0, b < E ? b + 1 : E);
  q && (r = r.substring(q.length), q = q.replace(/\n+/g, `$&${l}`));
  let j = (v ? l ? "2" : "1" : "") + p;
  if (e && (j += " " + c(e.replace(/ ?[\r\n]+/g, " ")), u && u()), !s) {
    const D = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${l}`);
    let G = !1;
    const V = getFoldOptions(a, !0);
    o !== "folded" && t !== Scalar.BLOCK_FOLDED && (V.onOverflow = () => {
      G = !0;
    });
    const Q = foldFlowLines(`${q}${D}${g}`, l, FOLD_BLOCK, V);
    if (!G)
      return `>${j}
${l}${Q}`;
  }
  return r = r.replace(/\n+/g, `$&${l}`), `|${j}
${l}${q}${r}${g}`;
}
function plainString(e, t, r, a) {
  const { type: u, value: n } = e, { actualString: o, implicitKey: c, indent: f, indentStep: l, inFlow: s } = t;
  if (c && n.includes(`
`) || s && /[[\]{},]/.test(n))
    return quotedString(n, t);
  if (!n || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(n))
    return c || s || !n.includes(`
`) ? quotedString(n, t) : blockString(e, t, r, a);
  if (!c && !s && u !== Scalar.PLAIN && n.includes(`
`))
    return blockString(e, t, r, a);
  if (containsDocumentMarker(n)) {
    if (f === "")
      return t.forceBlockIndent = !0, blockString(e, t, r, a);
    if (c && f === l)
      return quotedString(n, t);
  }
  const p = n.replace(/\n+/g, `$&
${f}`);
  if (o) {
    const m = (v) => v.default && v.tag !== "tag:yaml.org,2002:str" && v.test?.test(p), { compat: g, tags: y } = t.doc.schema;
    if (y.some(m) || g?.some(m))
      return quotedString(n, t);
  }
  return c ? p : foldFlowLines(p, f, FOLD_FLOW, getFoldOptions(t, !1));
}
function stringifyString(e, t, r, a) {
  const { implicitKey: u, inFlow: n } = t, o = typeof e.value == "string" ? e : Object.assign({}, e, { value: String(e.value) });
  let { type: c } = e;
  c !== Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (c = Scalar.QUOTE_DOUBLE);
  const f = (s) => {
    switch (s) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return u || n ? quotedString(o.value, t) : blockString(o, t, r, a);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(o.value, t);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(o.value, t);
      case Scalar.PLAIN:
        return plainString(o, t, r, a);
      default:
        return null;
    }
  };
  let l = f(c);
  if (l === null) {
    const { defaultKeyType: s, defaultStringType: p } = t.options, m = u && s || p;
    if (l = f(m), l === null)
      throw new Error(`Unsupported default string type ${m}`);
  }
  return l;
}
function createStringifyContext(e, t) {
  const r = Object.assign({
    blockQuote: !0,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, e.schema.toStringOptions, t);
  let a;
  switch (r.collectionStyle) {
    case "block":
      a = !1;
      break;
    case "flow":
      a = !0;
      break;
    default:
      a = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: e,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: a,
    options: r
  };
}
function getTagObject(e, t) {
  if (t.tag) {
    const u = e.filter((n) => n.tag === t.tag);
    if (u.length > 0)
      return u.find((n) => n.format === t.format) ?? u[0];
  }
  let r, a;
  if (isScalar$1(t)) {
    a = t.value;
    let u = e.filter((n) => n.identify?.(a));
    if (u.length > 1) {
      const n = u.filter((o) => o.test);
      n.length > 0 && (u = n);
    }
    r = u.find((n) => n.format === t.format) ?? u.find((n) => !n.format);
  } else
    a = t, r = e.find((u) => u.nodeClass && a instanceof u.nodeClass);
  if (!r) {
    const u = a?.constructor?.name ?? typeof a;
    throw new Error(`Tag not resolved for ${u} value`);
  }
  return r;
}
function stringifyProps(e, t, { anchors: r, doc: a }) {
  if (!a.directives)
    return "";
  const u = [], n = (isScalar$1(e) || isCollection$1(e)) && e.anchor;
  n && anchorIsValid(n) && (r.add(n), u.push(`&${n}`));
  const o = e.tag ? e.tag : t.default ? null : t.tag;
  return o && u.push(a.directives.tagString(o)), u.join(" ");
}
function stringify$3(e, t, r, a) {
  if (isPair(e))
    return e.toString(t, r, a);
  if (isAlias(e)) {
    if (t.doc.directives)
      return e.toString(t);
    if (t.resolvedAliases?.has(e))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    t.resolvedAliases ? t.resolvedAliases.add(e) : t.resolvedAliases = /* @__PURE__ */ new Set([e]), e = e.resolve(t.doc);
  }
  let u;
  const n = isNode(e) ? e : t.doc.createNode(e, { onTagObj: (f) => u = f });
  u || (u = getTagObject(t.doc.schema.tags, n));
  const o = stringifyProps(n, u, t);
  o.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + o.length + 1);
  const c = typeof u.stringify == "function" ? u.stringify(n, t, r, a) : isScalar$1(n) ? stringifyString(n, t, r, a) : n.toString(t, r, a);
  return o ? isScalar$1(n) || c[0] === "{" || c[0] === "[" ? `${o} ${c}` : `${o}
${t.indent}${c}` : c;
}
function stringifyPair({ key: e, value: t }, r, a, u) {
  const { allNullValues: n, doc: o, indent: c, indentStep: f, options: { commentString: l, indentSeq: s, simpleKeys: p } } = r;
  let m = isNode(e) && e.comment || null;
  if (p) {
    if (m)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (isCollection$1(e) || !isNode(e) && typeof e == "object") {
      const V = "With simple keys, collection cannot be used as a key value";
      throw new Error(V);
    }
  }
  let g = !p && (!e || m && t == null && !r.inFlow || isCollection$1(e) || (isScalar$1(e) ? e.type === Scalar.BLOCK_FOLDED || e.type === Scalar.BLOCK_LITERAL : typeof e == "object"));
  r = Object.assign({}, r, {
    allNullValues: !1,
    implicitKey: !g && (p || !n),
    indent: c + f
  });
  let y = !1, v = !1, E = stringify$3(e, r, () => y = !0, () => v = !0);
  if (!g && !r.inFlow && E.length > 1024) {
    if (p)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    g = !0;
  }
  if (r.inFlow) {
    if (n || t == null)
      return y && a && a(), E === "" ? "?" : g ? `? ${E}` : E;
  } else if (n && !p || t == null && g)
    return E = `? ${E}`, m && !y ? E += lineComment(E, r.indent, l(m)) : v && u && u(), E;
  y && (m = null), g ? (m && (E += lineComment(E, r.indent, l(m))), E = `? ${E}
${c}:`) : (E = `${E}:`, m && (E += lineComment(E, r.indent, l(m))));
  let b, q, O;
  isNode(t) ? (b = !!t.spaceBefore, q = t.commentBefore, O = t.comment) : (b = !1, q = null, O = null, t && typeof t == "object" && (t = o.createNode(t))), r.implicitKey = !1, !g && !m && isScalar$1(t) && (r.indentAtStart = E.length + 1), v = !1, !s && f.length >= 2 && !r.inFlow && !g && isSeq(t) && !t.flow && !t.tag && !t.anchor && (r.indent = r.indent.substring(2));
  let j = !1;
  const D = stringify$3(t, r, () => j = !0, () => v = !0);
  let G = " ";
  if (m || b || q) {
    if (G = b ? `
` : "", q) {
      const V = l(q);
      G += `
${indentComment(V, r.indent)}`;
    }
    D === "" && !r.inFlow ? G === `
` && (G = `

`) : G += `
${r.indent}`;
  } else if (!g && isCollection$1(t)) {
    const V = D[0], Q = D.indexOf(`
`), re = Q !== -1, ve = r.inFlow ?? t.flow ?? t.items.length === 0;
    if (re || !ve) {
      let te = !1;
      if (re && (V === "&" || V === "!")) {
        let R = D.indexOf(" ");
        V === "&" && R !== -1 && R < Q && D[R + 1] === "!" && (R = D.indexOf(" ", R + 1)), (R === -1 || Q < R) && (te = !0);
      }
      te || (G = `
${r.indent}`);
    }
  } else (D === "" || D[0] === `
`) && (G = "");
  return E += G + D, r.inFlow ? j && a && a() : O && !j ? E += lineComment(E, r.indent, l(O)) : v && u && u(), E;
}
function warn(e, t) {
  (e === "debug" || e === "warn") && console.warn(t);
}
const MERGE_KEY = "<<", merge = {
  identify: (e) => e === MERGE_KEY || typeof e == "symbol" && e.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
}, isMergeKey = (e, t) => (merge.identify(t) || isScalar$1(t) && (!t.type || t.type === Scalar.PLAIN) && merge.identify(t.value)) && e?.doc.schema.tags.some((r) => r.tag === merge.tag && r.default);
function addMergeToJSMap(e, t, r) {
  if (r = e && isAlias(r) ? r.resolve(e.doc) : r, isSeq(r))
    for (const a of r.items)
      mergeValue(e, t, a);
  else if (Array.isArray(r))
    for (const a of r)
      mergeValue(e, t, a);
  else
    mergeValue(e, t, r);
}
function mergeValue(e, t, r) {
  const a = e && isAlias(r) ? r.resolve(e.doc) : r;
  if (!isMap(a))
    throw new Error("Merge sources must be maps or map aliases");
  const u = a.toJSON(null, e, Map);
  for (const [n, o] of u)
    t instanceof Map ? t.has(n) || t.set(n, o) : t instanceof Set ? t.add(n) : Object.prototype.hasOwnProperty.call(t, n) || Object.defineProperty(t, n, {
      value: o,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return t;
}
function addPairToJSMap(e, t, { key: r, value: a }) {
  if (isNode(r) && r.addToJSMap)
    r.addToJSMap(e, t, a);
  else if (isMergeKey(e, r))
    addMergeToJSMap(e, t, a);
  else {
    const u = toJS(r, "", e);
    if (t instanceof Map)
      t.set(u, toJS(a, u, e));
    else if (t instanceof Set)
      t.add(u);
    else {
      const n = stringifyKey(r, u, e), o = toJS(a, n, e);
      n in t ? Object.defineProperty(t, n, {
        value: o,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : t[n] = o;
    }
  }
  return t;
}
function stringifyKey(e, t, r) {
  if (t === null)
    return "";
  if (typeof t != "object")
    return String(t);
  if (isNode(e) && r?.doc) {
    const a = createStringifyContext(r.doc, {});
    a.anchors = /* @__PURE__ */ new Set();
    for (const n of r.anchors.keys())
      a.anchors.add(n.anchor);
    a.inFlow = !0, a.inStringifyKey = !0;
    const u = e.toString(a);
    if (!r.mapKeyWarned) {
      let n = JSON.stringify(u);
      n.length > 40 && (n = n.substring(0, 36) + '..."'), warn(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${n}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = !0;
    }
    return u;
  }
  return JSON.stringify(t);
}
function createPair(e, t, r) {
  const a = createNode(e, void 0, r), u = createNode(t, void 0, r);
  return new Pair(a, u);
}
class Pair {
  constructor(t, r = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR }), this.key = t, this.value = r;
  }
  clone(t) {
    let { key: r, value: a } = this;
    return isNode(r) && (r = r.clone(t)), isNode(a) && (a = a.clone(t)), new Pair(r, a);
  }
  toJSON(t, r) {
    const a = r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(r, a, this);
  }
  toString(t, r, a) {
    return t?.doc ? stringifyPair(this, t, r, a) : JSON.stringify(this);
  }
}
function stringifyCollection(e, t, r) {
  return (t.inFlow ?? e.flow ? stringifyFlowCollection : stringifyBlockCollection)(e, t, r);
}
function stringifyBlockCollection({ comment: e, items: t }, r, { blockItemPrefix: a, flowChars: u, itemIndent: n, onChompKeep: o, onComment: c }) {
  const { indent: f, options: { commentString: l } } = r, s = Object.assign({}, r, { indent: n, type: null });
  let p = !1;
  const m = [];
  for (let y = 0; y < t.length; ++y) {
    const v = t[y];
    let E = null;
    if (isNode(v))
      !p && v.spaceBefore && m.push(""), addCommentBefore(r, m, v.commentBefore, p), v.comment && (E = v.comment);
    else if (isPair(v)) {
      const q = isNode(v.key) ? v.key : null;
      q && (!p && q.spaceBefore && m.push(""), addCommentBefore(r, m, q.commentBefore, p));
    }
    p = !1;
    let b = stringify$3(v, s, () => E = null, () => p = !0);
    E && (b += lineComment(b, n, l(E))), p && E && (p = !1), m.push(a + b);
  }
  let g;
  if (m.length === 0)
    g = u.start + u.end;
  else {
    g = m[0];
    for (let y = 1; y < m.length; ++y) {
      const v = m[y];
      g += v ? `
${f}${v}` : `
`;
    }
  }
  return e ? (g += `
` + indentComment(l(e), f), c && c()) : p && o && o(), g;
}
function stringifyFlowCollection({ items: e }, t, { flowChars: r, itemIndent: a }) {
  const { indent: u, indentStep: n, flowCollectionPadding: o, options: { commentString: c } } = t;
  a += n;
  const f = Object.assign({}, t, {
    indent: a,
    inFlow: !0,
    type: null
  });
  let l = !1, s = 0;
  const p = [];
  for (let y = 0; y < e.length; ++y) {
    const v = e[y];
    let E = null;
    if (isNode(v))
      v.spaceBefore && p.push(""), addCommentBefore(t, p, v.commentBefore, !1), v.comment && (E = v.comment);
    else if (isPair(v)) {
      const q = isNode(v.key) ? v.key : null;
      q && (q.spaceBefore && p.push(""), addCommentBefore(t, p, q.commentBefore, !1), q.comment && (l = !0));
      const O = isNode(v.value) ? v.value : null;
      O ? (O.comment && (E = O.comment), O.commentBefore && (l = !0)) : v.value == null && q?.comment && (E = q.comment);
    }
    E && (l = !0);
    let b = stringify$3(v, f, () => E = null);
    y < e.length - 1 && (b += ","), E && (b += lineComment(b, a, c(E))), !l && (p.length > s || b.includes(`
`)) && (l = !0), p.push(b), s = p.length;
  }
  const { start: m, end: g } = r;
  if (p.length === 0)
    return m + g;
  if (!l) {
    const y = p.reduce((v, E) => v + E.length + 2, 2);
    l = t.options.lineWidth > 0 && y > t.options.lineWidth;
  }
  if (l) {
    let y = m;
    for (const v of p)
      y += v ? `
${n}${u}${v}` : `
`;
    return `${y}
${u}${g}`;
  } else
    return `${m}${o}${p.join(" ")}${o}${g}`;
}
function addCommentBefore({ indent: e, options: { commentString: t } }, r, a, u) {
  if (a && u && (a = a.replace(/^\n+/, "")), a) {
    const n = indentComment(t(a), e);
    r.push(n.trimStart());
  }
}
function findPair(e, t) {
  const r = isScalar$1(t) ? t.value : t;
  for (const a of e)
    if (isPair(a) && (a.key === t || a.key === r || isScalar$1(a.key) && a.key.value === r))
      return a;
}
class YAMLMap extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(t) {
    super(MAP, t), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(t, r, a) {
    const { keepUndefined: u, replacer: n } = a, o = new this(t), c = (f, l) => {
      if (typeof n == "function")
        l = n.call(r, f, l);
      else if (Array.isArray(n) && !n.includes(f))
        return;
      (l !== void 0 || u) && o.items.push(createPair(f, l, a));
    };
    if (r instanceof Map)
      for (const [f, l] of r)
        c(f, l);
    else if (r && typeof r == "object")
      for (const f of Object.keys(r))
        c(f, r[f]);
    return typeof t.sortMapEntries == "function" && o.items.sort(t.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(t, r) {
    let a;
    isPair(t) ? a = t : !t || typeof t != "object" || !("key" in t) ? a = new Pair(t, t?.value) : a = new Pair(t.key, t.value);
    const u = findPair(this.items, a.key), n = this.schema?.sortMapEntries;
    if (u) {
      if (!r)
        throw new Error(`Key ${a.key} already set`);
      isScalar$1(u.value) && isScalarValue(a.value) ? u.value.value = a.value : u.value = a.value;
    } else if (n) {
      const o = this.items.findIndex((c) => n(a, c) < 0);
      o === -1 ? this.items.push(a) : this.items.splice(o, 0, a);
    } else
      this.items.push(a);
  }
  delete(t) {
    const r = findPair(this.items, t);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : !1;
  }
  get(t, r) {
    const u = findPair(this.items, t)?.value;
    return (!r && isScalar$1(u) ? u.value : u) ?? void 0;
  }
  has(t) {
    return !!findPair(this.items, t);
  }
  set(t, r) {
    this.add(new Pair(t, r), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(t, r, a) {
    const u = a ? new a() : r?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    r?.onCreate && r.onCreate(u);
    for (const n of this.items)
      addPairToJSMap(r, u, n);
    return u;
  }
  toString(t, r, a) {
    if (!t)
      return JSON.stringify(this);
    for (const u of this.items)
      if (!isPair(u))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(u)} instead`);
    return !t.allNullValues && this.hasAllNullValues(!1) && (t = Object.assign({}, t, { allNullValues: !0 })), stringifyCollection(this, t, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: t.indent || "",
      onChompKeep: a,
      onComment: r
    });
  }
}
const map = {
  collection: "map",
  default: !0,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(e, t) {
    return isMap(e) || t("Expected a mapping for this tag"), e;
  },
  createNode: (e, t, r) => YAMLMap.from(e, t, r)
};
class YAMLSeq extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(t) {
    super(SEQ, t), this.items = [];
  }
  add(t) {
    this.items.push(t);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    const r = asItemIndex(t);
    return typeof r != "number" ? !1 : this.items.splice(r, 1).length > 0;
  }
  get(t, r) {
    const a = asItemIndex(t);
    if (typeof a != "number")
      return;
    const u = this.items[a];
    return !r && isScalar$1(u) ? u.value : u;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(t) {
    const r = asItemIndex(t);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(t, r) {
    const a = asItemIndex(t);
    if (typeof a != "number")
      throw new Error(`Expected a valid index, not ${t}.`);
    const u = this.items[a];
    isScalar$1(u) && isScalarValue(r) ? u.value = r : this.items[a] = r;
  }
  toJSON(t, r) {
    const a = [];
    r?.onCreate && r.onCreate(a);
    let u = 0;
    for (const n of this.items)
      a.push(toJS(n, String(u++), r));
    return a;
  }
  toString(t, r, a) {
    return t ? stringifyCollection(this, t, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (t.indent || "") + "  ",
      onChompKeep: a,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(t, r, a) {
    const { replacer: u } = a, n = new this(t);
    if (r && Symbol.iterator in Object(r)) {
      let o = 0;
      for (let c of r) {
        if (typeof u == "function") {
          const f = r instanceof Set ? c : String(o++);
          c = u.call(r, f, c);
        }
        n.items.push(createNode(c, void 0, a));
      }
    }
    return n;
  }
}
function asItemIndex(e) {
  let t = isScalar$1(e) ? e.value : e;
  return t && typeof t == "string" && (t = Number(t)), typeof t == "number" && Number.isInteger(t) && t >= 0 ? t : null;
}
const seq = {
  collection: "seq",
  default: !0,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(e, t) {
    return isSeq(e) || t("Expected a sequence for this tag"), e;
  },
  createNode: (e, t, r) => YAMLSeq.from(e, t, r)
}, string = {
  identify: (e) => typeof e == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (e) => e,
  stringify(e, t, r, a) {
    return t = Object.assign({ actualString: !0 }, t), stringifyString(e, t, r, a);
  }
}, nullTag = {
  identify: (e) => e == null,
  createNode: () => new Scalar(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source: e }, t) => typeof e == "string" && nullTag.test.test(e) ? e : t.options.nullStr
}, boolTag = {
  identify: (e) => typeof e == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (e) => new Scalar(e[0] === "t" || e[0] === "T"),
  stringify({ source: e, value: t }, r) {
    if (e && boolTag.test.test(e)) {
      const a = e[0] === "t" || e[0] === "T";
      if (t === a)
        return e;
    }
    return t ? r.options.trueStr : r.options.falseStr;
  }
};
function stringifyNumber({ format: e, minFractionDigits: t, tag: r, value: a }) {
  if (typeof a == "bigint")
    return String(a);
  const u = typeof a == "number" ? a : Number(a);
  if (!isFinite(u))
    return isNaN(u) ? ".nan" : u < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(a);
  if (!e && t && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let o = n.indexOf(".");
    o < 0 && (o = n.length, n += ".");
    let c = t - (n.length - o - 1);
    for (; c-- > 0; )
      n += "0";
  }
  return n;
}
const floatNaN$1 = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e) => e.slice(-3).toLowerCase() === "nan" ? NaN : e[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
}, floatExp$1 = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (e) => parseFloat(e),
  stringify(e) {
    const t = Number(e.value);
    return isFinite(t) ? t.toExponential() : stringifyNumber(e);
  }
}, float$1 = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(e) {
    const t = new Scalar(parseFloat(e)), r = e.indexOf(".");
    return r !== -1 && e[e.length - 1] === "0" && (t.minFractionDigits = e.length - r - 1), t;
  },
  stringify: stringifyNumber
}, intIdentify$2 = (e) => typeof e == "bigint" || Number.isInteger(e), intResolve$1 = (e, t, r, { intAsBigInt: a }) => a ? BigInt(e) : parseInt(e.substring(t), r);
function intStringify$1(e, t, r) {
  const { value: a } = e;
  return intIdentify$2(a) && a >= 0 ? r + a.toString(t) : stringifyNumber(e);
}
const intOct$1 = {
  identify: (e) => intIdentify$2(e) && e >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (e, t, r) => intResolve$1(e, 2, 8, r),
  stringify: (e) => intStringify$1(e, 8, "0o")
}, int$1 = {
  identify: intIdentify$2,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (e, t, r) => intResolve$1(e, 0, 10, r),
  stringify: stringifyNumber
}, intHex$1 = {
  identify: (e) => intIdentify$2(e) && e >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (e, t, r) => intResolve$1(e, 2, 16, r),
  stringify: (e) => intStringify$1(e, 16, "0x")
}, schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(e) {
  return typeof e == "bigint" || Number.isInteger(e);
}
const stringifyJSON = ({ value: e }) => JSON.stringify(e), jsonScalars = [
  {
    identify: (e) => typeof e == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (e) => e,
    stringify: stringifyJSON
  },
  {
    identify: (e) => e == null,
    createNode: () => new Scalar(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (e) => typeof e == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (e) => e === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (e, t, { intAsBigInt: r }) => r ? BigInt(e) : parseInt(e, 10),
    stringify: ({ value: e }) => intIdentify$1(e) ? e.toString() : JSON.stringify(e)
  },
  {
    identify: (e) => typeof e == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (e) => parseFloat(e),
    stringify: stringifyJSON
  }
], jsonError = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(e, t) {
    return t(`Unresolved plain scalar ${JSON.stringify(e)}`), e;
  }
}, schema$1 = [map, seq].concat(jsonScalars, jsonError), binary = {
  identify: (e) => e instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(e, t) {
    if (typeof atob == "function") {
      const r = atob(e.replace(/[\n\r]/g, "")), a = new Uint8Array(r.length);
      for (let u = 0; u < r.length; ++u)
        a[u] = r.charCodeAt(u);
      return a;
    } else
      return t("This environment does not support reading binary tags; either Buffer or atob is required"), e;
  },
  stringify({ comment: e, type: t, value: r }, a, u, n) {
    if (!r)
      return "";
    const o = r;
    let c;
    if (typeof btoa == "function") {
      let f = "";
      for (let l = 0; l < o.length; ++l)
        f += String.fromCharCode(o[l]);
      c = btoa(f);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (t || (t = Scalar.BLOCK_LITERAL), t !== Scalar.QUOTE_DOUBLE) {
      const f = Math.max(a.options.lineWidth - a.indent.length, a.options.minContentWidth), l = Math.ceil(c.length / f), s = new Array(l);
      for (let p = 0, m = 0; p < l; ++p, m += f)
        s[p] = c.substr(m, f);
      c = s.join(t === Scalar.BLOCK_LITERAL ? `
` : " ");
    }
    return stringifyString({ comment: e, type: t, value: c }, a, u, n);
  }
};
function resolvePairs(e, t) {
  if (isSeq(e))
    for (let r = 0; r < e.items.length; ++r) {
      let a = e.items[r];
      if (!isPair(a)) {
        if (isMap(a)) {
          a.items.length > 1 && t("Each pair must have its own sequence indicator");
          const u = a.items[0] || new Pair(new Scalar(null));
          if (a.commentBefore && (u.key.commentBefore = u.key.commentBefore ? `${a.commentBefore}
${u.key.commentBefore}` : a.commentBefore), a.comment) {
            const n = u.value ?? u.key;
            n.comment = n.comment ? `${a.comment}
${n.comment}` : a.comment;
          }
          a = u;
        }
        e.items[r] = isPair(a) ? a : new Pair(a);
      }
    }
  else
    t("Expected a sequence for this tag");
  return e;
}
function createPairs(e, t, r) {
  const { replacer: a } = r, u = new YAMLSeq(e);
  u.tag = "tag:yaml.org,2002:pairs";
  let n = 0;
  if (t && Symbol.iterator in Object(t))
    for (let o of t) {
      typeof a == "function" && (o = a.call(t, String(n++), o));
      let c, f;
      if (Array.isArray(o))
        if (o.length === 2)
          c = o[0], f = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const l = Object.keys(o);
        if (l.length === 1)
          c = l[0], f = o[c];
        else
          throw new TypeError(`Expected tuple with one key, not ${l.length} keys`);
      } else
        c = o;
      u.items.push(createPair(c, f, r));
    }
  return u;
}
const pairs = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super(), this.add = YAMLMap.prototype.add.bind(this), this.delete = YAMLMap.prototype.delete.bind(this), this.get = YAMLMap.prototype.get.bind(this), this.has = YAMLMap.prototype.has.bind(this), this.set = YAMLMap.prototype.set.bind(this), this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(t, r) {
    if (!r)
      return super.toJSON(t);
    const a = /* @__PURE__ */ new Map();
    r?.onCreate && r.onCreate(a);
    for (const u of this.items) {
      let n, o;
      if (isPair(u) ? (n = toJS(u.key, "", r), o = toJS(u.value, n, r)) : n = toJS(u, "", r), a.has(n))
        throw new Error("Ordered maps must not include duplicate keys");
      a.set(n, o);
    }
    return a;
  }
  static from(t, r, a) {
    const u = createPairs(t, r, a), n = new this();
    return n.items = u.items, n;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (e) => e instanceof Map,
  nodeClass: YAMLOMap,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(e, t) {
    const r = resolvePairs(e, t), a = [];
    for (const { key: u } of r.items)
      isScalar$1(u) && (a.includes(u.value) ? t(`Ordered maps must not include duplicate keys: ${u.value}`) : a.push(u.value));
    return Object.assign(new YAMLOMap(), r);
  },
  createNode: (e, t, r) => YAMLOMap.from(e, t, r)
};
function boolStringify({ value: e, source: t }, r) {
  return t && (e ? trueTag : falseTag).test.test(t) ? t : e ? r.options.trueStr : r.options.falseStr;
}
const trueTag = {
  identify: (e) => e === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(!0),
  stringify: boolStringify
}, falseTag = {
  identify: (e) => e === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(!1),
  stringify: boolStringify
}, floatNaN = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e) => e.slice(-3).toLowerCase() === "nan" ? NaN : e[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
}, floatExp = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (e) => parseFloat(e.replace(/_/g, "")),
  stringify(e) {
    const t = Number(e.value);
    return isFinite(t) ? t.toExponential() : stringifyNumber(e);
  }
}, float = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(e) {
    const t = new Scalar(parseFloat(e.replace(/_/g, ""))), r = e.indexOf(".");
    if (r !== -1) {
      const a = e.substring(r + 1).replace(/_/g, "");
      a[a.length - 1] === "0" && (t.minFractionDigits = a.length);
    }
    return t;
  },
  stringify: stringifyNumber
}, intIdentify = (e) => typeof e == "bigint" || Number.isInteger(e);
function intResolve(e, t, r, { intAsBigInt: a }) {
  const u = e[0];
  if ((u === "-" || u === "+") && (t += 1), e = e.substring(t).replace(/_/g, ""), a) {
    switch (r) {
      case 2:
        e = `0b${e}`;
        break;
      case 8:
        e = `0o${e}`;
        break;
      case 16:
        e = `0x${e}`;
        break;
    }
    const o = BigInt(e);
    return u === "-" ? BigInt(-1) * o : o;
  }
  const n = parseInt(e, r);
  return u === "-" ? -1 * n : n;
}
function intStringify(e, t, r) {
  const { value: a } = e;
  if (intIdentify(a)) {
    const u = a.toString(t);
    return a < 0 ? "-" + r + u.substr(1) : r + u;
  }
  return stringifyNumber(e);
}
const intBin = {
  identify: intIdentify,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (e, t, r) => intResolve(e, 2, 2, r),
  stringify: (e) => intStringify(e, 2, "0b")
}, intOct = {
  identify: intIdentify,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (e, t, r) => intResolve(e, 1, 8, r),
  stringify: (e) => intStringify(e, 8, "0")
}, int = {
  identify: intIdentify,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (e, t, r) => intResolve(e, 0, 10, r),
  stringify: stringifyNumber
}, intHex = {
  identify: intIdentify,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (e, t, r) => intResolve(e, 2, 16, r),
  stringify: (e) => intStringify(e, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(t) {
    super(t), this.tag = YAMLSet.tag;
  }
  add(t) {
    let r;
    isPair(t) ? r = t : t && typeof t == "object" && "key" in t && "value" in t && t.value === null ? r = new Pair(t.key, null) : r = new Pair(t, null), findPair(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(t, r) {
    const a = findPair(this.items, t);
    return !r && isPair(a) ? isScalar$1(a.key) ? a.key.value : a.key : a;
  }
  set(t, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const a = findPair(this.items, t);
    a && !r ? this.items.splice(this.items.indexOf(a), 1) : !a && r && this.items.push(new Pair(t));
  }
  toJSON(t, r) {
    return super.toJSON(t, r, Set);
  }
  toString(t, r, a) {
    if (!t)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, t, { allNullValues: !0 }), r, a);
    throw new Error("Set items must all have null values");
  }
  static from(t, r, a) {
    const { replacer: u } = a, n = new this(t);
    if (r && Symbol.iterator in Object(r))
      for (let o of r)
        typeof u == "function" && (o = u.call(r, o, o)), n.items.push(createPair(o, null, a));
    return n;
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set$1 = {
  collection: "map",
  identify: (e) => e instanceof Set,
  nodeClass: YAMLSet,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (e, t, r) => YAMLSet.from(e, t, r),
  resolve(e, t) {
    if (isMap(e)) {
      if (e.hasAllNullValues(!0))
        return Object.assign(new YAMLSet(), e);
      t("Set items must all have null values");
    } else
      t("Expected a mapping for this tag");
    return e;
  }
};
function parseSexagesimal(e, t) {
  const r = e[0], a = r === "-" || r === "+" ? e.substring(1) : e, u = (o) => t ? BigInt(o) : Number(o), n = a.replace(/_/g, "").split(":").reduce((o, c) => o * u(60) + u(c), u(0));
  return r === "-" ? u(-1) * n : n;
}
function stringifySexagesimal(e) {
  let { value: t } = e, r = (o) => o;
  if (typeof t == "bigint")
    r = (o) => BigInt(o);
  else if (isNaN(t) || !isFinite(t))
    return stringifyNumber(e);
  let a = "";
  t < 0 && (a = "-", t *= r(-1));
  const u = r(60), n = [t % u];
  return t < 60 ? n.unshift(0) : (t = (t - n[0]) / u, n.unshift(t % u), t >= 60 && (t = (t - n[0]) / u, n.unshift(t))), a + n.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (e) => typeof e == "bigint" || Number.isInteger(e),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (e, t, { intAsBigInt: r }) => parseSexagesimal(e, r),
  stringify: stringifySexagesimal
}, floatTime = {
  identify: (e) => typeof e == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (e) => parseSexagesimal(e, !1),
  stringify: stringifySexagesimal
}, timestamp = {
  identify: (e) => e instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(e) {
    const t = e.match(timestamp.test);
    if (!t)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, a, u, n, o, c] = t.map(Number), f = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0;
    let l = Date.UTC(r, a - 1, u, n || 0, o || 0, c || 0, f);
    const s = t[8];
    if (s && s !== "Z") {
      let p = parseSexagesimal(s, !1);
      Math.abs(p) < 30 && (p *= 60), l -= 6e4 * p;
    }
    return new Date(l);
  },
  stringify: ({ value: e }) => e?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
}, schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  merge,
  omap,
  pairs,
  set$1,
  intTime,
  floatTime,
  timestamp
], schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]), tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set: set$1,
  timestamp
}, coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set$1,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(e, t, r) {
  const a = schemas.get(t);
  if (a && !e)
    return r && !a.includes(merge) ? a.concat(merge) : a.slice();
  let u = a;
  if (!u)
    if (Array.isArray(e))
      u = [];
    else {
      const n = Array.from(schemas.keys()).filter((o) => o !== "yaml11").map((o) => JSON.stringify(o)).join(", ");
      throw new Error(`Unknown schema "${t}"; use one of ${n} or define customTags array`);
    }
  if (Array.isArray(e))
    for (const n of e)
      u = u.concat(n);
  else typeof e == "function" && (u = e(u.slice()));
  return r && (u = u.concat(merge)), u.reduce((n, o) => {
    const c = typeof o == "string" ? tagsByName[o] : o;
    if (!c) {
      const f = JSON.stringify(o), l = Object.keys(tagsByName).map((s) => JSON.stringify(s)).join(", ");
      throw new Error(`Unknown custom tag ${f}; use one of ${l}`);
    }
    return n.includes(c) || n.push(c), n;
  }, []);
}
const sortMapEntriesByKey = (e, t) => e.key < t.key ? -1 : e.key > t.key ? 1 : 0;
class Schema {
  constructor({ compat: t, customTags: r, merge: a, resolveKnownTags: u, schema: n, sortMapEntries: o, toStringDefaults: c }) {
    this.compat = Array.isArray(t) ? getTags(t, "compat") : t ? getTags(null, t) : null, this.name = typeof n == "string" && n || "core", this.knownTags = u ? coreKnownTags : {}, this.tags = getTags(r, this.name, a), this.toStringOptions = c ?? null, Object.defineProperty(this, MAP, { value: map }), Object.defineProperty(this, SCALAR$1, { value: string }), Object.defineProperty(this, SEQ, { value: seq }), this.sortMapEntries = typeof o == "function" ? o : o === !0 ? sortMapEntriesByKey : null;
  }
  clone() {
    const t = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    return t.tags = this.tags.slice(), t;
  }
}
function stringifyDocument(e, t) {
  const r = [];
  let a = t.directives === !0;
  if (t.directives !== !1 && e.directives) {
    const f = e.directives.toString(e);
    f ? (r.push(f), a = !0) : e.directives.docStart && (a = !0);
  }
  a && r.push("---");
  const u = createStringifyContext(e, t), { commentString: n } = u.options;
  if (e.commentBefore) {
    r.length !== 1 && r.unshift("");
    const f = n(e.commentBefore);
    r.unshift(indentComment(f, ""));
  }
  let o = !1, c = null;
  if (e.contents) {
    if (isNode(e.contents)) {
      if (e.contents.spaceBefore && a && r.push(""), e.contents.commentBefore) {
        const s = n(e.contents.commentBefore);
        r.push(indentComment(s, ""));
      }
      u.forceBlockIndent = !!e.comment, c = e.contents.comment;
    }
    const f = c ? void 0 : () => o = !0;
    let l = stringify$3(e.contents, u, () => c = null, f);
    c && (l += lineComment(l, "", n(c))), (l[0] === "|" || l[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${l}` : r.push(l);
  } else
    r.push(stringify$3(e.contents, u));
  if (e.directives?.docEnd)
    if (e.comment) {
      const f = n(e.comment);
      f.includes(`
`) ? (r.push("..."), r.push(indentComment(f, ""))) : r.push(`... ${f}`);
    } else
      r.push("...");
  else {
    let f = e.comment;
    f && o && (f = f.replace(/^\n+/, "")), f && ((!o || c) && r[r.length - 1] !== "" && r.push(""), r.push(indentComment(n(f), "")));
  }
  return r.join(`
`) + `
`;
}
class Document {
  constructor(t, r, a) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let u = null;
    typeof r == "function" || Array.isArray(r) ? u = r : a === void 0 && r && (a = r, r = void 0);
    const n = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      stringKeys: !1,
      uniqueKeys: !0,
      version: "1.2"
    }, a);
    this.options = n;
    let { version: o } = n;
    a?._directives ? (this.directives = a._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new Directives({ version: o }), this.setSchema(o, a), this.contents = t === void 0 ? null : this.createNode(t, u, a);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const t = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    return t.commentBefore = this.commentBefore, t.comment = this.comment, t.errors = this.errors.slice(), t.warnings = this.warnings.slice(), t.options = Object.assign({}, this.options), this.directives && (t.directives = this.directives.clone()), t.schema = this.schema.clone(), t.contents = isNode(this.contents) ? this.contents.clone(t.schema) : this.contents, this.range && (t.range = this.range.slice()), t;
  }
  /** Adds a value to the document. */
  add(t) {
    assertCollection(this.contents) && this.contents.add(t);
  }
  /** Adds a value to the document. */
  addIn(t, r) {
    assertCollection(this.contents) && this.contents.addIn(t, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(t, r) {
    if (!t.anchor) {
      const a = anchorNames(this);
      t.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || a.has(r) ? findNewAnchor(r || "a", a) : r;
    }
    return new Alias(t.anchor);
  }
  createNode(t, r, a) {
    let u;
    if (typeof r == "function")
      t = r.call({ "": t }, "", t), u = r;
    else if (Array.isArray(r)) {
      const E = (q) => typeof q == "number" || q instanceof String || q instanceof Number, b = r.filter(E).map(String);
      b.length > 0 && (r = r.concat(b)), u = r;
    } else a === void 0 && r && (a = r, r = void 0);
    const { aliasDuplicateObjects: n, anchorPrefix: o, flow: c, keepUndefined: f, onTagObj: l, tag: s } = a ?? {}, { onAnchor: p, setAnchors: m, sourceObjects: g } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), y = {
      aliasDuplicateObjects: n ?? !0,
      keepUndefined: f ?? !1,
      onAnchor: p,
      onTagObj: l,
      replacer: u,
      schema: this.schema,
      sourceObjects: g
    }, v = createNode(t, s, y);
    return c && isCollection$1(v) && (v.flow = !0), m(), v;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(t, r, a = {}) {
    const u = this.createNode(t, null, a), n = this.createNode(r, null, a);
    return new Pair(u, n);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    return assertCollection(this.contents) ? this.contents.delete(t) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    return isEmptyPath(t) ? this.contents == null ? !1 : (this.contents = null, !0) : assertCollection(this.contents) ? this.contents.deleteIn(t) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(t, r) {
    return isCollection$1(this.contents) ? this.contents.get(t, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, r) {
    return isEmptyPath(t) ? !r && isScalar$1(this.contents) ? this.contents.value : this.contents : isCollection$1(this.contents) ? this.contents.getIn(t, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(t) {
    return isCollection$1(this.contents) ? this.contents.has(t) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(t) {
    return isEmptyPath(t) ? this.contents !== void 0 : isCollection$1(this.contents) ? this.contents.hasIn(t) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(t, r) {
    this.contents == null ? this.contents = collectionFromPath(this.schema, [t], r) : assertCollection(this.contents) && this.contents.set(t, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, r) {
    isEmptyPath(t) ? this.contents = r : this.contents == null ? this.contents = collectionFromPath(this.schema, Array.from(t), r) : assertCollection(this.contents) && this.contents.setIn(t, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(t, r = {}) {
    typeof t == "number" && (t = String(t));
    let a;
    switch (t) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Directives({ version: "1.1" }), a = { resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = t : this.directives = new Directives({ version: t }), a = { resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, a = null;
        break;
      default: {
        const u = JSON.stringify(t);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${u}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (a)
      this.schema = new Schema(Object.assign(a, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: t, jsonArg: r, mapAsMap: a, maxAliasCount: u, onAnchor: n, reviver: o } = {}) {
    const c = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !t,
      mapAsMap: a === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof u == "number" ? u : 100
    }, f = toJS(this.contents, r ?? "", c);
    if (typeof n == "function")
      for (const { count: l, res: s } of c.anchors.values())
        n(s, l);
    return typeof o == "function" ? applyReviver(o, { "": f }, "", f) : f;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(t, r) {
    return this.toJS({ json: !0, jsonArg: t, mapAsMap: !1, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(t = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in t && (!Number.isInteger(t.indent) || Number(t.indent) <= 0)) {
      const r = JSON.stringify(t.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return stringifyDocument(this, t);
  }
}
function assertCollection(e) {
  if (isCollection$1(e))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class YAMLError extends Error {
  constructor(t, r, a, u) {
    super(), this.name = t, this.code = a, this.message = u, this.pos = r;
  }
}
class YAMLParseError extends YAMLError {
  constructor(t, r, a) {
    super("YAMLParseError", t, r, a);
  }
}
class YAMLWarning extends YAMLError {
  constructor(t, r, a) {
    super("YAMLWarning", t, r, a);
  }
}
const prettifyError = (e, t) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((c) => t.linePos(c));
  const { line: a, col: u } = r.linePos[0];
  r.message += ` at line ${a}, column ${u}`;
  let n = u - 1, o = e.substring(t.lineStarts[a - 1], t.lineStarts[a]).replace(/[\n\r]+$/, "");
  if (n >= 60 && o.length > 80) {
    const c = Math.min(n - 39, o.length - 79);
    o = "…" + o.substring(c), n -= c - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + "…"), a > 1 && /^ *$/.test(o.substring(0, n))) {
    let c = e.substring(t.lineStarts[a - 2], t.lineStarts[a - 1]);
    c.length > 80 && (c = c.substring(0, 79) + `…
`), o = c + o;
  }
  if (/[^ ]/.test(o)) {
    let c = 1;
    const f = r.linePos[1];
    f && f.line === a && f.col > u && (c = Math.max(1, Math.min(f.col - u, 80 - n)));
    const l = " ".repeat(n) + "^".repeat(c);
    r.message += `:

${o}
${l}
`;
  }
};
function resolveProps(e, { flow: t, indicator: r, next: a, offset: u, onError: n, parentIndent: o, startOnNewline: c }) {
  let f = !1, l = c, s = c, p = "", m = "", g = !1, y = !1, v = null, E = null, b = null, q = null, O = null, j = null, D = null;
  for (const Q of e)
    switch (y && (Q.type !== "space" && Q.type !== "newline" && Q.type !== "comma" && n(Q.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), y = !1), v && (l && Q.type !== "comment" && Q.type !== "newline" && n(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), v = null), Q.type) {
      case "space":
        !t && (r !== "doc-start" || a?.type !== "flow-collection") && Q.source.includes("	") && (v = Q), s = !0;
        break;
      case "comment": {
        s || n(Q, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const re = Q.source.substring(1) || " ";
        p ? p += m + re : p = re, m = "", l = !1;
        break;
      }
      case "newline":
        l ? p ? p += Q.source : (!j || r !== "seq-item-ind") && (f = !0) : m += Q.source, l = !0, g = !0, (E || b) && (q = Q), s = !0;
        break;
      case "anchor":
        E && n(Q, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), Q.source.endsWith(":") && n(Q.offset + Q.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), E = Q, D === null && (D = Q.offset), l = !1, s = !1, y = !0;
        break;
      case "tag": {
        b && n(Q, "MULTIPLE_TAGS", "A node can have at most one tag"), b = Q, D === null && (D = Q.offset), l = !1, s = !1, y = !0;
        break;
      }
      case r:
        (E || b) && n(Q, "BAD_PROP_ORDER", `Anchors and tags must be after the ${Q.source} indicator`), j && n(Q, "UNEXPECTED_TOKEN", `Unexpected ${Q.source} in ${t ?? "collection"}`), j = Q, l = r === "seq-item-ind" || r === "explicit-key-ind", s = !1;
        break;
      case "comma":
        if (t) {
          O && n(Q, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), O = Q, l = !1, s = !1;
          break;
        }
      // else fallthrough
      default:
        n(Q, "UNEXPECTED_TOKEN", `Unexpected ${Q.type} token`), l = !1, s = !1;
    }
  const G = e[e.length - 1], V = G ? G.offset + G.source.length : u;
  return y && a && a.type !== "space" && a.type !== "newline" && a.type !== "comma" && (a.type !== "scalar" || a.source !== "") && n(a.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), v && (l && v.indent <= o || a?.type === "block-map" || a?.type === "block-seq") && n(v, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: O,
    found: j,
    spaceBefore: f,
    comment: p,
    hasNewline: g,
    anchor: E,
    tag: b,
    newlineAfterProp: q,
    end: V,
    start: D ?? V
  };
}
function containsNewline(e) {
  if (!e)
    return null;
  switch (e.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (e.source.includes(`
`))
        return !0;
      if (e.end) {
        for (const t of e.end)
          if (t.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const t of e.items) {
        for (const r of t.start)
          if (r.type === "newline")
            return !0;
        if (t.sep) {
          for (const r of t.sep)
            if (r.type === "newline")
              return !0;
        }
        if (containsNewline(t.key) || containsNewline(t.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function flowIndentCheck(e, t, r) {
  if (t?.type === "flow-collection") {
    const a = t.end[0];
    a.indent === e && (a.source === "]" || a.source === "}") && containsNewline(t) && r(a, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function mapIncludes(e, t, r) {
  const { uniqueKeys: a } = e.options;
  if (a === !1)
    return !1;
  const u = typeof a == "function" ? a : (n, o) => n === o || isScalar$1(n) && isScalar$1(o) && n.value === o.value;
  return t.some((n) => u(n.key, r));
}
const startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: e, composeEmptyNode: t }, r, a, u, n) {
  const o = n?.nodeClass ?? YAMLMap, c = new o(r.schema);
  r.atRoot && (r.atRoot = !1);
  let f = a.offset, l = null;
  for (const s of a.items) {
    const { start: p, key: m, sep: g, value: y } = s, v = resolveProps(p, {
      indicator: "explicit-key-ind",
      next: m ?? g?.[0],
      offset: f,
      onError: u,
      parentIndent: a.indent,
      startOnNewline: !0
    }), E = !v.found;
    if (E) {
      if (m && (m.type === "block-seq" ? u(f, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in m && m.indent !== a.indent && u(f, "BAD_INDENT", startColMsg)), !v.anchor && !v.tag && !g) {
        l = v.end, v.comment && (c.comment ? c.comment += `
` + v.comment : c.comment = v.comment);
        continue;
      }
      (v.newlineAfterProp || containsNewline(m)) && u(m ?? p[p.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else v.found?.indent !== a.indent && u(f, "BAD_INDENT", startColMsg);
    r.atKey = !0;
    const b = v.end, q = m ? e(r, m, v, u) : t(r, b, p, null, v, u);
    r.schema.compat && flowIndentCheck(a.indent, m, u), r.atKey = !1, mapIncludes(r, c.items, q) && u(b, "DUPLICATE_KEY", "Map keys must be unique");
    const O = resolveProps(g ?? [], {
      indicator: "map-value-ind",
      next: y,
      offset: q.range[2],
      onError: u,
      parentIndent: a.indent,
      startOnNewline: !m || m.type === "block-scalar"
    });
    if (f = O.end, O.found) {
      E && (y?.type === "block-map" && !O.hasNewline && u(f, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && v.start < O.found.offset - 1024 && u(q.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const j = y ? e(r, y, O, u) : t(r, f, g, null, O, u);
      r.schema.compat && flowIndentCheck(a.indent, y, u), f = j.range[2];
      const D = new Pair(q, j);
      r.options.keepSourceTokens && (D.srcToken = s), c.items.push(D);
    } else {
      E && u(q.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), O.comment && (q.comment ? q.comment += `
` + O.comment : q.comment = O.comment);
      const j = new Pair(q);
      r.options.keepSourceTokens && (j.srcToken = s), c.items.push(j);
    }
  }
  return l && l < f && u(l, "IMPOSSIBLE", "Map comment with trailing content"), c.range = [a.offset, f, l ?? f], c;
}
function resolveBlockSeq({ composeNode: e, composeEmptyNode: t }, r, a, u, n) {
  const o = n?.nodeClass ?? YAMLSeq, c = new o(r.schema);
  r.atRoot && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let f = a.offset, l = null;
  for (const { start: s, value: p } of a.items) {
    const m = resolveProps(s, {
      indicator: "seq-item-ind",
      next: p,
      offset: f,
      onError: u,
      parentIndent: a.indent,
      startOnNewline: !0
    });
    if (!m.found)
      if (m.anchor || m.tag || p)
        p && p.type === "block-seq" ? u(m.end, "BAD_INDENT", "All sequence items must start at the same column") : u(f, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        l = m.end, m.comment && (c.comment = m.comment);
        continue;
      }
    const g = p ? e(r, p, m, u) : t(r, m.end, s, null, m, u);
    r.schema.compat && flowIndentCheck(a.indent, p, u), f = g.range[2], c.items.push(g);
  }
  return c.range = [a.offset, f, l ?? f], c;
}
function resolveEnd(e, t, r, a) {
  let u = "";
  if (e) {
    let n = !1, o = "";
    for (const c of e) {
      const { source: f, type: l } = c;
      switch (l) {
        case "space":
          n = !0;
          break;
        case "comment": {
          r && !n && a(c, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const s = f.substring(1) || " ";
          u ? u += o + s : u = s, o = "";
          break;
        }
        case "newline":
          u && (o += f), n = !0;
          break;
        default:
          a(c, "UNEXPECTED_TOKEN", `Unexpected ${l} at node end`);
      }
      t += f.length;
    }
  }
  return { comment: u, offset: t };
}
const blockMsg = "Block collections are not allowed within flow collections", isBlock = (e) => e && (e.type === "block-map" || e.type === "block-seq");
function resolveFlowCollection({ composeNode: e, composeEmptyNode: t }, r, a, u, n) {
  const o = a.start.source === "{", c = o ? "flow map" : "flow sequence", f = n?.nodeClass ?? (o ? YAMLMap : YAMLSeq), l = new f(r.schema);
  l.flow = !0;
  const s = r.atRoot;
  s && (r.atRoot = !1), r.atKey && (r.atKey = !1);
  let p = a.offset + a.start.source.length;
  for (let E = 0; E < a.items.length; ++E) {
    const b = a.items[E], { start: q, key: O, sep: j, value: D } = b, G = resolveProps(q, {
      flow: c,
      indicator: "explicit-key-ind",
      next: O ?? j?.[0],
      offset: p,
      onError: u,
      parentIndent: a.indent,
      startOnNewline: !1
    });
    if (!G.found) {
      if (!G.anchor && !G.tag && !j && !D) {
        E === 0 && G.comma ? u(G.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${c}`) : E < a.items.length - 1 && u(G.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${c}`), G.comment && (l.comment ? l.comment += `
` + G.comment : l.comment = G.comment), p = G.end;
        continue;
      }
      !o && r.options.strict && containsNewline(O) && u(
        O,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (E === 0)
      G.comma && u(G.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${c}`);
    else if (G.comma || u(G.start, "MISSING_CHAR", `Missing , between ${c} items`), G.comment) {
      let V = "";
      e: for (const Q of q)
        switch (Q.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            V = Q.source.substring(1);
            break e;
          default:
            break e;
        }
      if (V) {
        let Q = l.items[l.items.length - 1];
        isPair(Q) && (Q = Q.value ?? Q.key), Q.comment ? Q.comment += `
` + V : Q.comment = V, G.comment = G.comment.substring(V.length + 1);
      }
    }
    if (!o && !j && !G.found) {
      const V = D ? e(r, D, G, u) : t(r, G.end, j, null, G, u);
      l.items.push(V), p = V.range[2], isBlock(D) && u(V.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      r.atKey = !0;
      const V = G.end, Q = O ? e(r, O, G, u) : t(r, V, q, null, G, u);
      isBlock(O) && u(Q.range, "BLOCK_IN_FLOW", blockMsg), r.atKey = !1;
      const re = resolveProps(j ?? [], {
        flow: c,
        indicator: "map-value-ind",
        next: D,
        offset: Q.range[2],
        onError: u,
        parentIndent: a.indent,
        startOnNewline: !1
      });
      if (re.found) {
        if (!o && !G.found && r.options.strict) {
          if (j)
            for (const R of j) {
              if (R === re.found)
                break;
              if (R.type === "newline") {
                u(R, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          G.start < re.found.offset - 1024 && u(re.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else D && ("source" in D && D.source && D.source[0] === ":" ? u(D, "MISSING_CHAR", `Missing space after : in ${c}`) : u(re.start, "MISSING_CHAR", `Missing , or : between ${c} items`));
      const ve = D ? e(r, D, re, u) : re.found ? t(r, re.end, j, null, re, u) : null;
      ve ? isBlock(D) && u(ve.range, "BLOCK_IN_FLOW", blockMsg) : re.comment && (Q.comment ? Q.comment += `
` + re.comment : Q.comment = re.comment);
      const te = new Pair(Q, ve);
      if (r.options.keepSourceTokens && (te.srcToken = b), o) {
        const R = l;
        mapIncludes(r, R.items, Q) && u(V, "DUPLICATE_KEY", "Map keys must be unique"), R.items.push(te);
      } else {
        const R = new YAMLMap(r.schema);
        R.flow = !0, R.items.push(te);
        const M = (ve ?? Q).range;
        R.range = [Q.range[0], M[1], M[2]], l.items.push(R);
      }
      p = ve ? ve.range[2] : re.end;
    }
  }
  const m = o ? "}" : "]", [g, ...y] = a.end;
  let v = p;
  if (g && g.source === m)
    v = g.offset + g.source.length;
  else {
    const E = c[0].toUpperCase() + c.substring(1), b = s ? `${E} must end with a ${m}` : `${E} in block collection must be sufficiently indented and end with a ${m}`;
    u(p, s ? "MISSING_CHAR" : "BAD_INDENT", b), g && g.source.length !== 1 && y.unshift(g);
  }
  if (y.length > 0) {
    const E = resolveEnd(y, v, r.options.strict, u);
    E.comment && (l.comment ? l.comment += `
` + E.comment : l.comment = E.comment), l.range = [a.offset, v, E.offset];
  } else
    l.range = [a.offset, v, v];
  return l;
}
function resolveCollection(e, t, r, a, u, n) {
  const o = r.type === "block-map" ? resolveBlockMap(e, t, r, a, n) : r.type === "block-seq" ? resolveBlockSeq(e, t, r, a, n) : resolveFlowCollection(e, t, r, a, n), c = o.constructor;
  return u === "!" || u === c.tagName ? (o.tag = c.tagName, o) : (u && (o.tag = u), o);
}
function composeCollection(e, t, r, a, u) {
  const n = a.tag, o = n ? t.directives.tagName(n.source, (m) => u(n, "TAG_RESOLVE_FAILED", m)) : null;
  if (r.type === "block-seq") {
    const { anchor: m, newlineAfterProp: g } = a, y = m && n ? m.offset > n.offset ? m : n : m ?? n;
    y && (!g || g.offset < y.offset) && u(y, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const c = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!n || !o || o === "!" || o === YAMLMap.tagName && c === "map" || o === YAMLSeq.tagName && c === "seq")
    return resolveCollection(e, t, r, u, o);
  let f = t.schema.tags.find((m) => m.tag === o && m.collection === c);
  if (!f) {
    const m = t.schema.knownTags[o];
    if (m && m.collection === c)
      t.schema.tags.push(Object.assign({}, m, { default: !1 })), f = m;
    else
      return m ? u(n, "BAD_COLLECTION_TYPE", `${m.tag} used for ${c} collection, but expects ${m.collection ?? "scalar"}`, !0) : u(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o}`, !0), resolveCollection(e, t, r, u, o);
  }
  const l = resolveCollection(e, t, r, u, o, f), s = f.resolve?.(l, (m) => u(n, "TAG_RESOLVE_FAILED", m), t.options) ?? l, p = isNode(s) ? s : new Scalar(s);
  return p.range = l.range, p.tag = o, f?.format && (p.format = f.format), p;
}
function resolveBlockScalar(e, t, r) {
  const a = t.offset, u = parseBlockScalarHeader(t, e.options.strict, r);
  if (!u)
    return { value: "", type: null, comment: "", range: [a, a, a] };
  const n = u.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL, o = t.source ? splitLines(t.source) : [];
  let c = o.length;
  for (let v = o.length - 1; v >= 0; --v) {
    const E = o[v][1];
    if (E === "" || E === "\r")
      c = v;
    else
      break;
  }
  if (c === 0) {
    const v = u.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let E = a + u.length;
    return t.source && (E += t.source.length), { value: v, type: n, comment: u.comment, range: [a, E, E] };
  }
  let f = t.indent + u.indent, l = t.offset + u.length, s = 0;
  for (let v = 0; v < c; ++v) {
    const [E, b] = o[v];
    if (b === "" || b === "\r")
      u.indent === 0 && E.length > f && (f = E.length);
    else {
      E.length < f && r(l + E.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), u.indent === 0 && (f = E.length), s = v, f === 0 && !e.atRoot && r(l, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    l += E.length + b.length + 1;
  }
  for (let v = o.length - 1; v >= c; --v)
    o[v][0].length > f && (c = v + 1);
  let p = "", m = "", g = !1;
  for (let v = 0; v < s; ++v)
    p += o[v][0].slice(f) + `
`;
  for (let v = s; v < c; ++v) {
    let [E, b] = o[v];
    l += E.length + b.length + 1;
    const q = b[b.length - 1] === "\r";
    if (q && (b = b.slice(0, -1)), b && E.length < f) {
      const j = `Block scalar lines must not be less indented than their ${u.indent ? "explicit indentation indicator" : "first line"}`;
      r(l - b.length - (q ? 2 : 1), "BAD_INDENT", j), E = "";
    }
    n === Scalar.BLOCK_LITERAL ? (p += m + E.slice(f) + b, m = `
`) : E.length > f || b[0] === "	" ? (m === " " ? m = `
` : !g && m === `
` && (m = `

`), p += m + E.slice(f) + b, m = `
`, g = !0) : b === "" ? m === `
` ? p += `
` : m = `
` : (p += m + b, m = " ", g = !1);
  }
  switch (u.chomp) {
    case "-":
      break;
    case "+":
      for (let v = c; v < o.length; ++v)
        p += `
` + o[v][0].slice(f);
      p[p.length - 1] !== `
` && (p += `
`);
      break;
    default:
      p += `
`;
  }
  const y = a + u.length + t.source.length;
  return { value: p, type: n, comment: u.comment, range: [a, y, y] };
}
function parseBlockScalarHeader({ offset: e, props: t }, r, a) {
  if (t[0].type !== "block-scalar-header")
    return a(t[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: u } = t[0], n = u[0];
  let o = 0, c = "", f = -1;
  for (let m = 1; m < u.length; ++m) {
    const g = u[m];
    if (!c && (g === "-" || g === "+"))
      c = g;
    else {
      const y = Number(g);
      !o && y ? o = y : f === -1 && (f = e + m);
    }
  }
  f !== -1 && a(f, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${u}`);
  let l = !1, s = "", p = u.length;
  for (let m = 1; m < t.length; ++m) {
    const g = t[m];
    switch (g.type) {
      case "space":
        l = !0;
      // fallthrough
      case "newline":
        p += g.source.length;
        break;
      case "comment":
        r && !l && a(g, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), p += g.source.length, s = g.source.substring(1);
        break;
      case "error":
        a(g, "UNEXPECTED_TOKEN", g.message), p += g.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const y = `Unexpected token in block scalar header: ${g.type}`;
        a(g, "UNEXPECTED_TOKEN", y);
        const v = g.source;
        v && typeof v == "string" && (p += v.length);
      }
    }
  }
  return { mode: n, indent: o, chomp: c, comment: s, length: p };
}
function splitLines(e) {
  const t = e.split(/\n( *)/), r = t[0], a = r.match(/^( *)/), n = [a?.[1] ? [a[1], r.slice(a[1].length)] : ["", r]];
  for (let o = 1; o < t.length; o += 2)
    n.push([t[o], t[o + 1]]);
  return n;
}
function resolveFlowScalar(e, t, r) {
  const { offset: a, type: u, source: n, end: o } = e;
  let c, f;
  const l = (m, g, y) => r(a + m, g, y);
  switch (u) {
    case "scalar":
      c = Scalar.PLAIN, f = plainValue(n, l);
      break;
    case "single-quoted-scalar":
      c = Scalar.QUOTE_SINGLE, f = singleQuotedValue(n, l);
      break;
    case "double-quoted-scalar":
      c = Scalar.QUOTE_DOUBLE, f = doubleQuotedValue(n, l);
      break;
    /* istanbul ignore next should not happen */
    default:
      return r(e, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${u}`), {
        value: "",
        type: null,
        comment: "",
        range: [a, a + n.length, a + n.length]
      };
  }
  const s = a + n.length, p = resolveEnd(o, s, t, r);
  return {
    value: f,
    type: c,
    comment: p.comment,
    range: [a, s, p.offset]
  };
}
function plainValue(e, t) {
  let r = "";
  switch (e[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${e[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${e[0]}`;
      break;
    }
  }
  return r && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), foldLines(e);
}
function singleQuotedValue(e, t) {
  return (e[e.length - 1] !== "'" || e.length === 1) && t(e.length, "MISSING_CHAR", "Missing closing 'quote"), foldLines(e.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(e) {
  let t, r;
  try {
    t = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    t = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let a = t.exec(e);
  if (!a)
    return e;
  let u = a[1], n = " ", o = t.lastIndex;
  for (r.lastIndex = o; a = r.exec(e); )
    a[1] === "" ? n === `
` ? u += n : n = `
` : (u += n + a[1], n = " "), o = r.lastIndex;
  const c = /[ \t]*(.*)/sy;
  return c.lastIndex = o, a = c.exec(e), u + n + (a?.[1] ?? "");
}
function doubleQuotedValue(e, t) {
  let r = "";
  for (let a = 1; a < e.length - 1; ++a) {
    const u = e[a];
    if (!(u === "\r" && e[a + 1] === `
`))
      if (u === `
`) {
        const { fold: n, offset: o } = foldNewline(e, a);
        r += n, a = o;
      } else if (u === "\\") {
        let n = e[++a];
        const o = escapeCodes[n];
        if (o)
          r += o;
        else if (n === `
`)
          for (n = e[a + 1]; n === " " || n === "	"; )
            n = e[++a + 1];
        else if (n === "\r" && e[a + 1] === `
`)
          for (n = e[++a + 1]; n === " " || n === "	"; )
            n = e[++a + 1];
        else if (n === "x" || n === "u" || n === "U") {
          const c = { x: 2, u: 4, U: 8 }[n];
          r += parseCharCode(e, a + 1, c, t), a += c;
        } else {
          const c = e.substr(a - 1, 2);
          t(a - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${c}`), r += c;
        }
      } else if (u === " " || u === "	") {
        const n = a;
        let o = e[a + 1];
        for (; o === " " || o === "	"; )
          o = e[++a + 1];
        o !== `
` && !(o === "\r" && e[a + 2] === `
`) && (r += a > n ? e.slice(n, a + 1) : u);
      } else
        r += u;
  }
  return (e[e.length - 1] !== '"' || e.length === 1) && t(e.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function foldNewline(e, t) {
  let r = "", a = e[t + 1];
  for (; (a === " " || a === "	" || a === `
` || a === "\r") && !(a === "\r" && e[t + 2] !== `
`); )
    a === `
` && (r += `
`), t += 1, a = e[t + 1];
  return r || (r = " "), { fold: r, offset: t };
}
const escapeCodes = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: " ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(e, t, r, a) {
  const u = e.substr(t, r), o = u.length === r && /^[0-9a-fA-F]+$/.test(u) ? parseInt(u, 16) : NaN;
  if (isNaN(o)) {
    const c = e.substr(t - 2, r + 2);
    return a(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${c}`), c;
  }
  return String.fromCodePoint(o);
}
function composeScalar(e, t, r, a) {
  const { value: u, type: n, comment: o, range: c } = t.type === "block-scalar" ? resolveBlockScalar(e, t, a) : resolveFlowScalar(t, e.options.strict, a), f = r ? e.directives.tagName(r.source, (p) => a(r, "TAG_RESOLVE_FAILED", p)) : null;
  let l;
  e.options.stringKeys && e.atKey ? l = e.schema[SCALAR$1] : f ? l = findScalarTagByName(e.schema, u, f, r, a) : t.type === "scalar" ? l = findScalarTagByTest(e, u, t, a) : l = e.schema[SCALAR$1];
  let s;
  try {
    const p = l.resolve(u, (m) => a(r ?? t, "TAG_RESOLVE_FAILED", m), e.options);
    s = isScalar$1(p) ? p : new Scalar(p);
  } catch (p) {
    const m = p instanceof Error ? p.message : String(p);
    a(r ?? t, "TAG_RESOLVE_FAILED", m), s = new Scalar(u);
  }
  return s.range = c, s.source = u, n && (s.type = n), f && (s.tag = f), l.format && (s.format = l.format), o && (s.comment = o), s;
}
function findScalarTagByName(e, t, r, a, u) {
  if (r === "!")
    return e[SCALAR$1];
  const n = [];
  for (const c of e.tags)
    if (!c.collection && c.tag === r)
      if (c.default && c.test)
        n.push(c);
      else
        return c;
  for (const c of n)
    if (c.test?.test(t))
      return c;
  const o = e.knownTags[r];
  return o && !o.collection ? (e.tags.push(Object.assign({}, o, { default: !1, test: void 0 })), o) : (u(a, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), e[SCALAR$1]);
}
function findScalarTagByTest({ atKey: e, directives: t, schema: r }, a, u, n) {
  const o = r.tags.find((c) => (c.default === !0 || e && c.default === "key") && c.test?.test(a)) || r[SCALAR$1];
  if (r.compat) {
    const c = r.compat.find((f) => f.default && f.test?.test(a)) ?? r[SCALAR$1];
    if (o.tag !== c.tag) {
      const f = t.tagString(o.tag), l = t.tagString(c.tag), s = `Value may be parsed as either ${f} or ${l}`;
      n(u, "TAG_RESOLVE_FAILED", s, !0);
    }
  }
  return o;
}
function emptyScalarPosition(e, t, r) {
  if (t) {
    r === null && (r = t.length);
    for (let a = r - 1; a >= 0; --a) {
      let u = t[a];
      switch (u.type) {
        case "space":
        case "comment":
        case "newline":
          e -= u.source.length;
          continue;
      }
      for (u = t[++a]; u?.type === "space"; )
        e += u.source.length, u = t[++a];
      break;
    }
  }
  return e;
}
const CN = { composeNode, composeEmptyNode };
function composeNode(e, t, r, a) {
  const u = e.atKey, { spaceBefore: n, comment: o, anchor: c, tag: f } = r;
  let l, s = !0;
  switch (t.type) {
    case "alias":
      l = composeAlias(e, t, a), (c || f) && a(t, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      l = composeScalar(e, t, f, a), c && (l.anchor = c.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      l = composeCollection(CN, e, t, r, a), c && (l.anchor = c.source.substring(1));
      break;
    default: {
      const p = t.type === "error" ? t.message : `Unsupported token (type: ${t.type})`;
      a(t, "UNEXPECTED_TOKEN", p), l = composeEmptyNode(e, t.offset, void 0, null, r, a), s = !1;
    }
  }
  return c && l.anchor === "" && a(c, "BAD_ALIAS", "Anchor cannot be an empty string"), u && e.options.stringKeys && (!isScalar$1(l) || typeof l.value != "string" || l.tag && l.tag !== "tag:yaml.org,2002:str") && a(f ?? t, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), n && (l.spaceBefore = !0), o && (t.type === "scalar" && t.source === "" ? l.comment = o : l.commentBefore = o), e.options.keepSourceTokens && s && (l.srcToken = t), l;
}
function composeEmptyNode(e, t, r, a, { spaceBefore: u, comment: n, anchor: o, tag: c, end: f }, l) {
  const s = {
    type: "scalar",
    offset: emptyScalarPosition(t, r, a),
    indent: -1,
    source: ""
  }, p = composeScalar(e, s, c, l);
  return o && (p.anchor = o.source.substring(1), p.anchor === "" && l(o, "BAD_ALIAS", "Anchor cannot be an empty string")), u && (p.spaceBefore = !0), n && (p.comment = n, p.range[2] = f), p;
}
function composeAlias({ options: e }, { offset: t, source: r, end: a }, u) {
  const n = new Alias(r.substring(1));
  n.source === "" && u(t, "BAD_ALIAS", "Alias cannot be an empty string"), n.source.endsWith(":") && u(t + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const o = t + r.length, c = resolveEnd(a, o, e.strict, u);
  return n.range = [t, o, c.offset], c.comment && (n.comment = c.comment), n;
}
function composeDoc(e, t, { offset: r, start: a, value: u, end: n }, o) {
  const c = Object.assign({ _directives: t }, e), f = new Document(void 0, c), l = {
    atKey: !1,
    atRoot: !0,
    directives: f.directives,
    options: f.options,
    schema: f.schema
  }, s = resolveProps(a, {
    indicator: "doc-start",
    next: u ?? n?.[0],
    offset: r,
    onError: o,
    parentIndent: 0,
    startOnNewline: !0
  });
  s.found && (f.directives.docStart = !0, u && (u.type === "block-map" || u.type === "block-seq") && !s.hasNewline && o(s.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), f.contents = u ? composeNode(l, u, s, o) : composeEmptyNode(l, s.end, a, null, s, o);
  const p = f.contents.range[2], m = resolveEnd(n, p, !1, o);
  return m.comment && (f.comment = m.comment), f.range = [r, p, m.offset], f;
}
function getErrorPos(e) {
  if (typeof e == "number")
    return [e, e + 1];
  if (Array.isArray(e))
    return e.length === 2 ? e : [e[0], e[1]];
  const { offset: t, source: r } = e;
  return [t, t + (typeof r == "string" ? r.length : 1)];
}
function parsePrelude(e) {
  let t = "", r = !1, a = !1;
  for (let u = 0; u < e.length; ++u) {
    const n = e[u];
    switch (n[0]) {
      case "#":
        t += (t === "" ? "" : a ? `

` : `
`) + (n.substring(1) || " "), r = !0, a = !1;
        break;
      case "%":
        e[u + 1]?.[0] !== "#" && (u += 1), r = !1;
        break;
      default:
        r || (a = !0), r = !1;
    }
  }
  return { comment: t, afterEmptyLine: a };
}
class Composer {
  constructor(t = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, a, u, n) => {
      const o = getErrorPos(r);
      n ? this.warnings.push(new YAMLWarning(o, a, u)) : this.errors.push(new YAMLParseError(o, a, u));
    }, this.directives = new Directives({ version: t.version || "1.2" }), this.options = t;
  }
  decorate(t, r) {
    const { comment: a, afterEmptyLine: u } = parsePrelude(this.prelude);
    if (a) {
      const n = t.contents;
      if (r)
        t.comment = t.comment ? `${t.comment}
${a}` : a;
      else if (u || t.directives.docStart || !n)
        t.commentBefore = a;
      else if (isCollection$1(n) && !n.flow && n.items.length > 0) {
        let o = n.items[0];
        isPair(o) && (o = o.key);
        const c = o.commentBefore;
        o.commentBefore = c ? `${a}
${c}` : a;
      } else {
        const o = n.commentBefore;
        n.commentBefore = o ? `${a}
${o}` : a;
      }
    }
    r ? (Array.prototype.push.apply(t.errors, this.errors), Array.prototype.push.apply(t.warnings, this.warnings)) : (t.errors = this.errors, t.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(t, r = !1, a = -1) {
    for (const u of t)
      yield* this.next(u);
    yield* this.end(r, a);
  }
  /** Advance the composer by one CST token. */
  *next(t) {
    switch (t.type) {
      case "directive":
        this.directives.add(t.source, (r, a, u) => {
          const n = getErrorPos(t);
          n[0] += r, this.onError(n, "BAD_DIRECTIVE", a, u);
        }), this.prelude.push(t.source), this.atDirectives = !0;
        break;
      case "document": {
        const r = composeDoc(this.options, this.directives, t, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(t, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, !1), this.doc && (yield this.doc), this.doc = r, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(t.source);
        break;
      case "error": {
        const r = t.source ? `${t.message}: ${JSON.stringify(t.source)}` : t.message, a = new YAMLParseError(getErrorPos(t), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(a) : this.doc.errors.push(a);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const a = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(t), "UNEXPECTED_TOKEN", a));
          break;
        }
        this.doc.directives.docEnd = !0;
        const r = resolveEnd(t.end, t.offset + t.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), r.comment) {
          const a = this.doc.comment;
          this.doc.comment = a ? `${a}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(t), "UNEXPECTED_TOKEN", `Unsupported token ${t.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(t = !1, r = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (t) {
      const a = Object.assign({ _directives: this.directives }, this.options), u = new Document(void 0, a);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), u.range = [0, r, r], this.decorate(u, !1), yield u;
    }
  }
}
function resolveAsScalar(e, t = !0, r) {
  if (e) {
    const a = (u, n, o) => {
      const c = typeof u == "number" ? u : Array.isArray(u) ? u[0] : u.offset;
      if (r)
        r(c, n, o);
      else
        throw new YAMLParseError([c, c + 1], n, o);
    };
    switch (e.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(e, t, a);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict: t } }, e, a);
    }
  }
  return null;
}
function createScalarToken(e, t) {
  const { implicitKey: r = !1, indent: a, inFlow: u = !1, offset: n = -1, type: o = "PLAIN" } = t, c = stringifyString({ type: o, value: e }, {
    implicitKey: r,
    indent: a > 0 ? " ".repeat(a) : "",
    inFlow: u,
    options: { blockQuote: !0, lineWidth: -1 }
  }), f = t.end ?? [
    { type: "newline", offset: -1, indent: a, source: `
` }
  ];
  switch (c[0]) {
    case "|":
    case ">": {
      const l = c.indexOf(`
`), s = c.substring(0, l), p = c.substring(l + 1) + `
`, m = [
        { type: "block-scalar-header", offset: n, indent: a, source: s }
      ];
      return addEndtoBlockProps(m, f) || m.push({ type: "newline", offset: -1, indent: a, source: `
` }), { type: "block-scalar", offset: n, indent: a, props: m, source: p };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: n, indent: a, source: c, end: f };
    case "'":
      return { type: "single-quoted-scalar", offset: n, indent: a, source: c, end: f };
    default:
      return { type: "scalar", offset: n, indent: a, source: c, end: f };
  }
}
function setScalarValue(e, t, r = {}) {
  let { afterKey: a = !1, implicitKey: u = !1, inFlow: n = !1, type: o } = r, c = "indent" in e ? e.indent : null;
  if (a && typeof c == "number" && (c += 2), !o)
    switch (e.type) {
      case "single-quoted-scalar":
        o = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        o = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const l = e.props[0];
        if (l.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        o = l.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        o = "PLAIN";
    }
  const f = stringifyString({ type: o, value: t }, {
    implicitKey: u || c === null,
    indent: c !== null && c > 0 ? " ".repeat(c) : "",
    inFlow: n,
    options: { blockQuote: !0, lineWidth: -1 }
  });
  switch (f[0]) {
    case "|":
    case ">":
      setBlockScalarValue(e, f);
      break;
    case '"':
      setFlowScalarValue(e, f, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(e, f, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(e, f, "scalar");
  }
}
function setBlockScalarValue(e, t) {
  const r = t.indexOf(`
`), a = t.substring(0, r), u = t.substring(r + 1) + `
`;
  if (e.type === "block-scalar") {
    const n = e.props[0];
    if (n.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    n.source = a, e.source = u;
  } else {
    const { offset: n } = e, o = "indent" in e ? e.indent : -1, c = [
      { type: "block-scalar-header", offset: n, indent: o, source: a }
    ];
    addEndtoBlockProps(c, "end" in e ? e.end : void 0) || c.push({ type: "newline", offset: -1, indent: o, source: `
` });
    for (const f of Object.keys(e))
      f !== "type" && f !== "offset" && delete e[f];
    Object.assign(e, { type: "block-scalar", indent: o, props: c, source: u });
  }
}
function addEndtoBlockProps(e, t) {
  if (t)
    for (const r of t)
      switch (r.type) {
        case "space":
        case "comment":
          e.push(r);
          break;
        case "newline":
          return e.push(r), !0;
      }
  return !1;
}
function setFlowScalarValue(e, t, r) {
  switch (e.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      e.type = r, e.source = t;
      break;
    case "block-scalar": {
      const a = e.props.slice(1);
      let u = t.length;
      e.props[0].type === "block-scalar-header" && (u -= e.props[0].source.length);
      for (const n of a)
        n.offset += u;
      delete e.props, Object.assign(e, { type: r, source: t, end: a });
      break;
    }
    case "block-map":
    case "block-seq": {
      const u = { type: "newline", offset: e.offset + t.length, indent: e.indent, source: `
` };
      delete e.items, Object.assign(e, { type: r, source: t, end: [u] });
      break;
    }
    default: {
      const a = "indent" in e ? e.indent : -1, u = "end" in e && Array.isArray(e.end) ? e.end.filter((n) => n.type === "space" || n.type === "comment" || n.type === "newline") : [];
      for (const n of Object.keys(e))
        n !== "type" && n !== "offset" && delete e[n];
      Object.assign(e, { type: r, indent: a, source: t, end: u });
    }
  }
}
const stringify$2 = (e) => "type" in e ? stringifyToken(e) : stringifyItem(e);
function stringifyToken(e) {
  switch (e.type) {
    case "block-scalar": {
      let t = "";
      for (const r of e.props)
        t += stringifyToken(r);
      return t + e.source;
    }
    case "block-map":
    case "block-seq": {
      let t = "";
      for (const r of e.items)
        t += stringifyItem(r);
      return t;
    }
    case "flow-collection": {
      let t = e.start.source;
      for (const r of e.items)
        t += stringifyItem(r);
      for (const r of e.end)
        t += r.source;
      return t;
    }
    case "document": {
      let t = stringifyItem(e);
      if (e.end)
        for (const r of e.end)
          t += r.source;
      return t;
    }
    default: {
      let t = e.source;
      if ("end" in e && e.end)
        for (const r of e.end)
          t += r.source;
      return t;
    }
  }
}
function stringifyItem({ start: e, key: t, sep: r, value: a }) {
  let u = "";
  for (const n of e)
    u += n.source;
  if (t && (u += stringifyToken(t)), r)
    for (const n of r)
      u += n.source;
  return a && (u += stringifyToken(a)), u;
}
const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
function visit(e, t) {
  "type" in e && e.type === "document" && (e = { start: e.start, value: e.value }), _visit(Object.freeze([]), e, t);
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (e, t) => {
  let r = e;
  for (const [a, u] of t) {
    const n = r?.[a];
    if (n && "items" in n)
      r = n.items[u];
    else
      return;
  }
  return r;
};
visit.parentCollection = (e, t) => {
  const r = visit.itemAtPath(e, t.slice(0, -1)), a = t[t.length - 1][0], u = r?.[a];
  if (u && "items" in u)
    return u;
  throw new Error("Parent collection not found");
};
function _visit(e, t, r) {
  let a = r(t, e);
  if (typeof a == "symbol")
    return a;
  for (const u of ["key", "value"]) {
    const n = t[u];
    if (n && "items" in n) {
      for (let o = 0; o < n.items.length; ++o) {
        const c = _visit(Object.freeze(e.concat([[u, o]])), n.items[o], r);
        if (typeof c == "number")
          o = c - 1;
        else {
          if (c === BREAK)
            return BREAK;
          c === REMOVE && (n.items.splice(o, 1), o -= 1);
        }
      }
      typeof a == "function" && u === "key" && (a = a(t, e));
    }
  }
  return typeof a == "function" ? a(t, e) : a;
}
const BOM = "\uFEFF", DOCUMENT = "", FLOW_END = "", SCALAR = "", isCollection = (e) => !!e && "items" in e, isScalar = (e) => !!e && (e.type === "scalar" || e.type === "single-quoted-scalar" || e.type === "double-quoted-scalar" || e.type === "block-scalar");
function prettyToken(e) {
  switch (e) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(e);
  }
}
function tokenType(e) {
  switch (e) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (e[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
const cst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  createScalarToken,
  isCollection,
  isScalar,
  prettyToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$2,
  tokenType,
  visit
}, Symbol.toStringTag, { value: "Module" }));
function isEmpty(e) {
  switch (e) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const hexDigits = new Set("0123456789ABCDEFabcdef"), tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), flowIndicatorChars = new Set(",[]{}"), invalidAnchorChars = new Set(` ,[]{}
\r	`), isNotAnchorChar = (e) => !e || invalidAnchorChars.has(e);
class Lexer {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(t, r = !1) {
    if (t) {
      if (typeof t != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + t : t, this.lineEndPos = null;
    }
    this.atEnd = !r;
    let a = this.next ?? "stream";
    for (; a && (r || this.hasChars(1)); )
      a = yield* this.parseNext(a);
  }
  atLineEnd() {
    let t = this.pos, r = this.buffer[t];
    for (; r === " " || r === "	"; )
      r = this.buffer[++t];
    return !r || r === "#" || r === `
` ? !0 : r === "\r" ? this.buffer[t + 1] === `
` : !1;
  }
  charAt(t) {
    return this.buffer[this.pos + t];
  }
  continueScalar(t) {
    let r = this.buffer[t];
    if (this.indentNext > 0) {
      let a = 0;
      for (; r === " "; )
        r = this.buffer[++a + t];
      if (r === "\r") {
        const u = this.buffer[a + t + 1];
        if (u === `
` || !u && !this.atEnd)
          return t + a + 1;
      }
      return r === `
` || a >= this.indentNext || !r && !this.atEnd ? t + a : -1;
    }
    if (r === "-" || r === ".") {
      const a = this.buffer.substr(t, 3);
      if ((a === "---" || a === "...") && isEmpty(this.buffer[t + 3]))
        return -1;
    }
    return t;
  }
  getLine() {
    let t = this.lineEndPos;
    return (typeof t != "number" || t !== -1 && t < this.pos) && (t = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = t), t === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[t - 1] === "\r" && (t -= 1), this.buffer.substring(this.pos, t));
  }
  hasChars(t) {
    return this.pos + t <= this.buffer.length;
  }
  setNext(t) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = t, null;
  }
  peek(t) {
    return this.buffer.substr(this.pos, t);
  }
  *parseNext(t) {
    switch (t) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let t = this.getLine();
    if (t === null)
      return this.setNext("stream");
    if (t[0] === BOM && (yield* this.pushCount(1), t = t.substring(1)), t[0] === "%") {
      let r = t.length, a = t.indexOf("#");
      for (; a !== -1; ) {
        const n = t[a - 1];
        if (n === " " || n === "	") {
          r = a - 1;
          break;
        } else
          a = t.indexOf("#", a + 1);
      }
      for (; ; ) {
        const n = t[r - 1];
        if (n === " " || n === "	")
          r -= 1;
        else
          break;
      }
      const u = (yield* this.pushCount(r)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(t.length - u), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(!0);
      return yield* this.pushCount(t.length - r), yield* this.pushNewline(), "stream";
    }
    return yield DOCUMENT, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const t = this.charAt(0);
    if (!t && !this.atEnd)
      return this.setNext("line-start");
    if (t === "-" || t === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if ((r === "---" || r === "...") && isEmpty(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, r === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [t, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((t === "-" || t === "?" || t === ":") && isEmpty(r)) {
      const a = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += a, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const t = this.getLine();
    if (t === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (t[r]) {
      case "#":
        yield* this.pushCount(t.length - r);
      // fallthrough
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(isNotAnchorChar), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(!0), yield* this.pushCount(t.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let t, r, a = -1;
    do
      t = yield* this.pushNewline(), t > 0 ? (r = yield* this.pushSpaces(!1), this.indentValue = a = r) : r = 0, r += yield* this.pushSpaces(!0);
    while (t + r > 0);
    const u = this.getLine();
    if (u === null)
      return this.setNext("flow");
    if ((a !== -1 && a < this.indentNext && u[0] !== "#" || a === 0 && (u.startsWith("---") || u.startsWith("...")) && isEmpty(u[3])) && !(a === this.indentNext - 1 && this.flowLevel === 1 && (u[0] === "]" || u[0] === "}")))
      return this.flowLevel = 0, yield FLOW_END, yield* this.parseLineStart();
    let n = 0;
    for (; u[n] === ","; )
      n += yield* this.pushCount(1), n += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (n += yield* this.pushIndicators(), u[n]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(u.length - n), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(isNotAnchorChar), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || isEmpty(o) || o === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      // fallthrough
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const t = this.charAt(0);
    let r = this.buffer.indexOf(t, this.pos + 1);
    if (t === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let n = 0;
        for (; this.buffer[r - 1 - n] === "\\"; )
          n += 1;
        if (n % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const a = this.buffer.substring(0, r);
    let u = a.indexOf(`
`, this.pos);
    if (u !== -1) {
      for (; u !== -1; ) {
        const n = this.continueScalar(u + 1);
        if (n === -1)
          break;
        u = a.indexOf(`
`, n);
      }
      u !== -1 && (r = u - (a[u - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let t = this.pos;
    for (; ; ) {
      const r = this.buffer[++t];
      if (r === "+")
        this.blockScalarKeep = !0;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => isEmpty(r) || r === "#");
  }
  *parseBlockScalar() {
    let t = this.pos - 1, r = 0, a;
    e: for (let n = this.pos; a = this.buffer[n]; ++n)
      switch (a) {
        case " ":
          r += 1;
          break;
        case `
`:
          t = n, r = 0;
          break;
        case "\r": {
          const o = this.buffer[n + 1];
          if (!o && !this.atEnd)
            return this.setNext("block-scalar");
          if (o === `
`)
            break;
        }
        // fallthrough
        default:
          break e;
      }
    if (!a && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const n = this.continueScalar(t + 1);
        if (n === -1)
          break;
        t = this.buffer.indexOf(`
`, n);
      } while (t !== -1);
      if (t === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        t = this.buffer.length;
      }
    }
    let u = t + 1;
    for (a = this.buffer[u]; a === " "; )
      a = this.buffer[++u];
    if (a === "	") {
      for (; a === "	" || a === " " || a === "\r" || a === `
`; )
        a = this.buffer[++u];
      t = u - 1;
    } else if (!this.blockScalarKeep)
      do {
        let n = t - 1, o = this.buffer[n];
        o === "\r" && (o = this.buffer[--n]);
        const c = n;
        for (; o === " "; )
          o = this.buffer[--n];
        if (o === `
` && n >= this.pos && n + 1 + r > c)
          t = n;
        else
          break;
      } while (!0);
    return yield SCALAR, yield* this.pushToIndex(t + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const t = this.flowLevel > 0;
    let r = this.pos - 1, a = this.pos - 1, u;
    for (; u = this.buffer[++a]; )
      if (u === ":") {
        const n = this.buffer[a + 1];
        if (isEmpty(n) || t && flowIndicatorChars.has(n))
          break;
        r = a;
      } else if (isEmpty(u)) {
        let n = this.buffer[a + 1];
        if (u === "\r" && (n === `
` ? (a += 1, u = `
`, n = this.buffer[a + 1]) : r = a), n === "#" || t && flowIndicatorChars.has(n))
          break;
        if (u === `
`) {
          const o = this.continueScalar(a + 1);
          if (o === -1)
            break;
          a = Math.max(a, o - 2);
        }
      } else {
        if (t && flowIndicatorChars.has(u))
          break;
        r = a;
      }
    return !u && !this.atEnd ? this.setNext("plain-scalar") : (yield SCALAR, yield* this.pushToIndex(r + 1, !0), t ? "flow" : "doc");
  }
  *pushCount(t) {
    return t > 0 ? (yield this.buffer.substr(this.pos, t), this.pos += t, t) : 0;
  }
  *pushToIndex(t, r) {
    const a = this.buffer.slice(this.pos, t);
    return a ? (yield a, this.pos += a.length, a.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const t = this.flowLevel > 0, r = this.charAt(1);
        if (isEmpty(r) || t && flowIndicatorChars.has(r))
          return t ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let t = this.pos + 2, r = this.buffer[t];
      for (; !isEmpty(r) && r !== ">"; )
        r = this.buffer[++t];
      return yield* this.pushToIndex(r === ">" ? t + 1 : t, !1);
    } else {
      let t = this.pos + 1, r = this.buffer[t];
      for (; r; )
        if (tagChars.has(r))
          r = this.buffer[++t];
        else if (r === "%" && hexDigits.has(this.buffer[t + 1]) && hexDigits.has(this.buffer[t + 2]))
          r = this.buffer[t += 3];
        else
          break;
      return yield* this.pushToIndex(t, !1);
    }
  }
  *pushNewline() {
    const t = this.buffer[this.pos];
    return t === `
` ? yield* this.pushCount(1) : t === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(t) {
    let r = this.pos - 1, a;
    do
      a = this.buffer[++r];
    while (a === " " || t && a === "	");
    const u = r - this.pos;
    return u > 0 && (yield this.buffer.substr(this.pos, u), this.pos = r), u;
  }
  *pushUntil(t) {
    let r = this.pos, a = this.buffer[r];
    for (; !t(a); )
      a = this.buffer[++r];
    return yield* this.pushToIndex(r, !1);
  }
}
class LineCounter {
  constructor() {
    this.lineStarts = [], this.addNewLine = (t) => this.lineStarts.push(t), this.linePos = (t) => {
      let r = 0, a = this.lineStarts.length;
      for (; r < a; ) {
        const n = r + a >> 1;
        this.lineStarts[n] < t ? r = n + 1 : a = n;
      }
      if (this.lineStarts[r] === t)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: t };
      const u = this.lineStarts[r - 1];
      return { line: r, col: t - u + 1 };
    };
  }
}
function includesToken(e, t) {
  for (let r = 0; r < e.length; ++r)
    if (e[r].type === t)
      return !0;
  return !1;
}
function findNonEmptyIndex(e) {
  for (let t = 0; t < e.length; ++t)
    switch (e[t].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return t;
    }
  return -1;
}
function isFlowToken(e) {
  switch (e?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function getPrevProps(e) {
  switch (e.type) {
    case "document":
      return e.start;
    case "block-map": {
      const t = e.items[e.items.length - 1];
      return t.sep ?? t.start;
    }
    case "block-seq":
      return e.items[e.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(e) {
  if (e.length === 0)
    return [];
  let t = e.length;
  e: for (; --t >= 0; )
    switch (e[t].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; e[++t]?.type === "space"; )
    ;
  return e.splice(t, e.length);
}
function fixFlowSeqItems(e) {
  if (e.start.type === "flow-seq-start")
    for (const t of e.items)
      t.sep && !t.value && !includesToken(t.start, "explicit-key-ind") && !includesToken(t.sep, "map-value-ind") && (t.key && (t.value = t.key), delete t.key, isFlowToken(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep), delete t.sep);
}
class Parser {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(t) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new Lexer(), this.onNewLine = t;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(t, r = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const a of this.lexer.lex(t, r))
      yield* this.next(a);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(t) {
    if (this.source = t, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += t.length;
      return;
    }
    const r = tokenType(t);
    if (r)
      if (r === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + t.length);
            break;
          case "space":
            this.atNewLine && t[0] === " " && (this.indent += t.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += t.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += t.length;
      }
    else {
      const a = `Not a YAML token: ${t}`;
      yield* this.pop({ type: "error", offset: this.offset, message: a, source: t }), this.offset += t.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const t = this.peek(1);
    if (this.type === "doc-end" && (!t || t.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!t)
      return yield* this.stream();
    switch (t.type) {
      case "document":
        return yield* this.document(t);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(t);
      case "block-scalar":
        return yield* this.blockScalar(t);
      case "block-map":
        return yield* this.blockMap(t);
      case "block-seq":
        return yield* this.blockSequence(t);
      case "flow-collection":
        return yield* this.flowCollection(t);
      case "doc-end":
        return yield* this.documentEnd(t);
    }
    yield* this.pop();
  }
  peek(t) {
    return this.stack[this.stack.length - t];
  }
  *pop(t) {
    const r = t ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const a = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in a ? a.indent : 0 : r.type === "flow-collection" && a.type === "document" && (r.indent = 0), r.type === "flow-collection" && fixFlowSeqItems(r), a.type) {
        case "document":
          a.value = r;
          break;
        case "block-scalar":
          a.props.push(r);
          break;
        case "block-map": {
          const u = a.items[a.items.length - 1];
          if (u.value) {
            a.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (u.sep)
            u.value = r;
          else {
            Object.assign(u, { key: r, sep: [] }), this.onKeyLine = !u.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const u = a.items[a.items.length - 1];
          u.value ? a.items.push({ start: [], value: r }) : u.value = r;
          break;
        }
        case "flow-collection": {
          const u = a.items[a.items.length - 1];
          !u || u.value ? a.items.push({ start: [], key: r, sep: [] }) : u.sep ? u.value = r : Object.assign(u, { key: r, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((a.type === "document" || a.type === "block-map" || a.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const u = r.items[r.items.length - 1];
        u && !u.sep && !u.value && u.start.length > 0 && findNonEmptyIndex(u.start) === -1 && (r.indent === 0 || u.start.every((n) => n.type !== "comment" || n.indent < r.indent)) && (a.type === "document" ? a.end = u.start : a.items.push({ start: u.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const t = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && t.start.push(this.sourceToken), this.stack.push(t);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(t) {
    if (t.value)
      return yield* this.lineEnd(t);
    switch (this.type) {
      case "doc-start": {
        findNonEmptyIndex(t.start) !== -1 ? (yield* this.pop(), yield* this.step()) : t.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        t.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(t);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(t) {
    if (this.type === "map-value-ind") {
      const r = getPrevProps(this.peek(2)), a = getFirstKeyStartProps(r);
      let u;
      t.end ? (u = t.end, u.push(this.sourceToken), delete t.end) : u = [this.sourceToken];
      const n = {
        type: "block-map",
        offset: t.offset,
        indent: t.indent,
        items: [{ start: a, key: t, sep: u }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = n;
    } else
      yield* this.lineEnd(t);
  }
  *blockScalar(t) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        t.props.push(this.sourceToken);
        return;
      case "scalar":
        if (t.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(t) {
    const r = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, r.value) {
          const a = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(a) ? a[a.length - 1] : void 0)?.type === "comment" ? a?.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          t.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, t.indent)) {
            const u = t.items[t.items.length - 2]?.value?.end;
            if (Array.isArray(u)) {
              Array.prototype.push.apply(u, r.start), u.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= t.indent) {
      const a = !this.onKeyLine && this.indent === t.indent, u = a && (r.sep || r.explicitKey) && this.type !== "seq-item-ind";
      let n = [];
      if (u && r.sep && !r.value) {
        const o = [];
        for (let c = 0; c < r.sep.length; ++c) {
          const f = r.sep[c];
          switch (f.type) {
            case "newline":
              o.push(c);
              break;
            case "space":
              break;
            case "comment":
              f.indent > t.indent && (o.length = 0);
              break;
            default:
              o.length = 0;
          }
        }
        o.length >= 2 && (n = r.sep.splice(o[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          u || r.value ? (n.push(this.sourceToken), t.items.push({ start: n }), this.onKeyLine = !0) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !r.explicitKey ? (r.start.push(this.sourceToken), r.explicitKey = !0) : u || r.value ? (n.push(this.sourceToken), t.items.push({ start: n, explicitKey: !0 })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: !0 }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (r.explicitKey)
            if (r.sep)
              if (r.value)
                t.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (includesToken(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: n, key: null, sep: [this.sourceToken] }]
                });
              else if (isFlowToken(r.key) && !includesToken(r.sep, "newline")) {
                const o = getFirstKeyStartProps(r.start), c = r.key, f = r.sep;
                f.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: c, sep: f }]
                });
              } else n.length > 0 ? r.sep = r.sep.concat(n, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (includesToken(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const o = getFirstKeyStartProps(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: o, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || u ? t.items.push({ start: n, key: null, sep: [this.sourceToken] }) : includesToken(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          u || r.value ? (t.items.push({ start: n, key: o, sep: [] }), this.onKeyLine = !0) : r.sep ? this.stack.push(o) : (Object.assign(r, { key: o, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const o = this.startBlockValue(t);
          if (o) {
            if (o.type === "block-seq") {
              if (!r.explicitKey && r.sep && !includesToken(r.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else a && t.items.push({ start: n });
            this.stack.push(o);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(t) {
    const r = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const a = "end" in r.value ? r.value.end : void 0;
          (Array.isArray(a) ? a[a.length - 1] : void 0)?.type === "comment" ? a?.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          t.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, t.indent)) {
            const u = t.items[t.items.length - 2]?.value?.end;
            if (Array.isArray(u)) {
              Array.prototype.push.apply(u, r.start), u.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= t.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== t.indent)
          break;
        r.value || includesToken(r.start, "seq-item-ind") ? t.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > t.indent) {
      const a = this.startBlockValue(t);
      if (a) {
        this.stack.push(a);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(t) {
    const r = t.items[t.items.length - 1];
    if (this.type === "flow-error-end") {
      let a;
      do
        yield* this.pop(), a = this.peek(1);
      while (a && a.type === "flow-collection");
    } else if (t.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? t.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? t.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? t.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const u = this.flowScalar(this.type);
          !r || r.value ? t.items.push({ start: [], key: u, sep: [] }) : r.sep ? this.stack.push(u) : Object.assign(r, { key: u, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          t.end.push(this.sourceToken);
          return;
      }
      const a = this.startBlockValue(t);
      a ? this.stack.push(a) : (yield* this.pop(), yield* this.step());
    } else {
      const a = this.peek(2);
      if (a.type === "block-map" && (this.type === "map-value-ind" && a.indent === t.indent || this.type === "newline" && !a.items[a.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && a.type !== "flow-collection") {
        const u = getPrevProps(a), n = getFirstKeyStartProps(u);
        fixFlowSeqItems(t);
        const o = t.end.splice(1, t.end.length);
        o.push(this.sourceToken);
        const c = {
          type: "block-map",
          offset: t.offset,
          indent: t.indent,
          items: [{ start: n, key: t, sep: o }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = c;
      } else
        yield* this.lineEnd(t);
    }
  }
  flowScalar(t) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: t,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(t) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const r = getPrevProps(t), a = getFirstKeyStartProps(r);
        return a.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: a, explicitKey: !0 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const r = getPrevProps(t), a = getFirstKeyStartProps(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: a, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(t, r) {
    return this.type !== "comment" || this.indent <= r ? !1 : t.every((a) => a.type === "newline" || a.type === "space");
  }
  *documentEnd(t) {
    this.type !== "doc-mode" && (t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(t) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      // fallthrough
      case "space":
      case "comment":
      default:
        t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function parseOptions(e) {
  const t = e.prettyErrors !== !1;
  return { lineCounter: e.lineCounter || t && new LineCounter() || null, prettyErrors: t };
}
function parseAllDocuments(e, t = {}) {
  const { lineCounter: r, prettyErrors: a } = parseOptions(t), u = new Parser(r?.addNewLine), n = new Composer(t), o = Array.from(n.compose(u.parse(e)));
  if (a && r)
    for (const c of o)
      c.errors.forEach(prettifyError(e, r)), c.warnings.forEach(prettifyError(e, r));
  return o.length > 0 ? o : Object.assign([], { empty: !0 }, n.streamInfo());
}
function parseDocument(e, t = {}) {
  const { lineCounter: r, prettyErrors: a } = parseOptions(t), u = new Parser(r?.addNewLine), n = new Composer(t);
  let o = null;
  for (const c of n.compose(u.parse(e), !0, e.length))
    if (!o)
      o = c;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new YAMLParseError(c.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return a && r && (o.errors.forEach(prettifyError(e, r)), o.warnings.forEach(prettifyError(e, r))), o;
}
function parse$3(e, t, r) {
  let a;
  typeof t == "function" ? a = t : r === void 0 && t && typeof t == "object" && (r = t);
  const u = parseDocument(e, r);
  if (!u)
    return null;
  if (u.warnings.forEach((n) => warn(u.options.logLevel, n)), u.errors.length > 0) {
    if (u.options.logLevel !== "silent")
      throw u.errors[0];
    u.errors = [];
  }
  return u.toJS(Object.assign({ reviver: a }, r));
}
function stringify$1(e, t, r) {
  let a = null;
  if (typeof t == "function" || Array.isArray(t) ? a = t : r === void 0 && t && (r = t), typeof r == "string" && (r = r.length), typeof r == "number") {
    const u = Math.round(r);
    r = u < 1 ? void 0 : u > 8 ? { indent: 8 } : { indent: u };
  }
  if (e === void 0) {
    const { keepUndefined: u } = r ?? t ?? {};
    if (!u)
      return;
  }
  return isDocument(e) && !a ? e.toString(r) : new Document(e, a, r).toString(r);
}
const YAML = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias,
  CST: cst,
  Composer,
  Document,
  Lexer,
  LineCounter,
  Pair,
  Parser,
  Scalar,
  Schema,
  YAMLError,
  YAMLMap,
  YAMLParseError,
  YAMLSeq,
  YAMLWarning,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  parse: parse$3,
  parseAllDocuments,
  parseDocument,
  stringify: stringify$1,
  visit: visit$1,
  visitAsync
}, Symbol.toStringTag, { value: "Module" }));
class ConfigCore {
  //
  #e = null;
  #t = null;
  #r = {
    gui: {
      port: 17127
    }
  };
  /**
   *
   * @param dir
   */
  constructor(t) {
    this.#e = t;
  }
  /**
   *
   * @returns
   */
  #i() {
    if (!this.#e)
      return this.#t;
    const t = pathBrowserifyExports.join(process$1.cwd(), this.#e);
    if (!existsSync(t))
      return this.saveValue(this.#r), this.#t;
  }
  /**
   * 当且仅当配置文件存在时
   */
  get value() {
    return this.#t ? this.#t : this.#i();
  }
  /**
   * 保存value
   */
  saveValue(t) {
    if (!this.#e)
      return;
    const r = pathBrowserifyExports.join(process$1.cwd(), this.#e);
    existsSync(r) || mkdirSync(pathBrowserifyExports.dirname(r)), YAML.stringify(t), writeFileSync(r);
  }
  #n = null;
  /**
   * package.json
   */
  get package() {
    if (this.#n)
      return this.#n;
    const t = process$1.env.PKG_PATH || pathBrowserifyExports.join(process$1.cwd(), "package.json");
    if (!existsSync(t))
      return logger.warn({
        code: ResultCode.FailInternal,
        message: "package.json not found",
        data: null
      }), null;
  }
  /**
   * 命令行参数，
   * ****
   * 获取 --name value
   * ****
   * 例：argv.login == 'gui'
   */
  get argv() {
    const t = {};
    return new Proxy(t, {
      get(r, a) {
        if (typeof a == "symbol")
          return;
        const u = process$1.argv.indexOf(a);
        if (u !== -1)
          return process$1.argv[u + 1];
        const n = process$1.argv.indexOf(`--${a}`);
        return n !== -1 ? process$1.argv[n + 1] : null;
      }
    });
  }
}
const getConfig = () => {
  if (globalThis?.config)
    return globalThis.config;
  const e = process$1.env.CFG_PATH || "alemon.config.yaml";
  return globalThis.config = new ConfigCore(e), globalThis.config;
}, getConfigValue = () => getConfig()?.value || {};
var cryptoBrowserify = {}, browser$i = { exports: {} }, safeBuffer$4 = { exports: {} }, dist$1 = {}, hasRequiredDist$1;
function requireDist$1() {
  return hasRequiredDist$1 || (hasRequiredDist$1 = 1, (function(e) {
    Object.defineProperties(e, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = s, r.toByteArray = m, r.fromByteArray = v;
    for (var a = [], u = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, f = o.length; c < f; ++c)
      a[c] = o[c], u[o.charCodeAt(c)] = c;
    u[45] = 62, u[95] = 63;
    function l(q) {
      var O = q.length;
      if (O % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var j = q.indexOf("=");
      j === -1 && (j = O);
      var D = j === O ? 0 : 4 - j % 4;
      return [j, D];
    }
    function s(q) {
      var O = l(q), j = O[0], D = O[1];
      return (j + D) * 3 / 4 - D;
    }
    function p(q, O, j) {
      return (O + j) * 3 / 4 - j;
    }
    function m(q) {
      var O, j = l(q), D = j[0], G = j[1], V = new n(p(q, D, G)), Q = 0, re = G > 0 ? D - 4 : D, ve;
      for (ve = 0; ve < re; ve += 4)
        O = u[q.charCodeAt(ve)] << 18 | u[q.charCodeAt(ve + 1)] << 12 | u[q.charCodeAt(ve + 2)] << 6 | u[q.charCodeAt(ve + 3)], V[Q++] = O >> 16 & 255, V[Q++] = O >> 8 & 255, V[Q++] = O & 255;
      return G === 2 && (O = u[q.charCodeAt(ve)] << 2 | u[q.charCodeAt(ve + 1)] >> 4, V[Q++] = O & 255), G === 1 && (O = u[q.charCodeAt(ve)] << 10 | u[q.charCodeAt(ve + 1)] << 4 | u[q.charCodeAt(ve + 2)] >> 2, V[Q++] = O >> 8 & 255, V[Q++] = O & 255), V;
    }
    function g(q) {
      return a[q >> 18 & 63] + a[q >> 12 & 63] + a[q >> 6 & 63] + a[q & 63];
    }
    function y(q, O, j) {
      for (var D, G = [], V = O; V < j; V += 3)
        D = (q[V] << 16 & 16711680) + (q[V + 1] << 8 & 65280) + (q[V + 2] & 255), G.push(g(D));
      return G.join("");
    }
    function v(q) {
      for (var O, j = q.length, D = j % 3, G = [], V = 16383, Q = 0, re = j - D; Q < re; Q += V)
        G.push(y(q, Q, Q + V > re ? re : Q + V));
      return D === 1 ? (O = q[j - 1], G.push(
        a[O >> 2] + a[O << 4 & 63] + "=="
      )) : D === 2 && (O = (q[j - 2] << 8) + q[j - 1], G.push(
        a[O >> 10] + a[O >> 4 & 63] + a[O << 2 & 63] + "="
      )), G.join("");
    }
    var E = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    E.read = function(q, O, j, D, G) {
      var V, Q, re = G * 8 - D - 1, ve = (1 << re) - 1, te = ve >> 1, R = -7, M = j ? G - 1 : 0, h = j ? -1 : 1, S = q[O + M];
      for (M += h, V = S & (1 << -R) - 1, S >>= -R, R += re; R > 0; V = V * 256 + q[O + M], M += h, R -= 8)
        ;
      for (Q = V & (1 << -R) - 1, V >>= -R, R += D; R > 0; Q = Q * 256 + q[O + M], M += h, R -= 8)
        ;
      if (V === 0)
        V = 1 - te;
      else {
        if (V === ve)
          return Q ? NaN : (S ? -1 : 1) * (1 / 0);
        Q = Q + Math.pow(2, D), V = V - te;
      }
      return (S ? -1 : 1) * Q * Math.pow(2, V - D);
    }, E.write = function(q, O, j, D, G, V) {
      var Q, re, ve, te = V * 8 - G - 1, R = (1 << te) - 1, M = R >> 1, h = G === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = D ? 0 : V - 1, B = D ? 1 : -1, T = O < 0 || O === 0 && 1 / O < 0 ? 1 : 0;
      for (O = Math.abs(O), isNaN(O) || O === 1 / 0 ? (re = isNaN(O) ? 1 : 0, Q = R) : (Q = Math.floor(Math.log(O) / Math.LN2), O * (ve = Math.pow(2, -Q)) < 1 && (Q--, ve *= 2), Q + M >= 1 ? O += h / ve : O += h * Math.pow(2, 1 - M), O * ve >= 2 && (Q++, ve /= 2), Q + M >= R ? (re = 0, Q = R) : Q + M >= 1 ? (re = (O * ve - 1) * Math.pow(2, G), Q = Q + M) : (re = O * Math.pow(2, M - 1) * Math.pow(2, G), Q = 0)); G >= 8; q[j + S] = re & 255, S += B, re /= 256, G -= 8)
        ;
      for (Q = Q << G | re, te += G; te > 0; q[j + S] = Q & 255, S += B, Q /= 256, te -= 8)
        ;
      q[j + S - B] |= T * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(q) {
      const O = r, j = E, D = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      q.Buffer = R, q.SlowBuffer = U, q.INSPECT_MAX_BYTES = 50;
      const G = 2147483647;
      q.kMaxLength = G;
      const { Uint8Array: V, ArrayBuffer: Q, SharedArrayBuffer: re } = globalThis;
      R.TYPED_ARRAY_SUPPORT = ve(), !R.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function ve() {
        try {
          const ne = new V(1), W = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(W, V.prototype), Object.setPrototypeOf(ne, W), ne.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(R.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (R.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(R.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (R.isBuffer(this))
            return this.byteOffset;
        }
      });
      function te(ne) {
        if (ne > G)
          throw new RangeError('The value "' + ne + '" is invalid for option "size"');
        const W = new V(ne);
        return Object.setPrototypeOf(W, R.prototype), W;
      }
      function R(ne, W, J) {
        if (typeof ne == "number") {
          if (typeof W == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return B(ne);
        }
        return M(ne, W, J);
      }
      R.poolSize = 8192;
      function M(ne, W, J) {
        if (typeof ne == "string")
          return T(ne, W);
        if (Q.isView(ne))
          return I(ne);
        if (ne == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
          );
        if (de(ne, Q) || ne && de(ne.buffer, Q) || typeof re < "u" && (de(ne, re) || ne && de(ne.buffer, re)))
          return C(ne, W, J);
        if (typeof ne == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const me = ne.valueOf && ne.valueOf();
        if (me != null && me !== ne)
          return R.from(me, W, J);
        const Ee = $(ne);
        if (Ee) return Ee;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ne[Symbol.toPrimitive] == "function")
          return R.from(ne[Symbol.toPrimitive]("string"), W, J);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ne
        );
      }
      R.from = function(ne, W, J) {
        return M(ne, W, J);
      }, Object.setPrototypeOf(R.prototype, V.prototype), Object.setPrototypeOf(R, V);
      function h(ne) {
        if (typeof ne != "number")
          throw new TypeError('"size" argument must be of type number');
        if (ne < 0)
          throw new RangeError('The value "' + ne + '" is invalid for option "size"');
      }
      function S(ne, W, J) {
        return h(ne), ne <= 0 ? te(ne) : W !== void 0 ? typeof J == "string" ? te(ne).fill(W, J) : te(ne).fill(W) : te(ne);
      }
      R.alloc = function(ne, W, J) {
        return S(ne, W, J);
      };
      function B(ne) {
        return h(ne), te(ne < 0 ? 0 : w(ne) | 0);
      }
      R.allocUnsafe = function(ne) {
        return B(ne);
      }, R.allocUnsafeSlow = function(ne) {
        return B(ne);
      };
      function T(ne, W) {
        if ((typeof W != "string" || W === "") && (W = "utf8"), !R.isEncoding(W))
          throw new TypeError("Unknown encoding: " + W);
        const J = ie(ne, W) | 0;
        let me = te(J);
        const Ee = me.write(ne, W);
        return Ee !== J && (me = me.slice(0, Ee)), me;
      }
      function k(ne) {
        const W = ne.length < 0 ? 0 : w(ne.length) | 0, J = te(W);
        for (let me = 0; me < W; me += 1)
          J[me] = ne[me] & 255;
        return J;
      }
      function I(ne) {
        if (de(ne, V)) {
          const W = new V(ne);
          return C(W.buffer, W.byteOffset, W.byteLength);
        }
        return k(ne);
      }
      function C(ne, W, J) {
        if (W < 0 || ne.byteLength < W)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (ne.byteLength < W + (J || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let me;
        return W === void 0 && J === void 0 ? me = new V(ne) : J === void 0 ? me = new V(ne, W) : me = new V(ne, W, J), Object.setPrototypeOf(me, R.prototype), me;
      }
      function $(ne) {
        if (R.isBuffer(ne)) {
          const W = w(ne.length) | 0, J = te(W);
          return J.length === 0 || ne.copy(J, 0, 0, W), J;
        }
        if (ne.length !== void 0)
          return typeof ne.length != "number" || _e(ne.length) ? te(0) : k(ne);
        if (ne.type === "Buffer" && Array.isArray(ne.data))
          return k(ne.data);
      }
      function w(ne) {
        if (ne >= G)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + G.toString(16) + " bytes");
        return ne | 0;
      }
      function U(ne) {
        return +ne != ne && (ne = 0), R.alloc(+ne);
      }
      R.isBuffer = function(W) {
        return W != null && W._isBuffer === !0 && W !== R.prototype;
      }, R.compare = function(W, J) {
        if (de(W, V) && (W = R.from(W, W.offset, W.byteLength)), de(J, V) && (J = R.from(J, J.offset, J.byteLength)), !R.isBuffer(W) || !R.isBuffer(J))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (W === J) return 0;
        let me = W.length, Ee = J.length;
        for (let ke = 0, Ie = Math.min(me, Ee); ke < Ie; ++ke)
          if (W[ke] !== J[ke]) {
            me = W[ke], Ee = J[ke];
            break;
          }
        return me < Ee ? -1 : Ee < me ? 1 : 0;
      }, R.isEncoding = function(W) {
        switch (String(W).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, R.concat = function(W, J) {
        if (!Array.isArray(W))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (W.length === 0)
          return R.alloc(0);
        let me;
        if (J === void 0)
          for (J = 0, me = 0; me < W.length; ++me)
            J += W[me].length;
        const Ee = R.allocUnsafe(J);
        let ke = 0;
        for (me = 0; me < W.length; ++me) {
          let Ie = W[me];
          if (de(Ie, V))
            ke + Ie.length > Ee.length ? (R.isBuffer(Ie) || (Ie = R.from(Ie)), Ie.copy(Ee, ke)) : V.prototype.set.call(
              Ee,
              Ie,
              ke
            );
          else if (R.isBuffer(Ie))
            Ie.copy(Ee, ke);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          ke += Ie.length;
        }
        return Ee;
      };
      function ie(ne, W) {
        if (R.isBuffer(ne))
          return ne.length;
        if (Q.isView(ne) || de(ne, Q))
          return ne.byteLength;
        if (typeof ne != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ne
          );
        const J = ne.length, me = arguments.length > 2 && arguments[2] === !0;
        if (!me && J === 0) return 0;
        let Ee = !1;
        for (; ; )
          switch (W) {
            case "ascii":
            case "latin1":
            case "binary":
              return J;
            case "utf8":
            case "utf-8":
              return Te(ne).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return J * 2;
            case "hex":
              return J >>> 1;
            case "base64":
              return Se(ne).length;
            default:
              if (Ee)
                return me ? -1 : Te(ne).length;
              W = ("" + W).toLowerCase(), Ee = !0;
          }
      }
      R.byteLength = ie;
      function le(ne, W, J) {
        let me = !1;
        if ((W === void 0 || W < 0) && (W = 0), W > this.length || ((J === void 0 || J > this.length) && (J = this.length), J <= 0) || (J >>>= 0, W >>>= 0, J <= W))
          return "";
        for (ne || (ne = "utf8"); ; )
          switch (ne) {
            case "hex":
              return rt(this, W, J);
            case "utf8":
            case "utf-8":
              return Pe(this, W, J);
            case "ascii":
              return je(this, W, J);
            case "latin1":
            case "binary":
              return Oe(this, W, J);
            case "base64":
              return Re(this, W, J);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return He(this, W, J);
            default:
              if (me) throw new TypeError("Unknown encoding: " + ne);
              ne = (ne + "").toLowerCase(), me = !0;
          }
      }
      R.prototype._isBuffer = !0;
      function ee(ne, W, J) {
        const me = ne[W];
        ne[W] = ne[J], ne[J] = me;
      }
      R.prototype.swap16 = function() {
        const W = this.length;
        if (W % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let J = 0; J < W; J += 2)
          ee(this, J, J + 1);
        return this;
      }, R.prototype.swap32 = function() {
        const W = this.length;
        if (W % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let J = 0; J < W; J += 4)
          ee(this, J, J + 3), ee(this, J + 1, J + 2);
        return this;
      }, R.prototype.swap64 = function() {
        const W = this.length;
        if (W % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let J = 0; J < W; J += 8)
          ee(this, J, J + 7), ee(this, J + 1, J + 6), ee(this, J + 2, J + 5), ee(this, J + 3, J + 4);
        return this;
      }, R.prototype.toString = function() {
        const W = this.length;
        return W === 0 ? "" : arguments.length === 0 ? Pe(this, 0, W) : le.apply(this, arguments);
      }, R.prototype.toLocaleString = R.prototype.toString, R.prototype.equals = function(W) {
        if (!R.isBuffer(W)) throw new TypeError("Argument must be a Buffer");
        return this === W ? !0 : R.compare(this, W) === 0;
      }, R.prototype.inspect = function() {
        let W = "";
        const J = q.INSPECT_MAX_BYTES;
        return W = this.toString("hex", 0, J).replace(/(.{2})/g, "$1 ").trim(), this.length > J && (W += " ... "), "<Buffer " + W + ">";
      }, D && (R.prototype[D] = R.prototype.inspect), R.prototype.compare = function(W, J, me, Ee, ke) {
        if (de(W, V) && (W = R.from(W, W.offset, W.byteLength)), !R.isBuffer(W))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof W
          );
        if (J === void 0 && (J = 0), me === void 0 && (me = W ? W.length : 0), Ee === void 0 && (Ee = 0), ke === void 0 && (ke = this.length), J < 0 || me > W.length || Ee < 0 || ke > this.length)
          throw new RangeError("out of range index");
        if (Ee >= ke && J >= me)
          return 0;
        if (Ee >= ke)
          return -1;
        if (J >= me)
          return 1;
        if (J >>>= 0, me >>>= 0, Ee >>>= 0, ke >>>= 0, this === W) return 0;
        let Ie = ke - Ee, at = me - J;
        const ot = Math.min(Ie, at), it = this.slice(Ee, ke), ct = W.slice(J, me);
        for (let nt = 0; nt < ot; ++nt)
          if (it[nt] !== ct[nt]) {
            Ie = it[nt], at = ct[nt];
            break;
          }
        return Ie < at ? -1 : at < Ie ? 1 : 0;
      };
      function F(ne, W, J, me, Ee) {
        if (ne.length === 0) return -1;
        if (typeof J == "string" ? (me = J, J = 0) : J > 2147483647 ? J = 2147483647 : J < -2147483648 && (J = -2147483648), J = +J, _e(J) && (J = Ee ? 0 : ne.length - 1), J < 0 && (J = ne.length + J), J >= ne.length) {
          if (Ee) return -1;
          J = ne.length - 1;
        } else if (J < 0)
          if (Ee) J = 0;
          else return -1;
        if (typeof W == "string" && (W = R.from(W, me)), R.isBuffer(W))
          return W.length === 0 ? -1 : z(ne, W, J, me, Ee);
        if (typeof W == "number")
          return W = W & 255, typeof V.prototype.indexOf == "function" ? Ee ? V.prototype.indexOf.call(ne, W, J) : V.prototype.lastIndexOf.call(ne, W, J) : z(ne, [W], J, me, Ee);
        throw new TypeError("val must be string, number or Buffer");
      }
      function z(ne, W, J, me, Ee) {
        let ke = 1, Ie = ne.length, at = W.length;
        if (me !== void 0 && (me = String(me).toLowerCase(), me === "ucs2" || me === "ucs-2" || me === "utf16le" || me === "utf-16le")) {
          if (ne.length < 2 || W.length < 2)
            return -1;
          ke = 2, Ie /= 2, at /= 2, J /= 2;
        }
        function ot(ct, nt) {
          return ke === 1 ? ct[nt] : ct.readUInt16BE(nt * ke);
        }
        let it;
        if (Ee) {
          let ct = -1;
          for (it = J; it < Ie; it++)
            if (ot(ne, it) === ot(W, ct === -1 ? 0 : it - ct)) {
              if (ct === -1 && (ct = it), it - ct + 1 === at) return ct * ke;
            } else
              ct !== -1 && (it -= it - ct), ct = -1;
        } else
          for (J + at > Ie && (J = Ie - at), it = J; it >= 0; it--) {
            let ct = !0;
            for (let nt = 0; nt < at; nt++)
              if (ot(ne, it + nt) !== ot(W, nt)) {
                ct = !1;
                break;
              }
            if (ct) return it;
          }
        return -1;
      }
      R.prototype.includes = function(W, J, me) {
        return this.indexOf(W, J, me) !== -1;
      }, R.prototype.indexOf = function(W, J, me) {
        return F(this, W, J, me, !0);
      }, R.prototype.lastIndexOf = function(W, J, me) {
        return F(this, W, J, me, !1);
      };
      function se(ne, W, J, me) {
        J = Number(J) || 0;
        const Ee = ne.length - J;
        me ? (me = Number(me), me > Ee && (me = Ee)) : me = Ee;
        const ke = W.length;
        me > ke / 2 && (me = ke / 2);
        let Ie;
        for (Ie = 0; Ie < me; ++Ie) {
          const at = parseInt(W.substr(Ie * 2, 2), 16);
          if (_e(at)) return Ie;
          ne[J + Ie] = at;
        }
        return Ie;
      }
      function he(ne, W, J, me) {
        return Ce(Te(W, ne.length - J), ne, J, me);
      }
      function ae(ne, W, J, me) {
        return Ce(Ne(W), ne, J, me);
      }
      function X(ne, W, J, me) {
        return Ce(Se(W), ne, J, me);
      }
      function be(ne, W, J, me) {
        return Ce(K(W, ne.length - J), ne, J, me);
      }
      R.prototype.write = function(W, J, me, Ee) {
        if (J === void 0)
          Ee = "utf8", me = this.length, J = 0;
        else if (me === void 0 && typeof J == "string")
          Ee = J, me = this.length, J = 0;
        else if (isFinite(J))
          J = J >>> 0, isFinite(me) ? (me = me >>> 0, Ee === void 0 && (Ee = "utf8")) : (Ee = me, me = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const ke = this.length - J;
        if ((me === void 0 || me > ke) && (me = ke), W.length > 0 && (me < 0 || J < 0) || J > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        Ee || (Ee = "utf8");
        let Ie = !1;
        for (; ; )
          switch (Ee) {
            case "hex":
              return se(this, W, J, me);
            case "utf8":
            case "utf-8":
              return he(this, W, J, me);
            case "ascii":
            case "latin1":
            case "binary":
              return ae(this, W, J, me);
            case "base64":
              return X(this, W, J, me);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return be(this, W, J, me);
            default:
              if (Ie) throw new TypeError("Unknown encoding: " + Ee);
              Ee = ("" + Ee).toLowerCase(), Ie = !0;
          }
      }, R.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function Re(ne, W, J) {
        return W === 0 && J === ne.length ? O.fromByteArray(ne) : O.fromByteArray(ne.slice(W, J));
      }
      function Pe(ne, W, J) {
        J = Math.min(ne.length, J);
        const me = [];
        let Ee = W;
        for (; Ee < J; ) {
          const ke = ne[Ee];
          let Ie = null, at = ke > 239 ? 4 : ke > 223 ? 3 : ke > 191 ? 2 : 1;
          if (Ee + at <= J) {
            let ot, it, ct, nt;
            switch (at) {
              case 1:
                ke < 128 && (Ie = ke);
                break;
              case 2:
                ot = ne[Ee + 1], (ot & 192) === 128 && (nt = (ke & 31) << 6 | ot & 63, nt > 127 && (Ie = nt));
                break;
              case 3:
                ot = ne[Ee + 1], it = ne[Ee + 2], (ot & 192) === 128 && (it & 192) === 128 && (nt = (ke & 15) << 12 | (ot & 63) << 6 | it & 63, nt > 2047 && (nt < 55296 || nt > 57343) && (Ie = nt));
                break;
              case 4:
                ot = ne[Ee + 1], it = ne[Ee + 2], ct = ne[Ee + 3], (ot & 192) === 128 && (it & 192) === 128 && (ct & 192) === 128 && (nt = (ke & 15) << 18 | (ot & 63) << 12 | (it & 63) << 6 | ct & 63, nt > 65535 && nt < 1114112 && (Ie = nt));
            }
          }
          Ie === null ? (Ie = 65533, at = 1) : Ie > 65535 && (Ie -= 65536, me.push(Ie >>> 10 & 1023 | 55296), Ie = 56320 | Ie & 1023), me.push(Ie), Ee += at;
        }
        return De(me);
      }
      const Fe = 4096;
      function De(ne) {
        const W = ne.length;
        if (W <= Fe)
          return String.fromCharCode.apply(String, ne);
        let J = "", me = 0;
        for (; me < W; )
          J += String.fromCharCode.apply(
            String,
            ne.slice(me, me += Fe)
          );
        return J;
      }
      function je(ne, W, J) {
        let me = "";
        J = Math.min(ne.length, J);
        for (let Ee = W; Ee < J; ++Ee)
          me += String.fromCharCode(ne[Ee] & 127);
        return me;
      }
      function Oe(ne, W, J) {
        let me = "";
        J = Math.min(ne.length, J);
        for (let Ee = W; Ee < J; ++Ee)
          me += String.fromCharCode(ne[Ee]);
        return me;
      }
      function rt(ne, W, J) {
        const me = ne.length;
        (!W || W < 0) && (W = 0), (!J || J < 0 || J > me) && (J = me);
        let Ee = "";
        for (let ke = W; ke < J; ++ke)
          Ee += Me[ne[ke]];
        return Ee;
      }
      function He(ne, W, J) {
        const me = ne.slice(W, J);
        let Ee = "";
        for (let ke = 0; ke < me.length - 1; ke += 2)
          Ee += String.fromCharCode(me[ke] + me[ke + 1] * 256);
        return Ee;
      }
      R.prototype.slice = function(W, J) {
        const me = this.length;
        W = ~~W, J = J === void 0 ? me : ~~J, W < 0 ? (W += me, W < 0 && (W = 0)) : W > me && (W = me), J < 0 ? (J += me, J < 0 && (J = 0)) : J > me && (J = me), J < W && (J = W);
        const Ee = this.subarray(W, J);
        return Object.setPrototypeOf(Ee, R.prototype), Ee;
      };
      function Qe(ne, W, J) {
        if (ne % 1 !== 0 || ne < 0) throw new RangeError("offset is not uint");
        if (ne + W > J) throw new RangeError("Trying to access beyond buffer length");
      }
      R.prototype.readUintLE = R.prototype.readUIntLE = function(W, J, me) {
        W = W >>> 0, J = J >>> 0, me || Qe(W, J, this.length);
        let Ee = this[W], ke = 1, Ie = 0;
        for (; ++Ie < J && (ke *= 256); )
          Ee += this[W + Ie] * ke;
        return Ee;
      }, R.prototype.readUintBE = R.prototype.readUIntBE = function(W, J, me) {
        W = W >>> 0, J = J >>> 0, me || Qe(W, J, this.length);
        let Ee = this[W + --J], ke = 1;
        for (; J > 0 && (ke *= 256); )
          Ee += this[W + --J] * ke;
        return Ee;
      }, R.prototype.readUint8 = R.prototype.readUInt8 = function(W, J) {
        return W = W >>> 0, J || Qe(W, 1, this.length), this[W];
      }, R.prototype.readUint16LE = R.prototype.readUInt16LE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 2, this.length), this[W] | this[W + 1] << 8;
      }, R.prototype.readUint16BE = R.prototype.readUInt16BE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 2, this.length), this[W] << 8 | this[W + 1];
      }, R.prototype.readUint32LE = R.prototype.readUInt32LE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), (this[W] | this[W + 1] << 8 | this[W + 2] << 16) + this[W + 3] * 16777216;
      }, R.prototype.readUint32BE = R.prototype.readUInt32BE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), this[W] * 16777216 + (this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3]);
      }, R.prototype.readBigUInt64LE = tt(function(W) {
        W = W >>> 0, xe(W, "offset");
        const J = this[W], me = this[W + 7];
        (J === void 0 || me === void 0) && pe(W, this.length - 8);
        const Ee = J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24, ke = this[++W] + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + me * 2 ** 24;
        return BigInt(Ee) + (BigInt(ke) << BigInt(32));
      }), R.prototype.readBigUInt64BE = tt(function(W) {
        W = W >>> 0, xe(W, "offset");
        const J = this[W], me = this[W + 7];
        (J === void 0 || me === void 0) && pe(W, this.length - 8);
        const Ee = J * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W], ke = this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + me;
        return (BigInt(Ee) << BigInt(32)) + BigInt(ke);
      }), R.prototype.readIntLE = function(W, J, me) {
        W = W >>> 0, J = J >>> 0, me || Qe(W, J, this.length);
        let Ee = this[W], ke = 1, Ie = 0;
        for (; ++Ie < J && (ke *= 256); )
          Ee += this[W + Ie] * ke;
        return ke *= 128, Ee >= ke && (Ee -= Math.pow(2, 8 * J)), Ee;
      }, R.prototype.readIntBE = function(W, J, me) {
        W = W >>> 0, J = J >>> 0, me || Qe(W, J, this.length);
        let Ee = J, ke = 1, Ie = this[W + --Ee];
        for (; Ee > 0 && (ke *= 256); )
          Ie += this[W + --Ee] * ke;
        return ke *= 128, Ie >= ke && (Ie -= Math.pow(2, 8 * J)), Ie;
      }, R.prototype.readInt8 = function(W, J) {
        return W = W >>> 0, J || Qe(W, 1, this.length), this[W] & 128 ? (255 - this[W] + 1) * -1 : this[W];
      }, R.prototype.readInt16LE = function(W, J) {
        W = W >>> 0, J || Qe(W, 2, this.length);
        const me = this[W] | this[W + 1] << 8;
        return me & 32768 ? me | 4294901760 : me;
      }, R.prototype.readInt16BE = function(W, J) {
        W = W >>> 0, J || Qe(W, 2, this.length);
        const me = this[W + 1] | this[W] << 8;
        return me & 32768 ? me | 4294901760 : me;
      }, R.prototype.readInt32LE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), this[W] | this[W + 1] << 8 | this[W + 2] << 16 | this[W + 3] << 24;
      }, R.prototype.readInt32BE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), this[W] << 24 | this[W + 1] << 16 | this[W + 2] << 8 | this[W + 3];
      }, R.prototype.readBigInt64LE = tt(function(W) {
        W = W >>> 0, xe(W, "offset");
        const J = this[W], me = this[W + 7];
        (J === void 0 || me === void 0) && pe(W, this.length - 8);
        const Ee = this[W + 4] + this[W + 5] * 2 ** 8 + this[W + 6] * 2 ** 16 + (me << 24);
        return (BigInt(Ee) << BigInt(32)) + BigInt(J + this[++W] * 2 ** 8 + this[++W] * 2 ** 16 + this[++W] * 2 ** 24);
      }), R.prototype.readBigInt64BE = tt(function(W) {
        W = W >>> 0, xe(W, "offset");
        const J = this[W], me = this[W + 7];
        (J === void 0 || me === void 0) && pe(W, this.length - 8);
        const Ee = (J << 24) + // Overflow
        this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + this[++W];
        return (BigInt(Ee) << BigInt(32)) + BigInt(this[++W] * 2 ** 24 + this[++W] * 2 ** 16 + this[++W] * 2 ** 8 + me);
      }), R.prototype.readFloatLE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), j.read(this, W, !0, 23, 4);
      }, R.prototype.readFloatBE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 4, this.length), j.read(this, W, !1, 23, 4);
      }, R.prototype.readDoubleLE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 8, this.length), j.read(this, W, !0, 52, 8);
      }, R.prototype.readDoubleBE = function(W, J) {
        return W = W >>> 0, J || Qe(W, 8, this.length), j.read(this, W, !1, 52, 8);
      };
      function Je(ne, W, J, me, Ee, ke) {
        if (!R.isBuffer(ne)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (W > Ee || W < ke) throw new RangeError('"value" argument is out of bounds');
        if (J + me > ne.length) throw new RangeError("Index out of range");
      }
      R.prototype.writeUintLE = R.prototype.writeUIntLE = function(W, J, me, Ee) {
        if (W = +W, J = J >>> 0, me = me >>> 0, !Ee) {
          const at = Math.pow(2, 8 * me) - 1;
          Je(this, W, J, me, at, 0);
        }
        let ke = 1, Ie = 0;
        for (this[J] = W & 255; ++Ie < me && (ke *= 256); )
          this[J + Ie] = W / ke & 255;
        return J + me;
      }, R.prototype.writeUintBE = R.prototype.writeUIntBE = function(W, J, me, Ee) {
        if (W = +W, J = J >>> 0, me = me >>> 0, !Ee) {
          const at = Math.pow(2, 8 * me) - 1;
          Je(this, W, J, me, at, 0);
        }
        let ke = me - 1, Ie = 1;
        for (this[J + ke] = W & 255; --ke >= 0 && (Ie *= 256); )
          this[J + ke] = W / Ie & 255;
        return J + me;
      }, R.prototype.writeUint8 = R.prototype.writeUInt8 = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 1, 255, 0), this[J] = W & 255, J + 1;
      }, R.prototype.writeUint16LE = R.prototype.writeUInt16LE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 2, 65535, 0), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
      }, R.prototype.writeUint16BE = R.prototype.writeUInt16BE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 2, 65535, 0), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
      }, R.prototype.writeUint32LE = R.prototype.writeUInt32LE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 4, 4294967295, 0), this[J + 3] = W >>> 24, this[J + 2] = W >>> 16, this[J + 1] = W >>> 8, this[J] = W & 255, J + 4;
      }, R.prototype.writeUint32BE = R.prototype.writeUInt32BE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 4, 4294967295, 0), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
      };
      function we(ne, W, J, me, Ee) {
        ue(W, me, Ee, ne, J, 7);
        let ke = Number(W & BigInt(4294967295));
        ne[J++] = ke, ke = ke >> 8, ne[J++] = ke, ke = ke >> 8, ne[J++] = ke, ke = ke >> 8, ne[J++] = ke;
        let Ie = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J++] = Ie, Ie = Ie >> 8, ne[J++] = Ie, Ie = Ie >> 8, ne[J++] = Ie, Ie = Ie >> 8, ne[J++] = Ie, J;
      }
      function Ae(ne, W, J, me, Ee) {
        ue(W, me, Ee, ne, J, 7);
        let ke = Number(W & BigInt(4294967295));
        ne[J + 7] = ke, ke = ke >> 8, ne[J + 6] = ke, ke = ke >> 8, ne[J + 5] = ke, ke = ke >> 8, ne[J + 4] = ke;
        let Ie = Number(W >> BigInt(32) & BigInt(4294967295));
        return ne[J + 3] = Ie, Ie = Ie >> 8, ne[J + 2] = Ie, Ie = Ie >> 8, ne[J + 1] = Ie, Ie = Ie >> 8, ne[J] = Ie, J + 8;
      }
      R.prototype.writeBigUInt64LE = tt(function(W, J = 0) {
        return we(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
      }), R.prototype.writeBigUInt64BE = tt(function(W, J = 0) {
        return Ae(this, W, J, BigInt(0), BigInt("0xffffffffffffffff"));
      }), R.prototype.writeIntLE = function(W, J, me, Ee) {
        if (W = +W, J = J >>> 0, !Ee) {
          const ot = Math.pow(2, 8 * me - 1);
          Je(this, W, J, me, ot - 1, -ot);
        }
        let ke = 0, Ie = 1, at = 0;
        for (this[J] = W & 255; ++ke < me && (Ie *= 256); )
          W < 0 && at === 0 && this[J + ke - 1] !== 0 && (at = 1), this[J + ke] = (W / Ie >> 0) - at & 255;
        return J + me;
      }, R.prototype.writeIntBE = function(W, J, me, Ee) {
        if (W = +W, J = J >>> 0, !Ee) {
          const ot = Math.pow(2, 8 * me - 1);
          Je(this, W, J, me, ot - 1, -ot);
        }
        let ke = me - 1, Ie = 1, at = 0;
        for (this[J + ke] = W & 255; --ke >= 0 && (Ie *= 256); )
          W < 0 && at === 0 && this[J + ke + 1] !== 0 && (at = 1), this[J + ke] = (W / Ie >> 0) - at & 255;
        return J + me;
      }, R.prototype.writeInt8 = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 1, 127, -128), W < 0 && (W = 255 + W + 1), this[J] = W & 255, J + 1;
      }, R.prototype.writeInt16LE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 2, 32767, -32768), this[J] = W & 255, this[J + 1] = W >>> 8, J + 2;
      }, R.prototype.writeInt16BE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 2, 32767, -32768), this[J] = W >>> 8, this[J + 1] = W & 255, J + 2;
      }, R.prototype.writeInt32LE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 4, 2147483647, -2147483648), this[J] = W & 255, this[J + 1] = W >>> 8, this[J + 2] = W >>> 16, this[J + 3] = W >>> 24, J + 4;
      }, R.prototype.writeInt32BE = function(W, J, me) {
        return W = +W, J = J >>> 0, me || Je(this, W, J, 4, 2147483647, -2147483648), W < 0 && (W = 4294967295 + W + 1), this[J] = W >>> 24, this[J + 1] = W >>> 16, this[J + 2] = W >>> 8, this[J + 3] = W & 255, J + 4;
      }, R.prototype.writeBigInt64LE = tt(function(W, J = 0) {
        return we(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), R.prototype.writeBigInt64BE = tt(function(W, J = 0) {
        return Ae(this, W, J, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function ze(ne, W, J, me, Ee, ke) {
        if (J + me > ne.length) throw new RangeError("Index out of range");
        if (J < 0) throw new RangeError("Index out of range");
      }
      function Ue(ne, W, J, me, Ee) {
        return W = +W, J = J >>> 0, Ee || ze(ne, W, J, 4), j.write(ne, W, J, me, 23, 4), J + 4;
      }
      R.prototype.writeFloatLE = function(W, J, me) {
        return Ue(this, W, J, !0, me);
      }, R.prototype.writeFloatBE = function(W, J, me) {
        return Ue(this, W, J, !1, me);
      };
      function Ge(ne, W, J, me, Ee) {
        return W = +W, J = J >>> 0, Ee || ze(ne, W, J, 8), j.write(ne, W, J, me, 52, 8), J + 8;
      }
      R.prototype.writeDoubleLE = function(W, J, me) {
        return Ge(this, W, J, !0, me);
      }, R.prototype.writeDoubleBE = function(W, J, me) {
        return Ge(this, W, J, !1, me);
      }, R.prototype.copy = function(W, J, me, Ee) {
        if (!R.isBuffer(W)) throw new TypeError("argument should be a Buffer");
        if (me || (me = 0), !Ee && Ee !== 0 && (Ee = this.length), J >= W.length && (J = W.length), J || (J = 0), Ee > 0 && Ee < me && (Ee = me), Ee === me || W.length === 0 || this.length === 0) return 0;
        if (J < 0)
          throw new RangeError("targetStart out of bounds");
        if (me < 0 || me >= this.length) throw new RangeError("Index out of range");
        if (Ee < 0) throw new RangeError("sourceEnd out of bounds");
        Ee > this.length && (Ee = this.length), W.length - J < Ee - me && (Ee = W.length - J + me);
        const ke = Ee - me;
        return this === W && typeof V.prototype.copyWithin == "function" ? this.copyWithin(J, me, Ee) : V.prototype.set.call(
          W,
          this.subarray(me, Ee),
          J
        ), ke;
      }, R.prototype.fill = function(W, J, me, Ee) {
        if (typeof W == "string") {
          if (typeof J == "string" ? (Ee = J, J = 0, me = this.length) : typeof me == "string" && (Ee = me, me = this.length), Ee !== void 0 && typeof Ee != "string")
            throw new TypeError("encoding must be a string");
          if (typeof Ee == "string" && !R.isEncoding(Ee))
            throw new TypeError("Unknown encoding: " + Ee);
          if (W.length === 1) {
            const Ie = W.charCodeAt(0);
            (Ee === "utf8" && Ie < 128 || Ee === "latin1") && (W = Ie);
          }
        } else typeof W == "number" ? W = W & 255 : typeof W == "boolean" && (W = Number(W));
        if (J < 0 || this.length < J || this.length < me)
          throw new RangeError("Out of range index");
        if (me <= J)
          return this;
        J = J >>> 0, me = me === void 0 ? this.length : me >>> 0, W || (W = 0);
        let ke;
        if (typeof W == "number")
          for (ke = J; ke < me; ++ke)
            this[ke] = W;
        else {
          const Ie = R.isBuffer(W) ? W : R.from(W, Ee), at = Ie.length;
          if (at === 0)
            throw new TypeError('The value "' + W + '" is invalid for argument "value"');
          for (ke = 0; ke < me - J; ++ke)
            this[ke + J] = Ie[ke % at];
        }
        return this;
      };
      const Xe = {};
      function oe(ne, W, J) {
        Xe[ne] = class extends J {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: W.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${ne}]`, this.stack, delete this.name;
          }
          get code() {
            return ne;
          }
          set code(Ee) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: Ee,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${ne}]: ${this.message}`;
          }
        };
      }
      oe(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(ne) {
          return ne ? `${ne} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), oe(
        "ERR_INVALID_ARG_TYPE",
        function(ne, W) {
          return `The "${ne}" argument must be of type number. Received type ${typeof W}`;
        },
        TypeError
      ), oe(
        "ERR_OUT_OF_RANGE",
        function(ne, W, J) {
          let me = `The value of "${ne}" is out of range.`, Ee = J;
          return Number.isInteger(J) && Math.abs(J) > 2 ** 32 ? Ee = L(String(J)) : typeof J == "bigint" && (Ee = String(J), (J > BigInt(2) ** BigInt(32) || J < -(BigInt(2) ** BigInt(32))) && (Ee = L(Ee)), Ee += "n"), me += ` It must be ${W}. Received ${Ee}`, me;
        },
        RangeError
      );
      function L(ne) {
        let W = "", J = ne.length;
        const me = ne[0] === "-" ? 1 : 0;
        for (; J >= me + 4; J -= 3)
          W = `_${ne.slice(J - 3, J)}${W}`;
        return `${ne.slice(0, J)}${W}`;
      }
      function H(ne, W, J) {
        xe(W, "offset"), (ne[W] === void 0 || ne[W + J] === void 0) && pe(W, ne.length - (J + 1));
      }
      function ue(ne, W, J, me, Ee, ke) {
        if (ne > J || ne < W) {
          const Ie = typeof W == "bigint" ? "n" : "";
          let at;
          throw W === 0 || W === BigInt(0) ? at = `>= 0${Ie} and < 2${Ie} ** ${(ke + 1) * 8}${Ie}` : at = `>= -(2${Ie} ** ${(ke + 1) * 8 - 1}${Ie}) and < 2 ** ${(ke + 1) * 8 - 1}${Ie}`, new Xe.ERR_OUT_OF_RANGE("value", at, ne);
        }
        H(me, Ee, ke);
      }
      function xe(ne, W) {
        if (typeof ne != "number")
          throw new Xe.ERR_INVALID_ARG_TYPE(W, "number", ne);
      }
      function pe(ne, W, J) {
        throw Math.floor(ne) !== ne ? (xe(ne, J), new Xe.ERR_OUT_OF_RANGE("offset", "an integer", ne)) : W < 0 ? new Xe.ERR_BUFFER_OUT_OF_BOUNDS() : new Xe.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${W}`,
          ne
        );
      }
      const ce = /[^+/0-9A-Za-z-_]/g;
      function Y(ne) {
        if (ne = ne.split("=")[0], ne = ne.trim().replace(ce, ""), ne.length < 2) return "";
        for (; ne.length % 4 !== 0; )
          ne = ne + "=";
        return ne;
      }
      function Te(ne, W) {
        W = W || 1 / 0;
        let J;
        const me = ne.length;
        let Ee = null;
        const ke = [];
        for (let Ie = 0; Ie < me; ++Ie) {
          if (J = ne.charCodeAt(Ie), J > 55295 && J < 57344) {
            if (!Ee) {
              if (J > 56319) {
                (W -= 3) > -1 && ke.push(239, 191, 189);
                continue;
              } else if (Ie + 1 === me) {
                (W -= 3) > -1 && ke.push(239, 191, 189);
                continue;
              }
              Ee = J;
              continue;
            }
            if (J < 56320) {
              (W -= 3) > -1 && ke.push(239, 191, 189), Ee = J;
              continue;
            }
            J = (Ee - 55296 << 10 | J - 56320) + 65536;
          } else Ee && (W -= 3) > -1 && ke.push(239, 191, 189);
          if (Ee = null, J < 128) {
            if ((W -= 1) < 0) break;
            ke.push(J);
          } else if (J < 2048) {
            if ((W -= 2) < 0) break;
            ke.push(
              J >> 6 | 192,
              J & 63 | 128
            );
          } else if (J < 65536) {
            if ((W -= 3) < 0) break;
            ke.push(
              J >> 12 | 224,
              J >> 6 & 63 | 128,
              J & 63 | 128
            );
          } else if (J < 1114112) {
            if ((W -= 4) < 0) break;
            ke.push(
              J >> 18 | 240,
              J >> 12 & 63 | 128,
              J >> 6 & 63 | 128,
              J & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return ke;
      }
      function Ne(ne) {
        const W = [];
        for (let J = 0; J < ne.length; ++J)
          W.push(ne.charCodeAt(J) & 255);
        return W;
      }
      function K(ne, W) {
        let J, me, Ee;
        const ke = [];
        for (let Ie = 0; Ie < ne.length && !((W -= 2) < 0); ++Ie)
          J = ne.charCodeAt(Ie), me = J >> 8, Ee = J % 256, ke.push(Ee), ke.push(me);
        return ke;
      }
      function Se(ne) {
        return O.toByteArray(Y(ne));
      }
      function Ce(ne, W, J, me) {
        let Ee;
        for (Ee = 0; Ee < me && !(Ee + J >= W.length || Ee >= ne.length); ++Ee)
          W[Ee + J] = ne[Ee];
        return Ee;
      }
      function de(ne, W) {
        return ne instanceof W || ne != null && ne.constructor != null && ne.constructor.name != null && ne.constructor.name === W.name;
      }
      function _e(ne) {
        return ne !== ne;
      }
      const Me = (function() {
        const ne = "0123456789abcdef", W = new Array(256);
        for (let J = 0; J < 16; ++J) {
          const me = J * 16;
          for (let Ee = 0; Ee < 16; ++Ee)
            W[me + Ee] = ne[J] + ne[Ee];
        }
        return W;
      })();
      function tt(ne) {
        return typeof BigInt > "u" ? We : ne;
      }
      function We() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const b = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = b, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  })(dist$1)), dist$1;
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$4;
function requireSafeBuffer$4() {
  return hasRequiredSafeBuffer$4 || (hasRequiredSafeBuffer$4 = 1, (function(e, t) {
    var r = requireDist$1(), a = r.Buffer;
    function u(o, c) {
      for (var f in o)
        c[f] = o[f];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (u(r, t), t.Buffer = n);
    function n(o, c, f) {
      return a(o, c, f);
    }
    n.prototype = Object.create(a.prototype), u(a, n), n.from = function(o, c, f) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return a(o, c, f);
    }, n.alloc = function(o, c, f) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var l = a(o);
      return c !== void 0 ? typeof f == "string" ? l.fill(c, f) : l.fill(c) : l.fill(0), l;
    }, n.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return a(o);
    }, n.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  })(safeBuffer$4, safeBuffer$4.exports)), safeBuffer$4.exports;
}
var hasRequiredBrowser$i;
function requireBrowser$i() {
  if (hasRequiredBrowser$i) return browser$i.exports;
  hasRequiredBrowser$i = 1;
  var e = 65536, t = 4294967295;
  function r() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var a = requireSafeBuffer$4().Buffer, u = globalThis.crypto || globalThis.msCrypto;
  u && u.getRandomValues ? browser$i.exports = n : browser$i.exports = r;
  function n(o, c) {
    if (o > t) throw new RangeError("requested too many random bytes");
    var f = a.allocUnsafe(o);
    if (o > 0)
      if (o > e)
        for (var l = 0; l < o; l += e)
          u.getRandomValues(f.slice(l, l + e));
      else
        u.getRandomValues(f);
    return typeof c == "function" ? process$1.nextTick(function() {
      c(null, f);
    }) : f;
  }
  return browser$i.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var a = function() {
      };
      a.prototype = r.prototype, t.prototype = new a(), t.prototype.constructor = t;
    }
  }), inherits_browser.exports;
}
var isarray$2, hasRequiredIsarray$2;
function requireIsarray$2() {
  if (hasRequiredIsarray$2) return isarray$2;
  hasRequiredIsarray$2 = 1;
  var e = {}.toString;
  return isarray$2 = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, isarray$2;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(t) {
    return t !== t;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var e = /* @__PURE__ */ require_isNaN();
  return sign$1 = function(r) {
    return e(r) || r === 0 ? r : r < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var e = /* @__PURE__ */ requireGOPD();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return gopd = e, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return esDefineProperty = e, esDefineProperty;
}
var shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), a = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
      return !1;
    var u = 42;
    t[r] = u;
    for (var n in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (c.value !== u || c.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, t = requireShams$1();
  return hasSymbols = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var e = /* @__PURE__ */ requireEsObjectAtoms();
  return Object_getPrototypeOf = e.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation$4, hasRequiredImplementation$4;
function requireImplementation$4() {
  if (hasRequiredImplementation$4) return implementation$4;
  hasRequiredImplementation$4 = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, a = "[object Function]", u = function(f, l) {
    for (var s = [], p = 0; p < f.length; p += 1)
      s[p] = f[p];
    for (var m = 0; m < l.length; m += 1)
      s[m + f.length] = l[m];
    return s;
  }, n = function(f, l) {
    for (var s = [], p = l, m = 0; p < f.length; p += 1, m += 1)
      s[m] = f[p];
    return s;
  }, o = function(c, f) {
    for (var l = "", s = 0; s < c.length; s += 1)
      l += c[s], s + 1 < c.length && (l += f);
    return l;
  };
  return implementation$4 = function(f) {
    var l = this;
    if (typeof l != "function" || t.apply(l) !== a)
      throw new TypeError(e + l);
    for (var s = n(arguments, 1), p, m = function() {
      if (this instanceof p) {
        var b = l.apply(
          this,
          u(s, arguments)
        );
        return Object(b) === b ? b : this;
      }
      return l.apply(
        f,
        u(s, arguments)
      );
    }, g = r(0, l.length - s.length), y = [], v = 0; v < g; v++)
      y[v] = "$" + v;
    if (p = Function("binder", "return function (" + o(y, ",") + "){ return binder.apply(this,arguments); }")(m), l.prototype) {
      var E = function() {
      };
      E.prototype = l.prototype, p.prototype = new E(), E.prototype = null;
    }
    return p;
  }, implementation$4;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var e = requireImplementation$4();
  return functionBind = Function.prototype.bind || e, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var e = requireFunctionBind(), t = requireFunctionApply(), r = requireFunctionCall(), a = requireReflectApply();
  return actualApply = a || e.call(r, t), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var e = requireFunctionBind(), t = /* @__PURE__ */ requireType(), r = requireFunctionCall(), a = requireActualApply();
  return callBindApplyHelpers = function(n) {
    if (n.length < 1 || typeof n[0] != "function")
      throw new t("a function is required");
    return a(e, r, n);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var e = requireCallBindApplyHelpers(), t = /* @__PURE__ */ requireGopd(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var a = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), u = Object, n = u.getPrototypeOf;
  return get = a && typeof a.get == "function" ? e([a.get]) : typeof n == "function" ? (
    /** @type {import('./get')} */
    function(c) {
      return n(c == null ? c : u(c));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var e = requireReflect_getPrototypeOf(), t = requireObject_getPrototypeOf(), r = /* @__PURE__ */ requireGet();
  return getProto = e ? function(u) {
    return e(u);
  } : t ? function(u) {
    if (!u || typeof u != "object" && typeof u != "function")
      throw new TypeError("getProto: not an object");
    return t(u);
  } : r ? function(u) {
    return r(u);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = requireFunctionBind();
  return hasown = r.call(e, t), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var e, t = /* @__PURE__ */ requireEsObjectAtoms(), r = /* @__PURE__ */ requireEsErrors(), a = /* @__PURE__ */ require_eval(), u = /* @__PURE__ */ requireRange(), n = /* @__PURE__ */ requireRef(), o = /* @__PURE__ */ requireSyntax(), c = /* @__PURE__ */ requireType(), f = /* @__PURE__ */ requireUri(), l = /* @__PURE__ */ requireAbs(), s = /* @__PURE__ */ requireFloor(), p = /* @__PURE__ */ requireMax(), m = /* @__PURE__ */ requireMin(), g = /* @__PURE__ */ requirePow(), y = /* @__PURE__ */ requireRound(), v = /* @__PURE__ */ requireSign$1(), E = Function, b = function(se) {
    try {
      return E('"use strict"; return (' + se + ").constructor;")();
    } catch {
    }
  }, q = /* @__PURE__ */ requireGopd(), O = /* @__PURE__ */ requireEsDefineProperty(), j = function() {
    throw new c();
  }, D = q ? (function() {
    try {
      return arguments.callee, j;
    } catch {
      try {
        return q(arguments, "callee").get;
      } catch {
        return j;
      }
    }
  })() : j, G = requireHasSymbols()(), V = requireGetProto(), Q = requireObject_getPrototypeOf(), re = requireReflect_getPrototypeOf(), ve = requireFunctionApply(), te = requireFunctionCall(), R = {}, M = typeof Uint8Array > "u" || !V ? e : V(Uint8Array), h = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": G && V ? V([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": R,
    "%AsyncGenerator%": R,
    "%AsyncGeneratorFunction%": R,
    "%AsyncIteratorPrototype%": R,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": a,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": E,
    "%GeneratorFunction%": R,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": G && V ? V(V([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !G || !V ? e : V((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": q,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": u,
    "%ReferenceError%": n,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !G || !V ? e : V((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": G && V ? V(""[Symbol.iterator]()) : e,
    "%Symbol%": G ? Symbol : e,
    "%SyntaxError%": o,
    "%ThrowTypeError%": D,
    "%TypedArray%": M,
    "%TypeError%": c,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": f,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": te,
    "%Function.prototype.apply%": ve,
    "%Object.defineProperty%": O,
    "%Object.getPrototypeOf%": Q,
    "%Math.abs%": l,
    "%Math.floor%": s,
    "%Math.max%": p,
    "%Math.min%": m,
    "%Math.pow%": g,
    "%Math.round%": y,
    "%Math.sign%": v,
    "%Reflect.getPrototypeOf%": re
  };
  if (V)
    try {
      null.error;
    } catch (se) {
      var S = V(V(se));
      h["%Error.prototype%"] = S;
    }
  var B = function se(he) {
    var ae;
    if (he === "%AsyncFunction%")
      ae = b("async function () {}");
    else if (he === "%GeneratorFunction%")
      ae = b("function* () {}");
    else if (he === "%AsyncGeneratorFunction%")
      ae = b("async function* () {}");
    else if (he === "%AsyncGenerator%") {
      var X = se("%AsyncGeneratorFunction%");
      X && (ae = X.prototype);
    } else if (he === "%AsyncIteratorPrototype%") {
      var be = se("%AsyncGenerator%");
      be && V && (ae = V(be.prototype));
    }
    return h[he] = ae, ae;
  }, T = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, k = requireFunctionBind(), I = /* @__PURE__ */ requireHasown(), C = k.call(te, Array.prototype.concat), $ = k.call(ve, Array.prototype.splice), w = k.call(te, String.prototype.replace), U = k.call(te, String.prototype.slice), ie = k.call(te, RegExp.prototype.exec), le = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ee = /\\(\\)?/g, F = function(he) {
    var ae = U(he, 0, 1), X = U(he, -1);
    if (ae === "%" && X !== "%")
      throw new o("invalid intrinsic syntax, expected closing `%`");
    if (X === "%" && ae !== "%")
      throw new o("invalid intrinsic syntax, expected opening `%`");
    var be = [];
    return w(he, le, function(Re, Pe, Fe, De) {
      be[be.length] = Fe ? w(De, ee, "$1") : Pe || Re;
    }), be;
  }, z = function(he, ae) {
    var X = he, be;
    if (I(T, X) && (be = T[X], X = "%" + be[0] + "%"), I(h, X)) {
      var Re = h[X];
      if (Re === R && (Re = B(X)), typeof Re > "u" && !ae)
        throw new c("intrinsic " + he + " exists, but is not available. Please file an issue!");
      return {
        alias: be,
        name: X,
        value: Re
      };
    }
    throw new o("intrinsic " + he + " does not exist!");
  };
  return getIntrinsic = function(he, ae) {
    if (typeof he != "string" || he.length === 0)
      throw new c("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof ae != "boolean")
      throw new c('"allowMissing" argument must be a boolean');
    if (ie(/^%?[^%]*%?$/, he) === null)
      throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var X = F(he), be = X.length > 0 ? X[0] : "", Re = z("%" + be + "%", ae), Pe = Re.name, Fe = Re.value, De = !1, je = Re.alias;
    je && (be = je[0], $(X, C([0, 1], je)));
    for (var Oe = 1, rt = !0; Oe < X.length; Oe += 1) {
      var He = X[Oe], Qe = U(He, 0, 1), Je = U(He, -1);
      if ((Qe === '"' || Qe === "'" || Qe === "`" || Je === '"' || Je === "'" || Je === "`") && Qe !== Je)
        throw new o("property names with quotes must have matching quotes");
      if ((He === "constructor" || !rt) && (De = !0), be += "." + He, Pe = "%" + be + "%", I(h, Pe))
        Fe = h[Pe];
      else if (Fe != null) {
        if (!(He in Fe)) {
          if (!ae)
            throw new c("base intrinsic for " + he + " exists, but the property is not available.");
          return;
        }
        if (q && Oe + 1 >= X.length) {
          var we = q(Fe, He);
          rt = !!we, rt && "get" in we && !("originalValue" in we.get) ? Fe = we.get : Fe = Fe[He];
        } else
          rt = I(Fe, He), Fe = Fe[He];
        rt && !De && (h[Pe] = Fe);
      }
    }
    return Fe;
  }, getIntrinsic;
}
var callBound$1, hasRequiredCallBound$1;
function requireCallBound$1() {
  if (hasRequiredCallBound$1) return callBound$1;
  hasRequiredCallBound$1 = 1;
  var e = /* @__PURE__ */ requireGetIntrinsic(), t = requireCallBindApplyHelpers(), r = t([e("%String.prototype.indexOf%")]);
  return callBound$1 = function(u, n) {
    var o = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(u, !!n)
    );
    return typeof o == "function" && r(u, ".prototype.") > -1 ? t(
      /** @type {const} */
      [o]
    ) : o;
  }, callBound$1;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, a;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw a;
        }
      }), a = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (q) {
      q !== a && (t = null);
    }
  else
    t = null;
  var u = /^\s*class\b/, n = function(O) {
    try {
      var j = e.call(O);
      return u.test(j);
    } catch {
      return !1;
    }
  }, o = function(O) {
    try {
      return n(O) ? !1 : (e.call(O), !0);
    } catch {
      return !1;
    }
  }, c = Object.prototype.toString, f = "[object Object]", l = "[object Function]", s = "[object GeneratorFunction]", p = "[object HTMLAllCollection]", m = "[object HTML document.all class]", g = "[object HTMLCollection]", y = typeof Symbol == "function" && !!Symbol.toStringTag, v = !(0 in [,]), E = function() {
    return !1;
  };
  if (typeof document == "object") {
    var b = document.all;
    c.call(b) === c.call(document.all) && (E = function(O) {
      if ((v || !O) && (typeof O > "u" || typeof O == "object"))
        try {
          var j = c.call(O);
          return (j === p || j === m || j === g || j === f) && O("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = t ? function(O) {
    if (E(O))
      return !0;
    if (!O || typeof O != "function" && typeof O != "object")
      return !1;
    try {
      t(O, null, r);
    } catch (j) {
      if (j !== a)
        return !1;
    }
    return !n(O) && o(O);
  } : function(O) {
    if (E(O))
      return !0;
    if (!O || typeof O != "function" && typeof O != "object")
      return !1;
    if (y)
      return o(O);
    if (n(O))
      return !1;
    var j = c.call(O);
    return j !== l && j !== s && !/^\[object HTML/.test(j) ? !1 : o(O);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var e = requireIsCallable(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, a = function(f, l, s) {
    for (var p = 0, m = f.length; p < m; p++)
      r.call(f, p) && (s == null ? l(f[p], p, f) : l.call(s, f[p], p, f));
  }, u = function(f, l, s) {
    for (var p = 0, m = f.length; p < m; p++)
      s == null ? l(f.charAt(p), p, f) : l.call(s, f.charAt(p), p, f);
  }, n = function(f, l, s) {
    for (var p in f)
      r.call(f, p) && (s == null ? l(f[p], p, f) : l.call(s, f[p], p, f));
  };
  function o(c) {
    return t.call(c) === "[object Array]";
  }
  return forEach = function(f, l, s) {
    if (!e(l))
      throw new TypeError("iterator must be a function");
    var p;
    arguments.length >= 3 && (p = s), o(f) ? a(f, l, p) : typeof f == "string" ? u(f, l, p) : n(f, l, p);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var e = /* @__PURE__ */ requirePossibleTypedArrayNames(), t = globalThis;
  return availableTypedArrays = function() {
    for (var a = [], u = 0; u < e.length; u++)
      typeof t[e[u]] == "function" && (a[a.length] = e[u]);
    return a;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var e = /* @__PURE__ */ requireEsDefineProperty(), t = /* @__PURE__ */ requireSyntax(), r = /* @__PURE__ */ requireType(), a = /* @__PURE__ */ requireGopd();
  return defineDataProperty = function(n, o, c) {
    if (!n || typeof n != "object" && typeof n != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof o != "string" && typeof o != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var f = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, s = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, m = !!a && a(n, o);
    if (e)
      e(n, o, {
        configurable: s === null && m ? m.configurable : !s,
        enumerable: f === null && m ? m.enumerable : !f,
        value: c,
        writable: l === null && m ? m.writable : !l
      });
    else if (p || !f && !l && !s)
      n[o] = c;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var e = /* @__PURE__ */ requireEsDefineProperty(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = t, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var e = /* @__PURE__ */ requireGetIntrinsic(), t = /* @__PURE__ */ requireDefineDataProperty(), r = /* @__PURE__ */ requireHasPropertyDescriptors()(), a = /* @__PURE__ */ requireGopd(), u = /* @__PURE__ */ requireType(), n = e("%Math.floor%");
  return setFunctionLength = function(c, f) {
    if (typeof c != "function")
      throw new u("`fn` is not a function");
    if (typeof f != "number" || f < 0 || f > 4294967295 || n(f) !== f)
      throw new u("`length` must be a positive 32-bit integer");
    var l = arguments.length > 2 && !!arguments[2], s = !0, p = !0;
    if ("length" in c && a) {
      var m = a(c, "length");
      m && !m.configurable && (s = !1), m && !m.writable && (p = !1);
    }
    return (s || p || !l) && (r ? t(
      /** @type {Parameters<define>[0]} */
      c,
      "length",
      f,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      c,
      "length",
      f
    )), c;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var e = requireFunctionBind(), t = requireFunctionApply(), r = requireActualApply();
  return applyBind = function() {
    return r(e, t, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, (function(e) {
    var t = /* @__PURE__ */ requireSetFunctionLength(), r = /* @__PURE__ */ requireEsDefineProperty(), a = requireCallBindApplyHelpers(), u = requireApplyBind();
    e.exports = function(o) {
      var c = a(arguments), f = o.length - (arguments.length - 1);
      return t(
        c,
        1 + (f > 0 ? f : 0),
        !0
      );
    }, r ? r(e.exports, "apply", { value: u }) : e.exports.apply = u;
  })(callBind)), callBind.exports;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var e = requireShams$1();
  return shams = function() {
    return e() && !!Symbol.toStringTag;
  }, shams;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var e = requireForEach(), t = /* @__PURE__ */ requireAvailableTypedArrays(), r = requireCallBind(), a = /* @__PURE__ */ requireCallBound$1(), u = /* @__PURE__ */ requireGopd(), n = requireGetProto(), o = a("Object.prototype.toString"), c = requireShams()(), f = globalThis, l = t(), s = a("String.prototype.slice"), p = a("Array.prototype.indexOf", !0) || function(E, b) {
    for (var q = 0; q < E.length; q += 1)
      if (E[q] === b)
        return q;
    return -1;
  }, m = { __proto__: null };
  c && u && n ? e(l, function(v) {
    var E = new f[v]();
    if (Symbol.toStringTag in E && n) {
      var b = n(E), q = u(b, Symbol.toStringTag);
      if (!q && b) {
        var O = n(b);
        q = u(O, Symbol.toStringTag);
      }
      m["$" + v] = r(q.get);
    }
  }) : e(l, function(v) {
    var E = new f[v](), b = E.slice || E.set;
    b && (m[
      /** @type {`$${import('.').TypedArrayName}`} */
      "$" + v
    ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
    // @ts-expect-error TODO FIXME
    r(b));
  });
  var g = function(E) {
    var b = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      m,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(q, O) {
        if (!b)
          try {
            "$" + q(E) === O && (b = /** @type {import('.').TypedArrayName} */
            s(O, 1));
          } catch {
          }
      }
    ), b;
  }, y = function(E) {
    var b = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      m,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(q, O) {
        if (!b)
          try {
            q(E), b = /** @type {import('.').TypedArrayName} */
            s(O, 1);
          } catch {
          }
      }
    ), b;
  };
  return whichTypedArray = function(E) {
    if (!E || typeof E != "object")
      return !1;
    if (!c) {
      var b = s(o(E), 8, -1);
      return p(l, b) > -1 ? b : b !== "Object" ? !1 : y(E);
    }
    return u ? g(E) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var e = /* @__PURE__ */ requireWhichTypedArray();
  return isTypedArray = function(r) {
    return !!e(r);
  }, isTypedArray;
}
var typedArrayBuffer, hasRequiredTypedArrayBuffer;
function requireTypedArrayBuffer() {
  if (hasRequiredTypedArrayBuffer) return typedArrayBuffer;
  hasRequiredTypedArrayBuffer = 1;
  var e = /* @__PURE__ */ requireType(), t = /* @__PURE__ */ requireCallBound$1(), r = t("TypedArray.prototype.buffer", !0), a = /* @__PURE__ */ requireIsTypedArray();
  return typedArrayBuffer = r || function(n) {
    if (!a(n))
      throw new e("Not a Typed Array");
    return n.buffer;
  }, typedArrayBuffer;
}
var toBuffer, hasRequiredToBuffer$2;
function requireToBuffer$2() {
  if (hasRequiredToBuffer$2) return toBuffer;
  hasRequiredToBuffer$2 = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireIsarray$2(), r = /* @__PURE__ */ requireTypedArrayBuffer(), a = ArrayBuffer.isView || function(f) {
    try {
      return r(f), !0;
    } catch {
      return !1;
    }
  }, u = typeof Uint8Array < "u", n = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o = n && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
  return toBuffer = function(f, l) {
    if (e.isBuffer(f))
      return f.constructor && !("isBuffer" in f) ? e.from(f) : f;
    if (typeof f == "string")
      return e.from(f, l);
    if (n && a(f)) {
      if (f.byteLength === 0)
        return e.alloc(0);
      if (o) {
        var s = e.from(f.buffer, f.byteOffset, f.byteLength);
        if (s.byteLength === f.byteLength)
          return s;
      }
      var p = f instanceof Uint8Array ? f : new Uint8Array(f.buffer, f.byteOffset, f.byteLength), m = e.from(p);
      if (m.length === f.byteLength)
        return m;
    }
    if (u && f instanceof Uint8Array)
      return e.from(f);
    var g = t(f);
    if (g)
      for (var y = 0; y < f.length; y += 1) {
        var v = f[y];
        if (typeof v != "number" || v < 0 || v > 255 || ~~v !== v)
          throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    if (g || e.isBuffer(f) && f.constructor && typeof f.constructor.isBuffer == "function" && f.constructor.isBuffer(f))
      return e.from(f);
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  }, toBuffer;
}
var toBuffer_1$1, hasRequiredToBuffer$1;
function requireToBuffer$1() {
  if (hasRequiredToBuffer$1) return toBuffer_1$1;
  hasRequiredToBuffer$1 = 1;
  var e = requireSafeBuffer$4().Buffer, t = /* @__PURE__ */ requireToBuffer$2(), r = typeof Uint8Array < "u", a = r && typeof ArrayBuffer < "u", u = a && ArrayBuffer.isView;
  return toBuffer_1$1 = function(n, o) {
    if (typeof n == "string" || e.isBuffer(n) || r && n instanceof Uint8Array || u && u(n))
      return t(n, o);
    throw new TypeError('The "data" argument must be a string, a Buffer, a Uint8Array, or a DataView');
  }, toBuffer_1$1;
}
var readableBrowser$2 = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: e } : processNextickArgs.exports = process$1;
  function e(t, r, a, u) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var n = arguments.length, o, c;
    switch (n) {
      case 0:
      case 1:
        return process$1.nextTick(t);
      case 2:
        return process$1.nextTick(function() {
          t.call(null, r);
        });
      case 3:
        return process$1.nextTick(function() {
          t.call(null, r, a);
        });
      case 4:
        return process$1.nextTick(function() {
          t.call(null, r, a, u);
        });
      default:
        for (o = new Array(n - 1), c = 0; c < o.length; )
          o[c++] = arguments[c];
        return process$1.nextTick(function() {
          t.apply(null, o);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray$1, hasRequiredIsarray$1;
function requireIsarray$1() {
  if (hasRequiredIsarray$1) return isarray$1;
  hasRequiredIsarray$1 = 1;
  var e = {}.toString;
  return isarray$1 = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, isarray$1;
}
var events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(D, G, V) {
    return Function.prototype.apply.call(D, G, V);
  }, r;
  e && typeof e.ownKeys == "function" ? r = e.ownKeys : Object.getOwnPropertySymbols ? r = function(D) {
    return Object.getOwnPropertyNames(D).concat(Object.getOwnPropertySymbols(D));
  } : r = function(D) {
    return Object.getOwnPropertyNames(D);
  };
  function a(j) {
    console && console.warn && console.warn(j);
  }
  var u = Number.isNaN || function(D) {
    return D !== D;
  };
  function n() {
    n.init.call(this);
  }
  events.exports = n, events.exports.once = b, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._eventsCount = 0, n.prototype._maxListeners = void 0;
  var o = 10;
  function c(j) {
    if (typeof j != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
  }
  Object.defineProperty(n, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return o;
    },
    set: function(j) {
      if (typeof j != "number" || j < 0 || u(j))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + j + ".");
      o = j;
    }
  }), n.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, n.prototype.setMaxListeners = function(D) {
    if (typeof D != "number" || D < 0 || u(D))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + D + ".");
    return this._maxListeners = D, this;
  };
  function f(j) {
    return j._maxListeners === void 0 ? n.defaultMaxListeners : j._maxListeners;
  }
  n.prototype.getMaxListeners = function() {
    return f(this);
  }, n.prototype.emit = function(D) {
    for (var G = [], V = 1; V < arguments.length; V++) G.push(arguments[V]);
    var Q = D === "error", re = this._events;
    if (re !== void 0)
      Q = Q && re.error === void 0;
    else if (!Q)
      return !1;
    if (Q) {
      var ve;
      if (G.length > 0 && (ve = G[0]), ve instanceof Error)
        throw ve;
      var te = new Error("Unhandled error." + (ve ? " (" + ve.message + ")" : ""));
      throw te.context = ve, te;
    }
    var R = re[D];
    if (R === void 0)
      return !1;
    if (typeof R == "function")
      t(R, this, G);
    else
      for (var M = R.length, h = y(R, M), V = 0; V < M; ++V)
        t(h[V], this, G);
    return !0;
  };
  function l(j, D, G, V) {
    var Q, re, ve;
    if (c(G), re = j._events, re === void 0 ? (re = j._events = /* @__PURE__ */ Object.create(null), j._eventsCount = 0) : (re.newListener !== void 0 && (j.emit(
      "newListener",
      D,
      G.listener ? G.listener : G
    ), re = j._events), ve = re[D]), ve === void 0)
      ve = re[D] = G, ++j._eventsCount;
    else if (typeof ve == "function" ? ve = re[D] = V ? [G, ve] : [ve, G] : V ? ve.unshift(G) : ve.push(G), Q = f(j), Q > 0 && ve.length > Q && !ve.warned) {
      ve.warned = !0;
      var te = new Error("Possible EventEmitter memory leak detected. " + ve.length + " " + String(D) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      te.name = "MaxListenersExceededWarning", te.emitter = j, te.type = D, te.count = ve.length, a(te);
    }
    return j;
  }
  n.prototype.addListener = function(D, G) {
    return l(this, D, G, !1);
  }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(D, G) {
    return l(this, D, G, !0);
  };
  function s() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function p(j, D, G) {
    var V = { fired: !1, wrapFn: void 0, target: j, type: D, listener: G }, Q = s.bind(V);
    return Q.listener = G, V.wrapFn = Q, Q;
  }
  n.prototype.once = function(D, G) {
    return c(G), this.on(D, p(this, D, G)), this;
  }, n.prototype.prependOnceListener = function(D, G) {
    return c(G), this.prependListener(D, p(this, D, G)), this;
  }, n.prototype.removeListener = function(D, G) {
    var V, Q, re, ve, te;
    if (c(G), Q = this._events, Q === void 0)
      return this;
    if (V = Q[D], V === void 0)
      return this;
    if (V === G || V.listener === G)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Q[D], Q.removeListener && this.emit("removeListener", D, V.listener || G));
    else if (typeof V != "function") {
      for (re = -1, ve = V.length - 1; ve >= 0; ve--)
        if (V[ve] === G || V[ve].listener === G) {
          te = V[ve].listener, re = ve;
          break;
        }
      if (re < 0)
        return this;
      re === 0 ? V.shift() : v(V, re), V.length === 1 && (Q[D] = V[0]), Q.removeListener !== void 0 && this.emit("removeListener", D, te || G);
    }
    return this;
  }, n.prototype.off = n.prototype.removeListener, n.prototype.removeAllListeners = function(D) {
    var G, V, Q;
    if (V = this._events, V === void 0)
      return this;
    if (V.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : V[D] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete V[D]), this;
    if (arguments.length === 0) {
      var re = Object.keys(V), ve;
      for (Q = 0; Q < re.length; ++Q)
        ve = re[Q], ve !== "removeListener" && this.removeAllListeners(ve);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (G = V[D], typeof G == "function")
      this.removeListener(D, G);
    else if (G !== void 0)
      for (Q = G.length - 1; Q >= 0; Q--)
        this.removeListener(D, G[Q]);
    return this;
  };
  function m(j, D, G) {
    var V = j._events;
    if (V === void 0)
      return [];
    var Q = V[D];
    return Q === void 0 ? [] : typeof Q == "function" ? G ? [Q.listener || Q] : [Q] : G ? E(Q) : y(Q, Q.length);
  }
  n.prototype.listeners = function(D) {
    return m(this, D, !0);
  }, n.prototype.rawListeners = function(D) {
    return m(this, D, !1);
  }, n.listenerCount = function(j, D) {
    return typeof j.listenerCount == "function" ? j.listenerCount(D) : g.call(j, D);
  }, n.prototype.listenerCount = g;
  function g(j) {
    var D = this._events;
    if (D !== void 0) {
      var G = D[j];
      if (typeof G == "function")
        return 1;
      if (G !== void 0)
        return G.length;
    }
    return 0;
  }
  n.prototype.eventNames = function() {
    return this._eventsCount > 0 ? r(this._events) : [];
  };
  function y(j, D) {
    for (var G = new Array(D), V = 0; V < D; ++V)
      G[V] = j[V];
    return G;
  }
  function v(j, D) {
    for (; D + 1 < j.length; D++)
      j[D] = j[D + 1];
    j.pop();
  }
  function E(j) {
    for (var D = new Array(j.length), G = 0; G < D.length; ++G)
      D[G] = j[G].listener || j[G];
    return D;
  }
  function b(j, D) {
    return new Promise(function(G, V) {
      function Q(ve) {
        j.removeListener(D, re), V(ve);
      }
      function re() {
        typeof j.removeListener == "function" && j.removeListener("error", Q), G([].slice.call(arguments));
      }
      O(j, D, re, { once: !0 }), D !== "error" && q(j, Q, { once: !0 });
    });
  }
  function q(j, D, G) {
    typeof j.on == "function" && O(j, "error", D, G);
  }
  function O(j, D, G, V) {
    if (typeof j.on == "function")
      V.once ? j.once(D, G) : j.on(D, G);
    else if (typeof j.addEventListener == "function")
      j.addEventListener(D, function Q(re) {
        V.once && j.removeEventListener(D, Q), G(re);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof j);
  }
  return events.exports;
}
var streamBrowser$2, hasRequiredStreamBrowser$2;
function requireStreamBrowser$2() {
  return hasRequiredStreamBrowser$2 || (hasRequiredStreamBrowser$2 = 1, streamBrowser$2 = requireEvents().EventEmitter), streamBrowser$2;
}
var safeBuffer$3 = { exports: {} }, hasRequiredSafeBuffer$3;
function requireSafeBuffer$3() {
  return hasRequiredSafeBuffer$3 || (hasRequiredSafeBuffer$3 = 1, (function(e, t) {
    var r = requireDist$1(), a = r.Buffer;
    function u(o, c) {
      for (var f in o)
        c[f] = o[f];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (u(r, t), t.Buffer = n);
    function n(o, c, f) {
      return a(o, c, f);
    }
    u(a, n), n.from = function(o, c, f) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return a(o, c, f);
    }, n.alloc = function(o, c, f) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var l = a(o);
      return c !== void 0 ? typeof f == "string" ? l.fill(c, f) : l.fill(c) : l.fill(0), l;
    }, n.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return a(o);
    }, n.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  })(safeBuffer$3, safeBuffer$3.exports)), safeBuffer$3.exports;
}
var util$1 = {}, hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  function e(v) {
    return Array.isArray ? Array.isArray(v) : y(v) === "[object Array]";
  }
  util$1.isArray = e;
  function t(v) {
    return typeof v == "boolean";
  }
  util$1.isBoolean = t;
  function r(v) {
    return v === null;
  }
  util$1.isNull = r;
  function a(v) {
    return v == null;
  }
  util$1.isNullOrUndefined = a;
  function u(v) {
    return typeof v == "number";
  }
  util$1.isNumber = u;
  function n(v) {
    return typeof v == "string";
  }
  util$1.isString = n;
  function o(v) {
    return typeof v == "symbol";
  }
  util$1.isSymbol = o;
  function c(v) {
    return v === void 0;
  }
  util$1.isUndefined = c;
  function f(v) {
    return y(v) === "[object RegExp]";
  }
  util$1.isRegExp = f;
  function l(v) {
    return typeof v == "object" && v !== null;
  }
  util$1.isObject = l;
  function s(v) {
    return y(v) === "[object Date]";
  }
  util$1.isDate = s;
  function p(v) {
    return y(v) === "[object Error]" || v instanceof Error;
  }
  util$1.isError = p;
  function m(v) {
    return typeof v == "function";
  }
  util$1.isFunction = m;
  function g(v) {
    return v === null || typeof v == "boolean" || typeof v == "number" || typeof v == "string" || typeof v == "symbol" || // ES6 symbol
    typeof v > "u";
  }
  util$1.isPrimitive = g, util$1.isBuffer = requireDist$1().Buffer.isBuffer;
  function y(v) {
    return Object.prototype.toString.call(v);
  }
  return util$1;
}
var util = {}, types = {}, isArguments$1, hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1) return isArguments$1;
  hasRequiredIsArguments$1 = 1;
  var e = requireShams()(), t = /* @__PURE__ */ requireCallBound$1(), r = t("Object.prototype.toString"), a = function(c) {
    return e && c && typeof c == "object" && Symbol.toStringTag in c ? !1 : r(c) === "[object Arguments]";
  }, u = function(c) {
    return a(c) ? !0 : c !== null && typeof c == "object" && "length" in c && typeof c.length == "number" && c.length >= 0 && r(c) !== "[object Array]" && "callee" in c && r(c.callee) === "[object Function]";
  }, n = (function() {
    return a(arguments);
  })();
  return a.isLegacyArguments = u, isArguments$1 = n ? a : u, isArguments$1;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var e = /* @__PURE__ */ requireCallBound$1(), t = requireShams()(), r = /* @__PURE__ */ requireHasown(), a = /* @__PURE__ */ requireGopd(), u;
  if (t) {
    var n = e("RegExp.prototype.exec"), o = {}, c = function() {
      throw o;
    }, f = {
      toString: c,
      valueOf: c
    };
    typeof Symbol.toPrimitive == "symbol" && (f[Symbol.toPrimitive] = c), u = function(m) {
      if (!m || typeof m != "object")
        return !1;
      var g = (
        /** @type {NonNullable<typeof gOPD>} */
        a(
          /** @type {{ lastIndex?: unknown }} */
          m,
          "lastIndex"
        )
      ), y = g && r(g, "value");
      if (!y)
        return !1;
      try {
        n(
          m,
          /** @type {string} */
          /** @type {unknown} */
          f
        );
      } catch (v) {
        return v === o;
      }
    };
  } else {
    var l = e("Object.prototype.toString"), s = "[object RegExp]";
    u = function(m) {
      return !m || typeof m != "object" && typeof m != "function" ? !1 : l(m) === s;
    };
  }
  return isRegex = u, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var e = /* @__PURE__ */ requireCallBound$1(), t = requireIsRegex(), r = e("RegExp.prototype.exec"), a = /* @__PURE__ */ requireType();
  return safeRegexTest = function(n) {
    if (!t(n))
      throw new a("`regex` must be a RegExp");
    return function(c) {
      return r(n, c) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var e = /* @__PURE__ */ requireCallBound$1(), t = /* @__PURE__ */ requireSafeRegexTest(), r = t(/^\s*(?:function)?\*/), a = requireShams()(), u = requireGetProto(), n = e("Object.prototype.toString"), o = e("Function.prototype.toString"), c = function() {
    if (!a)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, f;
  return isGeneratorFunction = function(s) {
    if (typeof s != "function")
      return !1;
    if (r(o(s)))
      return !0;
    if (!a) {
      var p = n(s);
      return p === "[object GeneratorFunction]";
    }
    if (!u)
      return !1;
    if (typeof f > "u") {
      var m = c();
      f = m ? (
        /** @type {GeneratorFunctionConstructor} */
        u(m)
      ) : !1;
    }
    return u(s) === f;
  }, isGeneratorFunction;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, (function(e) {
    var t = /* @__PURE__ */ requireIsArguments$1(), r = requireIsGeneratorFunction(), a = /* @__PURE__ */ requireWhichTypedArray(), u = /* @__PURE__ */ requireIsTypedArray();
    function n(Oe) {
      return Oe.call.bind(Oe);
    }
    var o = typeof BigInt < "u", c = typeof Symbol < "u", f = n(Object.prototype.toString), l = n(Number.prototype.valueOf), s = n(String.prototype.valueOf), p = n(Boolean.prototype.valueOf);
    if (o)
      var m = n(BigInt.prototype.valueOf);
    if (c)
      var g = n(Symbol.prototype.valueOf);
    function y(Oe, rt) {
      if (typeof Oe != "object")
        return !1;
      try {
        return rt(Oe), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = u;
    function v(Oe) {
      return typeof Promise < "u" && Oe instanceof Promise || Oe !== null && typeof Oe == "object" && typeof Oe.then == "function" && typeof Oe.catch == "function";
    }
    e.isPromise = v;
    function E(Oe) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Oe) : u(Oe) || U(Oe);
    }
    e.isArrayBufferView = E;
    function b(Oe) {
      return a(Oe) === "Uint8Array";
    }
    e.isUint8Array = b;
    function q(Oe) {
      return a(Oe) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = q;
    function O(Oe) {
      return a(Oe) === "Uint16Array";
    }
    e.isUint16Array = O;
    function j(Oe) {
      return a(Oe) === "Uint32Array";
    }
    e.isUint32Array = j;
    function D(Oe) {
      return a(Oe) === "Int8Array";
    }
    e.isInt8Array = D;
    function G(Oe) {
      return a(Oe) === "Int16Array";
    }
    e.isInt16Array = G;
    function V(Oe) {
      return a(Oe) === "Int32Array";
    }
    e.isInt32Array = V;
    function Q(Oe) {
      return a(Oe) === "Float32Array";
    }
    e.isFloat32Array = Q;
    function re(Oe) {
      return a(Oe) === "Float64Array";
    }
    e.isFloat64Array = re;
    function ve(Oe) {
      return a(Oe) === "BigInt64Array";
    }
    e.isBigInt64Array = ve;
    function te(Oe) {
      return a(Oe) === "BigUint64Array";
    }
    e.isBigUint64Array = te;
    function R(Oe) {
      return f(Oe) === "[object Map]";
    }
    R.working = typeof Map < "u" && R(/* @__PURE__ */ new Map());
    function M(Oe) {
      return typeof Map > "u" ? !1 : R.working ? R(Oe) : Oe instanceof Map;
    }
    e.isMap = M;
    function h(Oe) {
      return f(Oe) === "[object Set]";
    }
    h.working = typeof Set < "u" && h(/* @__PURE__ */ new Set());
    function S(Oe) {
      return typeof Set > "u" ? !1 : h.working ? h(Oe) : Oe instanceof Set;
    }
    e.isSet = S;
    function B(Oe) {
      return f(Oe) === "[object WeakMap]";
    }
    B.working = typeof WeakMap < "u" && B(/* @__PURE__ */ new WeakMap());
    function T(Oe) {
      return typeof WeakMap > "u" ? !1 : B.working ? B(Oe) : Oe instanceof WeakMap;
    }
    e.isWeakMap = T;
    function k(Oe) {
      return f(Oe) === "[object WeakSet]";
    }
    k.working = typeof WeakSet < "u" && k(/* @__PURE__ */ new WeakSet());
    function I(Oe) {
      return k(Oe);
    }
    e.isWeakSet = I;
    function C(Oe) {
      return f(Oe) === "[object ArrayBuffer]";
    }
    C.working = typeof ArrayBuffer < "u" && C(new ArrayBuffer());
    function $(Oe) {
      return typeof ArrayBuffer > "u" ? !1 : C.working ? C(Oe) : Oe instanceof ArrayBuffer;
    }
    e.isArrayBuffer = $;
    function w(Oe) {
      return f(Oe) === "[object DataView]";
    }
    w.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && w(new DataView(new ArrayBuffer(1), 0, 1));
    function U(Oe) {
      return typeof DataView > "u" ? !1 : w.working ? w(Oe) : Oe instanceof DataView;
    }
    e.isDataView = U;
    var ie = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function le(Oe) {
      return f(Oe) === "[object SharedArrayBuffer]";
    }
    function ee(Oe) {
      return typeof ie > "u" ? !1 : (typeof le.working > "u" && (le.working = le(new ie())), le.working ? le(Oe) : Oe instanceof ie);
    }
    e.isSharedArrayBuffer = ee;
    function F(Oe) {
      return f(Oe) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = F;
    function z(Oe) {
      return f(Oe) === "[object Map Iterator]";
    }
    e.isMapIterator = z;
    function se(Oe) {
      return f(Oe) === "[object Set Iterator]";
    }
    e.isSetIterator = se;
    function he(Oe) {
      return f(Oe) === "[object Generator]";
    }
    e.isGeneratorObject = he;
    function ae(Oe) {
      return f(Oe) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = ae;
    function X(Oe) {
      return y(Oe, l);
    }
    e.isNumberObject = X;
    function be(Oe) {
      return y(Oe, s);
    }
    e.isStringObject = be;
    function Re(Oe) {
      return y(Oe, p);
    }
    e.isBooleanObject = Re;
    function Pe(Oe) {
      return o && y(Oe, m);
    }
    e.isBigIntObject = Pe;
    function Fe(Oe) {
      return c && y(Oe, g);
    }
    e.isSymbolObject = Fe;
    function De(Oe) {
      return X(Oe) || be(Oe) || Re(Oe) || Pe(Oe) || Fe(Oe);
    }
    e.isBoxedPrimitive = De;
    function je(Oe) {
      return typeof Uint8Array < "u" && ($(Oe) || ee(Oe));
    }
    e.isAnyArrayBuffer = je, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Oe) {
      Object.defineProperty(e, Oe, {
        enumerable: !1,
        value: function() {
          throw new Error(Oe + " is not supported in userland");
        }
      });
    });
  })(types)), types;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(t) {
    return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, (function(e) {
    var t = Object.getOwnPropertyDescriptors || function(U) {
      for (var ie = Object.keys(U), le = {}, ee = 0; ee < ie.length; ee++)
        le[ie[ee]] = Object.getOwnPropertyDescriptor(U, ie[ee]);
      return le;
    }, r = /%[sdj%]/g;
    e.format = function(w) {
      if (!D(w)) {
        for (var U = [], ie = 0; ie < arguments.length; ie++)
          U.push(o(arguments[ie]));
        return U.join(" ");
      }
      for (var ie = 1, le = arguments, ee = le.length, F = String(w).replace(r, function(se) {
        if (se === "%%") return "%";
        if (ie >= ee) return se;
        switch (se) {
          case "%s":
            return String(le[ie++]);
          case "%d":
            return Number(le[ie++]);
          case "%j":
            try {
              return JSON.stringify(le[ie++]);
            } catch {
              return "[Circular]";
            }
          default:
            return se;
        }
      }), z = le[ie]; ie < ee; z = le[++ie])
        q(z) || !re(z) ? F += " " + z : F += " " + o(z);
      return F;
    }, e.deprecate = function(w, U) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return w;
      if (typeof process$1 > "u")
        return function() {
          return e.deprecate(w, U).apply(this, arguments);
        };
      var ie = !1;
      function le() {
        if (!ie) {
          if (process$1.throwDeprecation)
            throw new Error(U);
          process$1.traceDeprecation ? console.trace(U) : console.error(U), ie = !0;
        }
        return w.apply(this, arguments);
      }
      return le;
    };
    var a = {}, u = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var n = process$1.env.NODE_DEBUG;
      n = n.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + n + "$", "i");
    }
    e.debuglog = function(w) {
      if (w = w.toUpperCase(), !a[w])
        if (u.test(w)) {
          var U = process$1.pid;
          a[w] = function() {
            var ie = e.format.apply(e, arguments);
            console.error("%s %d: %s", w, U, ie);
          };
        } else
          a[w] = function() {
          };
      return a[w];
    };
    function o(w, U) {
      var ie = {
        seen: [],
        stylize: f
      };
      return arguments.length >= 3 && (ie.depth = arguments[2]), arguments.length >= 4 && (ie.colors = arguments[3]), b(U) ? ie.showHidden = U : U && e._extend(ie, U), V(ie.showHidden) && (ie.showHidden = !1), V(ie.depth) && (ie.depth = 2), V(ie.colors) && (ie.colors = !1), V(ie.customInspect) && (ie.customInspect = !0), ie.colors && (ie.stylize = c), s(ie, w, ie.depth);
    }
    e.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function c(w, U) {
      var ie = o.styles[U];
      return ie ? "\x1B[" + o.colors[ie][0] + "m" + w + "\x1B[" + o.colors[ie][1] + "m" : w;
    }
    function f(w, U) {
      return w;
    }
    function l(w) {
      var U = {};
      return w.forEach(function(ie, le) {
        U[ie] = !0;
      }), U;
    }
    function s(w, U, ie) {
      if (w.customInspect && U && R(U.inspect) && // Filter out the util module, it's inspect function is special
      U.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(U.constructor && U.constructor.prototype === U)) {
        var le = U.inspect(ie, w);
        return D(le) || (le = s(w, le, ie)), le;
      }
      var ee = p(w, U);
      if (ee)
        return ee;
      var F = Object.keys(U), z = l(F);
      if (w.showHidden && (F = Object.getOwnPropertyNames(U)), te(U) && (F.indexOf("message") >= 0 || F.indexOf("description") >= 0))
        return m(U);
      if (F.length === 0) {
        if (R(U)) {
          var se = U.name ? ": " + U.name : "";
          return w.stylize("[Function" + se + "]", "special");
        }
        if (Q(U))
          return w.stylize(RegExp.prototype.toString.call(U), "regexp");
        if (ve(U))
          return w.stylize(Date.prototype.toString.call(U), "date");
        if (te(U))
          return m(U);
      }
      var he = "", ae = !1, X = ["{", "}"];
      if (E(U) && (ae = !0, X = ["[", "]"]), R(U)) {
        var be = U.name ? ": " + U.name : "";
        he = " [Function" + be + "]";
      }
      if (Q(U) && (he = " " + RegExp.prototype.toString.call(U)), ve(U) && (he = " " + Date.prototype.toUTCString.call(U)), te(U) && (he = " " + m(U)), F.length === 0 && (!ae || U.length == 0))
        return X[0] + he + X[1];
      if (ie < 0)
        return Q(U) ? w.stylize(RegExp.prototype.toString.call(U), "regexp") : w.stylize("[Object]", "special");
      w.seen.push(U);
      var Re;
      return ae ? Re = g(w, U, ie, z, F) : Re = F.map(function(Pe) {
        return y(w, U, ie, z, Pe, ae);
      }), w.seen.pop(), v(Re, he, X);
    }
    function p(w, U) {
      if (V(U))
        return w.stylize("undefined", "undefined");
      if (D(U)) {
        var ie = "'" + JSON.stringify(U).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return w.stylize(ie, "string");
      }
      if (j(U))
        return w.stylize("" + U, "number");
      if (b(U))
        return w.stylize("" + U, "boolean");
      if (q(U))
        return w.stylize("null", "null");
    }
    function m(w) {
      return "[" + Error.prototype.toString.call(w) + "]";
    }
    function g(w, U, ie, le, ee) {
      for (var F = [], z = 0, se = U.length; z < se; ++z)
        k(U, String(z)) ? F.push(y(
          w,
          U,
          ie,
          le,
          String(z),
          !0
        )) : F.push("");
      return ee.forEach(function(he) {
        he.match(/^\d+$/) || F.push(y(
          w,
          U,
          ie,
          le,
          he,
          !0
        ));
      }), F;
    }
    function y(w, U, ie, le, ee, F) {
      var z, se, he;
      if (he = Object.getOwnPropertyDescriptor(U, ee) || { value: U[ee] }, he.get ? he.set ? se = w.stylize("[Getter/Setter]", "special") : se = w.stylize("[Getter]", "special") : he.set && (se = w.stylize("[Setter]", "special")), k(le, ee) || (z = "[" + ee + "]"), se || (w.seen.indexOf(he.value) < 0 ? (q(ie) ? se = s(w, he.value, null) : se = s(w, he.value, ie - 1), se.indexOf(`
`) > -1 && (F ? se = se.split(`
`).map(function(ae) {
        return "  " + ae;
      }).join(`
`).slice(2) : se = `
` + se.split(`
`).map(function(ae) {
        return "   " + ae;
      }).join(`
`))) : se = w.stylize("[Circular]", "special")), V(z)) {
        if (F && ee.match(/^\d+$/))
          return se;
        z = JSON.stringify("" + ee), z.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (z = z.slice(1, -1), z = w.stylize(z, "name")) : (z = z.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), z = w.stylize(z, "string"));
      }
      return z + ": " + se;
    }
    function v(w, U, ie) {
      var le = w.reduce(function(ee, F) {
        return F.indexOf(`
`) >= 0, ee + F.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return le > 60 ? ie[0] + (U === "" ? "" : U + `
 `) + " " + w.join(`,
  `) + " " + ie[1] : ie[0] + U + " " + w.join(", ") + " " + ie[1];
    }
    e.types = requireTypes();
    function E(w) {
      return Array.isArray(w);
    }
    e.isArray = E;
    function b(w) {
      return typeof w == "boolean";
    }
    e.isBoolean = b;
    function q(w) {
      return w === null;
    }
    e.isNull = q;
    function O(w) {
      return w == null;
    }
    e.isNullOrUndefined = O;
    function j(w) {
      return typeof w == "number";
    }
    e.isNumber = j;
    function D(w) {
      return typeof w == "string";
    }
    e.isString = D;
    function G(w) {
      return typeof w == "symbol";
    }
    e.isSymbol = G;
    function V(w) {
      return w === void 0;
    }
    e.isUndefined = V;
    function Q(w) {
      return re(w) && h(w) === "[object RegExp]";
    }
    e.isRegExp = Q, e.types.isRegExp = Q;
    function re(w) {
      return typeof w == "object" && w !== null;
    }
    e.isObject = re;
    function ve(w) {
      return re(w) && h(w) === "[object Date]";
    }
    e.isDate = ve, e.types.isDate = ve;
    function te(w) {
      return re(w) && (h(w) === "[object Error]" || w instanceof Error);
    }
    e.isError = te, e.types.isNativeError = te;
    function R(w) {
      return typeof w == "function";
    }
    e.isFunction = R;
    function M(w) {
      return w === null || typeof w == "boolean" || typeof w == "number" || typeof w == "string" || typeof w == "symbol" || // ES6 symbol
      typeof w > "u";
    }
    e.isPrimitive = M, e.isBuffer = requireIsBufferBrowser();
    function h(w) {
      return Object.prototype.toString.call(w);
    }
    function S(w) {
      return w < 10 ? "0" + w.toString(10) : w.toString(10);
    }
    var B = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function T() {
      var w = /* @__PURE__ */ new Date(), U = [
        S(w.getHours()),
        S(w.getMinutes()),
        S(w.getSeconds())
      ].join(":");
      return [w.getDate(), B[w.getMonth()], U].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", T(), e.format.apply(e, arguments));
    }, e.inherits = requireInherits_browser(), e._extend = function(w, U) {
      if (!U || !re(U)) return w;
      for (var ie = Object.keys(U), le = ie.length; le--; )
        w[ie[le]] = U[ie[le]];
      return w;
    };
    function k(w, U) {
      return Object.prototype.hasOwnProperty.call(w, U);
    }
    var I = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(U) {
      if (typeof U != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (I && U[I]) {
        var ie = U[I];
        if (typeof ie != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ie, I, {
          value: ie,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ie;
      }
      function ie() {
        for (var le, ee, F = new Promise(function(he, ae) {
          le = he, ee = ae;
        }), z = [], se = 0; se < arguments.length; se++)
          z.push(arguments[se]);
        z.push(function(he, ae) {
          he ? ee(he) : le(ae);
        });
        try {
          U.apply(this, z);
        } catch (he) {
          ee(he);
        }
        return F;
      }
      return Object.setPrototypeOf(ie, Object.getPrototypeOf(U)), I && Object.defineProperty(ie, I, {
        value: ie,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ie,
        t(U)
      );
    }, e.promisify.custom = I;
    function C(w, U) {
      if (!w) {
        var ie = new Error("Promise was rejected with a falsy value");
        ie.reason = w, w = ie;
      }
      return U(w);
    }
    function $(w) {
      if (typeof w != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function U() {
        for (var ie = [], le = 0; le < arguments.length; le++)
          ie.push(arguments[le]);
        var ee = ie.pop();
        if (typeof ee != "function")
          throw new TypeError("The last argument must be of type Function");
        var F = this, z = function() {
          return ee.apply(F, arguments);
        };
        w.apply(this, ie).then(
          function(se) {
            process$1.nextTick(z.bind(null, null, se));
          },
          function(se) {
            process$1.nextTick(C.bind(null, se, z));
          }
        );
      }
      return Object.setPrototypeOf(U, Object.getPrototypeOf(w)), Object.defineProperties(
        U,
        t(w)
      ), U;
    }
    e.callbackify = $;
  })(util)), util;
}
var BufferList$1 = { exports: {} }, hasRequiredBufferList$1;
function requireBufferList$1() {
  return hasRequiredBufferList$1 || (hasRequiredBufferList$1 = 1, (function(e) {
    function t(n, o) {
      if (!(n instanceof o))
        throw new TypeError("Cannot call a class as a function");
    }
    var r = requireSafeBuffer$3().Buffer, a = requireUtil();
    function u(n, o, c) {
      n.copy(o, c);
    }
    e.exports = (function() {
      function n() {
        t(this, n), this.head = null, this.tail = null, this.length = 0;
      }
      return n.prototype.push = function(c) {
        var f = { data: c, next: null };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }, n.prototype.unshift = function(c) {
        var f = { data: c, next: this.head };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }, n.prototype.shift = function() {
        if (this.length !== 0) {
          var c = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, c;
        }
      }, n.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, n.prototype.join = function(c) {
        if (this.length === 0) return "";
        for (var f = this.head, l = "" + f.data; f = f.next; )
          l += c + f.data;
        return l;
      }, n.prototype.concat = function(c) {
        if (this.length === 0) return r.alloc(0);
        for (var f = r.allocUnsafe(c >>> 0), l = this.head, s = 0; l; )
          u(l.data, f, s), s += l.data.length, l = l.next;
        return f;
      }, n;
    })(), a && a.inspect && a.inspect.custom && (e.exports.prototype[a.inspect.custom] = function() {
      var n = a.inspect({ length: this.length });
      return this.constructor.name + " " + n;
    });
  })(BufferList$1)), BufferList$1.exports;
}
var destroy_1$3, hasRequiredDestroy$3;
function requireDestroy$3() {
  if (hasRequiredDestroy$3) return destroy_1$3;
  hasRequiredDestroy$3 = 1;
  var e = requireProcessNextickArgs();
  function t(u, n) {
    var o = this, c = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return c || f ? (n ? n(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(a, this, u)) : e.nextTick(a, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(l) {
      !n && l ? o._writableState ? o._writableState.errorEmitted || (o._writableState.errorEmitted = !0, e.nextTick(a, o, l)) : e.nextTick(a, o, l) : n && n(l);
    }), this);
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function a(u, n) {
    u.emit("error", n);
  }
  return destroy_1$3 = {
    destroy: t,
    undestroy: r
  }, destroy_1$3;
}
var browser$h, hasRequiredBrowser$h;
function requireBrowser$h() {
  if (hasRequiredBrowser$h) return browser$h;
  hasRequiredBrowser$h = 1, browser$h = e;
  function e(r, a) {
    if (t("noDeprecation"))
      return r;
    var u = !1;
    function n() {
      if (!u) {
        if (t("throwDeprecation"))
          throw new Error(a);
        t("traceDeprecation") ? console.trace(a) : console.warn(a), u = !0;
      }
      return r.apply(this, arguments);
    }
    return n;
  }
  function t(r) {
    try {
      if (!globalThis.localStorage) return !1;
    } catch {
      return !1;
    }
    var a = globalThis.localStorage[r];
    return a == null ? !1 : String(a).toLowerCase() === "true";
  }
  return browser$h;
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2) return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  var e = requireProcessNextickArgs();
  _stream_writable$2 = v;
  function t(T) {
    var k = this;
    this.next = null, this.entry = null, this.finish = function() {
      B(k, T);
    };
  }
  var r = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, a;
  v.WritableState = g;
  var u = Object.create(requireUtil$1());
  u.inherits = requireInherits_browser();
  var n = {
    deprecate: requireBrowser$h()
  }, o = requireStreamBrowser$2(), c = requireSafeBuffer$3().Buffer, f = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function l(T) {
    return c.from(T);
  }
  function s(T) {
    return c.isBuffer(T) || T instanceof f;
  }
  var p = requireDestroy$3();
  u.inherits(v, o);
  function m() {
  }
  function g(T, k) {
    a = a || require_stream_duplex$2(), T = T || {};
    var I = k instanceof a;
    this.objectMode = !!T.objectMode, I && (this.objectMode = this.objectMode || !!T.writableObjectMode);
    var C = T.highWaterMark, $ = T.writableHighWaterMark, w = this.objectMode ? 16 : 16 * 1024;
    C || C === 0 ? this.highWaterMark = C : I && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = w, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var U = T.decodeStrings === !1;
    this.decodeStrings = !U, this.defaultEncoding = T.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ie) {
      V(k, ie);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  g.prototype.getBuffer = function() {
    for (var k = this.bufferedRequest, I = []; k; )
      I.push(k), k = k.next;
    return I;
  }, (function() {
    try {
      Object.defineProperty(g.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var y;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (y = Function.prototype[Symbol.hasInstance], Object.defineProperty(v, Symbol.hasInstance, {
    value: function(T) {
      return y.call(this, T) ? !0 : this !== v ? !1 : T && T._writableState instanceof g;
    }
  })) : y = function(T) {
    return T instanceof this;
  };
  function v(T) {
    if (a = a || require_stream_duplex$2(), !y.call(v, this) && !(this instanceof a))
      return new v(T);
    this._writableState = new g(T, this), this.writable = !0, T && (typeof T.write == "function" && (this._write = T.write), typeof T.writev == "function" && (this._writev = T.writev), typeof T.destroy == "function" && (this._destroy = T.destroy), typeof T.final == "function" && (this._final = T.final)), o.call(this);
  }
  v.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function E(T, k) {
    var I = new Error("write after end");
    T.emit("error", I), e.nextTick(k, I);
  }
  function b(T, k, I, C) {
    var $ = !0, w = !1;
    return I === null ? w = new TypeError("May not write null values to stream") : typeof I != "string" && I !== void 0 && !k.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w && (T.emit("error", w), e.nextTick(C, w), $ = !1), $;
  }
  v.prototype.write = function(T, k, I) {
    var C = this._writableState, $ = !1, w = !C.objectMode && s(T);
    return w && !c.isBuffer(T) && (T = l(T)), typeof k == "function" && (I = k, k = null), w ? k = "buffer" : k || (k = C.defaultEncoding), typeof I != "function" && (I = m), C.ended ? E(this, I) : (w || b(this, C, T, I)) && (C.pendingcb++, $ = O(this, C, w, T, k, I)), $;
  }, v.prototype.cork = function() {
    var T = this._writableState;
    T.corked++;
  }, v.prototype.uncork = function() {
    var T = this._writableState;
    T.corked && (T.corked--, !T.writing && !T.corked && !T.bufferProcessing && T.bufferedRequest && ve(this, T));
  }, v.prototype.setDefaultEncoding = function(k) {
    if (typeof k == "string" && (k = k.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((k + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + k);
    return this._writableState.defaultEncoding = k, this;
  };
  function q(T, k, I) {
    return !T.objectMode && T.decodeStrings !== !1 && typeof k == "string" && (k = c.from(k, I)), k;
  }
  Object.defineProperty(v.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function O(T, k, I, C, $, w) {
    if (!I) {
      var U = q(k, C, $);
      C !== U && (I = !0, $ = "buffer", C = U);
    }
    var ie = k.objectMode ? 1 : C.length;
    k.length += ie;
    var le = k.length < k.highWaterMark;
    if (le || (k.needDrain = !0), k.writing || k.corked) {
      var ee = k.lastBufferedRequest;
      k.lastBufferedRequest = {
        chunk: C,
        encoding: $,
        isBuf: I,
        callback: w,
        next: null
      }, ee ? ee.next = k.lastBufferedRequest : k.bufferedRequest = k.lastBufferedRequest, k.bufferedRequestCount += 1;
    } else
      j(T, k, !1, ie, C, $, w);
    return le;
  }
  function j(T, k, I, C, $, w, U) {
    k.writelen = C, k.writecb = U, k.writing = !0, k.sync = !0, I ? T._writev($, k.onwrite) : T._write($, w, k.onwrite), k.sync = !1;
  }
  function D(T, k, I, C, $) {
    --k.pendingcb, I ? (e.nextTick($, C), e.nextTick(h, T, k), T._writableState.errorEmitted = !0, T.emit("error", C)) : ($(C), T._writableState.errorEmitted = !0, T.emit("error", C), h(T, k));
  }
  function G(T) {
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0;
  }
  function V(T, k) {
    var I = T._writableState, C = I.sync, $ = I.writecb;
    if (G(I), k) D(T, I, C, k, $);
    else {
      var w = te(I);
      !w && !I.corked && !I.bufferProcessing && I.bufferedRequest && ve(T, I), C ? r(Q, T, I, w, $) : Q(T, I, w, $);
    }
  }
  function Q(T, k, I, C) {
    I || re(T, k), k.pendingcb--, C(), h(T, k);
  }
  function re(T, k) {
    k.length === 0 && k.needDrain && (k.needDrain = !1, T.emit("drain"));
  }
  function ve(T, k) {
    k.bufferProcessing = !0;
    var I = k.bufferedRequest;
    if (T._writev && I && I.next) {
      var C = k.bufferedRequestCount, $ = new Array(C), w = k.corkedRequestsFree;
      w.entry = I;
      for (var U = 0, ie = !0; I; )
        $[U] = I, I.isBuf || (ie = !1), I = I.next, U += 1;
      $.allBuffers = ie, j(T, k, !0, k.length, $, "", w.finish), k.pendingcb++, k.lastBufferedRequest = null, w.next ? (k.corkedRequestsFree = w.next, w.next = null) : k.corkedRequestsFree = new t(k), k.bufferedRequestCount = 0;
    } else {
      for (; I; ) {
        var le = I.chunk, ee = I.encoding, F = I.callback, z = k.objectMode ? 1 : le.length;
        if (j(T, k, !1, z, le, ee, F), I = I.next, k.bufferedRequestCount--, k.writing)
          break;
      }
      I === null && (k.lastBufferedRequest = null);
    }
    k.bufferedRequest = I, k.bufferProcessing = !1;
  }
  v.prototype._write = function(T, k, I) {
    I(new Error("_write() is not implemented"));
  }, v.prototype._writev = null, v.prototype.end = function(T, k, I) {
    var C = this._writableState;
    typeof T == "function" ? (I = T, T = null, k = null) : typeof k == "function" && (I = k, k = null), T != null && this.write(T, k), C.corked && (C.corked = 1, this.uncork()), C.ending || S(this, C, I);
  };
  function te(T) {
    return T.ending && T.length === 0 && T.bufferedRequest === null && !T.finished && !T.writing;
  }
  function R(T, k) {
    T._final(function(I) {
      k.pendingcb--, I && T.emit("error", I), k.prefinished = !0, T.emit("prefinish"), h(T, k);
    });
  }
  function M(T, k) {
    !k.prefinished && !k.finalCalled && (typeof T._final == "function" ? (k.pendingcb++, k.finalCalled = !0, e.nextTick(R, T, k)) : (k.prefinished = !0, T.emit("prefinish")));
  }
  function h(T, k) {
    var I = te(k);
    return I && (M(T, k), k.pendingcb === 0 && (k.finished = !0, T.emit("finish"))), I;
  }
  function S(T, k, I) {
    k.ending = !0, h(T, k), I && (k.finished ? e.nextTick(I) : T.once("finish", I)), k.ended = !0, T.writable = !1;
  }
  function B(T, k, I) {
    var C = T.entry;
    for (T.entry = null; C; ) {
      var $ = C.callback;
      k.pendingcb--, $(I), C = C.next;
    }
    k.corkedRequestsFree.next = T;
  }
  return Object.defineProperty(v.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(T) {
      this._writableState && (this._writableState.destroyed = T);
    }
  }), v.prototype.destroy = p.destroy, v.prototype._undestroy = p.undestroy, v.prototype._destroy = function(T, k) {
    this.end(), k(T);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2) return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var e = requireProcessNextickArgs(), t = Object.keys || function(p) {
    var m = [];
    for (var g in p)
      m.push(g);
    return m;
  };
  _stream_duplex$2 = f;
  var r = Object.create(requireUtil$1());
  r.inherits = requireInherits_browser();
  var a = require_stream_readable$2(), u = require_stream_writable$2();
  r.inherits(f, a);
  for (var n = t(u.prototype), o = 0; o < n.length; o++) {
    var c = n[o];
    f.prototype[c] || (f.prototype[c] = u.prototype[c]);
  }
  function f(p) {
    if (!(this instanceof f)) return new f(p);
    a.call(this, p), u.call(this, p), p && p.readable === !1 && (this.readable = !1), p && p.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, p && p.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", l);
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function l() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(s, this);
  }
  function s(p) {
    p.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(p) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = p, this._writableState.destroyed = p);
    }
  }), f.prototype._destroy = function(p, m) {
    this.push(null), this.end(), e.nextTick(m, p);
  }, _stream_duplex$2;
}
var string_decoder$2 = {}, safeBuffer$2 = { exports: {} }, hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  return hasRequiredSafeBuffer$2 || (hasRequiredSafeBuffer$2 = 1, (function(e, t) {
    var r = requireDist$1(), a = r.Buffer;
    function u(o, c) {
      for (var f in o)
        c[f] = o[f];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (u(r, t), t.Buffer = n);
    function n(o, c, f) {
      return a(o, c, f);
    }
    u(a, n), n.from = function(o, c, f) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return a(o, c, f);
    }, n.alloc = function(o, c, f) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var l = a(o);
      return c !== void 0 ? typeof f == "string" ? l.fill(c, f) : l.fill(c) : l.fill(0), l;
    }, n.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return a(o);
    }, n.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  })(safeBuffer$2, safeBuffer$2.exports)), safeBuffer$2.exports;
}
var hasRequiredString_decoder$2;
function requireString_decoder$2() {
  if (hasRequiredString_decoder$2) return string_decoder$2;
  hasRequiredString_decoder$2 = 1;
  var e = requireSafeBuffer$2().Buffer, t = e.isEncoding || function(b) {
    switch (b = "" + b, b && b.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(b) {
    if (!b) return "utf8";
    for (var q; ; )
      switch (b) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return b;
        default:
          if (q) return;
          b = ("" + b).toLowerCase(), q = !0;
      }
  }
  function a(b) {
    var q = r(b);
    if (typeof q != "string" && (e.isEncoding === t || !t(b))) throw new Error("Unknown encoding: " + b);
    return q || b;
  }
  string_decoder$2.StringDecoder = u;
  function u(b) {
    this.encoding = a(b);
    var q;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = m, q = 4;
        break;
      case "utf8":
        this.fillLast = f, q = 4;
        break;
      case "base64":
        this.text = g, this.end = y, q = 3;
        break;
      default:
        this.write = v, this.end = E;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(q);
  }
  u.prototype.write = function(b) {
    if (b.length === 0) return "";
    var q, O;
    if (this.lastNeed) {
      if (q = this.fillLast(b), q === void 0) return "";
      O = this.lastNeed, this.lastNeed = 0;
    } else
      O = 0;
    return O < b.length ? q ? q + this.text(b, O) : this.text(b, O) : q || "";
  }, u.prototype.end = s, u.prototype.text = l, u.prototype.fillLast = function(b) {
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
  };
  function n(b) {
    return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
  }
  function o(b, q, O) {
    var j = q.length - 1;
    if (j < O) return 0;
    var D = n(q[j]);
    return D >= 0 ? (D > 0 && (b.lastNeed = D - 1), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (b.lastNeed = D - 2), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (D === 2 ? D = 0 : b.lastNeed = D - 3), D) : 0));
  }
  function c(b, q, O) {
    if ((q[0] & 192) !== 128)
      return b.lastNeed = 0, "�";
    if (b.lastNeed > 1 && q.length > 1) {
      if ((q[1] & 192) !== 128)
        return b.lastNeed = 1, "�";
      if (b.lastNeed > 2 && q.length > 2 && (q[2] & 192) !== 128)
        return b.lastNeed = 2, "�";
    }
  }
  function f(b) {
    var q = this.lastTotal - this.lastNeed, O = c(this, b);
    if (O !== void 0) return O;
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, q, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, q, 0, b.length), this.lastNeed -= b.length;
  }
  function l(b, q) {
    var O = o(this, b, q);
    if (!this.lastNeed) return b.toString("utf8", q);
    this.lastTotal = O;
    var j = b.length - (O - this.lastNeed);
    return b.copy(this.lastChar, 0, j), b.toString("utf8", q, j);
  }
  function s(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + "�" : q;
  }
  function p(b, q) {
    if ((b.length - q) % 2 === 0) {
      var O = b.toString("utf16le", q);
      if (O) {
        var j = O.charCodeAt(O.length - 1);
        if (j >= 55296 && j <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], O.slice(0, -1);
      }
      return O;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", q, b.length - 1);
  }
  function m(b) {
    var q = b && b.length ? this.write(b) : "";
    if (this.lastNeed) {
      var O = this.lastTotal - this.lastNeed;
      return q + this.lastChar.toString("utf16le", 0, O);
    }
    return q;
  }
  function g(b, q) {
    var O = (b.length - q) % 3;
    return O === 0 ? b.toString("base64", q) : (this.lastNeed = 3 - O, this.lastTotal = 3, O === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", q, b.length - O));
  }
  function y(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : q;
  }
  function v(b) {
    return b.toString(this.encoding);
  }
  function E(b) {
    return b && b.length ? this.write(b) : "";
  }
  return string_decoder$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2) return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  var e = requireProcessNextickArgs();
  _stream_readable$2 = q;
  var t = requireIsarray$1(), r;
  q.ReadableState = b, requireEvents().EventEmitter;
  var a = function(F, z) {
    return F.listeners(z).length;
  }, u = requireStreamBrowser$2(), n = requireSafeBuffer$3().Buffer, o = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function c(F) {
    return n.from(F);
  }
  function f(F) {
    return n.isBuffer(F) || F instanceof o;
  }
  var l = Object.create(requireUtil$1());
  l.inherits = requireInherits_browser();
  var s = requireUtil(), p = void 0;
  s && s.debuglog ? p = s.debuglog("stream") : p = function() {
  };
  var m = requireBufferList$1(), g = requireDestroy$3(), y;
  l.inherits(q, u);
  var v = ["error", "close", "destroy", "pause", "resume"];
  function E(F, z, se) {
    if (typeof F.prependListener == "function") return F.prependListener(z, se);
    !F._events || !F._events[z] ? F.on(z, se) : t(F._events[z]) ? F._events[z].unshift(se) : F._events[z] = [se, F._events[z]];
  }
  function b(F, z) {
    r = r || require_stream_duplex$2(), F = F || {};
    var se = z instanceof r;
    this.objectMode = !!F.objectMode, se && (this.objectMode = this.objectMode || !!F.readableObjectMode);
    var he = F.highWaterMark, ae = F.readableHighWaterMark, X = this.objectMode ? 16 : 16 * 1024;
    he || he === 0 ? this.highWaterMark = he : se && (ae || ae === 0) ? this.highWaterMark = ae : this.highWaterMark = X, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = F.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, F.encoding && (y || (y = requireString_decoder$2().StringDecoder), this.decoder = new y(F.encoding), this.encoding = F.encoding);
  }
  function q(F) {
    if (r = r || require_stream_duplex$2(), !(this instanceof q)) return new q(F);
    this._readableState = new b(F, this), this.readable = !0, F && (typeof F.read == "function" && (this._read = F.read), typeof F.destroy == "function" && (this._destroy = F.destroy)), u.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(F) {
      this._readableState && (this._readableState.destroyed = F);
    }
  }), q.prototype.destroy = g.destroy, q.prototype._undestroy = g.undestroy, q.prototype._destroy = function(F, z) {
    this.push(null), z(F);
  }, q.prototype.push = function(F, z) {
    var se = this._readableState, he;
    return se.objectMode ? he = !0 : typeof F == "string" && (z = z || se.defaultEncoding, z !== se.encoding && (F = n.from(F, z), z = ""), he = !0), O(this, F, z, !1, he);
  }, q.prototype.unshift = function(F) {
    return O(this, F, null, !0, !1);
  };
  function O(F, z, se, he, ae) {
    var X = F._readableState;
    if (z === null)
      X.reading = !1, ve(F, X);
    else {
      var be;
      ae || (be = D(X, z)), be ? F.emit("error", be) : X.objectMode || z && z.length > 0 ? (typeof z != "string" && !X.objectMode && Object.getPrototypeOf(z) !== n.prototype && (z = c(z)), he ? X.endEmitted ? F.emit("error", new Error("stream.unshift() after end event")) : j(F, X, z, !0) : X.ended ? F.emit("error", new Error("stream.push() after EOF")) : (X.reading = !1, X.decoder && !se ? (z = X.decoder.write(z), X.objectMode || z.length !== 0 ? j(F, X, z, !1) : M(F, X)) : j(F, X, z, !1))) : he || (X.reading = !1);
    }
    return G(X);
  }
  function j(F, z, se, he) {
    z.flowing && z.length === 0 && !z.sync ? (F.emit("data", se), F.read(0)) : (z.length += z.objectMode ? 1 : se.length, he ? z.buffer.unshift(se) : z.buffer.push(se), z.needReadable && te(F)), M(F, z);
  }
  function D(F, z) {
    var se;
    return !f(z) && typeof z != "string" && z !== void 0 && !F.objectMode && (se = new TypeError("Invalid non-string/buffer chunk")), se;
  }
  function G(F) {
    return !F.ended && (F.needReadable || F.length < F.highWaterMark || F.length === 0);
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(F) {
    return y || (y = requireString_decoder$2().StringDecoder), this._readableState.decoder = new y(F), this._readableState.encoding = F, this;
  };
  var V = 8388608;
  function Q(F) {
    return F >= V ? F = V : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
  }
  function re(F, z) {
    return F <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : F !== F ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (F > z.highWaterMark && (z.highWaterMark = Q(F)), F <= z.length ? F : z.ended ? z.length : (z.needReadable = !0, 0));
  }
  q.prototype.read = function(F) {
    p("read", F), F = parseInt(F, 10);
    var z = this._readableState, se = F;
    if (F !== 0 && (z.emittedReadable = !1), F === 0 && z.needReadable && (z.length >= z.highWaterMark || z.ended))
      return p("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? ie(this) : te(this), null;
    if (F = re(F, z), F === 0 && z.ended)
      return z.length === 0 && ie(this), null;
    var he = z.needReadable;
    p("need readable", he), (z.length === 0 || z.length - F < z.highWaterMark) && (he = !0, p("length less than watermark", he)), z.ended || z.reading ? (he = !1, p("reading or ended", he)) : he && (p("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (F = re(se, z)));
    var ae;
    return F > 0 ? ae = C(F, z) : ae = null, ae === null ? (z.needReadable = !0, F = 0) : z.length -= F, z.length === 0 && (z.ended || (z.needReadable = !0), se !== F && z.ended && ie(this)), ae !== null && this.emit("data", ae), ae;
  };
  function ve(F, z) {
    if (!z.ended) {
      if (z.decoder) {
        var se = z.decoder.end();
        se && se.length && (z.buffer.push(se), z.length += z.objectMode ? 1 : se.length);
      }
      z.ended = !0, te(F);
    }
  }
  function te(F) {
    var z = F._readableState;
    z.needReadable = !1, z.emittedReadable || (p("emitReadable", z.flowing), z.emittedReadable = !0, z.sync ? e.nextTick(R, F) : R(F));
  }
  function R(F) {
    p("emit readable"), F.emit("readable"), I(F);
  }
  function M(F, z) {
    z.readingMore || (z.readingMore = !0, e.nextTick(h, F, z));
  }
  function h(F, z) {
    for (var se = z.length; !z.reading && !z.flowing && !z.ended && z.length < z.highWaterMark && (p("maybeReadMore read 0"), F.read(0), se !== z.length); )
      se = z.length;
    z.readingMore = !1;
  }
  q.prototype._read = function(F) {
    this.emit("error", new Error("_read() is not implemented"));
  }, q.prototype.pipe = function(F, z) {
    var se = this, he = this._readableState;
    switch (he.pipesCount) {
      case 0:
        he.pipes = F;
        break;
      case 1:
        he.pipes = [he.pipes, F];
        break;
      default:
        he.pipes.push(F);
        break;
    }
    he.pipesCount += 1, p("pipe count=%d opts=%j", he.pipesCount, z);
    var ae = (!z || z.end !== !1) && F !== process$1.stdout && F !== process$1.stderr, X = ae ? Re : Je;
    he.endEmitted ? e.nextTick(X) : se.once("end", X), F.on("unpipe", be);
    function be(we, Ae) {
      p("onunpipe"), we === se && Ae && Ae.hasUnpiped === !1 && (Ae.hasUnpiped = !0, De());
    }
    function Re() {
      p("onend"), F.end();
    }
    var Pe = S(se);
    F.on("drain", Pe);
    var Fe = !1;
    function De() {
      p("cleanup"), F.removeListener("close", He), F.removeListener("finish", Qe), F.removeListener("drain", Pe), F.removeListener("error", rt), F.removeListener("unpipe", be), se.removeListener("end", Re), se.removeListener("end", Je), se.removeListener("data", Oe), Fe = !0, he.awaitDrain && (!F._writableState || F._writableState.needDrain) && Pe();
    }
    var je = !1;
    se.on("data", Oe);
    function Oe(we) {
      p("ondata"), je = !1;
      var Ae = F.write(we);
      Ae === !1 && !je && ((he.pipesCount === 1 && he.pipes === F || he.pipesCount > 1 && ee(he.pipes, F) !== -1) && !Fe && (p("false write response, pause", he.awaitDrain), he.awaitDrain++, je = !0), se.pause());
    }
    function rt(we) {
      p("onerror", we), Je(), F.removeListener("error", rt), a(F, "error") === 0 && F.emit("error", we);
    }
    E(F, "error", rt);
    function He() {
      F.removeListener("finish", Qe), Je();
    }
    F.once("close", He);
    function Qe() {
      p("onfinish"), F.removeListener("close", He), Je();
    }
    F.once("finish", Qe);
    function Je() {
      p("unpipe"), se.unpipe(F);
    }
    return F.emit("pipe", se), he.flowing || (p("pipe resume"), se.resume()), F;
  };
  function S(F) {
    return function() {
      var z = F._readableState;
      p("pipeOnDrain", z.awaitDrain), z.awaitDrain && z.awaitDrain--, z.awaitDrain === 0 && a(F, "data") && (z.flowing = !0, I(F));
    };
  }
  q.prototype.unpipe = function(F) {
    var z = this._readableState, se = { hasUnpiped: !1 };
    if (z.pipesCount === 0) return this;
    if (z.pipesCount === 1)
      return F && F !== z.pipes ? this : (F || (F = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, F && F.emit("unpipe", this, se), this);
    if (!F) {
      var he = z.pipes, ae = z.pipesCount;
      z.pipes = null, z.pipesCount = 0, z.flowing = !1;
      for (var X = 0; X < ae; X++)
        he[X].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var be = ee(z.pipes, F);
    return be === -1 ? this : (z.pipes.splice(be, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), F.emit("unpipe", this, se), this);
  }, q.prototype.on = function(F, z) {
    var se = u.prototype.on.call(this, F, z);
    if (F === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (F === "readable") {
      var he = this._readableState;
      !he.endEmitted && !he.readableListening && (he.readableListening = he.needReadable = !0, he.emittedReadable = !1, he.reading ? he.length && te(this) : e.nextTick(B, this));
    }
    return se;
  }, q.prototype.addListener = q.prototype.on;
  function B(F) {
    p("readable nexttick read 0"), F.read(0);
  }
  q.prototype.resume = function() {
    var F = this._readableState;
    return F.flowing || (p("resume"), F.flowing = !0, T(this, F)), this;
  };
  function T(F, z) {
    z.resumeScheduled || (z.resumeScheduled = !0, e.nextTick(k, F, z));
  }
  function k(F, z) {
    z.reading || (p("resume read 0"), F.read(0)), z.resumeScheduled = !1, z.awaitDrain = 0, F.emit("resume"), I(F), z.flowing && !z.reading && F.read(0);
  }
  q.prototype.pause = function() {
    return p("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function I(F) {
    var z = F._readableState;
    for (p("flow", z.flowing); z.flowing && F.read() !== null; )
      ;
  }
  q.prototype.wrap = function(F) {
    var z = this, se = this._readableState, he = !1;
    F.on("end", function() {
      if (p("wrapped end"), se.decoder && !se.ended) {
        var be = se.decoder.end();
        be && be.length && z.push(be);
      }
      z.push(null);
    }), F.on("data", function(be) {
      if (p("wrapped data"), se.decoder && (be = se.decoder.write(be)), !(se.objectMode && be == null) && !(!se.objectMode && (!be || !be.length))) {
        var Re = z.push(be);
        Re || (he = !0, F.pause());
      }
    });
    for (var ae in F)
      this[ae] === void 0 && typeof F[ae] == "function" && (this[ae] = /* @__PURE__ */ (function(be) {
        return function() {
          return F[be].apply(F, arguments);
        };
      })(ae));
    for (var X = 0; X < v.length; X++)
      F.on(v[X], this.emit.bind(this, v[X]));
    return this._read = function(be) {
      p("wrapped _read", be), he && (he = !1, F.resume());
    }, this;
  }, Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), q._fromList = C;
  function C(F, z) {
    if (z.length === 0) return null;
    var se;
    return z.objectMode ? se = z.buffer.shift() : !F || F >= z.length ? (z.decoder ? se = z.buffer.join("") : z.buffer.length === 1 ? se = z.buffer.head.data : se = z.buffer.concat(z.length), z.buffer.clear()) : se = $(F, z.buffer, z.decoder), se;
  }
  function $(F, z, se) {
    var he;
    return F < z.head.data.length ? (he = z.head.data.slice(0, F), z.head.data = z.head.data.slice(F)) : F === z.head.data.length ? he = z.shift() : he = se ? w(F, z) : U(F, z), he;
  }
  function w(F, z) {
    var se = z.head, he = 1, ae = se.data;
    for (F -= ae.length; se = se.next; ) {
      var X = se.data, be = F > X.length ? X.length : F;
      if (be === X.length ? ae += X : ae += X.slice(0, F), F -= be, F === 0) {
        be === X.length ? (++he, se.next ? z.head = se.next : z.head = z.tail = null) : (z.head = se, se.data = X.slice(be));
        break;
      }
      ++he;
    }
    return z.length -= he, ae;
  }
  function U(F, z) {
    var se = n.allocUnsafe(F), he = z.head, ae = 1;
    for (he.data.copy(se), F -= he.data.length; he = he.next; ) {
      var X = he.data, be = F > X.length ? X.length : F;
      if (X.copy(se, se.length - F, 0, be), F -= be, F === 0) {
        be === X.length ? (++ae, he.next ? z.head = he.next : z.head = z.tail = null) : (z.head = he, he.data = X.slice(be));
        break;
      }
      ++ae;
    }
    return z.length -= ae, se;
  }
  function ie(F) {
    var z = F._readableState;
    if (z.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    z.endEmitted || (z.ended = !0, e.nextTick(le, z, F));
  }
  function le(F, z) {
    !F.endEmitted && F.length === 0 && (F.endEmitted = !0, z.readable = !1, z.emit("end"));
  }
  function ee(F, z) {
    for (var se = 0, he = F.length; se < he; se++)
      if (F[se] === z) return se;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform$2;
function require_stream_transform$2() {
  if (hasRequired_stream_transform$2) return _stream_transform$2;
  hasRequired_stream_transform$2 = 1, _stream_transform$2 = a;
  var e = require_stream_duplex$2(), t = Object.create(requireUtil$1());
  t.inherits = requireInherits_browser(), t.inherits(a, e);
  function r(o, c) {
    var f = this._transformState;
    f.transforming = !1;
    var l = f.writecb;
    if (!l)
      return this.emit("error", new Error("write callback called multiple times"));
    f.writechunk = null, f.writecb = null, c != null && this.push(c), l(o);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  function a(o) {
    if (!(this instanceof a)) return new a(o);
    e.call(this, o), this._transformState = {
      afterTransform: r.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, o && (typeof o.transform == "function" && (this._transform = o.transform), typeof o.flush == "function" && (this._flush = o.flush)), this.on("prefinish", u);
  }
  function u() {
    var o = this;
    typeof this._flush == "function" ? this._flush(function(c, f) {
      n(o, c, f);
    }) : n(this, null, null);
  }
  a.prototype.push = function(o, c) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, o, c);
  }, a.prototype._transform = function(o, c, f) {
    throw new Error("_transform() is not implemented");
  }, a.prototype._write = function(o, c, f) {
    var l = this._transformState;
    if (l.writecb = f, l.writechunk = o, l.writeencoding = c, !l.transforming) {
      var s = this._readableState;
      (l.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  }, a.prototype._read = function(o) {
    var c = this._transformState;
    c.writechunk !== null && c.writecb && !c.transforming ? (c.transforming = !0, this._transform(c.writechunk, c.writeencoding, c.afterTransform)) : c.needTransform = !0;
  }, a.prototype._destroy = function(o, c) {
    var f = this;
    e.prototype._destroy.call(this, o, function(l) {
      c(l), f.emit("close");
    });
  };
  function n(o, c, f) {
    if (c) return o.emit("error", c);
    if (f != null && o.push(f), o._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (o._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return o.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough$2;
function require_stream_passthrough$2() {
  if (hasRequired_stream_passthrough$2) return _stream_passthrough$2;
  hasRequired_stream_passthrough$2 = 1, _stream_passthrough$2 = r;
  var e = require_stream_transform$2(), t = Object.create(requireUtil$1());
  t.inherits = requireInherits_browser(), t.inherits(r, e);
  function r(a) {
    if (!(this instanceof r)) return new r(a);
    e.call(this, a);
  }
  return r.prototype._transform = function(a, u, n) {
    n(null, a);
  }, _stream_passthrough$2;
}
var hasRequiredReadableBrowser$2;
function requireReadableBrowser$2() {
  return hasRequiredReadableBrowser$2 || (hasRequiredReadableBrowser$2 = 1, (function(e, t) {
    t = e.exports = require_stream_readable$2(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable$2(), t.Duplex = require_stream_duplex$2(), t.Transform = require_stream_transform$2(), t.PassThrough = require_stream_passthrough$2();
  })(readableBrowser$2, readableBrowser$2.exports)), readableBrowser$2.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireToBuffer$1(), r = requireReadableBrowser$2().Transform, a = requireInherits_browser();
  function u(n) {
    r.call(this), this._block = e.allocUnsafe(n), this._blockSize = n, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return a(u, r), u.prototype._transform = function(n, o, c) {
    var f = null;
    try {
      this.update(n, o);
    } catch (l) {
      f = l;
    }
    c(f);
  }, u.prototype._flush = function(n) {
    var o = null;
    try {
      this.push(this.digest());
    } catch (c) {
      o = c;
    }
    n(o);
  }, u.prototype.update = function(n, o) {
    if (this._finalized)
      throw new Error("Digest already called");
    for (var c = t(n, o), f = this._block, l = 0; this._blockOffset + c.length - l >= this._blockSize; ) {
      for (var s = this._blockOffset; s < this._blockSize; )
        f[s] = c[l], s += 1, l += 1;
      this._update(), this._blockOffset = 0;
    }
    for (; l < c.length; )
      f[this._blockOffset] = c[l], this._blockOffset += 1, l += 1;
    for (var p = 0, m = c.length * 8; m > 0; ++p)
      this._length[p] += m, m = this._length[p] / 4294967296 | 0, m > 0 && (this._length[p] -= 4294967296 * m);
    return this;
  }, u.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, u.prototype.digest = function(n) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var o = this._digest();
    n !== void 0 && (o = o.toString(n)), this._block.fill(0), this._blockOffset = 0;
    for (var c = 0; c < 4; ++c)
      this._length[c] = 0;
    return o;
  }, u.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = u, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var e = requireInherits_browser(), t = requireHashBase(), r = requireSafeBuffer$4().Buffer, a = new Array(16);
  function u() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(u, t), u.prototype._update = function() {
    for (var s = a, p = 0; p < 16; ++p) s[p] = this._block.readInt32LE(p * 4);
    var m = this._a, g = this._b, y = this._c, v = this._d;
    m = o(m, g, y, v, s[0], 3614090360, 7), v = o(v, m, g, y, s[1], 3905402710, 12), y = o(y, v, m, g, s[2], 606105819, 17), g = o(g, y, v, m, s[3], 3250441966, 22), m = o(m, g, y, v, s[4], 4118548399, 7), v = o(v, m, g, y, s[5], 1200080426, 12), y = o(y, v, m, g, s[6], 2821735955, 17), g = o(g, y, v, m, s[7], 4249261313, 22), m = o(m, g, y, v, s[8], 1770035416, 7), v = o(v, m, g, y, s[9], 2336552879, 12), y = o(y, v, m, g, s[10], 4294925233, 17), g = o(g, y, v, m, s[11], 2304563134, 22), m = o(m, g, y, v, s[12], 1804603682, 7), v = o(v, m, g, y, s[13], 4254626195, 12), y = o(y, v, m, g, s[14], 2792965006, 17), g = o(g, y, v, m, s[15], 1236535329, 22), m = c(m, g, y, v, s[1], 4129170786, 5), v = c(v, m, g, y, s[6], 3225465664, 9), y = c(y, v, m, g, s[11], 643717713, 14), g = c(g, y, v, m, s[0], 3921069994, 20), m = c(m, g, y, v, s[5], 3593408605, 5), v = c(v, m, g, y, s[10], 38016083, 9), y = c(y, v, m, g, s[15], 3634488961, 14), g = c(g, y, v, m, s[4], 3889429448, 20), m = c(m, g, y, v, s[9], 568446438, 5), v = c(v, m, g, y, s[14], 3275163606, 9), y = c(y, v, m, g, s[3], 4107603335, 14), g = c(g, y, v, m, s[8], 1163531501, 20), m = c(m, g, y, v, s[13], 2850285829, 5), v = c(v, m, g, y, s[2], 4243563512, 9), y = c(y, v, m, g, s[7], 1735328473, 14), g = c(g, y, v, m, s[12], 2368359562, 20), m = f(m, g, y, v, s[5], 4294588738, 4), v = f(v, m, g, y, s[8], 2272392833, 11), y = f(y, v, m, g, s[11], 1839030562, 16), g = f(g, y, v, m, s[14], 4259657740, 23), m = f(m, g, y, v, s[1], 2763975236, 4), v = f(v, m, g, y, s[4], 1272893353, 11), y = f(y, v, m, g, s[7], 4139469664, 16), g = f(g, y, v, m, s[10], 3200236656, 23), m = f(m, g, y, v, s[13], 681279174, 4), v = f(v, m, g, y, s[0], 3936430074, 11), y = f(y, v, m, g, s[3], 3572445317, 16), g = f(g, y, v, m, s[6], 76029189, 23), m = f(m, g, y, v, s[9], 3654602809, 4), v = f(v, m, g, y, s[12], 3873151461, 11), y = f(y, v, m, g, s[15], 530742520, 16), g = f(g, y, v, m, s[2], 3299628645, 23), m = l(m, g, y, v, s[0], 4096336452, 6), v = l(v, m, g, y, s[7], 1126891415, 10), y = l(y, v, m, g, s[14], 2878612391, 15), g = l(g, y, v, m, s[5], 4237533241, 21), m = l(m, g, y, v, s[12], 1700485571, 6), v = l(v, m, g, y, s[3], 2399980690, 10), y = l(y, v, m, g, s[10], 4293915773, 15), g = l(g, y, v, m, s[1], 2240044497, 21), m = l(m, g, y, v, s[8], 1873313359, 6), v = l(v, m, g, y, s[15], 4264355552, 10), y = l(y, v, m, g, s[6], 2734768916, 15), g = l(g, y, v, m, s[13], 1309151649, 21), m = l(m, g, y, v, s[4], 4149444226, 6), v = l(v, m, g, y, s[11], 3174756917, 10), y = l(y, v, m, g, s[2], 718787259, 15), g = l(g, y, v, m, s[9], 3951481745, 21), this._a = this._a + m | 0, this._b = this._b + g | 0, this._c = this._c + y | 0, this._d = this._d + v | 0;
  }, u.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var s = r.allocUnsafe(16);
    return s.writeInt32LE(this._a, 0), s.writeInt32LE(this._b, 4), s.writeInt32LE(this._c, 8), s.writeInt32LE(this._d, 12), s;
  };
  function n(s, p) {
    return s << p | s >>> 32 - p;
  }
  function o(s, p, m, g, y, v, E) {
    return n(s + (p & m | ~p & g) + y + v | 0, E) + p | 0;
  }
  function c(s, p, m, g, y, v, E) {
    return n(s + (p & g | m & ~g) + y + v | 0, E) + p | 0;
  }
  function f(s, p, m, g, y, v, E) {
    return n(s + (p ^ m ^ g) + y + v | 0, E) + p | 0;
  }
  function l(s, p, m, g, y, v, E) {
    return n(s + (m ^ (p | ~g)) + y + v | 0, E) + p | 0;
  }
  return md5_js = u, md5_js;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160;
  hasRequiredRipemd160 = 1;
  var e = requireDist$1().Buffer, t = requireInherits_browser(), r = requireHashBase(), a = new Array(16), u = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], n = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], o = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], c = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], f = [0, 1518500249, 1859775393, 2400959708, 2840853838], l = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function s(b, q) {
    return b << q | b >>> 32 - q;
  }
  function p(b, q, O, j, D, G, V, Q) {
    return s(b + (q ^ O ^ j) + G + V | 0, Q) + D | 0;
  }
  function m(b, q, O, j, D, G, V, Q) {
    return s(b + (q & O | ~q & j) + G + V | 0, Q) + D | 0;
  }
  function g(b, q, O, j, D, G, V, Q) {
    return s(b + ((q | ~O) ^ j) + G + V | 0, Q) + D | 0;
  }
  function y(b, q, O, j, D, G, V, Q) {
    return s(b + (q & j | O & ~j) + G + V | 0, Q) + D | 0;
  }
  function v(b, q, O, j, D, G, V, Q) {
    return s(b + (q ^ (O | ~j)) + G + V | 0, Q) + D | 0;
  }
  function E() {
    r.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  return t(E, r), E.prototype._update = function() {
    for (var b = a, q = 0; q < 16; ++q)
      b[q] = this._block.readInt32LE(q * 4);
    for (var O = this._a | 0, j = this._b | 0, D = this._c | 0, G = this._d | 0, V = this._e | 0, Q = this._a | 0, re = this._b | 0, ve = this._c | 0, te = this._d | 0, R = this._e | 0, M = 0; M < 80; M += 1) {
      var h, S;
      M < 16 ? (h = p(O, j, D, G, V, b[u[M]], f[0], o[M]), S = v(Q, re, ve, te, R, b[n[M]], l[0], c[M])) : M < 32 ? (h = m(O, j, D, G, V, b[u[M]], f[1], o[M]), S = y(Q, re, ve, te, R, b[n[M]], l[1], c[M])) : M < 48 ? (h = g(O, j, D, G, V, b[u[M]], f[2], o[M]), S = g(Q, re, ve, te, R, b[n[M]], l[2], c[M])) : M < 64 ? (h = y(O, j, D, G, V, b[u[M]], f[3], o[M]), S = m(Q, re, ve, te, R, b[n[M]], l[3], c[M])) : (h = v(O, j, D, G, V, b[u[M]], f[4], o[M]), S = p(Q, re, ve, te, R, b[n[M]], l[4], c[M])), O = V, V = G, G = s(D, 10), D = j, j = h, Q = R, R = te, te = s(ve, 10), ve = re, re = S;
    }
    var B = this._b + D + te | 0;
    this._b = this._c + G + R | 0, this._c = this._d + V + Q | 0, this._d = this._e + O + re | 0, this._e = this._a + j + ve | 0, this._a = B;
  }, E.prototype._digest = function() {
    this._block[this._blockOffset] = 128, this._blockOffset += 1, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var b = e.alloc ? e.alloc(20) : new e(20);
    return b.writeInt32LE(this._a, 0), b.writeInt32LE(this._b, 4), b.writeInt32LE(this._c, 8), b.writeInt32LE(this._d, 12), b.writeInt32LE(this._e, 16), b;
  }, ripemd160 = E, ripemd160;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var e = requireSafeBuffer$4().Buffer, t = /* @__PURE__ */ requireToBuffer$2();
  function r(a, u) {
    this._block = e.alloc(a), this._finalSize = u, this._blockSize = a, this._len = 0;
  }
  return r.prototype.update = function(a, u) {
    a = t(a, u || "utf8");
    for (var n = this._block, o = this._blockSize, c = a.length, f = this._len, l = 0; l < c; ) {
      for (var s = f % o, p = Math.min(c - l, o - s), m = 0; m < p; m++)
        n[s + m] = a[l + m];
      f += p, l += p, f % o === 0 && this._update(n);
    }
    return this._len += c, this;
  }, r.prototype.digest = function(a) {
    var u = this._len % this._blockSize;
    this._block[u] = 128, this._block.fill(0, u + 1), u >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var n = this._len * 8;
    if (n <= 4294967295)
      this._block.writeUInt32BE(n, this._blockSize - 4);
    else {
      var o = (n & 4294967295) >>> 0, c = (n - o) / 4294967296;
      this._block.writeUInt32BE(c, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
    }
    this._update(this._block);
    var f = this._hash();
    return a ? f.toString(a) : f;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = r, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), r = requireSafeBuffer$4().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], u = new Array(80);
  function n() {
    this.init(), this._w = u, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(l) {
    return l << 5 | l >>> 27;
  }
  function c(l) {
    return l << 30 | l >>> 2;
  }
  function f(l, s, p, m) {
    return l === 0 ? s & p | ~s & m : l === 2 ? s & p | s & m | p & m : s ^ p ^ m;
  }
  return n.prototype._update = function(l) {
    for (var s = this._w, p = this._a | 0, m = this._b | 0, g = this._c | 0, y = this._d | 0, v = this._e | 0, E = 0; E < 16; ++E)
      s[E] = l.readInt32BE(E * 4);
    for (; E < 80; ++E)
      s[E] = s[E - 3] ^ s[E - 8] ^ s[E - 14] ^ s[E - 16];
    for (var b = 0; b < 80; ++b) {
      var q = ~~(b / 20), O = o(p) + f(q, m, g, y) + v + s[b] + a[q] | 0;
      v = y, y = g, g = c(m), m = p, p = O;
    }
    this._a = p + this._a | 0, this._b = m + this._b | 0, this._c = g + this._c | 0, this._d = y + this._d | 0, this._e = v + this._e | 0;
  }, n.prototype._hash = function() {
    var l = r.allocUnsafe(20);
    return l.writeInt32BE(this._a | 0, 0), l.writeInt32BE(this._b | 0, 4), l.writeInt32BE(this._c | 0, 8), l.writeInt32BE(this._d | 0, 12), l.writeInt32BE(this._e | 0, 16), l;
  }, sha$1 = n, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), r = requireSafeBuffer$4().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], u = new Array(80);
  function n() {
    this.init(), this._w = u, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function o(s) {
    return s << 1 | s >>> 31;
  }
  function c(s) {
    return s << 5 | s >>> 27;
  }
  function f(s) {
    return s << 30 | s >>> 2;
  }
  function l(s, p, m, g) {
    return s === 0 ? p & m | ~p & g : s === 2 ? p & m | p & g | m & g : p ^ m ^ g;
  }
  return n.prototype._update = function(s) {
    for (var p = this._w, m = this._a | 0, g = this._b | 0, y = this._c | 0, v = this._d | 0, E = this._e | 0, b = 0; b < 16; ++b)
      p[b] = s.readInt32BE(b * 4);
    for (; b < 80; ++b)
      p[b] = o(p[b - 3] ^ p[b - 8] ^ p[b - 14] ^ p[b - 16]);
    for (var q = 0; q < 80; ++q) {
      var O = ~~(q / 20), j = c(m) + l(O, g, y, v) + E + p[q] + a[O] | 0;
      E = v, v = y, y = f(g), g = m, m = j;
    }
    this._a = m + this._a | 0, this._b = g + this._b | 0, this._c = y + this._c | 0, this._d = v + this._d | 0, this._e = E + this._e | 0;
  }, n.prototype._hash = function() {
    var s = r.allocUnsafe(20);
    return s.writeInt32BE(this._a | 0, 0), s.writeInt32BE(this._b | 0, 4), s.writeInt32BE(this._c | 0, 8), s.writeInt32BE(this._d | 0, 12), s.writeInt32BE(this._e | 0, 16), s;
  }, sha1 = n, sha1;
}
var sha256$1, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1;
  hasRequiredSha256 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), r = requireSafeBuffer$4().Buffer, a = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], u = new Array(64);
  function n() {
    this.init(), this._w = u, t.call(this, 64, 56);
  }
  e(n, t), n.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function o(m, g, y) {
    return y ^ m & (g ^ y);
  }
  function c(m, g, y) {
    return m & g | y & (m | g);
  }
  function f(m) {
    return (m >>> 2 | m << 30) ^ (m >>> 13 | m << 19) ^ (m >>> 22 | m << 10);
  }
  function l(m) {
    return (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7);
  }
  function s(m) {
    return (m >>> 7 | m << 25) ^ (m >>> 18 | m << 14) ^ m >>> 3;
  }
  function p(m) {
    return (m >>> 17 | m << 15) ^ (m >>> 19 | m << 13) ^ m >>> 10;
  }
  return n.prototype._update = function(m) {
    for (var g = this._w, y = this._a | 0, v = this._b | 0, E = this._c | 0, b = this._d | 0, q = this._e | 0, O = this._f | 0, j = this._g | 0, D = this._h | 0, G = 0; G < 16; ++G)
      g[G] = m.readInt32BE(G * 4);
    for (; G < 64; ++G)
      g[G] = p(g[G - 2]) + g[G - 7] + s(g[G - 15]) + g[G - 16] | 0;
    for (var V = 0; V < 64; ++V) {
      var Q = D + l(q) + o(q, O, j) + a[V] + g[V] | 0, re = f(y) + c(y, v, E) | 0;
      D = j, j = O, O = q, q = b + Q | 0, b = E, E = v, v = y, y = Q + re | 0;
    }
    this._a = y + this._a | 0, this._b = v + this._b | 0, this._c = E + this._c | 0, this._d = b + this._d | 0, this._e = q + this._e | 0, this._f = O + this._f | 0, this._g = j + this._g | 0, this._h = D + this._h | 0;
  }, n.prototype._hash = function() {
    var m = r.allocUnsafe(32);
    return m.writeInt32BE(this._a, 0), m.writeInt32BE(this._b, 4), m.writeInt32BE(this._c, 8), m.writeInt32BE(this._d, 12), m.writeInt32BE(this._e, 16), m.writeInt32BE(this._f, 20), m.writeInt32BE(this._g, 24), m.writeInt32BE(this._h, 28), m;
  }, sha256$1 = n, sha256$1;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var e = requireInherits_browser(), t = requireSha256(), r = requireHash$1(), a = requireSafeBuffer$4().Buffer, u = new Array(64);
  function n() {
    this.init(), this._w = u, r.call(this, 64, 56);
  }
  return e(n, t), n.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, n.prototype._hash = function() {
    var o = a.allocUnsafe(28);
    return o.writeInt32BE(this._a, 0), o.writeInt32BE(this._b, 4), o.writeInt32BE(this._c, 8), o.writeInt32BE(this._d, 12), o.writeInt32BE(this._e, 16), o.writeInt32BE(this._f, 20), o.writeInt32BE(this._g, 24), o;
  }, sha224$1 = n, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), r = requireSafeBuffer$4().Buffer, a = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], u = new Array(160);
  function n() {
    this.init(), this._w = u, t.call(this, 128, 112);
  }
  e(n, t), n.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function o(v, E, b) {
    return b ^ v & (E ^ b);
  }
  function c(v, E, b) {
    return v & E | b & (v | E);
  }
  function f(v, E) {
    return (v >>> 28 | E << 4) ^ (E >>> 2 | v << 30) ^ (E >>> 7 | v << 25);
  }
  function l(v, E) {
    return (v >>> 14 | E << 18) ^ (v >>> 18 | E << 14) ^ (E >>> 9 | v << 23);
  }
  function s(v, E) {
    return (v >>> 1 | E << 31) ^ (v >>> 8 | E << 24) ^ v >>> 7;
  }
  function p(v, E) {
    return (v >>> 1 | E << 31) ^ (v >>> 8 | E << 24) ^ (v >>> 7 | E << 25);
  }
  function m(v, E) {
    return (v >>> 19 | E << 13) ^ (E >>> 29 | v << 3) ^ v >>> 6;
  }
  function g(v, E) {
    return (v >>> 19 | E << 13) ^ (E >>> 29 | v << 3) ^ (v >>> 6 | E << 26);
  }
  function y(v, E) {
    return v >>> 0 < E >>> 0 ? 1 : 0;
  }
  return n.prototype._update = function(v) {
    for (var E = this._w, b = this._ah | 0, q = this._bh | 0, O = this._ch | 0, j = this._dh | 0, D = this._eh | 0, G = this._fh | 0, V = this._gh | 0, Q = this._hh | 0, re = this._al | 0, ve = this._bl | 0, te = this._cl | 0, R = this._dl | 0, M = this._el | 0, h = this._fl | 0, S = this._gl | 0, B = this._hl | 0, T = 0; T < 32; T += 2)
      E[T] = v.readInt32BE(T * 4), E[T + 1] = v.readInt32BE(T * 4 + 4);
    for (; T < 160; T += 2) {
      var k = E[T - 30], I = E[T - 30 + 1], C = s(k, I), $ = p(I, k);
      k = E[T - 4], I = E[T - 4 + 1];
      var w = m(k, I), U = g(I, k), ie = E[T - 14], le = E[T - 14 + 1], ee = E[T - 32], F = E[T - 32 + 1], z = $ + le | 0, se = C + ie + y(z, $) | 0;
      z = z + U | 0, se = se + w + y(z, U) | 0, z = z + F | 0, se = se + ee + y(z, F) | 0, E[T] = se, E[T + 1] = z;
    }
    for (var he = 0; he < 160; he += 2) {
      se = E[he], z = E[he + 1];
      var ae = c(b, q, O), X = c(re, ve, te), be = f(b, re), Re = f(re, b), Pe = l(D, M), Fe = l(M, D), De = a[he], je = a[he + 1], Oe = o(D, G, V), rt = o(M, h, S), He = B + Fe | 0, Qe = Q + Pe + y(He, B) | 0;
      He = He + rt | 0, Qe = Qe + Oe + y(He, rt) | 0, He = He + je | 0, Qe = Qe + De + y(He, je) | 0, He = He + z | 0, Qe = Qe + se + y(He, z) | 0;
      var Je = Re + X | 0, we = be + ae + y(Je, Re) | 0;
      Q = V, B = S, V = G, S = h, G = D, h = M, M = R + He | 0, D = j + Qe + y(M, R) | 0, j = O, R = te, O = q, te = ve, q = b, ve = re, re = He + Je | 0, b = Qe + we + y(re, He) | 0;
    }
    this._al = this._al + re | 0, this._bl = this._bl + ve | 0, this._cl = this._cl + te | 0, this._dl = this._dl + R | 0, this._el = this._el + M | 0, this._fl = this._fl + h | 0, this._gl = this._gl + S | 0, this._hl = this._hl + B | 0, this._ah = this._ah + b + y(this._al, re) | 0, this._bh = this._bh + q + y(this._bl, ve) | 0, this._ch = this._ch + O + y(this._cl, te) | 0, this._dh = this._dh + j + y(this._dl, R) | 0, this._eh = this._eh + D + y(this._el, M) | 0, this._fh = this._fh + G + y(this._fl, h) | 0, this._gh = this._gh + V + y(this._gl, S) | 0, this._hh = this._hh + Q + y(this._hl, B) | 0;
  }, n.prototype._hash = function() {
    var v = r.allocUnsafe(64);
    function E(b, q, O) {
      v.writeInt32BE(b, O), v.writeInt32BE(q, O + 4);
    }
    return E(this._ah, this._al, 0), E(this._bh, this._bl, 8), E(this._ch, this._cl, 16), E(this._dh, this._dl, 24), E(this._eh, this._el, 32), E(this._fh, this._fl, 40), E(this._gh, this._gl, 48), E(this._hh, this._hl, 56), v;
  }, sha512$1 = n, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var e = requireInherits_browser(), t = requireSha512(), r = requireHash$1(), a = requireSafeBuffer$4().Buffer, u = new Array(160);
  function n() {
    this.init(), this._w = u, r.call(this, 128, 112);
  }
  return e(n, t), n.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, n.prototype._hash = function() {
    var o = a.allocUnsafe(48);
    function c(f, l, s) {
      o.writeInt32BE(f, s), o.writeInt32BE(l, s + 4);
    }
    return c(this._ah, this._al, 0), c(this._bh, this._bl, 8), c(this._ch, this._cl, 16), c(this._dh, this._dl, 24), c(this._eh, this._el, 32), c(this._fh, this._fl, 40), o;
  }, sha384$1 = n, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  return hasRequiredSha_js || (hasRequiredSha_js = 1, (function(e) {
    e.exports = function(r) {
      var a = r.toLowerCase(), u = e.exports[a];
      if (!u)
        throw new Error(a + " is not supported (we accept pull requests)");
      return new u();
    }, e.exports.sha = requireSha$1(), e.exports.sha1 = requireSha1(), e.exports.sha224 = requireSha224(), e.exports.sha256 = requireSha256(), e.exports.sha384 = requireSha384(), e.exports.sha512 = requireSha512();
  })(sha_js)), sha_js.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(y, v) {
    var E = Object.keys(y);
    if (Object.getOwnPropertySymbols) {
      var b = Object.getOwnPropertySymbols(y);
      v && (b = b.filter(function(q) {
        return Object.getOwnPropertyDescriptor(y, q).enumerable;
      })), E.push.apply(E, b);
    }
    return E;
  }
  function t(y) {
    for (var v = 1; v < arguments.length; v++) {
      var E = arguments[v] != null ? arguments[v] : {};
      v % 2 ? e(Object(E), !0).forEach(function(b) {
        r(y, b, E[b]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(E)) : e(Object(E)).forEach(function(b) {
        Object.defineProperty(y, b, Object.getOwnPropertyDescriptor(E, b));
      });
    }
    return y;
  }
  function r(y, v, E) {
    return v = o(v), v in y ? Object.defineProperty(y, v, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : y[v] = E, y;
  }
  function a(y, v) {
    if (!(y instanceof v))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(y, v) {
    for (var E = 0; E < v.length; E++) {
      var b = v[E];
      b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(y, o(b.key), b);
    }
  }
  function n(y, v, E) {
    return v && u(y.prototype, v), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function o(y) {
    var v = c(y, "string");
    return typeof v == "symbol" ? v : String(v);
  }
  function c(y, v) {
    if (typeof y != "object" || y === null) return y;
    var E = y[Symbol.toPrimitive];
    if (E !== void 0) {
      var b = E.call(y, v);
      if (typeof b != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(y);
  }
  var f = requireDist$1(), l = f.Buffer, s = requireUtil(), p = s.inspect, m = p && p.custom || "inspect";
  function g(y, v, E) {
    l.prototype.copy.call(y, v, E);
  }
  return buffer_list = /* @__PURE__ */ (function() {
    function y() {
      a(this, y), this.head = null, this.tail = null, this.length = 0;
    }
    return n(y, [{
      key: "push",
      value: function(E) {
        var b = {
          data: E,
          next: null
        };
        this.length > 0 ? this.tail.next = b : this.head = b, this.tail = b, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(E) {
        var b = {
          data: E,
          next: this.head
        };
        this.length === 0 && (this.tail = b), this.head = b, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var E = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(E) {
        if (this.length === 0) return "";
        for (var b = this.head, q = "" + b.data; b = b.next; ) q += E + b.data;
        return q;
      }
    }, {
      key: "concat",
      value: function(E) {
        if (this.length === 0) return l.alloc(0);
        for (var b = l.allocUnsafe(E >>> 0), q = this.head, O = 0; q; )
          g(q.data, b, O), O += q.data.length, q = q.next;
        return b;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(E, b) {
        var q;
        return E < this.head.data.length ? (q = this.head.data.slice(0, E), this.head.data = this.head.data.slice(E)) : E === this.head.data.length ? q = this.shift() : q = b ? this._getString(E) : this._getBuffer(E), q;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(E) {
        var b = this.head, q = 1, O = b.data;
        for (E -= O.length; b = b.next; ) {
          var j = b.data, D = E > j.length ? j.length : E;
          if (D === j.length ? O += j : O += j.slice(0, E), E -= D, E === 0) {
            D === j.length ? (++q, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = j.slice(D));
            break;
          }
          ++q;
        }
        return this.length -= q, O;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(E) {
        var b = l.allocUnsafe(E), q = this.head, O = 1;
        for (q.data.copy(b), E -= q.data.length; q = q.next; ) {
          var j = q.data, D = E > j.length ? j.length : E;
          if (j.copy(b, b.length - E, 0, D), E -= D, E === 0) {
            D === j.length ? (++O, q.next ? this.head = q.next : this.head = this.tail = null) : (this.head = q, q.data = j.slice(D));
            break;
          }
          ++O;
        }
        return this.length -= O, b;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: m,
      value: function(E, b) {
        return p(this, t(t({}, b), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), y;
  })(), buffer_list;
}
var destroy_1$2, hasRequiredDestroy$2;
function requireDestroy$2() {
  if (hasRequiredDestroy$2) return destroy_1$2;
  hasRequiredDestroy$2 = 1;
  function e(o, c) {
    var f = this, l = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return l || s ? (c ? c(o) : o && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(u, this, o)) : process$1.nextTick(u, this, o)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(o || null, function(p) {
      !c && p ? f._writableState ? f._writableState.errorEmitted ? process$1.nextTick(r, f) : (f._writableState.errorEmitted = !0, process$1.nextTick(t, f, p)) : process$1.nextTick(t, f, p) : c ? (process$1.nextTick(r, f), c(p)) : process$1.nextTick(r, f);
    }), this);
  }
  function t(o, c) {
    u(o, c), r(o);
  }
  function r(o) {
    o._writableState && !o._writableState.emitClose || o._readableState && !o._readableState.emitClose || o.emit("close");
  }
  function a() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function u(o, c) {
    o.emit("error", c);
  }
  function n(o, c) {
    var f = o._readableState, l = o._writableState;
    f && f.autoDestroy || l && l.autoDestroy ? o.destroy(c) : o.emit("error", c);
  }
  return destroy_1$2 = {
    destroy: e,
    undestroy: a,
    errorOrDestroy: n
  }, destroy_1$2;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(c, f) {
    c.prototype = Object.create(f.prototype), c.prototype.constructor = c, c.__proto__ = f;
  }
  var t = {};
  function r(c, f, l) {
    l || (l = Error);
    function s(m, g, y) {
      return typeof f == "string" ? f : f(m, g, y);
    }
    var p = /* @__PURE__ */ (function(m) {
      e(g, m);
      function g(y, v, E) {
        return m.call(this, s(y, v, E)) || this;
      }
      return g;
    })(l);
    p.prototype.name = l.name, p.prototype.code = c, t[c] = p;
  }
  function a(c, f) {
    if (Array.isArray(c)) {
      var l = c.length;
      return c = c.map(function(s) {
        return String(s);
      }), l > 2 ? "one of ".concat(f, " ").concat(c.slice(0, l - 1).join(", "), ", or ") + c[l - 1] : l === 2 ? "one of ".concat(f, " ").concat(c[0], " or ").concat(c[1]) : "of ".concat(f, " ").concat(c[0]);
    } else
      return "of ".concat(f, " ").concat(String(c));
  }
  function u(c, f, l) {
    return c.substr(0, f.length) === f;
  }
  function n(c, f, l) {
    return (l === void 0 || l > c.length) && (l = c.length), c.substring(l - f.length, l) === f;
  }
  function o(c, f, l) {
    return typeof l != "number" && (l = 0), l + f.length > c.length ? !1 : c.indexOf(f, l) !== -1;
  }
  return r("ERR_INVALID_OPT_VALUE", function(c, f) {
    return 'The value "' + f + '" is invalid for option "' + c + '"';
  }, TypeError), r("ERR_INVALID_ARG_TYPE", function(c, f, l) {
    var s;
    typeof f == "string" && u(f, "not ") ? (s = "must not be", f = f.replace(/^not /, "")) : s = "must be";
    var p;
    if (n(c, " argument"))
      p = "The ".concat(c, " ").concat(s, " ").concat(a(f, "type"));
    else {
      var m = o(c, ".") ? "property" : "argument";
      p = 'The "'.concat(c, '" ').concat(m, " ").concat(s, " ").concat(a(f, "type"));
    }
    return p += ". Received type ".concat(typeof l), p;
  }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(c) {
    return "The " + c + " method is not implemented";
  }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(c) {
    return "Cannot call " + c + " after a stream was destroyed";
  }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(c) {
    return "Unknown encoding: " + c;
  }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(a, u, n) {
    return a.highWaterMark != null ? a.highWaterMark : u ? a[n] : null;
  }
  function r(a, u, n, o) {
    var c = t(u, o, n);
    if (c != null) {
      if (!(isFinite(c) && Math.floor(c) === c) || c < 0) {
        var f = o ? n : "highWaterMark";
        throw new e(f, c);
      }
      return Math.floor(c);
    }
    return a.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: r
  }, state;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Q;
  function e(ee) {
    var F = this;
    this.next = null, this.entry = null, this.finish = function() {
      le(F, ee);
    };
  }
  var t;
  Q.WritableState = G;
  var r = {
    deprecate: requireBrowser$h()
  }, a = requireStreamBrowser$1(), u = requireDist$1().Buffer, n = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function o(ee) {
    return u.from(ee);
  }
  function c(ee) {
    return u.isBuffer(ee) || ee instanceof n;
  }
  var f = requireDestroy$2(), l = requireState(), s = l.getHighWaterMark, p = requireErrorsBrowser().codes, m = p.ERR_INVALID_ARG_TYPE, g = p.ERR_METHOD_NOT_IMPLEMENTED, y = p.ERR_MULTIPLE_CALLBACK, v = p.ERR_STREAM_CANNOT_PIPE, E = p.ERR_STREAM_DESTROYED, b = p.ERR_STREAM_NULL_VALUES, q = p.ERR_STREAM_WRITE_AFTER_END, O = p.ERR_UNKNOWN_ENCODING, j = f.errorOrDestroy;
  requireInherits_browser()(Q, a);
  function D() {
  }
  function G(ee, F, z) {
    t = t || require_stream_duplex$1(), ee = ee || {}, typeof z != "boolean" && (z = F instanceof t), this.objectMode = !!ee.objectMode, z && (this.objectMode = this.objectMode || !!ee.writableObjectMode), this.highWaterMark = s(this, ee, "writableHighWaterMark", z), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var se = ee.decodeStrings === !1;
    this.decodeStrings = !se, this.defaultEncoding = ee.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(he) {
      B(F, he);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ee.emitClose !== !1, this.autoDestroy = !!ee.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  G.prototype.getBuffer = function() {
    for (var F = this.bufferedRequest, z = []; F; )
      z.push(F), F = F.next;
    return z;
  }, (function() {
    try {
      Object.defineProperty(G.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var V;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(Q, Symbol.hasInstance, {
    value: function(F) {
      return V.call(this, F) ? !0 : this !== Q ? !1 : F && F._writableState instanceof G;
    }
  })) : V = function(F) {
    return F instanceof this;
  };
  function Q(ee) {
    t = t || require_stream_duplex$1();
    var F = this instanceof t;
    if (!F && !V.call(Q, this)) return new Q(ee);
    this._writableState = new G(ee, this, F), this.writable = !0, ee && (typeof ee.write == "function" && (this._write = ee.write), typeof ee.writev == "function" && (this._writev = ee.writev), typeof ee.destroy == "function" && (this._destroy = ee.destroy), typeof ee.final == "function" && (this._final = ee.final)), a.call(this);
  }
  Q.prototype.pipe = function() {
    j(this, new v());
  };
  function re(ee, F) {
    var z = new q();
    j(ee, z), process$1.nextTick(F, z);
  }
  function ve(ee, F, z, se) {
    var he;
    return z === null ? he = new b() : typeof z != "string" && !F.objectMode && (he = new m("chunk", ["string", "Buffer"], z)), he ? (j(ee, he), process$1.nextTick(se, he), !1) : !0;
  }
  Q.prototype.write = function(ee, F, z) {
    var se = this._writableState, he = !1, ae = !se.objectMode && c(ee);
    return ae && !u.isBuffer(ee) && (ee = o(ee)), typeof F == "function" && (z = F, F = null), ae ? F = "buffer" : F || (F = se.defaultEncoding), typeof z != "function" && (z = D), se.ending ? re(this, z) : (ae || ve(this, se, ee, z)) && (se.pendingcb++, he = R(this, se, ae, ee, F, z)), he;
  }, Q.prototype.cork = function() {
    this._writableState.corked++;
  }, Q.prototype.uncork = function() {
    var ee = this._writableState;
    ee.corked && (ee.corked--, !ee.writing && !ee.corked && !ee.bufferProcessing && ee.bufferedRequest && I(this, ee));
  }, Q.prototype.setDefaultEncoding = function(F) {
    if (typeof F == "string" && (F = F.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((F + "").toLowerCase()) > -1)) throw new O(F);
    return this._writableState.defaultEncoding = F, this;
  }, Object.defineProperty(Q.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function te(ee, F, z) {
    return !ee.objectMode && ee.decodeStrings !== !1 && typeof F == "string" && (F = u.from(F, z)), F;
  }
  Object.defineProperty(Q.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function R(ee, F, z, se, he, ae) {
    if (!z) {
      var X = te(F, se, he);
      se !== X && (z = !0, he = "buffer", se = X);
    }
    var be = F.objectMode ? 1 : se.length;
    F.length += be;
    var Re = F.length < F.highWaterMark;
    if (Re || (F.needDrain = !0), F.writing || F.corked) {
      var Pe = F.lastBufferedRequest;
      F.lastBufferedRequest = {
        chunk: se,
        encoding: he,
        isBuf: z,
        callback: ae,
        next: null
      }, Pe ? Pe.next = F.lastBufferedRequest : F.bufferedRequest = F.lastBufferedRequest, F.bufferedRequestCount += 1;
    } else
      M(ee, F, !1, be, se, he, ae);
    return Re;
  }
  function M(ee, F, z, se, he, ae, X) {
    F.writelen = se, F.writecb = X, F.writing = !0, F.sync = !0, F.destroyed ? F.onwrite(new E("write")) : z ? ee._writev(he, F.onwrite) : ee._write(he, ae, F.onwrite), F.sync = !1;
  }
  function h(ee, F, z, se, he) {
    --F.pendingcb, z ? (process$1.nextTick(he, se), process$1.nextTick(U, ee, F), ee._writableState.errorEmitted = !0, j(ee, se)) : (he(se), ee._writableState.errorEmitted = !0, j(ee, se), U(ee, F));
  }
  function S(ee) {
    ee.writing = !1, ee.writecb = null, ee.length -= ee.writelen, ee.writelen = 0;
  }
  function B(ee, F) {
    var z = ee._writableState, se = z.sync, he = z.writecb;
    if (typeof he != "function") throw new y();
    if (S(z), F) h(ee, z, se, F, he);
    else {
      var ae = C(z) || ee.destroyed;
      !ae && !z.corked && !z.bufferProcessing && z.bufferedRequest && I(ee, z), se ? process$1.nextTick(T, ee, z, ae, he) : T(ee, z, ae, he);
    }
  }
  function T(ee, F, z, se) {
    z || k(ee, F), F.pendingcb--, se(), U(ee, F);
  }
  function k(ee, F) {
    F.length === 0 && F.needDrain && (F.needDrain = !1, ee.emit("drain"));
  }
  function I(ee, F) {
    F.bufferProcessing = !0;
    var z = F.bufferedRequest;
    if (ee._writev && z && z.next) {
      var se = F.bufferedRequestCount, he = new Array(se), ae = F.corkedRequestsFree;
      ae.entry = z;
      for (var X = 0, be = !0; z; )
        he[X] = z, z.isBuf || (be = !1), z = z.next, X += 1;
      he.allBuffers = be, M(ee, F, !0, F.length, he, "", ae.finish), F.pendingcb++, F.lastBufferedRequest = null, ae.next ? (F.corkedRequestsFree = ae.next, ae.next = null) : F.corkedRequestsFree = new e(F), F.bufferedRequestCount = 0;
    } else {
      for (; z; ) {
        var Re = z.chunk, Pe = z.encoding, Fe = z.callback, De = F.objectMode ? 1 : Re.length;
        if (M(ee, F, !1, De, Re, Pe, Fe), z = z.next, F.bufferedRequestCount--, F.writing)
          break;
      }
      z === null && (F.lastBufferedRequest = null);
    }
    F.bufferedRequest = z, F.bufferProcessing = !1;
  }
  Q.prototype._write = function(ee, F, z) {
    z(new g("_write()"));
  }, Q.prototype._writev = null, Q.prototype.end = function(ee, F, z) {
    var se = this._writableState;
    return typeof ee == "function" ? (z = ee, ee = null, F = null) : typeof F == "function" && (z = F, F = null), ee != null && this.write(ee, F), se.corked && (se.corked = 1, this.uncork()), se.ending || ie(this, se, z), this;
  }, Object.defineProperty(Q.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function C(ee) {
    return ee.ending && ee.length === 0 && ee.bufferedRequest === null && !ee.finished && !ee.writing;
  }
  function $(ee, F) {
    ee._final(function(z) {
      F.pendingcb--, z && j(ee, z), F.prefinished = !0, ee.emit("prefinish"), U(ee, F);
    });
  }
  function w(ee, F) {
    !F.prefinished && !F.finalCalled && (typeof ee._final == "function" && !F.destroyed ? (F.pendingcb++, F.finalCalled = !0, process$1.nextTick($, ee, F)) : (F.prefinished = !0, ee.emit("prefinish")));
  }
  function U(ee, F) {
    var z = C(F);
    if (z && (w(ee, F), F.pendingcb === 0 && (F.finished = !0, ee.emit("finish"), F.autoDestroy))) {
      var se = ee._readableState;
      (!se || se.autoDestroy && se.endEmitted) && ee.destroy();
    }
    return z;
  }
  function ie(ee, F, z) {
    F.ending = !0, U(ee, F), z && (F.finished ? process$1.nextTick(z) : ee.once("finish", z)), F.ended = !0, ee.writable = !1;
  }
  function le(ee, F, z) {
    var se = ee.entry;
    for (ee.entry = null; se; ) {
      var he = se.callback;
      F.pendingcb--, he(z), se = se.next;
    }
    F.corkedRequestsFree.next = ee;
  }
  return Object.defineProperty(Q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(F) {
      this._writableState && (this._writableState.destroyed = F);
    }
  }), Q.prototype.destroy = f.destroy, Q.prototype._undestroy = f.undestroy, Q.prototype._destroy = function(ee, F) {
    F(ee);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(l) {
    var s = [];
    for (var p in l) s.push(p);
    return s;
  };
  _stream_duplex$1 = o;
  var t = require_stream_readable$1(), r = require_stream_writable$1();
  requireInherits_browser()(o, t);
  for (var a = e(r.prototype), u = 0; u < a.length; u++) {
    var n = a[u];
    o.prototype[n] || (o.prototype[n] = r.prototype[n]);
  }
  function o(l) {
    if (!(this instanceof o)) return new o(l);
    t.call(this, l), r.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", c)));
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(o.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(o.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function c() {
    this._writableState.ended || process$1.nextTick(f, this);
  }
  function f(l) {
    l.end();
  }
  return Object.defineProperty(o.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(s) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = s, this._writableState.destroyed = s);
    }
  }), _stream_duplex$1;
}
var string_decoder$1 = {}, hasRequiredString_decoder$1;
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1) return string_decoder$1;
  hasRequiredString_decoder$1 = 1;
  var e = requireSafeBuffer$4().Buffer, t = e.isEncoding || function(b) {
    switch (b = "" + b, b && b.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(b) {
    if (!b) return "utf8";
    for (var q; ; )
      switch (b) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return b;
        default:
          if (q) return;
          b = ("" + b).toLowerCase(), q = !0;
      }
  }
  function a(b) {
    var q = r(b);
    if (typeof q != "string" && (e.isEncoding === t || !t(b))) throw new Error("Unknown encoding: " + b);
    return q || b;
  }
  string_decoder$1.StringDecoder = u;
  function u(b) {
    this.encoding = a(b);
    var q;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = m, q = 4;
        break;
      case "utf8":
        this.fillLast = f, q = 4;
        break;
      case "base64":
        this.text = g, this.end = y, q = 3;
        break;
      default:
        this.write = v, this.end = E;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(q);
  }
  u.prototype.write = function(b) {
    if (b.length === 0) return "";
    var q, O;
    if (this.lastNeed) {
      if (q = this.fillLast(b), q === void 0) return "";
      O = this.lastNeed, this.lastNeed = 0;
    } else
      O = 0;
    return O < b.length ? q ? q + this.text(b, O) : this.text(b, O) : q || "";
  }, u.prototype.end = s, u.prototype.text = l, u.prototype.fillLast = function(b) {
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
  };
  function n(b) {
    return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
  }
  function o(b, q, O) {
    var j = q.length - 1;
    if (j < O) return 0;
    var D = n(q[j]);
    return D >= 0 ? (D > 0 && (b.lastNeed = D - 1), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (b.lastNeed = D - 2), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (D === 2 ? D = 0 : b.lastNeed = D - 3), D) : 0));
  }
  function c(b, q, O) {
    if ((q[0] & 192) !== 128)
      return b.lastNeed = 0, "�";
    if (b.lastNeed > 1 && q.length > 1) {
      if ((q[1] & 192) !== 128)
        return b.lastNeed = 1, "�";
      if (b.lastNeed > 2 && q.length > 2 && (q[2] & 192) !== 128)
        return b.lastNeed = 2, "�";
    }
  }
  function f(b) {
    var q = this.lastTotal - this.lastNeed, O = c(this, b);
    if (O !== void 0) return O;
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, q, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, q, 0, b.length), this.lastNeed -= b.length;
  }
  function l(b, q) {
    var O = o(this, b, q);
    if (!this.lastNeed) return b.toString("utf8", q);
    this.lastTotal = O;
    var j = b.length - (O - this.lastNeed);
    return b.copy(this.lastChar, 0, j), b.toString("utf8", q, j);
  }
  function s(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + "�" : q;
  }
  function p(b, q) {
    if ((b.length - q) % 2 === 0) {
      var O = b.toString("utf16le", q);
      if (O) {
        var j = O.charCodeAt(O.length - 1);
        if (j >= 55296 && j <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], O.slice(0, -1);
      }
      return O;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", q, b.length - 1);
  }
  function m(b) {
    var q = b && b.length ? this.write(b) : "";
    if (this.lastNeed) {
      var O = this.lastTotal - this.lastNeed;
      return q + this.lastChar.toString("utf16le", 0, O);
    }
    return q;
  }
  function g(b, q) {
    var O = (b.length - q) % 3;
    return O === 0 ? b.toString("base64", q) : (this.lastNeed = 3 - O, this.lastTotal = 3, O === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", q, b.length - O));
  }
  function y(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : q;
  }
  function v(b) {
    return b.toString(this.encoding);
  }
  function E(b) {
    return b && b.length ? this.write(b) : "";
  }
  return string_decoder$1;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(n) {
    var o = !1;
    return function() {
      if (!o) {
        o = !0;
        for (var c = arguments.length, f = new Array(c), l = 0; l < c; l++)
          f[l] = arguments[l];
        n.apply(this, f);
      }
    };
  }
  function r() {
  }
  function a(n) {
    return n.setHeader && typeof n.abort == "function";
  }
  function u(n, o, c) {
    if (typeof o == "function") return u(n, null, o);
    o || (o = {}), c = t(c || r);
    var f = o.readable || o.readable !== !1 && n.readable, l = o.writable || o.writable !== !1 && n.writable, s = function() {
      n.writable || m();
    }, p = n._writableState && n._writableState.finished, m = function() {
      l = !1, p = !0, f || c.call(n);
    }, g = n._readableState && n._readableState.endEmitted, y = function() {
      f = !1, g = !0, l || c.call(n);
    }, v = function(O) {
      c.call(n, O);
    }, E = function() {
      var O;
      if (f && !g)
        return (!n._readableState || !n._readableState.ended) && (O = new e()), c.call(n, O);
      if (l && !p)
        return (!n._writableState || !n._writableState.ended) && (O = new e()), c.call(n, O);
    }, b = function() {
      n.req.on("finish", m);
    };
    return a(n) ? (n.on("complete", m), n.on("abort", E), n.req ? b() : n.on("request", b)) : l && !n._writableState && (n.on("end", s), n.on("close", s)), n.on("end", y), n.on("finish", m), o.error !== !1 && n.on("error", v), n.on("close", E), function() {
      n.removeListener("complete", m), n.removeListener("abort", E), n.removeListener("request", b), n.req && n.req.removeListener("finish", m), n.removeListener("end", s), n.removeListener("close", s), n.removeListener("finish", m), n.removeListener("end", y), n.removeListener("error", v), n.removeListener("close", E);
    };
  }
  return endOfStream = u, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function t(O, j, D) {
    return j = r(j), j in O ? Object.defineProperty(O, j, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : O[j] = D, O;
  }
  function r(O) {
    var j = a(O, "string");
    return typeof j == "symbol" ? j : String(j);
  }
  function a(O, j) {
    if (typeof O != "object" || O === null) return O;
    var D = O[Symbol.toPrimitive];
    if (D !== void 0) {
      var G = D.call(O, j);
      if (typeof G != "object") return G;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (j === "string" ? String : Number)(O);
  }
  var u = requireEndOfStream(), n = Symbol("lastResolve"), o = Symbol("lastReject"), c = Symbol("error"), f = Symbol("ended"), l = Symbol("lastPromise"), s = Symbol("handlePromise"), p = Symbol("stream");
  function m(O, j) {
    return {
      value: O,
      done: j
    };
  }
  function g(O) {
    var j = O[n];
    if (j !== null) {
      var D = O[p].read();
      D !== null && (O[l] = null, O[n] = null, O[o] = null, j(m(D, !1)));
    }
  }
  function y(O) {
    process$1.nextTick(g, O);
  }
  function v(O, j) {
    return function(D, G) {
      O.then(function() {
        if (j[f]) {
          D(m(void 0, !0));
          return;
        }
        j[s](D, G);
      }, G);
    };
  }
  var E = Object.getPrototypeOf(function() {
  }), b = Object.setPrototypeOf((e = {
    get stream() {
      return this[p];
    },
    next: function() {
      var j = this, D = this[c];
      if (D !== null)
        return Promise.reject(D);
      if (this[f])
        return Promise.resolve(m(void 0, !0));
      if (this[p].destroyed)
        return new Promise(function(re, ve) {
          process$1.nextTick(function() {
            j[c] ? ve(j[c]) : re(m(void 0, !0));
          });
        });
      var G = this[l], V;
      if (G)
        V = new Promise(v(G, this));
      else {
        var Q = this[p].read();
        if (Q !== null)
          return Promise.resolve(m(Q, !1));
        V = new Promise(this[s]);
      }
      return this[l] = V, V;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var j = this;
    return new Promise(function(D, G) {
      j[p].destroy(null, function(V) {
        if (V) {
          G(V);
          return;
        }
        D(m(void 0, !0));
      });
    });
  }), e), E), q = function(j) {
    var D, G = Object.create(b, (D = {}, t(D, p, {
      value: j,
      writable: !0
    }), t(D, n, {
      value: null,
      writable: !0
    }), t(D, o, {
      value: null,
      writable: !0
    }), t(D, c, {
      value: null,
      writable: !0
    }), t(D, f, {
      value: j._readableState.endEmitted,
      writable: !0
    }), t(D, s, {
      value: function(Q, re) {
        var ve = G[p].read();
        ve ? (G[l] = null, G[n] = null, G[o] = null, Q(m(ve, !1))) : (G[n] = Q, G[o] = re);
      },
      writable: !0
    }), D));
    return G[l] = null, u(j, function(V) {
      if (V && V.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Q = G[o];
        Q !== null && (G[l] = null, G[n] = null, G[o] = null, Q(V)), G[c] = V;
        return;
      }
      var re = G[n];
      re !== null && (G[l] = null, G[n] = null, G[o] = null, re(m(void 0, !0))), G[f] = !0;
    }), j.on("readable", y.bind(null, G)), G;
  };
  return async_iterator = q, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = re;
  var e;
  re.ReadableState = Q, requireEvents().EventEmitter;
  var t = function(X, be) {
    return X.listeners(be).length;
  }, r = requireStreamBrowser$1(), a = requireDist$1().Buffer, u = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function n(ae) {
    return a.from(ae);
  }
  function o(ae) {
    return a.isBuffer(ae) || ae instanceof u;
  }
  var c = requireUtil(), f;
  c && c.debuglog ? f = c.debuglog("stream") : f = function() {
  };
  var l = requireBuffer_list(), s = requireDestroy$2(), p = requireState(), m = p.getHighWaterMark, g = requireErrorsBrowser().codes, y = g.ERR_INVALID_ARG_TYPE, v = g.ERR_STREAM_PUSH_AFTER_EOF, E = g.ERR_METHOD_NOT_IMPLEMENTED, b = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, q, O, j;
  requireInherits_browser()(re, r);
  var D = s.errorOrDestroy, G = ["error", "close", "destroy", "pause", "resume"];
  function V(ae, X, be) {
    if (typeof ae.prependListener == "function") return ae.prependListener(X, be);
    !ae._events || !ae._events[X] ? ae.on(X, be) : Array.isArray(ae._events[X]) ? ae._events[X].unshift(be) : ae._events[X] = [be, ae._events[X]];
  }
  function Q(ae, X, be) {
    e = e || require_stream_duplex$1(), ae = ae || {}, typeof be != "boolean" && (be = X instanceof e), this.objectMode = !!ae.objectMode, be && (this.objectMode = this.objectMode || !!ae.readableObjectMode), this.highWaterMark = m(this, ae, "readableHighWaterMark", be), this.buffer = new l(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ae.emitClose !== !1, this.autoDestroy = !!ae.autoDestroy, this.destroyed = !1, this.defaultEncoding = ae.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ae.encoding && (q || (q = requireString_decoder$1().StringDecoder), this.decoder = new q(ae.encoding), this.encoding = ae.encoding);
  }
  function re(ae) {
    if (e = e || require_stream_duplex$1(), !(this instanceof re)) return new re(ae);
    var X = this instanceof e;
    this._readableState = new Q(ae, this, X), this.readable = !0, ae && (typeof ae.read == "function" && (this._read = ae.read), typeof ae.destroy == "function" && (this._destroy = ae.destroy)), r.call(this);
  }
  Object.defineProperty(re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(X) {
      this._readableState && (this._readableState.destroyed = X);
    }
  }), re.prototype.destroy = s.destroy, re.prototype._undestroy = s.undestroy, re.prototype._destroy = function(ae, X) {
    X(ae);
  }, re.prototype.push = function(ae, X) {
    var be = this._readableState, Re;
    return be.objectMode ? Re = !0 : typeof ae == "string" && (X = X || be.defaultEncoding, X !== be.encoding && (ae = a.from(ae, X), X = ""), Re = !0), ve(this, ae, X, !1, Re);
  }, re.prototype.unshift = function(ae) {
    return ve(this, ae, null, !0, !1);
  };
  function ve(ae, X, be, Re, Pe) {
    f("readableAddChunk", X);
    var Fe = ae._readableState;
    if (X === null)
      Fe.reading = !1, B(ae, Fe);
    else {
      var De;
      if (Pe || (De = R(Fe, X)), De)
        D(ae, De);
      else if (Fe.objectMode || X && X.length > 0)
        if (typeof X != "string" && !Fe.objectMode && Object.getPrototypeOf(X) !== a.prototype && (X = n(X)), Re)
          Fe.endEmitted ? D(ae, new b()) : te(ae, Fe, X, !0);
        else if (Fe.ended)
          D(ae, new v());
        else {
          if (Fe.destroyed)
            return !1;
          Fe.reading = !1, Fe.decoder && !be ? (X = Fe.decoder.write(X), Fe.objectMode || X.length !== 0 ? te(ae, Fe, X, !1) : I(ae, Fe)) : te(ae, Fe, X, !1);
        }
      else Re || (Fe.reading = !1, I(ae, Fe));
    }
    return !Fe.ended && (Fe.length < Fe.highWaterMark || Fe.length === 0);
  }
  function te(ae, X, be, Re) {
    X.flowing && X.length === 0 && !X.sync ? (X.awaitDrain = 0, ae.emit("data", be)) : (X.length += X.objectMode ? 1 : be.length, Re ? X.buffer.unshift(be) : X.buffer.push(be), X.needReadable && T(ae)), I(ae, X);
  }
  function R(ae, X) {
    var be;
    return !o(X) && typeof X != "string" && X !== void 0 && !ae.objectMode && (be = new y("chunk", ["string", "Buffer", "Uint8Array"], X)), be;
  }
  re.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, re.prototype.setEncoding = function(ae) {
    q || (q = requireString_decoder$1().StringDecoder);
    var X = new q(ae);
    this._readableState.decoder = X, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var be = this._readableState.buffer.head, Re = ""; be !== null; )
      Re += X.write(be.data), be = be.next;
    return this._readableState.buffer.clear(), Re !== "" && this._readableState.buffer.push(Re), this._readableState.length = Re.length, this;
  };
  var M = 1073741824;
  function h(ae) {
    return ae >= M ? ae = M : (ae--, ae |= ae >>> 1, ae |= ae >>> 2, ae |= ae >>> 4, ae |= ae >>> 8, ae |= ae >>> 16, ae++), ae;
  }
  function S(ae, X) {
    return ae <= 0 || X.length === 0 && X.ended ? 0 : X.objectMode ? 1 : ae !== ae ? X.flowing && X.length ? X.buffer.head.data.length : X.length : (ae > X.highWaterMark && (X.highWaterMark = h(ae)), ae <= X.length ? ae : X.ended ? X.length : (X.needReadable = !0, 0));
  }
  re.prototype.read = function(ae) {
    f("read", ae), ae = parseInt(ae, 10);
    var X = this._readableState, be = ae;
    if (ae !== 0 && (X.emittedReadable = !1), ae === 0 && X.needReadable && ((X.highWaterMark !== 0 ? X.length >= X.highWaterMark : X.length > 0) || X.ended))
      return f("read: emitReadable", X.length, X.ended), X.length === 0 && X.ended ? z(this) : T(this), null;
    if (ae = S(ae, X), ae === 0 && X.ended)
      return X.length === 0 && z(this), null;
    var Re = X.needReadable;
    f("need readable", Re), (X.length === 0 || X.length - ae < X.highWaterMark) && (Re = !0, f("length less than watermark", Re)), X.ended || X.reading ? (Re = !1, f("reading or ended", Re)) : Re && (f("do read"), X.reading = !0, X.sync = !0, X.length === 0 && (X.needReadable = !0), this._read(X.highWaterMark), X.sync = !1, X.reading || (ae = S(be, X)));
    var Pe;
    return ae > 0 ? Pe = F(ae, X) : Pe = null, Pe === null ? (X.needReadable = X.length <= X.highWaterMark, ae = 0) : (X.length -= ae, X.awaitDrain = 0), X.length === 0 && (X.ended || (X.needReadable = !0), be !== ae && X.ended && z(this)), Pe !== null && this.emit("data", Pe), Pe;
  };
  function B(ae, X) {
    if (f("onEofChunk"), !X.ended) {
      if (X.decoder) {
        var be = X.decoder.end();
        be && be.length && (X.buffer.push(be), X.length += X.objectMode ? 1 : be.length);
      }
      X.ended = !0, X.sync ? T(ae) : (X.needReadable = !1, X.emittedReadable || (X.emittedReadable = !0, k(ae)));
    }
  }
  function T(ae) {
    var X = ae._readableState;
    f("emitReadable", X.needReadable, X.emittedReadable), X.needReadable = !1, X.emittedReadable || (f("emitReadable", X.flowing), X.emittedReadable = !0, process$1.nextTick(k, ae));
  }
  function k(ae) {
    var X = ae._readableState;
    f("emitReadable_", X.destroyed, X.length, X.ended), !X.destroyed && (X.length || X.ended) && (ae.emit("readable"), X.emittedReadable = !1), X.needReadable = !X.flowing && !X.ended && X.length <= X.highWaterMark, ee(ae);
  }
  function I(ae, X) {
    X.readingMore || (X.readingMore = !0, process$1.nextTick(C, ae, X));
  }
  function C(ae, X) {
    for (; !X.reading && !X.ended && (X.length < X.highWaterMark || X.flowing && X.length === 0); ) {
      var be = X.length;
      if (f("maybeReadMore read 0"), ae.read(0), be === X.length)
        break;
    }
    X.readingMore = !1;
  }
  re.prototype._read = function(ae) {
    D(this, new E("_read()"));
  }, re.prototype.pipe = function(ae, X) {
    var be = this, Re = this._readableState;
    switch (Re.pipesCount) {
      case 0:
        Re.pipes = ae;
        break;
      case 1:
        Re.pipes = [Re.pipes, ae];
        break;
      default:
        Re.pipes.push(ae);
        break;
    }
    Re.pipesCount += 1, f("pipe count=%d opts=%j", Re.pipesCount, X);
    var Pe = (!X || X.end !== !1) && ae !== process$1.stdout && ae !== process$1.stderr, Fe = Pe ? je : ze;
    Re.endEmitted ? process$1.nextTick(Fe) : be.once("end", Fe), ae.on("unpipe", De);
    function De(Ue, Ge) {
      f("onunpipe"), Ue === be && Ge && Ge.hasUnpiped === !1 && (Ge.hasUnpiped = !0, He());
    }
    function je() {
      f("onend"), ae.end();
    }
    var Oe = $(be);
    ae.on("drain", Oe);
    var rt = !1;
    function He() {
      f("cleanup"), ae.removeListener("close", we), ae.removeListener("finish", Ae), ae.removeListener("drain", Oe), ae.removeListener("error", Je), ae.removeListener("unpipe", De), be.removeListener("end", je), be.removeListener("end", ze), be.removeListener("data", Qe), rt = !0, Re.awaitDrain && (!ae._writableState || ae._writableState.needDrain) && Oe();
    }
    be.on("data", Qe);
    function Qe(Ue) {
      f("ondata");
      var Ge = ae.write(Ue);
      f("dest.write", Ge), Ge === !1 && ((Re.pipesCount === 1 && Re.pipes === ae || Re.pipesCount > 1 && he(Re.pipes, ae) !== -1) && !rt && (f("false write response, pause", Re.awaitDrain), Re.awaitDrain++), be.pause());
    }
    function Je(Ue) {
      f("onerror", Ue), ze(), ae.removeListener("error", Je), t(ae, "error") === 0 && D(ae, Ue);
    }
    V(ae, "error", Je);
    function we() {
      ae.removeListener("finish", Ae), ze();
    }
    ae.once("close", we);
    function Ae() {
      f("onfinish"), ae.removeListener("close", we), ze();
    }
    ae.once("finish", Ae);
    function ze() {
      f("unpipe"), be.unpipe(ae);
    }
    return ae.emit("pipe", be), Re.flowing || (f("pipe resume"), be.resume()), ae;
  };
  function $(ae) {
    return function() {
      var be = ae._readableState;
      f("pipeOnDrain", be.awaitDrain), be.awaitDrain && be.awaitDrain--, be.awaitDrain === 0 && t(ae, "data") && (be.flowing = !0, ee(ae));
    };
  }
  re.prototype.unpipe = function(ae) {
    var X = this._readableState, be = {
      hasUnpiped: !1
    };
    if (X.pipesCount === 0) return this;
    if (X.pipesCount === 1)
      return ae && ae !== X.pipes ? this : (ae || (ae = X.pipes), X.pipes = null, X.pipesCount = 0, X.flowing = !1, ae && ae.emit("unpipe", this, be), this);
    if (!ae) {
      var Re = X.pipes, Pe = X.pipesCount;
      X.pipes = null, X.pipesCount = 0, X.flowing = !1;
      for (var Fe = 0; Fe < Pe; Fe++) Re[Fe].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var De = he(X.pipes, ae);
    return De === -1 ? this : (X.pipes.splice(De, 1), X.pipesCount -= 1, X.pipesCount === 1 && (X.pipes = X.pipes[0]), ae.emit("unpipe", this, be), this);
  }, re.prototype.on = function(ae, X) {
    var be = r.prototype.on.call(this, ae, X), Re = this._readableState;
    return ae === "data" ? (Re.readableListening = this.listenerCount("readable") > 0, Re.flowing !== !1 && this.resume()) : ae === "readable" && !Re.endEmitted && !Re.readableListening && (Re.readableListening = Re.needReadable = !0, Re.flowing = !1, Re.emittedReadable = !1, f("on readable", Re.length, Re.reading), Re.length ? T(this) : Re.reading || process$1.nextTick(U, this)), be;
  }, re.prototype.addListener = re.prototype.on, re.prototype.removeListener = function(ae, X) {
    var be = r.prototype.removeListener.call(this, ae, X);
    return ae === "readable" && process$1.nextTick(w, this), be;
  }, re.prototype.removeAllListeners = function(ae) {
    var X = r.prototype.removeAllListeners.apply(this, arguments);
    return (ae === "readable" || ae === void 0) && process$1.nextTick(w, this), X;
  };
  function w(ae) {
    var X = ae._readableState;
    X.readableListening = ae.listenerCount("readable") > 0, X.resumeScheduled && !X.paused ? X.flowing = !0 : ae.listenerCount("data") > 0 && ae.resume();
  }
  function U(ae) {
    f("readable nexttick read 0"), ae.read(0);
  }
  re.prototype.resume = function() {
    var ae = this._readableState;
    return ae.flowing || (f("resume"), ae.flowing = !ae.readableListening, ie(this, ae)), ae.paused = !1, this;
  };
  function ie(ae, X) {
    X.resumeScheduled || (X.resumeScheduled = !0, process$1.nextTick(le, ae, X));
  }
  function le(ae, X) {
    f("resume", X.reading), X.reading || ae.read(0), X.resumeScheduled = !1, ae.emit("resume"), ee(ae), X.flowing && !X.reading && ae.read(0);
  }
  re.prototype.pause = function() {
    return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ee(ae) {
    var X = ae._readableState;
    for (f("flow", X.flowing); X.flowing && ae.read() !== null; ) ;
  }
  re.prototype.wrap = function(ae) {
    var X = this, be = this._readableState, Re = !1;
    ae.on("end", function() {
      if (f("wrapped end"), be.decoder && !be.ended) {
        var De = be.decoder.end();
        De && De.length && X.push(De);
      }
      X.push(null);
    }), ae.on("data", function(De) {
      if (f("wrapped data"), be.decoder && (De = be.decoder.write(De)), !(be.objectMode && De == null) && !(!be.objectMode && (!De || !De.length))) {
        var je = X.push(De);
        je || (Re = !0, ae.pause());
      }
    });
    for (var Pe in ae)
      this[Pe] === void 0 && typeof ae[Pe] == "function" && (this[Pe] = /* @__PURE__ */ (function(je) {
        return function() {
          return ae[je].apply(ae, arguments);
        };
      })(Pe));
    for (var Fe = 0; Fe < G.length; Fe++)
      ae.on(G[Fe], this.emit.bind(this, G[Fe]));
    return this._read = function(De) {
      f("wrapped _read", De), Re && (Re = !1, ae.resume());
    }, this;
  }, typeof Symbol == "function" && (re.prototype[Symbol.asyncIterator] = function() {
    return O === void 0 && (O = requireAsync_iterator()), O(this);
  }), Object.defineProperty(re.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(re.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(re.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(X) {
      this._readableState && (this._readableState.flowing = X);
    }
  }), re._fromList = F, Object.defineProperty(re.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function F(ae, X) {
    if (X.length === 0) return null;
    var be;
    return X.objectMode ? be = X.buffer.shift() : !ae || ae >= X.length ? (X.decoder ? be = X.buffer.join("") : X.buffer.length === 1 ? be = X.buffer.first() : be = X.buffer.concat(X.length), X.buffer.clear()) : be = X.buffer.consume(ae, X.decoder), be;
  }
  function z(ae) {
    var X = ae._readableState;
    f("endReadable", X.endEmitted), X.endEmitted || (X.ended = !0, process$1.nextTick(se, X, ae));
  }
  function se(ae, X) {
    if (f("endReadableNT", ae.endEmitted, ae.length), !ae.endEmitted && ae.length === 0 && (ae.endEmitted = !0, X.readable = !1, X.emit("end"), ae.autoDestroy)) {
      var be = X._writableState;
      (!be || be.autoDestroy && be.finished) && X.destroy();
    }
  }
  typeof Symbol == "function" && (re.from = function(ae, X) {
    return j === void 0 && (j = requireFromBrowser()), j(re, ae, X);
  });
  function he(ae, X) {
    for (var be = 0, Re = ae.length; be < Re; be++)
      if (ae[be] === X) return be;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = c;
  var e = requireErrorsBrowser().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, r = e.ERR_MULTIPLE_CALLBACK, a = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, u = e.ERR_TRANSFORM_WITH_LENGTH_0, n = require_stream_duplex$1();
  requireInherits_browser()(c, n);
  function o(s, p) {
    var m = this._transformState;
    m.transforming = !1;
    var g = m.writecb;
    if (g === null)
      return this.emit("error", new r());
    m.writechunk = null, m.writecb = null, p != null && this.push(p), g(s);
    var y = this._readableState;
    y.reading = !1, (y.needReadable || y.length < y.highWaterMark) && this._read(y.highWaterMark);
  }
  function c(s) {
    if (!(this instanceof c)) return new c(s);
    n.call(this, s), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", f);
  }
  function f() {
    var s = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(p, m) {
      l(s, p, m);
    }) : l(this, null, null);
  }
  c.prototype.push = function(s, p) {
    return this._transformState.needTransform = !1, n.prototype.push.call(this, s, p);
  }, c.prototype._transform = function(s, p, m) {
    m(new t("_transform()"));
  }, c.prototype._write = function(s, p, m) {
    var g = this._transformState;
    if (g.writecb = m, g.writechunk = s, g.writeencoding = p, !g.transforming) {
      var y = this._readableState;
      (g.needTransform || y.needReadable || y.length < y.highWaterMark) && this._read(y.highWaterMark);
    }
  }, c.prototype._read = function(s) {
    var p = this._transformState;
    p.writechunk !== null && !p.transforming ? (p.transforming = !0, this._transform(p.writechunk, p.writeencoding, p.afterTransform)) : p.needTransform = !0;
  }, c.prototype._destroy = function(s, p) {
    n.prototype._destroy.call(this, s, function(m) {
      p(m);
    });
  };
  function l(s, p, m) {
    if (p) return s.emit("error", p);
    if (m != null && s.push(m), s._writableState.length) throw new u();
    if (s._transformState.transforming) throw new a();
    return s.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var e = require_stream_transform$1();
  requireInherits_browser()(t, e);
  function t(r) {
    if (!(this instanceof t)) return new t(r);
    e.call(this, r);
  }
  return t.prototype._transform = function(r, a, u) {
    u(null, r);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function t(m) {
    var g = !1;
    return function() {
      g || (g = !0, m.apply(void 0, arguments));
    };
  }
  var r = requireErrorsBrowser().codes, a = r.ERR_MISSING_ARGS, u = r.ERR_STREAM_DESTROYED;
  function n(m) {
    if (m) throw m;
  }
  function o(m) {
    return m.setHeader && typeof m.abort == "function";
  }
  function c(m, g, y, v) {
    v = t(v);
    var E = !1;
    m.on("close", function() {
      E = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(m, {
      readable: g,
      writable: y
    }, function(q) {
      if (q) return v(q);
      E = !0, v();
    });
    var b = !1;
    return function(q) {
      if (!E && !b) {
        if (b = !0, o(m)) return m.abort();
        if (typeof m.destroy == "function") return m.destroy();
        v(q || new u("pipe"));
      }
    };
  }
  function f(m) {
    m();
  }
  function l(m, g) {
    return m.pipe(g);
  }
  function s(m) {
    return !m.length || typeof m[m.length - 1] != "function" ? n : m.pop();
  }
  function p() {
    for (var m = arguments.length, g = new Array(m), y = 0; y < m; y++)
      g[y] = arguments[y];
    var v = s(g);
    if (Array.isArray(g[0]) && (g = g[0]), g.length < 2)
      throw new a("streams");
    var E, b = g.map(function(q, O) {
      var j = O < g.length - 1, D = O > 0;
      return c(q, j, D, function(G) {
        E || (E = G), G && b.forEach(f), !j && (b.forEach(f), v(E));
      });
    });
    return g.reduce(l);
  }
  return pipeline_1 = p, pipeline_1;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = r;
  var e = requireEvents().EventEmitter, t = requireInherits_browser();
  t(r, e), r.Readable = require_stream_readable$1(), r.Writable = require_stream_writable$1(), r.Duplex = require_stream_duplex$1(), r.Transform = require_stream_transform$1(), r.PassThrough = require_stream_passthrough$1(), r.finished = requireEndOfStream(), r.pipeline = requirePipeline(), r.Stream = r;
  function r() {
    e.call(this);
  }
  return r.prototype.pipe = function(a, u) {
    var n = this;
    function o(g) {
      a.writable && a.write(g) === !1 && n.pause && n.pause();
    }
    n.on("data", o);
    function c() {
      n.readable && n.resume && n.resume();
    }
    a.on("drain", c), !a._isStdio && (!u || u.end !== !1) && (n.on("end", l), n.on("close", s));
    var f = !1;
    function l() {
      f || (f = !0, a.end());
    }
    function s() {
      f || (f = !0, typeof a.destroy == "function" && a.destroy());
    }
    function p(g) {
      if (m(), e.listenerCount(this, "error") === 0)
        throw g;
    }
    n.on("error", p), a.on("error", p);
    function m() {
      n.removeListener("data", o), a.removeListener("drain", c), n.removeListener("end", l), n.removeListener("close", s), n.removeListener("error", p), a.removeListener("error", p), n.removeListener("end", m), n.removeListener("close", m), a.removeListener("close", m);
    }
    return n.on("end", m), n.on("close", m), a.on("close", m), a.emit("pipe", n), a;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireStreamBrowserify().Transform, r = requireString_decoder$1().StringDecoder, a = requireInherits_browser(), u = /* @__PURE__ */ requireToBuffer$2();
  function n(o) {
    t.call(this), this.hashMode = typeof o == "string", this.hashMode ? this[o] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return a(n, t), n.prototype.update = function(o, c, f) {
    var l = u(o, c), s = this._update(l);
    return this.hashMode ? this : (f && (s = this._toString(s, f)), s);
  }, n.prototype.setAutoPadding = function() {
  }, n.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, n.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, n.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, n.prototype._transform = function(o, c, f) {
    var l;
    try {
      this.hashMode ? this._update(o) : this.push(this._update(o));
    } catch (s) {
      l = s;
    } finally {
      f(l);
    }
  }, n.prototype._flush = function(o) {
    var c;
    try {
      this.push(this.__final());
    } catch (f) {
      c = f;
    }
    o(c);
  }, n.prototype._finalOrDigest = function(o) {
    var c = this.__final() || e.alloc(0);
    return o && (c = this._toString(c, o, !0)), c;
  }, n.prototype._toString = function(o, c, f) {
    if (this._decoder || (this._decoder = new r(c), this._encoding = c), this._encoding !== c)
      throw new Error("can’t switch encodings");
    var l = this._decoder.write(o);
    return f && (l += this._decoder.end()), l;
  }, cipherBase = n, cipherBase;
}
var browser$g, hasRequiredBrowser$g;
function requireBrowser$g() {
  if (hasRequiredBrowser$g) return browser$g;
  hasRequiredBrowser$g = 1;
  var e = requireInherits_browser(), t = requireMd5_js(), r = requireRipemd160(), a = requireSha_js(), u = requireCipherBase();
  function n(o) {
    u.call(this, "digest"), this._hash = o;
  }
  return e(n, u), n.prototype._update = function(o) {
    this._hash.update(o);
  }, n.prototype._final = function() {
    return this._hash.digest();
  }, browser$g = function(c) {
    return c = c.toLowerCase(), c === "md5" ? new t() : c === "rmd160" || c === "ripemd160" ? new r() : new n(a(c));
  }, browser$g;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var e = requireInherits_browser(), t = requireSafeBuffer$4().Buffer, r = requireCipherBase(), a = t.alloc(128), u = 64;
  function n(o, c) {
    r.call(this, "digest"), typeof c == "string" && (c = t.from(c)), this._alg = o, this._key = c, c.length > u ? c = o(c) : c.length < u && (c = t.concat([c, a], u));
    for (var f = this._ipad = t.allocUnsafe(u), l = this._opad = t.allocUnsafe(u), s = 0; s < u; s++)
      f[s] = c[s] ^ 54, l[s] = c[s] ^ 92;
    this._hash = [f];
  }
  return e(n, r), n.prototype._update = function(o) {
    this._hash.push(o);
  }, n.prototype._final = function() {
    var o = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, o]));
  }, legacy = n, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var e = requireMd5_js();
  return md5 = function(t) {
    return new e().update(t).digest();
  }, md5;
}
var browser$f, hasRequiredBrowser$f;
function requireBrowser$f() {
  if (hasRequiredBrowser$f) return browser$f;
  hasRequiredBrowser$f = 1;
  var e = requireInherits_browser(), t = requireLegacy(), r = requireCipherBase(), a = requireSafeBuffer$4().Buffer, u = requireMd5(), n = requireRipemd160(), o = requireSha_js(), c = a.alloc(128);
  function f(l, s) {
    r.call(this, "digest"), typeof s == "string" && (s = a.from(s));
    var p = l === "sha512" || l === "sha384" ? 128 : 64;
    if (this._alg = l, this._key = s, s.length > p) {
      var m = l === "rmd160" ? new n() : o(l);
      s = m.update(s).digest();
    } else s.length < p && (s = a.concat([s, c], p));
    for (var g = this._ipad = a.allocUnsafe(p), y = this._opad = a.allocUnsafe(p), v = 0; v < p; v++)
      g[v] = s[v] ^ 54, y[v] = s[v] ^ 92;
    this._hash = l === "rmd160" ? new n() : o(l), this._hash.update(g);
  }
  return e(f, r), f.prototype._update = function(l) {
    this._hash.update(l);
  }, f.prototype._final = function() {
    var l = this._hash.digest(), s = this._alg === "rmd160" ? new n() : o(this._alg);
    return s.update(this._opad).update(l).digest();
  }, browser$f = function(s, p) {
    return s = s.toLowerCase(), s === "rmd160" || s === "ripemd160" ? new f("rmd160", p) : s === "md5" ? new t(u, p) : new f(s, p);
  }, browser$f;
}
const sha224WithRSAEncryption = { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption = { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption = { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption = { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, sha256 = { sign: "ecdsa", hash: "sha256", id: "" }, sha224 = { sign: "ecdsa", hash: "sha224", id: "" }, sha384 = { sign: "ecdsa", hash: "sha384", id: "" }, sha512 = { sign: "ecdsa", hash: "sha512", id: "" }, DSA = { sign: "dsa", hash: "sha1", id: "" }, ripemd160WithRSA = { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption = { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" },
  sha256WithRSAEncryption,
  "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" },
  sha384WithRSAEncryption,
  "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" },
  sha512WithRSAEncryption,
  "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" },
  "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" },
  "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" },
  "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" },
  DSA,
  "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" },
  "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" },
  "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" },
  "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" },
  "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" },
  "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" },
  "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" },
  "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" },
  "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" },
  ripemd160WithRSA,
  "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" },
  md5WithRSAEncryption,
  "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$e = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var e = isFinite, t = Math.pow(2, 30) - 1;
  return precondition = function(r, a) {
    if (typeof r != "number")
      throw new TypeError("Iterations not a number");
    if (r < 0 || !e(r))
      throw new TypeError("Bad iterations");
    if (typeof a != "number")
      throw new TypeError("Key length not a number");
    if (a < 0 || a > t || a !== a)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var e;
  if (globalThis.process && globalThis.process.browser)
    e = "utf-8";
  else if (globalThis.process && globalThis.process.version) {
    var t = parseInt(process$1.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return defaultEncoding_1 = e, defaultEncoding_1;
}
var toBuffer_1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer_1;
  hasRequiredToBuffer = 1;
  var e = requireSafeBuffer$4().Buffer, t = /* @__PURE__ */ requireToBuffer$2(), r = typeof Uint8Array < "u", a = r && typeof ArrayBuffer < "u", u = a && ArrayBuffer.isView;
  return toBuffer_1 = function(n, o, c) {
    if (typeof n == "string" || e.isBuffer(n) || r && n instanceof Uint8Array || u && u(n))
      return t(n, o);
    throw new TypeError(c + " must be a string, a Buffer, a Uint8Array, or a DataView");
  }, toBuffer_1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var e = requireMd5(), t = requireRipemd160(), r = requireSha_js(), a = requireSafeBuffer$4().Buffer, u = requirePrecondition(), n = requireDefaultEncoding(), o = requireToBuffer(), c = a.alloc(128), f = {
    __proto__: null,
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    "sha512-256": 32,
    ripemd160: 20,
    rmd160: 20
  }, l = {
    __proto__: null,
    "sha-1": "sha1",
    "sha-224": "sha224",
    "sha-256": "sha256",
    "sha-384": "sha384",
    "sha-512": "sha512",
    "ripemd-160": "ripemd160"
  };
  function s(y) {
    return new t().update(y).digest();
  }
  function p(y) {
    function v(E) {
      return r(y).update(E).digest();
    }
    return y === "rmd160" || y === "ripemd160" ? s : y === "md5" ? e : v;
  }
  function m(y, v, E) {
    var b = p(y), q = y === "sha512" || y === "sha384" ? 128 : 64;
    v.length > q ? v = b(v) : v.length < q && (v = a.concat([v, c], q));
    for (var O = a.allocUnsafe(q + f[y]), j = a.allocUnsafe(q + f[y]), D = 0; D < q; D++)
      O[D] = v[D] ^ 54, j[D] = v[D] ^ 92;
    var G = a.allocUnsafe(q + E + 4);
    O.copy(G, 0, 0, q), this.ipad1 = G, this.ipad2 = O, this.opad = j, this.alg = y, this.blocksize = q, this.hash = b, this.size = f[y];
  }
  m.prototype.run = function(y, v) {
    y.copy(v, this.blocksize);
    var E = this.hash(v);
    return E.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function g(y, v, E, b, q) {
    u(E, b), y = o(y, n, "Password"), v = o(v, n, "Salt");
    var O = (q || "sha1").toLowerCase(), j = l[O] || O, D = f[j];
    if (typeof D != "number" || !D)
      throw new TypeError("Digest algorithm not supported: " + q);
    var G = new m(j, y, v.length), V = a.allocUnsafe(b), Q = a.allocUnsafe(v.length + 4);
    v.copy(Q, 0, 0, v.length);
    for (var re = 0, ve = D, te = Math.ceil(b / ve), R = 1; R <= te; R++) {
      Q.writeUInt32BE(R, v.length);
      for (var M = G.run(Q, G.ipad1), h = M, S = 1; S < E; S++) {
        h = G.run(h, G.ipad2);
        for (var B = 0; B < ve; B++)
          M[B] ^= h[B];
      }
      M.copy(V, re), re += ve;
    }
    return V;
  }
  return syncBrowser = g, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var e = requireSafeBuffer$4().Buffer, t = requirePrecondition(), r = requireDefaultEncoding(), a = requireSyncBrowser(), u = requireToBuffer(), n, o = globalThis.crypto && globalThis.crypto.subtle, c = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, f = [], l;
  function s() {
    return l || (globalThis.process && globalThis.process.nextTick ? l = globalThis.process.nextTick : globalThis.queueMicrotask ? l = globalThis.queueMicrotask : globalThis.setImmediate ? l = globalThis.setImmediate : l = globalThis.setTimeout, l);
  }
  function p(y, v, E, b, q) {
    return o.importKey("raw", y, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function(O) {
      return o.deriveBits({
        name: "PBKDF2",
        salt: v,
        iterations: E,
        hash: {
          name: q
        }
      }, O, b << 3);
    }).then(function(O) {
      return e.from(O);
    });
  }
  function m(y) {
    if (globalThis.process && !globalThis.process.browser || !o || !o.importKey || !o.deriveBits)
      return Promise.resolve(!1);
    if (f[y] !== void 0)
      return f[y];
    n = n || e.alloc(8);
    var v = p(n, n, 10, 128, y).then(
      function() {
        return !0;
      },
      function() {
        return !1;
      }
    );
    return f[y] = v, v;
  }
  function g(y, v) {
    y.then(function(E) {
      s()(function() {
        v(null, E);
      });
    }, function(E) {
      s()(function() {
        v(E);
      });
    });
  }
  return async = function(y, v, E, b, q, O) {
    if (typeof q == "function" && (O = q, q = void 0), t(E, b), y = u(y, r, "Password"), v = u(v, r, "Salt"), typeof O != "function")
      throw new Error("No callback provided to pbkdf2");
    q = q || "sha1";
    var j = c[q.toLowerCase()];
    if (!j || typeof globalThis.Promise != "function") {
      s()(function() {
        var D;
        try {
          D = a(y, v, E, b, q);
        } catch (G) {
          O(G);
          return;
        }
        O(null, D);
      });
      return;
    }
    g(m(j).then(function(D) {
      return D ? p(y, v, E, b, j) : a(y, v, E, b, q);
    }), O);
  }, async;
}
var hasRequiredBrowser$e;
function requireBrowser$e() {
  return hasRequiredBrowser$e || (hasRequiredBrowser$e = 1, browser$e.pbkdf2 = requireAsync(), browser$e.pbkdf2Sync = requireSyncBrowser()), browser$e;
}
var browser$d = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1, utils$4.readUInt32BE = function(u, n) {
    var o = u[0 + n] << 24 | u[1 + n] << 16 | u[2 + n] << 8 | u[3 + n];
    return o >>> 0;
  }, utils$4.writeUInt32BE = function(u, n, o) {
    u[0 + o] = n >>> 24, u[1 + o] = n >>> 16 & 255, u[2 + o] = n >>> 8 & 255, u[3 + o] = n & 255;
  }, utils$4.ip = function(u, n, o, c) {
    for (var f = 0, l = 0, s = 6; s >= 0; s -= 2) {
      for (var p = 0; p <= 24; p += 8)
        f <<= 1, f |= n >>> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        f <<= 1, f |= u >>> p + s & 1;
    }
    for (var s = 6; s >= 0; s -= 2) {
      for (var p = 1; p <= 25; p += 8)
        l <<= 1, l |= n >>> p + s & 1;
      for (var p = 1; p <= 25; p += 8)
        l <<= 1, l |= u >>> p + s & 1;
    }
    o[c + 0] = f >>> 0, o[c + 1] = l >>> 0;
  }, utils$4.rip = function(u, n, o, c) {
    for (var f = 0, l = 0, s = 0; s < 4; s++)
      for (var p = 24; p >= 0; p -= 8)
        f <<= 1, f |= n >>> p + s & 1, f <<= 1, f |= u >>> p + s & 1;
    for (var s = 4; s < 8; s++)
      for (var p = 24; p >= 0; p -= 8)
        l <<= 1, l |= n >>> p + s & 1, l <<= 1, l |= u >>> p + s & 1;
    o[c + 0] = f >>> 0, o[c + 1] = l >>> 0;
  }, utils$4.pc1 = function(u, n, o, c) {
    for (var f = 0, l = 0, s = 7; s >= 5; s--) {
      for (var p = 0; p <= 24; p += 8)
        f <<= 1, f |= n >> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        f <<= 1, f |= u >> p + s & 1;
    }
    for (var p = 0; p <= 24; p += 8)
      f <<= 1, f |= n >> p + s & 1;
    for (var s = 1; s <= 3; s++) {
      for (var p = 0; p <= 24; p += 8)
        l <<= 1, l |= n >> p + s & 1;
      for (var p = 0; p <= 24; p += 8)
        l <<= 1, l |= u >> p + s & 1;
    }
    for (var p = 0; p <= 24; p += 8)
      l <<= 1, l |= u >> p + s & 1;
    o[c + 0] = f >>> 0, o[c + 1] = l >>> 0;
  }, utils$4.r28shl = function(u, n) {
    return u << n & 268435455 | u >>> 28 - n;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(u, n, o, c) {
    for (var f = 0, l = 0, s = e.length >>> 1, p = 0; p < s; p++)
      f <<= 1, f |= u >>> e[p] & 1;
    for (var p = s; p < e.length; p++)
      l <<= 1, l |= n >>> e[p] & 1;
    o[c + 0] = f >>> 0, o[c + 1] = l >>> 0;
  }, utils$4.expand = function(u, n, o) {
    var c = 0, f = 0;
    c = (u & 1) << 5 | u >>> 27;
    for (var l = 23; l >= 15; l -= 4)
      c <<= 6, c |= u >>> l & 63;
    for (var l = 11; l >= 3; l -= 4)
      f |= u >>> l & 63, f <<= 6;
    f |= (u & 31) << 1 | u >>> 31, n[o + 0] = c >>> 0, n[o + 1] = f >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(u, n) {
    for (var o = 0, c = 0; c < 4; c++) {
      var f = u >>> 18 - c * 6 & 63, l = t[c * 64 + f];
      o <<= 4, o |= l;
    }
    for (var c = 0; c < 4; c++) {
      var f = n >>> 18 - c * 6 & 63, l = t[256 + c * 64 + f];
      o <<= 4, o |= l;
    }
    return o >>> 0;
  };
  var r = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(u) {
    for (var n = 0, o = 0; o < r.length; o++)
      n <<= 1, n |= u >>> r[o] & 1;
    return n >>> 0;
  }, utils$4.padSplit = function(u, n, o) {
    for (var c = u.toString(2); c.length < n; )
      c = "0" + c;
    for (var f = [], l = 0; l < n; l += o)
      f.push(c.slice(l, l + o));
    return f.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = e;
  function e(t, r) {
    if (!t)
      throw new Error(r || "Assertion failed");
  }
  return e.equal = function(r, a, u) {
    if (r != a)
      throw new Error(u || "Assertion failed: " + r + " != " + a);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var e = requireMinimalisticAssert();
  function t(r) {
    this.options = r, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = r.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(a) {
    return a.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(a) : this._updateEncrypt(a);
  }, t.prototype._buffer = function(a, u) {
    for (var n = Math.min(this.buffer.length - this.bufferOff, a.length - u), o = 0; o < n; o++)
      this.buffer[this.bufferOff + o] = a[u + o];
    return this.bufferOff += n, n;
  }, t.prototype._flushBuffer = function(a, u) {
    return this._update(this.buffer, 0, a, u), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(a) {
    var u = 0, n = 0, o = (this.bufferOff + a.length) / this.blockSize | 0, c = new Array(o * this.blockSize);
    this.bufferOff !== 0 && (u += this._buffer(a, u), this.bufferOff === this.buffer.length && (n += this._flushBuffer(c, n)));
    for (var f = a.length - (a.length - u) % this.blockSize; u < f; u += this.blockSize)
      this._update(a, u, c, n), n += this.blockSize;
    for (; u < a.length; u++, this.bufferOff++)
      this.buffer[this.bufferOff] = a[u];
    return c;
  }, t.prototype._updateDecrypt = function(a) {
    for (var u = 0, n = 0, o = Math.ceil((this.bufferOff + a.length) / this.blockSize) - 1, c = new Array(o * this.blockSize); o > 0; o--)
      u += this._buffer(a, u), n += this._flushBuffer(c, n);
    return u += this._buffer(a, u), c;
  }, t.prototype.final = function(a) {
    var u;
    a && (u = this.update(a));
    var n;
    return this.type === "encrypt" ? n = this._finalEncrypt() : n = this._finalDecrypt(), u ? u.concat(n) : n;
  }, t.prototype._pad = function(a, u) {
    if (u === 0)
      return !1;
    for (; u < a.length; )
      a[u++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var a = new Array(this.blockSize);
    return this._update(this.buffer, 0, a, 0), a;
  }, t.prototype._unpad = function(a) {
    return a;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var a = new Array(this.blockSize);
    return this._flushBuffer(a, 0), this._unpad(a);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), r = requireUtils$4(), a = requireCipher();
  function u() {
    this.tmp = new Array(2), this.keys = null;
  }
  function n(c) {
    a.call(this, c);
    var f = new u();
    this._desState = f, this.deriveKeys(f, c.key);
  }
  t(n, a), des = n, n.create = function(f) {
    return new n(f);
  };
  var o = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return n.prototype.deriveKeys = function(f, l) {
    f.keys = new Array(32), e.equal(l.length, this.blockSize, "Invalid key length");
    var s = r.readUInt32BE(l, 0), p = r.readUInt32BE(l, 4);
    r.pc1(s, p, f.tmp, 0), s = f.tmp[0], p = f.tmp[1];
    for (var m = 0; m < f.keys.length; m += 2) {
      var g = o[m >>> 1];
      s = r.r28shl(s, g), p = r.r28shl(p, g), r.pc2(s, p, f.keys, m);
    }
  }, n.prototype._update = function(f, l, s, p) {
    var m = this._desState, g = r.readUInt32BE(f, l), y = r.readUInt32BE(f, l + 4);
    r.ip(g, y, m.tmp, 0), g = m.tmp[0], y = m.tmp[1], this.type === "encrypt" ? this._encrypt(m, g, y, m.tmp, 0) : this._decrypt(m, g, y, m.tmp, 0), g = m.tmp[0], y = m.tmp[1], r.writeUInt32BE(s, g, p), r.writeUInt32BE(s, y, p + 4);
  }, n.prototype._pad = function(f, l) {
    if (this.padding === !1)
      return !1;
    for (var s = f.length - l, p = l; p < f.length; p++)
      f[p] = s;
    return !0;
  }, n.prototype._unpad = function(f) {
    if (this.padding === !1)
      return f;
    for (var l = f[f.length - 1], s = f.length - l; s < f.length; s++)
      e.equal(f[s], l);
    return f.slice(0, f.length - l);
  }, n.prototype._encrypt = function(f, l, s, p, m) {
    for (var g = l, y = s, v = 0; v < f.keys.length; v += 2) {
      var E = f.keys[v], b = f.keys[v + 1];
      r.expand(y, f.tmp, 0), E ^= f.tmp[0], b ^= f.tmp[1];
      var q = r.substitute(E, b), O = r.permute(q), j = y;
      y = (g ^ O) >>> 0, g = j;
    }
    r.rip(y, g, p, m);
  }, n.prototype._decrypt = function(f, l, s, p, m) {
    for (var g = s, y = l, v = f.keys.length - 2; v >= 0; v -= 2) {
      var E = f.keys[v], b = f.keys[v + 1];
      r.expand(g, f.tmp, 0), E ^= f.tmp[0], b ^= f.tmp[1];
      var q = r.substitute(E, b), O = r.permute(q), j = g;
      g = (y ^ O) >>> 0, y = j;
    }
    r.rip(g, y, p, m);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), r = {};
  function a(n) {
    e.equal(n.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var o = 0; o < this.iv.length; o++)
      this.iv[o] = n[o];
  }
  function u(n) {
    function o(s) {
      n.call(this, s), this._cbcInit();
    }
    t(o, n);
    for (var c = Object.keys(r), f = 0; f < c.length; f++) {
      var l = c[f];
      o.prototype[l] = r[l];
    }
    return o.create = function(p) {
      return new o(p);
    }, o;
  }
  return cbc$1.instantiate = u, r._cbcInit = function() {
    var o = new a(this.options.iv);
    this._cbcState = o;
  }, r._update = function(o, c, f, l) {
    var s = this._cbcState, p = this.constructor.super_.prototype, m = s.iv;
    if (this.type === "encrypt") {
      for (var g = 0; g < this.blockSize; g++)
        m[g] ^= o[c + g];
      p._update.call(this, m, 0, f, l);
      for (var g = 0; g < this.blockSize; g++)
        m[g] = f[l + g];
    } else {
      p._update.call(this, o, c, f, l);
      for (var g = 0; g < this.blockSize; g++)
        f[l + g] ^= m[g];
      for (var g = 0; g < this.blockSize; g++)
        m[g] = o[c + g];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), r = requireCipher(), a = requireDes$1();
  function u(o, c) {
    e.equal(c.length, 24, "Invalid key length");
    var f = c.slice(0, 8), l = c.slice(8, 16), s = c.slice(16, 24);
    o === "encrypt" ? this.ciphers = [
      a.create({ type: "encrypt", key: f }),
      a.create({ type: "decrypt", key: l }),
      a.create({ type: "encrypt", key: s })
    ] : this.ciphers = [
      a.create({ type: "decrypt", key: s }),
      a.create({ type: "encrypt", key: l }),
      a.create({ type: "decrypt", key: f })
    ];
  }
  function n(o) {
    r.call(this, o);
    var c = new u(this.type, this.options.key);
    this._edeState = c;
  }
  return t(n, r), ede = n, n.create = function(c) {
    return new n(c);
  }, n.prototype._update = function(c, f, l, s) {
    var p = this._edeState;
    p.ciphers[0]._update(c, f, l, s), p.ciphers[1]._update(l, s, l, s), p.ciphers[2]._update(l, s, l, s);
  }, n.prototype._pad = a.prototype._pad, n.prototype._unpad = a.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$4(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var e = requireCipherBase(), t = requireDes(), r = requireInherits_browser(), a = requireSafeBuffer$4().Buffer, u = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  u.des = u["des-cbc"], u.des3 = u["des-ede3-cbc"], browserifyDes = n, r(n, e);
  function n(o) {
    e.call(this);
    var c = o.mode.toLowerCase(), f = u[c], l;
    o.decrypt ? l = "decrypt" : l = "encrypt";
    var s = o.key;
    a.isBuffer(s) || (s = a.from(s)), (c === "des-ede" || c === "des-ede-cbc") && (s = a.concat([s, s.slice(0, 8)]));
    var p = o.iv;
    a.isBuffer(p) || (p = a.from(p)), this._des = f.create({
      key: s,
      iv: p,
      type: l
    });
  }
  return n.prototype._update = function(o) {
    return a.from(this._des.update(o));
  }, n.prototype._final = function() {
    return a.from(this._des.final());
  }, browserifyDes;
}
var browser$c = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, ecb.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var a = r === t ? 0 : 4 - r % 4;
  return [r, a];
}
function byteLength(e) {
  var t = getLens(e), r = t[0], a = t[1];
  return (r + a) * 3 / 4 - a;
}
function _byteLength(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function toByteArray(e) {
  var t, r = getLens(e), a = r[0], u = r[1], n = new Arr(_byteLength(e, a, u)), o = 0, c = u > 0 ? a - 4 : a, f;
  for (f = 0; f < c; f += 4)
    t = revLookup[e.charCodeAt(f)] << 18 | revLookup[e.charCodeAt(f + 1)] << 12 | revLookup[e.charCodeAt(f + 2)] << 6 | revLookup[e.charCodeAt(f + 3)], n[o++] = t >> 16 & 255, n[o++] = t >> 8 & 255, n[o++] = t & 255;
  return u === 2 && (t = revLookup[e.charCodeAt(f)] << 2 | revLookup[e.charCodeAt(f + 1)] >> 4, n[o++] = t & 255), u === 1 && (t = revLookup[e.charCodeAt(f)] << 10 | revLookup[e.charCodeAt(f + 1)] << 4 | revLookup[e.charCodeAt(f + 2)] >> 2, n[o++] = t >> 8 & 255, n[o++] = t & 255), n;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, r) {
  for (var a, u = [], n = t; n < r; n += 3)
    a = (e[n] << 16 & 16711680) + (e[n + 1] << 8 & 65280) + (e[n + 2] & 255), u.push(tripletToBase64(a));
  return u.join("");
}
function fromByteArray(e) {
  for (var t, r = e.length, a = r % 3, u = [], n = 16383, o = 0, c = r - a; o < c; o += n)
    u.push(encodeChunk(e, o, o + n > c ? c : o + n));
  return a === 1 ? (t = e[r - 1], u.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : a === 2 && (t = (e[r - 2] << 8) + e[r - 1], u.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), u.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(e, t, r, a, u) {
  var n, o, c = u * 8 - a - 1, f = (1 << c) - 1, l = f >> 1, s = -7, p = r ? u - 1 : 0, m = r ? -1 : 1, g = e[t + p];
  for (p += m, n = g & (1 << -s) - 1, g >>= -s, s += c; s > 0; n = n * 256 + e[t + p], p += m, s -= 8)
    ;
  for (o = n & (1 << -s) - 1, n >>= -s, s += a; s > 0; o = o * 256 + e[t + p], p += m, s -= 8)
    ;
  if (n === 0)
    n = 1 - l;
  else {
    if (n === f)
      return o ? NaN : (g ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, a), n = n - l;
  }
  return (g ? -1 : 1) * o * Math.pow(2, n - a);
};
ieee754.write = function(e, t, r, a, u, n) {
  var o, c, f, l = n * 8 - u - 1, s = (1 << l) - 1, p = s >> 1, m = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = a ? 0 : n - 1, y = a ? 1 : -1, v = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, o = s) : (o = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -o)) < 1 && (o--, f *= 2), o + p >= 1 ? t += m / f : t += m * Math.pow(2, 1 - p), t * f >= 2 && (o++, f /= 2), o + p >= s ? (c = 0, o = s) : o + p >= 1 ? (c = (t * f - 1) * Math.pow(2, u), o = o + p) : (c = t * Math.pow(2, p - 1) * Math.pow(2, u), o = 0)); u >= 8; e[r + g] = c & 255, g += y, c /= 256, u -= 8)
    ;
  for (o = o << u | c, l += u; l > 0; e[r + g] = o & 255, g += y, o /= 256, l -= 8)
    ;
  e[r + g - y] |= v * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = base64Js, r = ieee754, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = s, e.SlowBuffer = D, e.INSPECT_MAX_BYTES = 50;
  const u = 2147483647;
  e.kMaxLength = u;
  const { Uint8Array: n, ArrayBuffer: o, SharedArrayBuffer: c } = globalThis;
  s.TYPED_ARRAY_SUPPORT = f(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function f() {
    try {
      const oe = new n(1), L = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(L, n.prototype), Object.setPrototypeOf(oe, L), oe.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(s.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(s.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (s.isBuffer(this))
        return this.byteOffset;
    }
  });
  function l(oe) {
    if (oe > u)
      throw new RangeError('The value "' + oe + '" is invalid for option "size"');
    const L = new n(oe);
    return Object.setPrototypeOf(L, s.prototype), L;
  }
  function s(oe, L, H) {
    if (typeof oe == "number") {
      if (typeof L == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(oe);
    }
    return p(oe, L, H);
  }
  s.poolSize = 8192;
  function p(oe, L, H) {
    if (typeof oe == "string")
      return v(oe, L);
    if (o.isView(oe))
      return b(oe);
    if (oe == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe
      );
    if (Ae(oe, o) || oe && Ae(oe.buffer, o) || typeof c < "u" && (Ae(oe, c) || oe && Ae(oe.buffer, c)))
      return q(oe, L, H);
    if (typeof oe == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const ue = oe.valueOf && oe.valueOf();
    if (ue != null && ue !== oe)
      return s.from(ue, L, H);
    const xe = O(oe);
    if (xe) return xe;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof oe[Symbol.toPrimitive] == "function")
      return s.from(oe[Symbol.toPrimitive]("string"), L, H);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof oe
    );
  }
  s.from = function(oe, L, H) {
    return p(oe, L, H);
  }, Object.setPrototypeOf(s.prototype, n.prototype), Object.setPrototypeOf(s, n);
  function m(oe) {
    if (typeof oe != "number")
      throw new TypeError('"size" argument must be of type number');
    if (oe < 0)
      throw new RangeError('The value "' + oe + '" is invalid for option "size"');
  }
  function g(oe, L, H) {
    return m(oe), oe <= 0 ? l(oe) : L !== void 0 ? typeof H == "string" ? l(oe).fill(L, H) : l(oe).fill(L) : l(oe);
  }
  s.alloc = function(oe, L, H) {
    return g(oe, L, H);
  };
  function y(oe) {
    return m(oe), l(oe < 0 ? 0 : j(oe) | 0);
  }
  s.allocUnsafe = function(oe) {
    return y(oe);
  }, s.allocUnsafeSlow = function(oe) {
    return y(oe);
  };
  function v(oe, L) {
    if ((typeof L != "string" || L === "") && (L = "utf8"), !s.isEncoding(L))
      throw new TypeError("Unknown encoding: " + L);
    const H = G(oe, L) | 0;
    let ue = l(H);
    const xe = ue.write(oe, L);
    return xe !== H && (ue = ue.slice(0, xe)), ue;
  }
  function E(oe) {
    const L = oe.length < 0 ? 0 : j(oe.length) | 0, H = l(L);
    for (let ue = 0; ue < L; ue += 1)
      H[ue] = oe[ue] & 255;
    return H;
  }
  function b(oe) {
    if (Ae(oe, n)) {
      const L = new n(oe);
      return q(L.buffer, L.byteOffset, L.byteLength);
    }
    return E(oe);
  }
  function q(oe, L, H) {
    if (L < 0 || oe.byteLength < L)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (oe.byteLength < L + (H || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let ue;
    return L === void 0 && H === void 0 ? ue = new n(oe) : H === void 0 ? ue = new n(oe, L) : ue = new n(oe, L, H), Object.setPrototypeOf(ue, s.prototype), ue;
  }
  function O(oe) {
    if (s.isBuffer(oe)) {
      const L = j(oe.length) | 0, H = l(L);
      return H.length === 0 || oe.copy(H, 0, 0, L), H;
    }
    if (oe.length !== void 0)
      return typeof oe.length != "number" || ze(oe.length) ? l(0) : E(oe);
    if (oe.type === "Buffer" && Array.isArray(oe.data))
      return E(oe.data);
  }
  function j(oe) {
    if (oe >= u)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
    return oe | 0;
  }
  function D(oe) {
    return +oe != oe && (oe = 0), s.alloc(+oe);
  }
  s.isBuffer = function(L) {
    return L != null && L._isBuffer === !0 && L !== s.prototype;
  }, s.compare = function(L, H) {
    if (Ae(L, n) && (L = s.from(L, L.offset, L.byteLength)), Ae(H, n) && (H = s.from(H, H.offset, H.byteLength)), !s.isBuffer(L) || !s.isBuffer(H))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (L === H) return 0;
    let ue = L.length, xe = H.length;
    for (let pe = 0, ce = Math.min(ue, xe); pe < ce; ++pe)
      if (L[pe] !== H[pe]) {
        ue = L[pe], xe = H[pe];
        break;
      }
    return ue < xe ? -1 : xe < ue ? 1 : 0;
  }, s.isEncoding = function(L) {
    switch (String(L).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, s.concat = function(L, H) {
    if (!Array.isArray(L))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (L.length === 0)
      return s.alloc(0);
    let ue;
    if (H === void 0)
      for (H = 0, ue = 0; ue < L.length; ++ue)
        H += L[ue].length;
    const xe = s.allocUnsafe(H);
    let pe = 0;
    for (ue = 0; ue < L.length; ++ue) {
      let ce = L[ue];
      if (Ae(ce, n))
        pe + ce.length > xe.length ? (s.isBuffer(ce) || (ce = s.from(ce)), ce.copy(xe, pe)) : n.prototype.set.call(
          xe,
          ce,
          pe
        );
      else if (s.isBuffer(ce))
        ce.copy(xe, pe);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      pe += ce.length;
    }
    return xe;
  };
  function G(oe, L) {
    if (s.isBuffer(oe))
      return oe.length;
    if (o.isView(oe) || Ae(oe, o))
      return oe.byteLength;
    if (typeof oe != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof oe
      );
    const H = oe.length, ue = arguments.length > 2 && arguments[2] === !0;
    if (!ue && H === 0) return 0;
    let xe = !1;
    for (; ; )
      switch (L) {
        case "ascii":
        case "latin1":
        case "binary":
          return H;
        case "utf8":
        case "utf-8":
          return rt(oe).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H * 2;
        case "hex":
          return H >>> 1;
        case "base64":
          return Je(oe).length;
        default:
          if (xe)
            return ue ? -1 : rt(oe).length;
          L = ("" + L).toLowerCase(), xe = !0;
      }
  }
  s.byteLength = G;
  function V(oe, L, H) {
    let ue = !1;
    if ((L === void 0 || L < 0) && (L = 0), L > this.length || ((H === void 0 || H > this.length) && (H = this.length), H <= 0) || (H >>>= 0, L >>>= 0, H <= L))
      return "";
    for (oe || (oe = "utf8"); ; )
      switch (oe) {
        case "hex":
          return w(this, L, H);
        case "utf8":
        case "utf-8":
          return T(this, L, H);
        case "ascii":
          return C(this, L, H);
        case "latin1":
        case "binary":
          return $(this, L, H);
        case "base64":
          return B(this, L, H);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U(this, L, H);
        default:
          if (ue) throw new TypeError("Unknown encoding: " + oe);
          oe = (oe + "").toLowerCase(), ue = !0;
      }
  }
  s.prototype._isBuffer = !0;
  function Q(oe, L, H) {
    const ue = oe[L];
    oe[L] = oe[H], oe[H] = ue;
  }
  s.prototype.swap16 = function() {
    const L = this.length;
    if (L % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let H = 0; H < L; H += 2)
      Q(this, H, H + 1);
    return this;
  }, s.prototype.swap32 = function() {
    const L = this.length;
    if (L % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let H = 0; H < L; H += 4)
      Q(this, H, H + 3), Q(this, H + 1, H + 2);
    return this;
  }, s.prototype.swap64 = function() {
    const L = this.length;
    if (L % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let H = 0; H < L; H += 8)
      Q(this, H, H + 7), Q(this, H + 1, H + 6), Q(this, H + 2, H + 5), Q(this, H + 3, H + 4);
    return this;
  }, s.prototype.toString = function() {
    const L = this.length;
    return L === 0 ? "" : arguments.length === 0 ? T(this, 0, L) : V.apply(this, arguments);
  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(L) {
    if (!s.isBuffer(L)) throw new TypeError("Argument must be a Buffer");
    return this === L ? !0 : s.compare(this, L) === 0;
  }, s.prototype.inspect = function() {
    let L = "";
    const H = e.INSPECT_MAX_BYTES;
    return L = this.toString("hex", 0, H).replace(/(.{2})/g, "$1 ").trim(), this.length > H && (L += " ... "), "<Buffer " + L + ">";
  }, a && (s.prototype[a] = s.prototype.inspect), s.prototype.compare = function(L, H, ue, xe, pe) {
    if (Ae(L, n) && (L = s.from(L, L.offset, L.byteLength)), !s.isBuffer(L))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof L
      );
    if (H === void 0 && (H = 0), ue === void 0 && (ue = L ? L.length : 0), xe === void 0 && (xe = 0), pe === void 0 && (pe = this.length), H < 0 || ue > L.length || xe < 0 || pe > this.length)
      throw new RangeError("out of range index");
    if (xe >= pe && H >= ue)
      return 0;
    if (xe >= pe)
      return -1;
    if (H >= ue)
      return 1;
    if (H >>>= 0, ue >>>= 0, xe >>>= 0, pe >>>= 0, this === L) return 0;
    let ce = pe - xe, Y = ue - H;
    const Te = Math.min(ce, Y), Ne = this.slice(xe, pe), K = L.slice(H, ue);
    for (let Se = 0; Se < Te; ++Se)
      if (Ne[Se] !== K[Se]) {
        ce = Ne[Se], Y = K[Se];
        break;
      }
    return ce < Y ? -1 : Y < ce ? 1 : 0;
  };
  function re(oe, L, H, ue, xe) {
    if (oe.length === 0) return -1;
    if (typeof H == "string" ? (ue = H, H = 0) : H > 2147483647 ? H = 2147483647 : H < -2147483648 && (H = -2147483648), H = +H, ze(H) && (H = xe ? 0 : oe.length - 1), H < 0 && (H = oe.length + H), H >= oe.length) {
      if (xe) return -1;
      H = oe.length - 1;
    } else if (H < 0)
      if (xe) H = 0;
      else return -1;
    if (typeof L == "string" && (L = s.from(L, ue)), s.isBuffer(L))
      return L.length === 0 ? -1 : ve(oe, L, H, ue, xe);
    if (typeof L == "number")
      return L = L & 255, typeof n.prototype.indexOf == "function" ? xe ? n.prototype.indexOf.call(oe, L, H) : n.prototype.lastIndexOf.call(oe, L, H) : ve(oe, [L], H, ue, xe);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ve(oe, L, H, ue, xe) {
    let pe = 1, ce = oe.length, Y = L.length;
    if (ue !== void 0 && (ue = String(ue).toLowerCase(), ue === "ucs2" || ue === "ucs-2" || ue === "utf16le" || ue === "utf-16le")) {
      if (oe.length < 2 || L.length < 2)
        return -1;
      pe = 2, ce /= 2, Y /= 2, H /= 2;
    }
    function Te(K, Se) {
      return pe === 1 ? K[Se] : K.readUInt16BE(Se * pe);
    }
    let Ne;
    if (xe) {
      let K = -1;
      for (Ne = H; Ne < ce; Ne++)
        if (Te(oe, Ne) === Te(L, K === -1 ? 0 : Ne - K)) {
          if (K === -1 && (K = Ne), Ne - K + 1 === Y) return K * pe;
        } else
          K !== -1 && (Ne -= Ne - K), K = -1;
    } else
      for (H + Y > ce && (H = ce - Y), Ne = H; Ne >= 0; Ne--) {
        let K = !0;
        for (let Se = 0; Se < Y; Se++)
          if (Te(oe, Ne + Se) !== Te(L, Se)) {
            K = !1;
            break;
          }
        if (K) return Ne;
      }
    return -1;
  }
  s.prototype.includes = function(L, H, ue) {
    return this.indexOf(L, H, ue) !== -1;
  }, s.prototype.indexOf = function(L, H, ue) {
    return re(this, L, H, ue, !0);
  }, s.prototype.lastIndexOf = function(L, H, ue) {
    return re(this, L, H, ue, !1);
  };
  function te(oe, L, H, ue) {
    H = Number(H) || 0;
    const xe = oe.length - H;
    ue ? (ue = Number(ue), ue > xe && (ue = xe)) : ue = xe;
    const pe = L.length;
    ue > pe / 2 && (ue = pe / 2);
    let ce;
    for (ce = 0; ce < ue; ++ce) {
      const Y = parseInt(L.substr(ce * 2, 2), 16);
      if (ze(Y)) return ce;
      oe[H + ce] = Y;
    }
    return ce;
  }
  function R(oe, L, H, ue) {
    return we(rt(L, oe.length - H), oe, H, ue);
  }
  function M(oe, L, H, ue) {
    return we(He(L), oe, H, ue);
  }
  function h(oe, L, H, ue) {
    return we(Je(L), oe, H, ue);
  }
  function S(oe, L, H, ue) {
    return we(Qe(L, oe.length - H), oe, H, ue);
  }
  s.prototype.write = function(L, H, ue, xe) {
    if (H === void 0)
      xe = "utf8", ue = this.length, H = 0;
    else if (ue === void 0 && typeof H == "string")
      xe = H, ue = this.length, H = 0;
    else if (isFinite(H))
      H = H >>> 0, isFinite(ue) ? (ue = ue >>> 0, xe === void 0 && (xe = "utf8")) : (xe = ue, ue = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const pe = this.length - H;
    if ((ue === void 0 || ue > pe) && (ue = pe), L.length > 0 && (ue < 0 || H < 0) || H > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    xe || (xe = "utf8");
    let ce = !1;
    for (; ; )
      switch (xe) {
        case "hex":
          return te(this, L, H, ue);
        case "utf8":
        case "utf-8":
          return R(this, L, H, ue);
        case "ascii":
        case "latin1":
        case "binary":
          return M(this, L, H, ue);
        case "base64":
          return h(this, L, H, ue);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S(this, L, H, ue);
        default:
          if (ce) throw new TypeError("Unknown encoding: " + xe);
          xe = ("" + xe).toLowerCase(), ce = !0;
      }
  }, s.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function B(oe, L, H) {
    return L === 0 && H === oe.length ? t.fromByteArray(oe) : t.fromByteArray(oe.slice(L, H));
  }
  function T(oe, L, H) {
    H = Math.min(oe.length, H);
    const ue = [];
    let xe = L;
    for (; xe < H; ) {
      const pe = oe[xe];
      let ce = null, Y = pe > 239 ? 4 : pe > 223 ? 3 : pe > 191 ? 2 : 1;
      if (xe + Y <= H) {
        let Te, Ne, K, Se;
        switch (Y) {
          case 1:
            pe < 128 && (ce = pe);
            break;
          case 2:
            Te = oe[xe + 1], (Te & 192) === 128 && (Se = (pe & 31) << 6 | Te & 63, Se > 127 && (ce = Se));
            break;
          case 3:
            Te = oe[xe + 1], Ne = oe[xe + 2], (Te & 192) === 128 && (Ne & 192) === 128 && (Se = (pe & 15) << 12 | (Te & 63) << 6 | Ne & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (ce = Se));
            break;
          case 4:
            Te = oe[xe + 1], Ne = oe[xe + 2], K = oe[xe + 3], (Te & 192) === 128 && (Ne & 192) === 128 && (K & 192) === 128 && (Se = (pe & 15) << 18 | (Te & 63) << 12 | (Ne & 63) << 6 | K & 63, Se > 65535 && Se < 1114112 && (ce = Se));
        }
      }
      ce === null ? (ce = 65533, Y = 1) : ce > 65535 && (ce -= 65536, ue.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), ue.push(ce), xe += Y;
    }
    return I(ue);
  }
  const k = 4096;
  function I(oe) {
    const L = oe.length;
    if (L <= k)
      return String.fromCharCode.apply(String, oe);
    let H = "", ue = 0;
    for (; ue < L; )
      H += String.fromCharCode.apply(
        String,
        oe.slice(ue, ue += k)
      );
    return H;
  }
  function C(oe, L, H) {
    let ue = "";
    H = Math.min(oe.length, H);
    for (let xe = L; xe < H; ++xe)
      ue += String.fromCharCode(oe[xe] & 127);
    return ue;
  }
  function $(oe, L, H) {
    let ue = "";
    H = Math.min(oe.length, H);
    for (let xe = L; xe < H; ++xe)
      ue += String.fromCharCode(oe[xe]);
    return ue;
  }
  function w(oe, L, H) {
    const ue = oe.length;
    (!L || L < 0) && (L = 0), (!H || H < 0 || H > ue) && (H = ue);
    let xe = "";
    for (let pe = L; pe < H; ++pe)
      xe += Ue[oe[pe]];
    return xe;
  }
  function U(oe, L, H) {
    const ue = oe.slice(L, H);
    let xe = "";
    for (let pe = 0; pe < ue.length - 1; pe += 2)
      xe += String.fromCharCode(ue[pe] + ue[pe + 1] * 256);
    return xe;
  }
  s.prototype.slice = function(L, H) {
    const ue = this.length;
    L = ~~L, H = H === void 0 ? ue : ~~H, L < 0 ? (L += ue, L < 0 && (L = 0)) : L > ue && (L = ue), H < 0 ? (H += ue, H < 0 && (H = 0)) : H > ue && (H = ue), H < L && (H = L);
    const xe = this.subarray(L, H);
    return Object.setPrototypeOf(xe, s.prototype), xe;
  };
  function ie(oe, L, H) {
    if (oe % 1 !== 0 || oe < 0) throw new RangeError("offset is not uint");
    if (oe + L > H) throw new RangeError("Trying to access beyond buffer length");
  }
  s.prototype.readUintLE = s.prototype.readUIntLE = function(L, H, ue) {
    L = L >>> 0, H = H >>> 0, ue || ie(L, H, this.length);
    let xe = this[L], pe = 1, ce = 0;
    for (; ++ce < H && (pe *= 256); )
      xe += this[L + ce] * pe;
    return xe;
  }, s.prototype.readUintBE = s.prototype.readUIntBE = function(L, H, ue) {
    L = L >>> 0, H = H >>> 0, ue || ie(L, H, this.length);
    let xe = this[L + --H], pe = 1;
    for (; H > 0 && (pe *= 256); )
      xe += this[L + --H] * pe;
    return xe;
  }, s.prototype.readUint8 = s.prototype.readUInt8 = function(L, H) {
    return L = L >>> 0, H || ie(L, 1, this.length), this[L];
  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(L, H) {
    return L = L >>> 0, H || ie(L, 2, this.length), this[L] | this[L + 1] << 8;
  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(L, H) {
    return L = L >>> 0, H || ie(L, 2, this.length), this[L] << 8 | this[L + 1];
  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), (this[L] | this[L + 1] << 8 | this[L + 2] << 16) + this[L + 3] * 16777216;
  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), this[L] * 16777216 + (this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3]);
  }, s.prototype.readBigUInt64LE = Ge(function(L) {
    L = L >>> 0, Fe(L, "offset");
    const H = this[L], ue = this[L + 7];
    (H === void 0 || ue === void 0) && De(L, this.length - 8);
    const xe = H + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + this[++L] * 2 ** 24, pe = this[++L] + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + ue * 2 ** 24;
    return BigInt(xe) + (BigInt(pe) << BigInt(32));
  }), s.prototype.readBigUInt64BE = Ge(function(L) {
    L = L >>> 0, Fe(L, "offset");
    const H = this[L], ue = this[L + 7];
    (H === void 0 || ue === void 0) && De(L, this.length - 8);
    const xe = H * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + this[++L], pe = this[++L] * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + ue;
    return (BigInt(xe) << BigInt(32)) + BigInt(pe);
  }), s.prototype.readIntLE = function(L, H, ue) {
    L = L >>> 0, H = H >>> 0, ue || ie(L, H, this.length);
    let xe = this[L], pe = 1, ce = 0;
    for (; ++ce < H && (pe *= 256); )
      xe += this[L + ce] * pe;
    return pe *= 128, xe >= pe && (xe -= Math.pow(2, 8 * H)), xe;
  }, s.prototype.readIntBE = function(L, H, ue) {
    L = L >>> 0, H = H >>> 0, ue || ie(L, H, this.length);
    let xe = H, pe = 1, ce = this[L + --xe];
    for (; xe > 0 && (pe *= 256); )
      ce += this[L + --xe] * pe;
    return pe *= 128, ce >= pe && (ce -= Math.pow(2, 8 * H)), ce;
  }, s.prototype.readInt8 = function(L, H) {
    return L = L >>> 0, H || ie(L, 1, this.length), this[L] & 128 ? (255 - this[L] + 1) * -1 : this[L];
  }, s.prototype.readInt16LE = function(L, H) {
    L = L >>> 0, H || ie(L, 2, this.length);
    const ue = this[L] | this[L + 1] << 8;
    return ue & 32768 ? ue | 4294901760 : ue;
  }, s.prototype.readInt16BE = function(L, H) {
    L = L >>> 0, H || ie(L, 2, this.length);
    const ue = this[L + 1] | this[L] << 8;
    return ue & 32768 ? ue | 4294901760 : ue;
  }, s.prototype.readInt32LE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), this[L] | this[L + 1] << 8 | this[L + 2] << 16 | this[L + 3] << 24;
  }, s.prototype.readInt32BE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), this[L] << 24 | this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3];
  }, s.prototype.readBigInt64LE = Ge(function(L) {
    L = L >>> 0, Fe(L, "offset");
    const H = this[L], ue = this[L + 7];
    (H === void 0 || ue === void 0) && De(L, this.length - 8);
    const xe = this[L + 4] + this[L + 5] * 2 ** 8 + this[L + 6] * 2 ** 16 + (ue << 24);
    return (BigInt(xe) << BigInt(32)) + BigInt(H + this[++L] * 2 ** 8 + this[++L] * 2 ** 16 + this[++L] * 2 ** 24);
  }), s.prototype.readBigInt64BE = Ge(function(L) {
    L = L >>> 0, Fe(L, "offset");
    const H = this[L], ue = this[L + 7];
    (H === void 0 || ue === void 0) && De(L, this.length - 8);
    const xe = (H << 24) + // Overflow
    this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + this[++L];
    return (BigInt(xe) << BigInt(32)) + BigInt(this[++L] * 2 ** 24 + this[++L] * 2 ** 16 + this[++L] * 2 ** 8 + ue);
  }), s.prototype.readFloatLE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), r.read(this, L, !0, 23, 4);
  }, s.prototype.readFloatBE = function(L, H) {
    return L = L >>> 0, H || ie(L, 4, this.length), r.read(this, L, !1, 23, 4);
  }, s.prototype.readDoubleLE = function(L, H) {
    return L = L >>> 0, H || ie(L, 8, this.length), r.read(this, L, !0, 52, 8);
  }, s.prototype.readDoubleBE = function(L, H) {
    return L = L >>> 0, H || ie(L, 8, this.length), r.read(this, L, !1, 52, 8);
  };
  function le(oe, L, H, ue, xe, pe) {
    if (!s.isBuffer(oe)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (L > xe || L < pe) throw new RangeError('"value" argument is out of bounds');
    if (H + ue > oe.length) throw new RangeError("Index out of range");
  }
  s.prototype.writeUintLE = s.prototype.writeUIntLE = function(L, H, ue, xe) {
    if (L = +L, H = H >>> 0, ue = ue >>> 0, !xe) {
      const Y = Math.pow(2, 8 * ue) - 1;
      le(this, L, H, ue, Y, 0);
    }
    let pe = 1, ce = 0;
    for (this[H] = L & 255; ++ce < ue && (pe *= 256); )
      this[H + ce] = L / pe & 255;
    return H + ue;
  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(L, H, ue, xe) {
    if (L = +L, H = H >>> 0, ue = ue >>> 0, !xe) {
      const Y = Math.pow(2, 8 * ue) - 1;
      le(this, L, H, ue, Y, 0);
    }
    let pe = ue - 1, ce = 1;
    for (this[H + pe] = L & 255; --pe >= 0 && (ce *= 256); )
      this[H + pe] = L / ce & 255;
    return H + ue;
  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 1, 255, 0), this[H] = L & 255, H + 1;
  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 2, 65535, 0), this[H] = L & 255, this[H + 1] = L >>> 8, H + 2;
  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 2, 65535, 0), this[H] = L >>> 8, this[H + 1] = L & 255, H + 2;
  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 4, 4294967295, 0), this[H + 3] = L >>> 24, this[H + 2] = L >>> 16, this[H + 1] = L >>> 8, this[H] = L & 255, H + 4;
  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 4, 4294967295, 0), this[H] = L >>> 24, this[H + 1] = L >>> 16, this[H + 2] = L >>> 8, this[H + 3] = L & 255, H + 4;
  };
  function ee(oe, L, H, ue, xe) {
    Pe(L, ue, xe, oe, H, 7);
    let pe = Number(L & BigInt(4294967295));
    oe[H++] = pe, pe = pe >> 8, oe[H++] = pe, pe = pe >> 8, oe[H++] = pe, pe = pe >> 8, oe[H++] = pe;
    let ce = Number(L >> BigInt(32) & BigInt(4294967295));
    return oe[H++] = ce, ce = ce >> 8, oe[H++] = ce, ce = ce >> 8, oe[H++] = ce, ce = ce >> 8, oe[H++] = ce, H;
  }
  function F(oe, L, H, ue, xe) {
    Pe(L, ue, xe, oe, H, 7);
    let pe = Number(L & BigInt(4294967295));
    oe[H + 7] = pe, pe = pe >> 8, oe[H + 6] = pe, pe = pe >> 8, oe[H + 5] = pe, pe = pe >> 8, oe[H + 4] = pe;
    let ce = Number(L >> BigInt(32) & BigInt(4294967295));
    return oe[H + 3] = ce, ce = ce >> 8, oe[H + 2] = ce, ce = ce >> 8, oe[H + 1] = ce, ce = ce >> 8, oe[H] = ce, H + 8;
  }
  s.prototype.writeBigUInt64LE = Ge(function(L, H = 0) {
    return ee(this, L, H, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeBigUInt64BE = Ge(function(L, H = 0) {
    return F(this, L, H, BigInt(0), BigInt("0xffffffffffffffff"));
  }), s.prototype.writeIntLE = function(L, H, ue, xe) {
    if (L = +L, H = H >>> 0, !xe) {
      const Te = Math.pow(2, 8 * ue - 1);
      le(this, L, H, ue, Te - 1, -Te);
    }
    let pe = 0, ce = 1, Y = 0;
    for (this[H] = L & 255; ++pe < ue && (ce *= 256); )
      L < 0 && Y === 0 && this[H + pe - 1] !== 0 && (Y = 1), this[H + pe] = (L / ce >> 0) - Y & 255;
    return H + ue;
  }, s.prototype.writeIntBE = function(L, H, ue, xe) {
    if (L = +L, H = H >>> 0, !xe) {
      const Te = Math.pow(2, 8 * ue - 1);
      le(this, L, H, ue, Te - 1, -Te);
    }
    let pe = ue - 1, ce = 1, Y = 0;
    for (this[H + pe] = L & 255; --pe >= 0 && (ce *= 256); )
      L < 0 && Y === 0 && this[H + pe + 1] !== 0 && (Y = 1), this[H + pe] = (L / ce >> 0) - Y & 255;
    return H + ue;
  }, s.prototype.writeInt8 = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 1, 127, -128), L < 0 && (L = 255 + L + 1), this[H] = L & 255, H + 1;
  }, s.prototype.writeInt16LE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 2, 32767, -32768), this[H] = L & 255, this[H + 1] = L >>> 8, H + 2;
  }, s.prototype.writeInt16BE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 2, 32767, -32768), this[H] = L >>> 8, this[H + 1] = L & 255, H + 2;
  }, s.prototype.writeInt32LE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 4, 2147483647, -2147483648), this[H] = L & 255, this[H + 1] = L >>> 8, this[H + 2] = L >>> 16, this[H + 3] = L >>> 24, H + 4;
  }, s.prototype.writeInt32BE = function(L, H, ue) {
    return L = +L, H = H >>> 0, ue || le(this, L, H, 4, 2147483647, -2147483648), L < 0 && (L = 4294967295 + L + 1), this[H] = L >>> 24, this[H + 1] = L >>> 16, this[H + 2] = L >>> 8, this[H + 3] = L & 255, H + 4;
  }, s.prototype.writeBigInt64LE = Ge(function(L, H = 0) {
    return ee(this, L, H, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), s.prototype.writeBigInt64BE = Ge(function(L, H = 0) {
    return F(this, L, H, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function z(oe, L, H, ue, xe, pe) {
    if (H + ue > oe.length) throw new RangeError("Index out of range");
    if (H < 0) throw new RangeError("Index out of range");
  }
  function se(oe, L, H, ue, xe) {
    return L = +L, H = H >>> 0, xe || z(oe, L, H, 4), r.write(oe, L, H, ue, 23, 4), H + 4;
  }
  s.prototype.writeFloatLE = function(L, H, ue) {
    return se(this, L, H, !0, ue);
  }, s.prototype.writeFloatBE = function(L, H, ue) {
    return se(this, L, H, !1, ue);
  };
  function he(oe, L, H, ue, xe) {
    return L = +L, H = H >>> 0, xe || z(oe, L, H, 8), r.write(oe, L, H, ue, 52, 8), H + 8;
  }
  s.prototype.writeDoubleLE = function(L, H, ue) {
    return he(this, L, H, !0, ue);
  }, s.prototype.writeDoubleBE = function(L, H, ue) {
    return he(this, L, H, !1, ue);
  }, s.prototype.copy = function(L, H, ue, xe) {
    if (!s.isBuffer(L)) throw new TypeError("argument should be a Buffer");
    if (ue || (ue = 0), !xe && xe !== 0 && (xe = this.length), H >= L.length && (H = L.length), H || (H = 0), xe > 0 && xe < ue && (xe = ue), xe === ue || L.length === 0 || this.length === 0) return 0;
    if (H < 0)
      throw new RangeError("targetStart out of bounds");
    if (ue < 0 || ue >= this.length) throw new RangeError("Index out of range");
    if (xe < 0) throw new RangeError("sourceEnd out of bounds");
    xe > this.length && (xe = this.length), L.length - H < xe - ue && (xe = L.length - H + ue);
    const pe = xe - ue;
    return this === L && typeof n.prototype.copyWithin == "function" ? this.copyWithin(H, ue, xe) : n.prototype.set.call(
      L,
      this.subarray(ue, xe),
      H
    ), pe;
  }, s.prototype.fill = function(L, H, ue, xe) {
    if (typeof L == "string") {
      if (typeof H == "string" ? (xe = H, H = 0, ue = this.length) : typeof ue == "string" && (xe = ue, ue = this.length), xe !== void 0 && typeof xe != "string")
        throw new TypeError("encoding must be a string");
      if (typeof xe == "string" && !s.isEncoding(xe))
        throw new TypeError("Unknown encoding: " + xe);
      if (L.length === 1) {
        const ce = L.charCodeAt(0);
        (xe === "utf8" && ce < 128 || xe === "latin1") && (L = ce);
      }
    } else typeof L == "number" ? L = L & 255 : typeof L == "boolean" && (L = Number(L));
    if (H < 0 || this.length < H || this.length < ue)
      throw new RangeError("Out of range index");
    if (ue <= H)
      return this;
    H = H >>> 0, ue = ue === void 0 ? this.length : ue >>> 0, L || (L = 0);
    let pe;
    if (typeof L == "number")
      for (pe = H; pe < ue; ++pe)
        this[pe] = L;
    else {
      const ce = s.isBuffer(L) ? L : s.from(L, xe), Y = ce.length;
      if (Y === 0)
        throw new TypeError('The value "' + L + '" is invalid for argument "value"');
      for (pe = 0; pe < ue - H; ++pe)
        this[pe + H] = ce[pe % Y];
    }
    return this;
  };
  const ae = {};
  function X(oe, L, H) {
    ae[oe] = class extends H {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: L.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${oe}]`, this.stack, delete this.name;
      }
      get code() {
        return oe;
      }
      set code(xe) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: xe,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${oe}]: ${this.message}`;
      }
    };
  }
  X(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(oe) {
      return oe ? `${oe} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), X(
    "ERR_INVALID_ARG_TYPE",
    function(oe, L) {
      return `The "${oe}" argument must be of type number. Received type ${typeof L}`;
    },
    TypeError
  ), X(
    "ERR_OUT_OF_RANGE",
    function(oe, L, H) {
      let ue = `The value of "${oe}" is out of range.`, xe = H;
      return Number.isInteger(H) && Math.abs(H) > 2 ** 32 ? xe = be(String(H)) : typeof H == "bigint" && (xe = String(H), (H > BigInt(2) ** BigInt(32) || H < -(BigInt(2) ** BigInt(32))) && (xe = be(xe)), xe += "n"), ue += ` It must be ${L}. Received ${xe}`, ue;
    },
    RangeError
  );
  function be(oe) {
    let L = "", H = oe.length;
    const ue = oe[0] === "-" ? 1 : 0;
    for (; H >= ue + 4; H -= 3)
      L = `_${oe.slice(H - 3, H)}${L}`;
    return `${oe.slice(0, H)}${L}`;
  }
  function Re(oe, L, H) {
    Fe(L, "offset"), (oe[L] === void 0 || oe[L + H] === void 0) && De(L, oe.length - (H + 1));
  }
  function Pe(oe, L, H, ue, xe, pe) {
    if (oe > H || oe < L) {
      const ce = typeof L == "bigint" ? "n" : "";
      let Y;
      throw L === 0 || L === BigInt(0) ? Y = `>= 0${ce} and < 2${ce} ** ${(pe + 1) * 8}${ce}` : Y = `>= -(2${ce} ** ${(pe + 1) * 8 - 1}${ce}) and < 2 ** ${(pe + 1) * 8 - 1}${ce}`, new ae.ERR_OUT_OF_RANGE("value", Y, oe);
    }
    Re(ue, xe, pe);
  }
  function Fe(oe, L) {
    if (typeof oe != "number")
      throw new ae.ERR_INVALID_ARG_TYPE(L, "number", oe);
  }
  function De(oe, L, H) {
    throw Math.floor(oe) !== oe ? (Fe(oe, H), new ae.ERR_OUT_OF_RANGE("offset", "an integer", oe)) : L < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS() : new ae.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${L}`,
      oe
    );
  }
  const je = /[^+/0-9A-Za-z-_]/g;
  function Oe(oe) {
    if (oe = oe.split("=")[0], oe = oe.trim().replace(je, ""), oe.length < 2) return "";
    for (; oe.length % 4 !== 0; )
      oe = oe + "=";
    return oe;
  }
  function rt(oe, L) {
    L = L || 1 / 0;
    let H;
    const ue = oe.length;
    let xe = null;
    const pe = [];
    for (let ce = 0; ce < ue; ++ce) {
      if (H = oe.charCodeAt(ce), H > 55295 && H < 57344) {
        if (!xe) {
          if (H > 56319) {
            (L -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          } else if (ce + 1 === ue) {
            (L -= 3) > -1 && pe.push(239, 191, 189);
            continue;
          }
          xe = H;
          continue;
        }
        if (H < 56320) {
          (L -= 3) > -1 && pe.push(239, 191, 189), xe = H;
          continue;
        }
        H = (xe - 55296 << 10 | H - 56320) + 65536;
      } else xe && (L -= 3) > -1 && pe.push(239, 191, 189);
      if (xe = null, H < 128) {
        if ((L -= 1) < 0) break;
        pe.push(H);
      } else if (H < 2048) {
        if ((L -= 2) < 0) break;
        pe.push(
          H >> 6 | 192,
          H & 63 | 128
        );
      } else if (H < 65536) {
        if ((L -= 3) < 0) break;
        pe.push(
          H >> 12 | 224,
          H >> 6 & 63 | 128,
          H & 63 | 128
        );
      } else if (H < 1114112) {
        if ((L -= 4) < 0) break;
        pe.push(
          H >> 18 | 240,
          H >> 12 & 63 | 128,
          H >> 6 & 63 | 128,
          H & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return pe;
  }
  function He(oe) {
    const L = [];
    for (let H = 0; H < oe.length; ++H)
      L.push(oe.charCodeAt(H) & 255);
    return L;
  }
  function Qe(oe, L) {
    let H, ue, xe;
    const pe = [];
    for (let ce = 0; ce < oe.length && !((L -= 2) < 0); ++ce)
      H = oe.charCodeAt(ce), ue = H >> 8, xe = H % 256, pe.push(xe), pe.push(ue);
    return pe;
  }
  function Je(oe) {
    return t.toByteArray(Oe(oe));
  }
  function we(oe, L, H, ue) {
    let xe;
    for (xe = 0; xe < ue && !(xe + H >= L.length || xe >= oe.length); ++xe)
      L[xe + H] = oe[xe];
    return xe;
  }
  function Ae(oe, L) {
    return oe instanceof L || oe != null && oe.constructor != null && oe.constructor.name != null && oe.constructor.name === L.name;
  }
  function ze(oe) {
    return oe !== oe;
  }
  const Ue = (function() {
    const oe = "0123456789abcdef", L = new Array(256);
    for (let H = 0; H < 16; ++H) {
      const ue = H * 16;
      for (let xe = 0; xe < 16; ++xe)
        L[ue + xe] = oe[H] + oe[xe];
    }
    return L;
  })();
  function Ge(oe) {
    return typeof BigInt > "u" ? Xe : oe;
  }
  function Xe() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer = buffer$1.Buffer;
var bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(t, r) {
    for (var a = Math.min(t.length, r.length), u = new Buffer(a), n = 0; n < a; ++n)
      u[n] = t[n] ^ r[n];
    return u;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var e = requireBufferXor();
  return cbc.encrypt = function(t, r) {
    var a = e(r, t._prev);
    return t._prev = t._cipher.encryptBlock(a), t._prev;
  }, cbc.decrypt = function(t, r) {
    var a = t._prev;
    t._prev = r;
    var u = t._cipher.decryptBlock(r);
    return e(u, a);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireBufferXor();
  function r(a, u, n) {
    var o = u.length, c = t(u, a._cache);
    return a._cache = a._cache.slice(o), a._prev = e.concat([a._prev, n ? u : c]), c;
  }
  return cfb.encrypt = function(a, u, n) {
    for (var o = e.allocUnsafe(0), c; u.length; )
      if (a._cache.length === 0 && (a._cache = a._cipher.encryptBlock(a._prev), a._prev = e.allocUnsafe(0)), a._cache.length <= u.length)
        c = a._cache.length, o = e.concat([o, r(a, u.slice(0, c), n)]), u = u.slice(c);
      else {
        o = e.concat([o, r(a, u, n)]);
        break;
      }
    return o;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var e = requireSafeBuffer$4().Buffer;
  function t(r, a, u) {
    var n = r._cipher.encryptBlock(r._prev), o = n[0] ^ a;
    return r._prev = e.concat([
      r._prev.slice(1),
      e.from([u ? a : o])
    ]), o;
  }
  return cfb8.encrypt = function(r, a, u) {
    for (var n = a.length, o = e.allocUnsafe(n), c = -1; ++c < n; )
      o[c] = t(r, a[c], u);
    return o;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var e = requireSafeBuffer$4().Buffer;
  function t(a, u, n) {
    for (var o, c = -1, f = 8, l = 0, s, p; ++c < f; )
      o = a._cipher.encryptBlock(a._prev), s = u & 1 << 7 - c ? 128 : 0, p = o[0] ^ s, l += (p & 128) >> c % 8, a._prev = r(a._prev, n ? s : p);
    return l;
  }
  function r(a, u) {
    var n = a.length, o = -1, c = e.allocUnsafe(a.length);
    for (a = e.concat([a, e.from([u])]); ++o < n; )
      c[o] = a[o] << 1 | a[o + 1] >> 7;
    return c;
  }
  return cfb1.encrypt = function(a, u, n) {
    for (var o = u.length, c = e.allocUnsafe(o), f = -1; ++f < o; )
      c[f] = t(a, u[f], n);
    return c;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var e = requireBufferXor();
  function t(r) {
    return r._prev = r._cipher.encryptBlock(r._prev), r._prev;
  }
  return ofb.encrypt = function(r, a) {
    for (; r._cache.length < a.length; )
      r._cache = Buffer.concat([r._cache, t(r)]);
    var u = r._cache.slice(0, a.length);
    return r._cache = r._cache.slice(a.length), e(a, u);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function e(t) {
    for (var r = t.length, a; r--; )
      if (a = t.readUInt8(r), a === 255)
        t.writeUInt8(0, r);
      else {
        a++, t.writeUInt8(a, r);
        break;
      }
  }
  return incr32_1 = e, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var e = requireBufferXor(), t = requireSafeBuffer$4().Buffer, r = requireIncr32();
  function a(n) {
    var o = n._cipher.encryptBlockRaw(n._prev);
    return r(n._prev), o;
  }
  var u = 16;
  return ctr.encrypt = function(n, o) {
    var c = Math.ceil(o.length / u), f = n._cache.length;
    n._cache = t.concat([
      n._cache,
      t.allocUnsafe(c * u)
    ]);
    for (var l = 0; l < c; l++) {
      var s = a(n), p = f + l * u;
      n._cache.writeUInt32BE(s[0], p + 0), n._cache.writeUInt32BE(s[1], p + 4), n._cache.writeUInt32BE(s[2], p + 8), n._cache.writeUInt32BE(s[3], p + 12);
    }
    var m = n._cache.slice(0, o.length);
    return n._cache = n._cache.slice(o.length), e(o, m);
  }, ctr;
}
const aes128 = { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192 = { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256 = { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, require$$2 = {
  "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" },
  "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" },
  "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" },
  "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" },
  "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" },
  "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" },
  "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" },
  "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" },
  "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" },
  "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" },
  "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" },
  "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" },
  "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" },
  "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" },
  "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" },
  "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" },
  "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" },
  "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" },
  "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" },
  "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" },
  "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" },
  "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" },
  "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var e = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var r in t)
    t[r].module = e[t[r].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var e = requireSafeBuffer$4().Buffer;
  function t(c) {
    e.isBuffer(c) || (c = e.from(c));
    for (var f = c.length / 4 | 0, l = new Array(f), s = 0; s < f; s++)
      l[s] = c.readUInt32BE(s * 4);
    return l;
  }
  function r(c) {
    for (var f = 0; f < c.length; c++)
      c[f] = 0;
  }
  function a(c, f, l, s, p) {
    for (var m = l[0], g = l[1], y = l[2], v = l[3], E = c[0] ^ f[0], b = c[1] ^ f[1], q = c[2] ^ f[2], O = c[3] ^ f[3], j, D, G, V, Q = 4, re = 1; re < p; re++)
      j = m[E >>> 24] ^ g[b >>> 16 & 255] ^ y[q >>> 8 & 255] ^ v[O & 255] ^ f[Q++], D = m[b >>> 24] ^ g[q >>> 16 & 255] ^ y[O >>> 8 & 255] ^ v[E & 255] ^ f[Q++], G = m[q >>> 24] ^ g[O >>> 16 & 255] ^ y[E >>> 8 & 255] ^ v[b & 255] ^ f[Q++], V = m[O >>> 24] ^ g[E >>> 16 & 255] ^ y[b >>> 8 & 255] ^ v[q & 255] ^ f[Q++], E = j, b = D, q = G, O = V;
    return j = (s[E >>> 24] << 24 | s[b >>> 16 & 255] << 16 | s[q >>> 8 & 255] << 8 | s[O & 255]) ^ f[Q++], D = (s[b >>> 24] << 24 | s[q >>> 16 & 255] << 16 | s[O >>> 8 & 255] << 8 | s[E & 255]) ^ f[Q++], G = (s[q >>> 24] << 24 | s[O >>> 16 & 255] << 16 | s[E >>> 8 & 255] << 8 | s[b & 255]) ^ f[Q++], V = (s[O >>> 24] << 24 | s[E >>> 16 & 255] << 16 | s[b >>> 8 & 255] << 8 | s[q & 255]) ^ f[Q++], j = j >>> 0, D = D >>> 0, G = G >>> 0, V = V >>> 0, [j, D, G, V];
  }
  var u = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], n = (function() {
    for (var c = new Array(256), f = 0; f < 256; f++)
      f < 128 ? c[f] = f << 1 : c[f] = f << 1 ^ 283;
    for (var l = [], s = [], p = [[], [], [], []], m = [[], [], [], []], g = 0, y = 0, v = 0; v < 256; ++v) {
      var E = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
      E = E >>> 8 ^ E & 255 ^ 99, l[g] = E, s[E] = g;
      var b = c[g], q = c[b], O = c[q], j = c[E] * 257 ^ E * 16843008;
      p[0][g] = j << 24 | j >>> 8, p[1][g] = j << 16 | j >>> 16, p[2][g] = j << 8 | j >>> 24, p[3][g] = j, j = O * 16843009 ^ q * 65537 ^ b * 257 ^ g * 16843008, m[0][E] = j << 24 | j >>> 8, m[1][E] = j << 16 | j >>> 16, m[2][E] = j << 8 | j >>> 24, m[3][E] = j, g === 0 ? g = y = 1 : (g = b ^ c[c[c[O ^ b]]], y ^= c[c[y]]);
    }
    return {
      SBOX: l,
      INV_SBOX: s,
      SUB_MIX: p,
      INV_SUB_MIX: m
    };
  })();
  function o(c) {
    this._key = t(c), this._reset();
  }
  return o.blockSize = 16, o.keySize = 256 / 8, o.prototype.blockSize = o.blockSize, o.prototype.keySize = o.keySize, o.prototype._reset = function() {
    for (var c = this._key, f = c.length, l = f + 6, s = (l + 1) * 4, p = [], m = 0; m < f; m++)
      p[m] = c[m];
    for (m = f; m < s; m++) {
      var g = p[m - 1];
      m % f === 0 ? (g = g << 8 | g >>> 24, g = n.SBOX[g >>> 24] << 24 | n.SBOX[g >>> 16 & 255] << 16 | n.SBOX[g >>> 8 & 255] << 8 | n.SBOX[g & 255], g ^= u[m / f | 0] << 24) : f > 6 && m % f === 4 && (g = n.SBOX[g >>> 24] << 24 | n.SBOX[g >>> 16 & 255] << 16 | n.SBOX[g >>> 8 & 255] << 8 | n.SBOX[g & 255]), p[m] = p[m - f] ^ g;
    }
    for (var y = [], v = 0; v < s; v++) {
      var E = s - v, b = p[E - (v % 4 ? 0 : 4)];
      v < 4 || E <= 4 ? y[v] = b : y[v] = n.INV_SUB_MIX[0][n.SBOX[b >>> 24]] ^ n.INV_SUB_MIX[1][n.SBOX[b >>> 16 & 255]] ^ n.INV_SUB_MIX[2][n.SBOX[b >>> 8 & 255]] ^ n.INV_SUB_MIX[3][n.SBOX[b & 255]];
    }
    this._nRounds = l, this._keySchedule = p, this._invKeySchedule = y;
  }, o.prototype.encryptBlockRaw = function(c) {
    return c = t(c), a(c, this._keySchedule, n.SUB_MIX, n.SBOX, this._nRounds);
  }, o.prototype.encryptBlock = function(c) {
    var f = this.encryptBlockRaw(c), l = e.allocUnsafe(16);
    return l.writeUInt32BE(f[0], 0), l.writeUInt32BE(f[1], 4), l.writeUInt32BE(f[2], 8), l.writeUInt32BE(f[3], 12), l;
  }, o.prototype.decryptBlock = function(c) {
    c = t(c);
    var f = c[1];
    c[1] = c[3], c[3] = f;
    var l = a(c, this._invKeySchedule, n.INV_SUB_MIX, n.INV_SBOX, this._nRounds), s = e.allocUnsafe(16);
    return s.writeUInt32BE(l[0], 0), s.writeUInt32BE(l[3], 4), s.writeUInt32BE(l[2], 8), s.writeUInt32BE(l[1], 12), s;
  }, o.prototype.scrub = function() {
    r(this._keySchedule), r(this._invKeySchedule), r(this._key);
  }, aes.AES = o, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var e = requireSafeBuffer$4().Buffer, t = e.alloc(16, 0);
  function r(n) {
    return [
      n.readUInt32BE(0),
      n.readUInt32BE(4),
      n.readUInt32BE(8),
      n.readUInt32BE(12)
    ];
  }
  function a(n) {
    var o = e.allocUnsafe(16);
    return o.writeUInt32BE(n[0] >>> 0, 0), o.writeUInt32BE(n[1] >>> 0, 4), o.writeUInt32BE(n[2] >>> 0, 8), o.writeUInt32BE(n[3] >>> 0, 12), o;
  }
  function u(n) {
    this.h = n, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return u.prototype.ghash = function(n) {
    for (var o = -1; ++o < n.length; )
      this.state[o] ^= n[o];
    this._multiply();
  }, u.prototype._multiply = function() {
    for (var n = r(this.h), o = [0, 0, 0, 0], c, f, l, s = -1; ++s < 128; ) {
      for (f = (this.state[~~(s / 8)] & 1 << 7 - s % 8) !== 0, f && (o[0] ^= n[0], o[1] ^= n[1], o[2] ^= n[2], o[3] ^= n[3]), l = (n[3] & 1) !== 0, c = 3; c > 0; c--)
        n[c] = n[c] >>> 1 | (n[c - 1] & 1) << 31;
      n[0] = n[0] >>> 1, l && (n[0] = n[0] ^ 225 << 24);
    }
    this.state = a(o);
  }, u.prototype.update = function(n) {
    this.cache = e.concat([this.cache, n]);
    for (var o; this.cache.length >= 16; )
      o = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(o);
  }, u.prototype.final = function(n, o) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(a([0, n, 0, o])), this.state;
  }, ghash = u, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$4().Buffer, r = requireCipherBase(), a = requireInherits_browser(), u = requireGhash(), n = requireBufferXor(), o = requireIncr32();
  function c(s, p) {
    var m = 0;
    s.length !== p.length && m++;
    for (var g = Math.min(s.length, p.length), y = 0; y < g; ++y)
      m += s[y] ^ p[y];
    return m;
  }
  function f(s, p, m) {
    if (p.length === 12)
      return s._finID = t.concat([p, t.from([0, 0, 0, 1])]), t.concat([p, t.from([0, 0, 0, 2])]);
    var g = new u(m), y = p.length, v = y % 16;
    g.update(p), v && (v = 16 - v, g.update(t.alloc(v, 0))), g.update(t.alloc(8, 0));
    var E = y * 8, b = t.alloc(8);
    b.writeUIntBE(E, 0, 8), g.update(b), s._finID = g.state;
    var q = t.from(s._finID);
    return o(q), q;
  }
  function l(s, p, m, g) {
    r.call(this);
    var y = t.alloc(4, 0);
    this._cipher = new e.AES(p);
    var v = this._cipher.encryptBlock(y);
    this._ghash = new u(v), m = f(this, m, v), this._prev = t.from(m), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = g, this._alen = 0, this._len = 0, this._mode = s, this._authTag = null, this._called = !1;
  }
  return a(l, r), l.prototype._update = function(s) {
    if (!this._called && this._alen) {
      var p = 16 - this._alen % 16;
      p < 16 && (p = t.alloc(p, 0), this._ghash.update(p));
    }
    this._called = !0;
    var m = this._mode.encrypt(this, s);
    return this._decrypt ? this._ghash.update(s) : this._ghash.update(m), this._len += s.length, m;
  }, l.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var s = n(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && c(s, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = s, this._cipher.scrub();
  }, l.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, l.prototype.setAuthTag = function(p) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = p;
  }, l.prototype.setAAD = function(p) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(p), this._alen += p.length;
  }, authCipher = l, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$4().Buffer, r = requireCipherBase(), a = requireInherits_browser();
  function u(n, o, c, f) {
    r.call(this), this._cipher = new e.AES(o), this._prev = t.from(c), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = f, this._mode = n;
  }
  return a(u, r), u.prototype._update = function(n) {
    return this._mode.encrypt(this, n, this._decrypt);
  }, u.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = u, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireMd5_js();
  function r(a, u, n, o) {
    if (e.isBuffer(a) || (a = e.from(a, "binary")), u && (e.isBuffer(u) || (u = e.from(u, "binary")), u.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var c = n / 8, f = e.alloc(c), l = e.alloc(o || 0), s = e.alloc(0); c > 0 || o > 0; ) {
      var p = new t();
      p.update(s), p.update(a), u && p.update(u), s = p.digest();
      var m = 0;
      if (c > 0) {
        var g = f.length - c;
        m = Math.min(c, s.length), s.copy(f, g, 0, m), c -= m;
      }
      if (m < s.length && o > 0) {
        var y = l.length - o, v = Math.min(o, s.length - m);
        s.copy(l, y, m, m + v), o -= v;
      }
    }
    return s.fill(0), { key: f, iv: l };
  }
  return evp_bytestokey = r, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var e = requireModes$1(), t = requireAuthCipher(), r = requireSafeBuffer$4().Buffer, a = requireStreamCipher(), u = requireCipherBase(), n = requireAes(), o = requireEvp_bytestokey(), c = requireInherits_browser();
  function f(g, y, v) {
    u.call(this), this._cache = new s(), this._cipher = new n.AES(y), this._prev = r.from(v), this._mode = g, this._autopadding = !0;
  }
  c(f, u), f.prototype._update = function(g) {
    this._cache.add(g);
    for (var y, v, E = []; y = this._cache.get(); )
      v = this._mode.encrypt(this, y), E.push(v);
    return r.concat(E);
  };
  var l = r.alloc(16, 16);
  f.prototype._final = function() {
    var g = this._cache.flush();
    if (this._autopadding)
      return g = this._mode.encrypt(this, g), this._cipher.scrub(), g;
    if (!g.equals(l))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, f.prototype.setAutoPadding = function(g) {
    return this._autopadding = !!g, this;
  };
  function s() {
    this.cache = r.allocUnsafe(0);
  }
  s.prototype.add = function(g) {
    this.cache = r.concat([this.cache, g]);
  }, s.prototype.get = function() {
    if (this.cache.length > 15) {
      var g = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), g;
    }
    return null;
  }, s.prototype.flush = function() {
    for (var g = 16 - this.cache.length, y = r.allocUnsafe(g), v = -1; ++v < g; )
      y.writeUInt8(g, v);
    return r.concat([this.cache, y]);
  };
  function p(g, y, v) {
    var E = e[g.toLowerCase()];
    if (!E) throw new TypeError("invalid suite type");
    if (typeof y == "string" && (y = r.from(y)), y.length !== E.key / 8) throw new TypeError("invalid key length " + y.length);
    if (typeof v == "string" && (v = r.from(v)), E.mode !== "GCM" && v.length !== E.iv) throw new TypeError("invalid iv length " + v.length);
    return E.type === "stream" ? new a(E.module, y, v) : E.type === "auth" ? new t(E.module, y, v) : new f(E.module, y, v);
  }
  function m(g, y) {
    var v = e[g.toLowerCase()];
    if (!v) throw new TypeError("invalid suite type");
    var E = o(y, !1, v.key, v.iv);
    return p(g, E.key, E.iv);
  }
  return encrypter.createCipheriv = p, encrypter.createCipher = m, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var e = requireAuthCipher(), t = requireSafeBuffer$4().Buffer, r = requireModes$1(), a = requireStreamCipher(), u = requireCipherBase(), n = requireAes(), o = requireEvp_bytestokey(), c = requireInherits_browser();
  function f(g, y, v) {
    u.call(this), this._cache = new l(), this._last = void 0, this._cipher = new n.AES(y), this._prev = t.from(v), this._mode = g, this._autopadding = !0;
  }
  c(f, u), f.prototype._update = function(g) {
    this._cache.add(g);
    for (var y, v, E = []; y = this._cache.get(this._autopadding); )
      v = this._mode.decrypt(this, y), E.push(v);
    return t.concat(E);
  }, f.prototype._final = function() {
    var g = this._cache.flush();
    if (this._autopadding)
      return s(this._mode.decrypt(this, g));
    if (g)
      throw new Error("data not multiple of block length");
  }, f.prototype.setAutoPadding = function(g) {
    return this._autopadding = !!g, this;
  };
  function l() {
    this.cache = t.allocUnsafe(0);
  }
  l.prototype.add = function(g) {
    this.cache = t.concat([this.cache, g]);
  }, l.prototype.get = function(g) {
    var y;
    if (g) {
      if (this.cache.length > 16)
        return y = this.cache.slice(0, 16), this.cache = this.cache.slice(16), y;
    } else if (this.cache.length >= 16)
      return y = this.cache.slice(0, 16), this.cache = this.cache.slice(16), y;
    return null;
  }, l.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function s(g) {
    var y = g[15];
    if (y < 1 || y > 16)
      throw new Error("unable to decrypt data");
    for (var v = -1; ++v < y; )
      if (g[v + (16 - y)] !== y)
        throw new Error("unable to decrypt data");
    if (y !== 16)
      return g.slice(0, 16 - y);
  }
  function p(g, y, v) {
    var E = r[g.toLowerCase()];
    if (!E) throw new TypeError("invalid suite type");
    if (typeof v == "string" && (v = t.from(v)), E.mode !== "GCM" && v.length !== E.iv) throw new TypeError("invalid iv length " + v.length);
    if (typeof y == "string" && (y = t.from(y)), y.length !== E.key / 8) throw new TypeError("invalid key length " + y.length);
    return E.type === "stream" ? new a(E.module, y, v, !0) : E.type === "auth" ? new e(E.module, y, v, !0) : new f(E.module, y, v);
  }
  function m(g, y) {
    var v = r[g.toLowerCase()];
    if (!v) throw new TypeError("invalid suite type");
    var E = o(y, !1, v.key, v.iv);
    return p(g, E.key, E.iv);
  }
  return decrypter.createDecipher = m, decrypter.createDecipheriv = p, decrypter;
}
var hasRequiredBrowser$d;
function requireBrowser$d() {
  if (hasRequiredBrowser$d) return browser$c;
  hasRequiredBrowser$d = 1;
  var e = requireEncrypter(), t = requireDecrypter(), r = require$$2;
  function a() {
    return Object.keys(r);
  }
  return browser$c.createCipher = browser$c.Cipher = e.createCipher, browser$c.createCipheriv = browser$c.Cipheriv = e.createCipheriv, browser$c.createDecipher = browser$c.Decipher = t.createDecipher, browser$c.createDecipheriv = browser$c.Decipheriv = t.createDecipheriv, browser$c.listCiphers = browser$c.getCiphers = a, browser$c;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, (function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  })(modes)), modes;
}
var hasRequiredBrowser$c;
function requireBrowser$c() {
  if (hasRequiredBrowser$c) return browser$d;
  hasRequiredBrowser$c = 1;
  var e = requireBrowserifyDes(), t = requireBrowser$d(), r = requireModes$1(), a = requireModes(), u = requireEvp_bytestokey();
  function n(s, p) {
    s = s.toLowerCase();
    var m, g;
    if (r[s])
      m = r[s].key, g = r[s].iv;
    else if (a[s])
      m = a[s].key * 8, g = a[s].iv;
    else
      throw new TypeError("invalid suite type");
    var y = u(p, !1, m, g);
    return c(s, y.key, y.iv);
  }
  function o(s, p) {
    s = s.toLowerCase();
    var m, g;
    if (r[s])
      m = r[s].key, g = r[s].iv;
    else if (a[s])
      m = a[s].key * 8, g = a[s].iv;
    else
      throw new TypeError("invalid suite type");
    var y = u(p, !1, m, g);
    return f(s, y.key, y.iv);
  }
  function c(s, p, m) {
    if (s = s.toLowerCase(), r[s]) return t.createCipheriv(s, p, m);
    if (a[s]) return new e({ key: p, iv: m, mode: s });
    throw new TypeError("invalid suite type");
  }
  function f(s, p, m) {
    if (s = s.toLowerCase(), r[s]) return t.createDecipheriv(s, p, m);
    if (a[s]) return new e({ key: p, iv: m, mode: s, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function l() {
    return Object.keys(a).concat(t.getCiphers());
  }
  return browser$d.createCipher = browser$d.Cipher = n, browser$d.createCipheriv = browser$d.Cipheriv = c, browser$d.createDecipher = browser$d.Decipher = o, browser$d.createDecipheriv = browser$d.Decipheriv = f, browser$d.listCiphers = browser$d.getCiphers = l, browser$d;
}
var browser$b = {}, bn$5 = { exports: {} }, bn$4 = bn$5.exports, hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, (function(e) {
    (function(t, r) {
      function a(te, R) {
        if (!te) throw new Error(R || "Assertion failed");
      }
      function u(te, R) {
        te.super_ = R;
        var M = function() {
        };
        M.prototype = R.prototype, te.prototype = new M(), te.prototype.constructor = te;
      }
      function n(te, R, M) {
        if (n.isBN(te))
          return te;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, te !== null && ((R === "le" || R === "be") && (M = R, R = 10), this._init(te || 0, R || 10, M || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var o;
      try {
        typeof globalThis < "u" && typeof globalThis.Buffer < "u" ? o = globalThis.Buffer : o = requireDist$1().Buffer;
      } catch {
      }
      n.isBN = function(R) {
        return R instanceof n ? !0 : R !== null && typeof R == "object" && R.constructor.wordSize === n.wordSize && Array.isArray(R.words);
      }, n.max = function(R, M) {
        return R.cmp(M) > 0 ? R : M;
      }, n.min = function(R, M) {
        return R.cmp(M) < 0 ? R : M;
      }, n.prototype._init = function(R, M, h) {
        if (typeof R == "number")
          return this._initNumber(R, M, h);
        if (typeof R == "object")
          return this._initArray(R, M, h);
        M === "hex" && (M = 16), a(M === (M | 0) && M >= 2 && M <= 36), R = R.toString().replace(/\s+/g, "");
        var S = 0;
        R[0] === "-" && (S++, this.negative = 1), S < R.length && (M === 16 ? this._parseHex(R, S, h) : (this._parseBase(R, M, S), h === "le" && this._initArray(this.toArray(), M, h)));
      }, n.prototype._initNumber = function(R, M, h) {
        R < 0 && (this.negative = 1, R = -R), R < 67108864 ? (this.words = [R & 67108863], this.length = 1) : R < 4503599627370496 ? (this.words = [
          R & 67108863,
          R / 67108864 & 67108863
        ], this.length = 2) : (a(R < 9007199254740992), this.words = [
          R & 67108863,
          R / 67108864 & 67108863,
          1
        ], this.length = 3), h === "le" && this._initArray(this.toArray(), M, h);
      }, n.prototype._initArray = function(R, M, h) {
        if (a(typeof R.length == "number"), R.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(R.length / 3), this.words = new Array(this.length);
        for (var S = 0; S < this.length; S++)
          this.words[S] = 0;
        var B, T, k = 0;
        if (h === "be")
          for (S = R.length - 1, B = 0; S >= 0; S -= 3)
            T = R[S] | R[S - 1] << 8 | R[S - 2] << 16, this.words[B] |= T << k & 67108863, this.words[B + 1] = T >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, B++);
        else if (h === "le")
          for (S = 0, B = 0; S < R.length; S += 3)
            T = R[S] | R[S + 1] << 8 | R[S + 2] << 16, this.words[B] |= T << k & 67108863, this.words[B + 1] = T >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, B++);
        return this.strip();
      };
      function c(te, R) {
        var M = te.charCodeAt(R);
        return M >= 65 && M <= 70 ? M - 55 : M >= 97 && M <= 102 ? M - 87 : M - 48 & 15;
      }
      function f(te, R, M) {
        var h = c(te, M);
        return M - 1 >= R && (h |= c(te, M - 1) << 4), h;
      }
      n.prototype._parseHex = function(R, M, h) {
        this.length = Math.ceil((R.length - M) / 6), this.words = new Array(this.length);
        for (var S = 0; S < this.length; S++)
          this.words[S] = 0;
        var B = 0, T = 0, k;
        if (h === "be")
          for (S = R.length - 1; S >= M; S -= 2)
            k = f(R, M, S) << B, this.words[T] |= k & 67108863, B >= 18 ? (B -= 18, T += 1, this.words[T] |= k >>> 26) : B += 8;
        else {
          var I = R.length - M;
          for (S = I % 2 === 0 ? M + 1 : M; S < R.length; S += 2)
            k = f(R, M, S) << B, this.words[T] |= k & 67108863, B >= 18 ? (B -= 18, T += 1, this.words[T] |= k >>> 26) : B += 8;
        }
        this.strip();
      };
      function l(te, R, M, h) {
        for (var S = 0, B = Math.min(te.length, M), T = R; T < B; T++) {
          var k = te.charCodeAt(T) - 48;
          S *= h, k >= 49 ? S += k - 49 + 10 : k >= 17 ? S += k - 17 + 10 : S += k;
        }
        return S;
      }
      n.prototype._parseBase = function(R, M, h) {
        this.words = [0], this.length = 1;
        for (var S = 0, B = 1; B <= 67108863; B *= M)
          S++;
        S--, B = B / M | 0;
        for (var T = R.length - h, k = T % S, I = Math.min(T, T - k) + h, C = 0, $ = h; $ < I; $ += S)
          C = l(R, $, $ + S, M), this.imuln(B), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
        if (k !== 0) {
          var w = 1;
          for (C = l(R, $, R.length, M), $ = 0; $ < k; $++)
            w *= M;
          this.imuln(w), this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
        }
        this.strip();
      }, n.prototype.copy = function(R) {
        R.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          R.words[M] = this.words[M];
        R.length = this.length, R.negative = this.negative, R.red = this.red;
      }, n.prototype.clone = function() {
        var R = new n(null);
        return this.copy(R), R;
      }, n.prototype._expand = function(R) {
        for (; this.length < R; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, n.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var s = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], p = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], m = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(R, M) {
        R = R || 10, M = M | 0 || 1;
        var h;
        if (R === 16 || R === "hex") {
          h = "";
          for (var S = 0, B = 0, T = 0; T < this.length; T++) {
            var k = this.words[T], I = ((k << S | B) & 16777215).toString(16);
            B = k >>> 24 - S & 16777215, S += 2, S >= 26 && (S -= 26, T--), B !== 0 || T !== this.length - 1 ? h = s[6 - I.length] + I + h : h = I + h;
          }
          for (B !== 0 && (h = B.toString(16) + h); h.length % M !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (R === (R | 0) && R >= 2 && R <= 36) {
          var C = p[R], $ = m[R];
          h = "";
          var w = this.clone();
          for (w.negative = 0; !w.isZero(); ) {
            var U = w.modn($).toString(R);
            w = w.idivn($), w.isZero() ? h = U + h : h = s[C - U.length] + U + h;
          }
          for (this.isZero() && (h = "0" + h); h.length % M !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        a(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var R = this.words[0];
        return this.length === 2 ? R += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? R += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -R : R;
      }, n.prototype.toJSON = function() {
        return this.toString(16);
      }, n.prototype.toBuffer = function(R, M) {
        return a(typeof o < "u"), this.toArrayLike(o, R, M);
      }, n.prototype.toArray = function(R, M) {
        return this.toArrayLike(Array, R, M);
      }, n.prototype.toArrayLike = function(R, M, h) {
        var S = this.byteLength(), B = h || Math.max(1, S);
        a(S <= B, "byte array longer than desired length"), a(B > 0, "Requested array length <= 0"), this.strip();
        var T = M === "le", k = new R(B), I, C, $ = this.clone();
        if (T) {
          for (C = 0; !$.isZero(); C++)
            I = $.andln(255), $.iushrn(8), k[C] = I;
          for (; C < B; C++)
            k[C] = 0;
        } else {
          for (C = 0; C < B - S; C++)
            k[C] = 0;
          for (C = 0; !$.isZero(); C++)
            I = $.andln(255), $.iushrn(8), k[B - C - 1] = I;
        }
        return k;
      }, Math.clz32 ? n.prototype._countBits = function(R) {
        return 32 - Math.clz32(R);
      } : n.prototype._countBits = function(R) {
        var M = R, h = 0;
        return M >= 4096 && (h += 13, M >>>= 13), M >= 64 && (h += 7, M >>>= 7), M >= 8 && (h += 4, M >>>= 4), M >= 2 && (h += 2, M >>>= 2), h + M;
      }, n.prototype._zeroBits = function(R) {
        if (R === 0) return 26;
        var M = R, h = 0;
        return (M & 8191) === 0 && (h += 13, M >>>= 13), (M & 127) === 0 && (h += 7, M >>>= 7), (M & 15) === 0 && (h += 4, M >>>= 4), (M & 3) === 0 && (h += 2, M >>>= 2), (M & 1) === 0 && h++, h;
      }, n.prototype.bitLength = function() {
        var R = this.words[this.length - 1], M = this._countBits(R);
        return (this.length - 1) * 26 + M;
      };
      function g(te) {
        for (var R = new Array(te.bitLength()), M = 0; M < R.length; M++) {
          var h = M / 26 | 0, S = M % 26;
          R[M] = (te.words[h] & 1 << S) >>> S;
        }
        return R;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var R = 0, M = 0; M < this.length; M++) {
          var h = this._zeroBits(this.words[M]);
          if (R += h, h !== 26) break;
        }
        return R;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(R) {
        return this.negative !== 0 ? this.abs().inotn(R).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(R) {
        return this.testn(R - 1) ? this.notn(R).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(R) {
        for (; this.length < R.length; )
          this.words[this.length++] = 0;
        for (var M = 0; M < R.length; M++)
          this.words[M] = this.words[M] | R.words[M];
        return this.strip();
      }, n.prototype.ior = function(R) {
        return a((this.negative | R.negative) === 0), this.iuor(R);
      }, n.prototype.or = function(R) {
        return this.length > R.length ? this.clone().ior(R) : R.clone().ior(this);
      }, n.prototype.uor = function(R) {
        return this.length > R.length ? this.clone().iuor(R) : R.clone().iuor(this);
      }, n.prototype.iuand = function(R) {
        var M;
        this.length > R.length ? M = R : M = this;
        for (var h = 0; h < M.length; h++)
          this.words[h] = this.words[h] & R.words[h];
        return this.length = M.length, this.strip();
      }, n.prototype.iand = function(R) {
        return a((this.negative | R.negative) === 0), this.iuand(R);
      }, n.prototype.and = function(R) {
        return this.length > R.length ? this.clone().iand(R) : R.clone().iand(this);
      }, n.prototype.uand = function(R) {
        return this.length > R.length ? this.clone().iuand(R) : R.clone().iuand(this);
      }, n.prototype.iuxor = function(R) {
        var M, h;
        this.length > R.length ? (M = this, h = R) : (M = R, h = this);
        for (var S = 0; S < h.length; S++)
          this.words[S] = M.words[S] ^ h.words[S];
        if (this !== M)
          for (; S < M.length; S++)
            this.words[S] = M.words[S];
        return this.length = M.length, this.strip();
      }, n.prototype.ixor = function(R) {
        return a((this.negative | R.negative) === 0), this.iuxor(R);
      }, n.prototype.xor = function(R) {
        return this.length > R.length ? this.clone().ixor(R) : R.clone().ixor(this);
      }, n.prototype.uxor = function(R) {
        return this.length > R.length ? this.clone().iuxor(R) : R.clone().iuxor(this);
      }, n.prototype.inotn = function(R) {
        a(typeof R == "number" && R >= 0);
        var M = Math.ceil(R / 26) | 0, h = R % 26;
        this._expand(M), h > 0 && M--;
        for (var S = 0; S < M; S++)
          this.words[S] = ~this.words[S] & 67108863;
        return h > 0 && (this.words[S] = ~this.words[S] & 67108863 >> 26 - h), this.strip();
      }, n.prototype.notn = function(R) {
        return this.clone().inotn(R);
      }, n.prototype.setn = function(R, M) {
        a(typeof R == "number" && R >= 0);
        var h = R / 26 | 0, S = R % 26;
        return this._expand(h + 1), M ? this.words[h] = this.words[h] | 1 << S : this.words[h] = this.words[h] & ~(1 << S), this.strip();
      }, n.prototype.iadd = function(R) {
        var M;
        if (this.negative !== 0 && R.negative === 0)
          return this.negative = 0, M = this.isub(R), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && R.negative !== 0)
          return R.negative = 0, M = this.isub(R), R.negative = 1, M._normSign();
        var h, S;
        this.length > R.length ? (h = this, S = R) : (h = R, S = this);
        for (var B = 0, T = 0; T < S.length; T++)
          M = (h.words[T] | 0) + (S.words[T] | 0) + B, this.words[T] = M & 67108863, B = M >>> 26;
        for (; B !== 0 && T < h.length; T++)
          M = (h.words[T] | 0) + B, this.words[T] = M & 67108863, B = M >>> 26;
        if (this.length = h.length, B !== 0)
          this.words[this.length] = B, this.length++;
        else if (h !== this)
          for (; T < h.length; T++)
            this.words[T] = h.words[T];
        return this;
      }, n.prototype.add = function(R) {
        var M;
        return R.negative !== 0 && this.negative === 0 ? (R.negative = 0, M = this.sub(R), R.negative ^= 1, M) : R.negative === 0 && this.negative !== 0 ? (this.negative = 0, M = R.sub(this), this.negative = 1, M) : this.length > R.length ? this.clone().iadd(R) : R.clone().iadd(this);
      }, n.prototype.isub = function(R) {
        if (R.negative !== 0) {
          R.negative = 0;
          var M = this.iadd(R);
          return R.negative = 1, M._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(R), this.negative = 1, this._normSign();
        var h = this.cmp(R);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var S, B;
        h > 0 ? (S = this, B = R) : (S = R, B = this);
        for (var T = 0, k = 0; k < B.length; k++)
          M = (S.words[k] | 0) - (B.words[k] | 0) + T, T = M >> 26, this.words[k] = M & 67108863;
        for (; T !== 0 && k < S.length; k++)
          M = (S.words[k] | 0) + T, T = M >> 26, this.words[k] = M & 67108863;
        if (T === 0 && k < S.length && S !== this)
          for (; k < S.length; k++)
            this.words[k] = S.words[k];
        return this.length = Math.max(this.length, k), S !== this && (this.negative = 1), this.strip();
      }, n.prototype.sub = function(R) {
        return this.clone().isub(R);
      };
      function y(te, R, M) {
        M.negative = R.negative ^ te.negative;
        var h = te.length + R.length | 0;
        M.length = h, h = h - 1 | 0;
        var S = te.words[0] | 0, B = R.words[0] | 0, T = S * B, k = T & 67108863, I = T / 67108864 | 0;
        M.words[0] = k;
        for (var C = 1; C < h; C++) {
          for (var $ = I >>> 26, w = I & 67108863, U = Math.min(C, R.length - 1), ie = Math.max(0, C - te.length + 1); ie <= U; ie++) {
            var le = C - ie | 0;
            S = te.words[le] | 0, B = R.words[ie] | 0, T = S * B + w, $ += T / 67108864 | 0, w = T & 67108863;
          }
          M.words[C] = w | 0, I = $ | 0;
        }
        return I !== 0 ? M.words[C] = I | 0 : M.length--, M.strip();
      }
      var v = function(R, M, h) {
        var S = R.words, B = M.words, T = h.words, k = 0, I, C, $, w = S[0] | 0, U = w & 8191, ie = w >>> 13, le = S[1] | 0, ee = le & 8191, F = le >>> 13, z = S[2] | 0, se = z & 8191, he = z >>> 13, ae = S[3] | 0, X = ae & 8191, be = ae >>> 13, Re = S[4] | 0, Pe = Re & 8191, Fe = Re >>> 13, De = S[5] | 0, je = De & 8191, Oe = De >>> 13, rt = S[6] | 0, He = rt & 8191, Qe = rt >>> 13, Je = S[7] | 0, we = Je & 8191, Ae = Je >>> 13, ze = S[8] | 0, Ue = ze & 8191, Ge = ze >>> 13, Xe = S[9] | 0, oe = Xe & 8191, L = Xe >>> 13, H = B[0] | 0, ue = H & 8191, xe = H >>> 13, pe = B[1] | 0, ce = pe & 8191, Y = pe >>> 13, Te = B[2] | 0, Ne = Te & 8191, K = Te >>> 13, Se = B[3] | 0, Ce = Se & 8191, de = Se >>> 13, _e = B[4] | 0, Me = _e & 8191, tt = _e >>> 13, We = B[5] | 0, ne = We & 8191, W = We >>> 13, J = B[6] | 0, me = J & 8191, Ee = J >>> 13, ke = B[7] | 0, Ie = ke & 8191, at = ke >>> 13, ot = B[8] | 0, it = ot & 8191, ct = ot >>> 13, nt = B[9] | 0, st = nt & 8191, yt = nt >>> 13;
        h.negative = R.negative ^ M.negative, h.length = 19, I = Math.imul(U, ue), C = Math.imul(U, xe), C = C + Math.imul(ie, ue) | 0, $ = Math.imul(ie, xe);
        var ft = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, I = Math.imul(ee, ue), C = Math.imul(ee, xe), C = C + Math.imul(F, ue) | 0, $ = Math.imul(F, xe), I = I + Math.imul(U, ce) | 0, C = C + Math.imul(U, Y) | 0, C = C + Math.imul(ie, ce) | 0, $ = $ + Math.imul(ie, Y) | 0;
        var dt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, I = Math.imul(se, ue), C = Math.imul(se, xe), C = C + Math.imul(he, ue) | 0, $ = Math.imul(he, xe), I = I + Math.imul(ee, ce) | 0, C = C + Math.imul(ee, Y) | 0, C = C + Math.imul(F, ce) | 0, $ = $ + Math.imul(F, Y) | 0, I = I + Math.imul(U, Ne) | 0, C = C + Math.imul(U, K) | 0, C = C + Math.imul(ie, Ne) | 0, $ = $ + Math.imul(ie, K) | 0;
        var Ut = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, I = Math.imul(X, ue), C = Math.imul(X, xe), C = C + Math.imul(be, ue) | 0, $ = Math.imul(be, xe), I = I + Math.imul(se, ce) | 0, C = C + Math.imul(se, Y) | 0, C = C + Math.imul(he, ce) | 0, $ = $ + Math.imul(he, Y) | 0, I = I + Math.imul(ee, Ne) | 0, C = C + Math.imul(ee, K) | 0, C = C + Math.imul(F, Ne) | 0, $ = $ + Math.imul(F, K) | 0, I = I + Math.imul(U, Ce) | 0, C = C + Math.imul(U, de) | 0, C = C + Math.imul(ie, Ce) | 0, $ = $ + Math.imul(ie, de) | 0;
        var Lt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, I = Math.imul(Pe, ue), C = Math.imul(Pe, xe), C = C + Math.imul(Fe, ue) | 0, $ = Math.imul(Fe, xe), I = I + Math.imul(X, ce) | 0, C = C + Math.imul(X, Y) | 0, C = C + Math.imul(be, ce) | 0, $ = $ + Math.imul(be, Y) | 0, I = I + Math.imul(se, Ne) | 0, C = C + Math.imul(se, K) | 0, C = C + Math.imul(he, Ne) | 0, $ = $ + Math.imul(he, K) | 0, I = I + Math.imul(ee, Ce) | 0, C = C + Math.imul(ee, de) | 0, C = C + Math.imul(F, Ce) | 0, $ = $ + Math.imul(F, de) | 0, I = I + Math.imul(U, Me) | 0, C = C + Math.imul(U, tt) | 0, C = C + Math.imul(ie, Me) | 0, $ = $ + Math.imul(ie, tt) | 0;
        var Dt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, I = Math.imul(je, ue), C = Math.imul(je, xe), C = C + Math.imul(Oe, ue) | 0, $ = Math.imul(Oe, xe), I = I + Math.imul(Pe, ce) | 0, C = C + Math.imul(Pe, Y) | 0, C = C + Math.imul(Fe, ce) | 0, $ = $ + Math.imul(Fe, Y) | 0, I = I + Math.imul(X, Ne) | 0, C = C + Math.imul(X, K) | 0, C = C + Math.imul(be, Ne) | 0, $ = $ + Math.imul(be, K) | 0, I = I + Math.imul(se, Ce) | 0, C = C + Math.imul(se, de) | 0, C = C + Math.imul(he, Ce) | 0, $ = $ + Math.imul(he, de) | 0, I = I + Math.imul(ee, Me) | 0, C = C + Math.imul(ee, tt) | 0, C = C + Math.imul(F, Me) | 0, $ = $ + Math.imul(F, tt) | 0, I = I + Math.imul(U, ne) | 0, C = C + Math.imul(U, W) | 0, C = C + Math.imul(ie, ne) | 0, $ = $ + Math.imul(ie, W) | 0;
        var Yt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, I = Math.imul(He, ue), C = Math.imul(He, xe), C = C + Math.imul(Qe, ue) | 0, $ = Math.imul(Qe, xe), I = I + Math.imul(je, ce) | 0, C = C + Math.imul(je, Y) | 0, C = C + Math.imul(Oe, ce) | 0, $ = $ + Math.imul(Oe, Y) | 0, I = I + Math.imul(Pe, Ne) | 0, C = C + Math.imul(Pe, K) | 0, C = C + Math.imul(Fe, Ne) | 0, $ = $ + Math.imul(Fe, K) | 0, I = I + Math.imul(X, Ce) | 0, C = C + Math.imul(X, de) | 0, C = C + Math.imul(be, Ce) | 0, $ = $ + Math.imul(be, de) | 0, I = I + Math.imul(se, Me) | 0, C = C + Math.imul(se, tt) | 0, C = C + Math.imul(he, Me) | 0, $ = $ + Math.imul(he, tt) | 0, I = I + Math.imul(ee, ne) | 0, C = C + Math.imul(ee, W) | 0, C = C + Math.imul(F, ne) | 0, $ = $ + Math.imul(F, W) | 0, I = I + Math.imul(U, me) | 0, C = C + Math.imul(U, Ee) | 0, C = C + Math.imul(ie, me) | 0, $ = $ + Math.imul(ie, Ee) | 0;
        var Kt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, I = Math.imul(we, ue), C = Math.imul(we, xe), C = C + Math.imul(Ae, ue) | 0, $ = Math.imul(Ae, xe), I = I + Math.imul(He, ce) | 0, C = C + Math.imul(He, Y) | 0, C = C + Math.imul(Qe, ce) | 0, $ = $ + Math.imul(Qe, Y) | 0, I = I + Math.imul(je, Ne) | 0, C = C + Math.imul(je, K) | 0, C = C + Math.imul(Oe, Ne) | 0, $ = $ + Math.imul(Oe, K) | 0, I = I + Math.imul(Pe, Ce) | 0, C = C + Math.imul(Pe, de) | 0, C = C + Math.imul(Fe, Ce) | 0, $ = $ + Math.imul(Fe, de) | 0, I = I + Math.imul(X, Me) | 0, C = C + Math.imul(X, tt) | 0, C = C + Math.imul(be, Me) | 0, $ = $ + Math.imul(be, tt) | 0, I = I + Math.imul(se, ne) | 0, C = C + Math.imul(se, W) | 0, C = C + Math.imul(he, ne) | 0, $ = $ + Math.imul(he, W) | 0, I = I + Math.imul(ee, me) | 0, C = C + Math.imul(ee, Ee) | 0, C = C + Math.imul(F, me) | 0, $ = $ + Math.imul(F, Ee) | 0, I = I + Math.imul(U, Ie) | 0, C = C + Math.imul(U, at) | 0, C = C + Math.imul(ie, Ie) | 0, $ = $ + Math.imul(ie, at) | 0;
        var Wt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, I = Math.imul(Ue, ue), C = Math.imul(Ue, xe), C = C + Math.imul(Ge, ue) | 0, $ = Math.imul(Ge, xe), I = I + Math.imul(we, ce) | 0, C = C + Math.imul(we, Y) | 0, C = C + Math.imul(Ae, ce) | 0, $ = $ + Math.imul(Ae, Y) | 0, I = I + Math.imul(He, Ne) | 0, C = C + Math.imul(He, K) | 0, C = C + Math.imul(Qe, Ne) | 0, $ = $ + Math.imul(Qe, K) | 0, I = I + Math.imul(je, Ce) | 0, C = C + Math.imul(je, de) | 0, C = C + Math.imul(Oe, Ce) | 0, $ = $ + Math.imul(Oe, de) | 0, I = I + Math.imul(Pe, Me) | 0, C = C + Math.imul(Pe, tt) | 0, C = C + Math.imul(Fe, Me) | 0, $ = $ + Math.imul(Fe, tt) | 0, I = I + Math.imul(X, ne) | 0, C = C + Math.imul(X, W) | 0, C = C + Math.imul(be, ne) | 0, $ = $ + Math.imul(be, W) | 0, I = I + Math.imul(se, me) | 0, C = C + Math.imul(se, Ee) | 0, C = C + Math.imul(he, me) | 0, $ = $ + Math.imul(he, Ee) | 0, I = I + Math.imul(ee, Ie) | 0, C = C + Math.imul(ee, at) | 0, C = C + Math.imul(F, Ie) | 0, $ = $ + Math.imul(F, at) | 0, I = I + Math.imul(U, it) | 0, C = C + Math.imul(U, ct) | 0, C = C + Math.imul(ie, it) | 0, $ = $ + Math.imul(ie, ct) | 0;
        var or = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, I = Math.imul(oe, ue), C = Math.imul(oe, xe), C = C + Math.imul(L, ue) | 0, $ = Math.imul(L, xe), I = I + Math.imul(Ue, ce) | 0, C = C + Math.imul(Ue, Y) | 0, C = C + Math.imul(Ge, ce) | 0, $ = $ + Math.imul(Ge, Y) | 0, I = I + Math.imul(we, Ne) | 0, C = C + Math.imul(we, K) | 0, C = C + Math.imul(Ae, Ne) | 0, $ = $ + Math.imul(Ae, K) | 0, I = I + Math.imul(He, Ce) | 0, C = C + Math.imul(He, de) | 0, C = C + Math.imul(Qe, Ce) | 0, $ = $ + Math.imul(Qe, de) | 0, I = I + Math.imul(je, Me) | 0, C = C + Math.imul(je, tt) | 0, C = C + Math.imul(Oe, Me) | 0, $ = $ + Math.imul(Oe, tt) | 0, I = I + Math.imul(Pe, ne) | 0, C = C + Math.imul(Pe, W) | 0, C = C + Math.imul(Fe, ne) | 0, $ = $ + Math.imul(Fe, W) | 0, I = I + Math.imul(X, me) | 0, C = C + Math.imul(X, Ee) | 0, C = C + Math.imul(be, me) | 0, $ = $ + Math.imul(be, Ee) | 0, I = I + Math.imul(se, Ie) | 0, C = C + Math.imul(se, at) | 0, C = C + Math.imul(he, Ie) | 0, $ = $ + Math.imul(he, at) | 0, I = I + Math.imul(ee, it) | 0, C = C + Math.imul(ee, ct) | 0, C = C + Math.imul(F, it) | 0, $ = $ + Math.imul(F, ct) | 0, I = I + Math.imul(U, st) | 0, C = C + Math.imul(U, yt) | 0, C = C + Math.imul(ie, st) | 0, $ = $ + Math.imul(ie, yt) | 0;
        var Gt = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, I = Math.imul(oe, ce), C = Math.imul(oe, Y), C = C + Math.imul(L, ce) | 0, $ = Math.imul(L, Y), I = I + Math.imul(Ue, Ne) | 0, C = C + Math.imul(Ue, K) | 0, C = C + Math.imul(Ge, Ne) | 0, $ = $ + Math.imul(Ge, K) | 0, I = I + Math.imul(we, Ce) | 0, C = C + Math.imul(we, de) | 0, C = C + Math.imul(Ae, Ce) | 0, $ = $ + Math.imul(Ae, de) | 0, I = I + Math.imul(He, Me) | 0, C = C + Math.imul(He, tt) | 0, C = C + Math.imul(Qe, Me) | 0, $ = $ + Math.imul(Qe, tt) | 0, I = I + Math.imul(je, ne) | 0, C = C + Math.imul(je, W) | 0, C = C + Math.imul(Oe, ne) | 0, $ = $ + Math.imul(Oe, W) | 0, I = I + Math.imul(Pe, me) | 0, C = C + Math.imul(Pe, Ee) | 0, C = C + Math.imul(Fe, me) | 0, $ = $ + Math.imul(Fe, Ee) | 0, I = I + Math.imul(X, Ie) | 0, C = C + Math.imul(X, at) | 0, C = C + Math.imul(be, Ie) | 0, $ = $ + Math.imul(be, at) | 0, I = I + Math.imul(se, it) | 0, C = C + Math.imul(se, ct) | 0, C = C + Math.imul(he, it) | 0, $ = $ + Math.imul(he, ct) | 0, I = I + Math.imul(ee, st) | 0, C = C + Math.imul(ee, yt) | 0, C = C + Math.imul(F, st) | 0, $ = $ + Math.imul(F, yt) | 0;
        var cr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, I = Math.imul(oe, Ne), C = Math.imul(oe, K), C = C + Math.imul(L, Ne) | 0, $ = Math.imul(L, K), I = I + Math.imul(Ue, Ce) | 0, C = C + Math.imul(Ue, de) | 0, C = C + Math.imul(Ge, Ce) | 0, $ = $ + Math.imul(Ge, de) | 0, I = I + Math.imul(we, Me) | 0, C = C + Math.imul(we, tt) | 0, C = C + Math.imul(Ae, Me) | 0, $ = $ + Math.imul(Ae, tt) | 0, I = I + Math.imul(He, ne) | 0, C = C + Math.imul(He, W) | 0, C = C + Math.imul(Qe, ne) | 0, $ = $ + Math.imul(Qe, W) | 0, I = I + Math.imul(je, me) | 0, C = C + Math.imul(je, Ee) | 0, C = C + Math.imul(Oe, me) | 0, $ = $ + Math.imul(Oe, Ee) | 0, I = I + Math.imul(Pe, Ie) | 0, C = C + Math.imul(Pe, at) | 0, C = C + Math.imul(Fe, Ie) | 0, $ = $ + Math.imul(Fe, at) | 0, I = I + Math.imul(X, it) | 0, C = C + Math.imul(X, ct) | 0, C = C + Math.imul(be, it) | 0, $ = $ + Math.imul(be, ct) | 0, I = I + Math.imul(se, st) | 0, C = C + Math.imul(se, yt) | 0, C = C + Math.imul(he, st) | 0, $ = $ + Math.imul(he, yt) | 0;
        var ur = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, I = Math.imul(oe, Ce), C = Math.imul(oe, de), C = C + Math.imul(L, Ce) | 0, $ = Math.imul(L, de), I = I + Math.imul(Ue, Me) | 0, C = C + Math.imul(Ue, tt) | 0, C = C + Math.imul(Ge, Me) | 0, $ = $ + Math.imul(Ge, tt) | 0, I = I + Math.imul(we, ne) | 0, C = C + Math.imul(we, W) | 0, C = C + Math.imul(Ae, ne) | 0, $ = $ + Math.imul(Ae, W) | 0, I = I + Math.imul(He, me) | 0, C = C + Math.imul(He, Ee) | 0, C = C + Math.imul(Qe, me) | 0, $ = $ + Math.imul(Qe, Ee) | 0, I = I + Math.imul(je, Ie) | 0, C = C + Math.imul(je, at) | 0, C = C + Math.imul(Oe, Ie) | 0, $ = $ + Math.imul(Oe, at) | 0, I = I + Math.imul(Pe, it) | 0, C = C + Math.imul(Pe, ct) | 0, C = C + Math.imul(Fe, it) | 0, $ = $ + Math.imul(Fe, ct) | 0, I = I + Math.imul(X, st) | 0, C = C + Math.imul(X, yt) | 0, C = C + Math.imul(be, st) | 0, $ = $ + Math.imul(be, yt) | 0;
        var lr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, I = Math.imul(oe, Me), C = Math.imul(oe, tt), C = C + Math.imul(L, Me) | 0, $ = Math.imul(L, tt), I = I + Math.imul(Ue, ne) | 0, C = C + Math.imul(Ue, W) | 0, C = C + Math.imul(Ge, ne) | 0, $ = $ + Math.imul(Ge, W) | 0, I = I + Math.imul(we, me) | 0, C = C + Math.imul(we, Ee) | 0, C = C + Math.imul(Ae, me) | 0, $ = $ + Math.imul(Ae, Ee) | 0, I = I + Math.imul(He, Ie) | 0, C = C + Math.imul(He, at) | 0, C = C + Math.imul(Qe, Ie) | 0, $ = $ + Math.imul(Qe, at) | 0, I = I + Math.imul(je, it) | 0, C = C + Math.imul(je, ct) | 0, C = C + Math.imul(Oe, it) | 0, $ = $ + Math.imul(Oe, ct) | 0, I = I + Math.imul(Pe, st) | 0, C = C + Math.imul(Pe, yt) | 0, C = C + Math.imul(Fe, st) | 0, $ = $ + Math.imul(Fe, yt) | 0;
        var er = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, I = Math.imul(oe, ne), C = Math.imul(oe, W), C = C + Math.imul(L, ne) | 0, $ = Math.imul(L, W), I = I + Math.imul(Ue, me) | 0, C = C + Math.imul(Ue, Ee) | 0, C = C + Math.imul(Ge, me) | 0, $ = $ + Math.imul(Ge, Ee) | 0, I = I + Math.imul(we, Ie) | 0, C = C + Math.imul(we, at) | 0, C = C + Math.imul(Ae, Ie) | 0, $ = $ + Math.imul(Ae, at) | 0, I = I + Math.imul(He, it) | 0, C = C + Math.imul(He, ct) | 0, C = C + Math.imul(Qe, it) | 0, $ = $ + Math.imul(Qe, ct) | 0, I = I + Math.imul(je, st) | 0, C = C + Math.imul(je, yt) | 0, C = C + Math.imul(Oe, st) | 0, $ = $ + Math.imul(Oe, yt) | 0;
        var tr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, I = Math.imul(oe, me), C = Math.imul(oe, Ee), C = C + Math.imul(L, me) | 0, $ = Math.imul(L, Ee), I = I + Math.imul(Ue, Ie) | 0, C = C + Math.imul(Ue, at) | 0, C = C + Math.imul(Ge, Ie) | 0, $ = $ + Math.imul(Ge, at) | 0, I = I + Math.imul(we, it) | 0, C = C + Math.imul(we, ct) | 0, C = C + Math.imul(Ae, it) | 0, $ = $ + Math.imul(Ae, ct) | 0, I = I + Math.imul(He, st) | 0, C = C + Math.imul(He, yt) | 0, C = C + Math.imul(Qe, st) | 0, $ = $ + Math.imul(Qe, yt) | 0;
        var rr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, I = Math.imul(oe, Ie), C = Math.imul(oe, at), C = C + Math.imul(L, Ie) | 0, $ = Math.imul(L, at), I = I + Math.imul(Ue, it) | 0, C = C + Math.imul(Ue, ct) | 0, C = C + Math.imul(Ge, it) | 0, $ = $ + Math.imul(Ge, ct) | 0, I = I + Math.imul(we, st) | 0, C = C + Math.imul(we, yt) | 0, C = C + Math.imul(Ae, st) | 0, $ = $ + Math.imul(Ae, yt) | 0;
        var fr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, I = Math.imul(oe, it), C = Math.imul(oe, ct), C = C + Math.imul(L, it) | 0, $ = Math.imul(L, ct), I = I + Math.imul(Ue, st) | 0, C = C + Math.imul(Ue, yt) | 0, C = C + Math.imul(Ge, st) | 0, $ = $ + Math.imul(Ge, yt) | 0;
        var pr = (k + I | 0) + ((C & 8191) << 13) | 0;
        k = ($ + (C >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, I = Math.imul(oe, st), C = Math.imul(oe, yt), C = C + Math.imul(L, st) | 0, $ = Math.imul(L, yt);
        var dr = (k + I | 0) + ((C & 8191) << 13) | 0;
        return k = ($ + (C >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, T[0] = ft, T[1] = dt, T[2] = Ut, T[3] = Lt, T[4] = Dt, T[5] = Yt, T[6] = Kt, T[7] = Wt, T[8] = or, T[9] = Gt, T[10] = cr, T[11] = ur, T[12] = lr, T[13] = er, T[14] = tr, T[15] = rr, T[16] = fr, T[17] = pr, T[18] = dr, k !== 0 && (T[19] = k, h.length++), h;
      };
      Math.imul || (v = y);
      function E(te, R, M) {
        M.negative = R.negative ^ te.negative, M.length = te.length + R.length;
        for (var h = 0, S = 0, B = 0; B < M.length - 1; B++) {
          var T = S;
          S = 0;
          for (var k = h & 67108863, I = Math.min(B, R.length - 1), C = Math.max(0, B - te.length + 1); C <= I; C++) {
            var $ = B - C, w = te.words[$] | 0, U = R.words[C] | 0, ie = w * U, le = ie & 67108863;
            T = T + (ie / 67108864 | 0) | 0, le = le + k | 0, k = le & 67108863, T = T + (le >>> 26) | 0, S += T >>> 26, T &= 67108863;
          }
          M.words[B] = k, h = T, T = S;
        }
        return h !== 0 ? M.words[B] = h : M.length--, M.strip();
      }
      function b(te, R, M) {
        var h = new q();
        return h.mulp(te, R, M);
      }
      n.prototype.mulTo = function(R, M) {
        var h, S = this.length + R.length;
        return this.length === 10 && R.length === 10 ? h = v(this, R, M) : S < 63 ? h = y(this, R, M) : S < 1024 ? h = E(this, R, M) : h = b(this, R, M), h;
      };
      function q(te, R) {
        this.x = te, this.y = R;
      }
      q.prototype.makeRBT = function(R) {
        for (var M = new Array(R), h = n.prototype._countBits(R) - 1, S = 0; S < R; S++)
          M[S] = this.revBin(S, h, R);
        return M;
      }, q.prototype.revBin = function(R, M, h) {
        if (R === 0 || R === h - 1) return R;
        for (var S = 0, B = 0; B < M; B++)
          S |= (R & 1) << M - B - 1, R >>= 1;
        return S;
      }, q.prototype.permute = function(R, M, h, S, B, T) {
        for (var k = 0; k < T; k++)
          S[k] = M[R[k]], B[k] = h[R[k]];
      }, q.prototype.transform = function(R, M, h, S, B, T) {
        this.permute(T, R, M, h, S, B);
        for (var k = 1; k < B; k <<= 1)
          for (var I = k << 1, C = Math.cos(2 * Math.PI / I), $ = Math.sin(2 * Math.PI / I), w = 0; w < B; w += I)
            for (var U = C, ie = $, le = 0; le < k; le++) {
              var ee = h[w + le], F = S[w + le], z = h[w + le + k], se = S[w + le + k], he = U * z - ie * se;
              se = U * se + ie * z, z = he, h[w + le] = ee + z, S[w + le] = F + se, h[w + le + k] = ee - z, S[w + le + k] = F - se, le !== I && (he = C * U - $ * ie, ie = C * ie + $ * U, U = he);
            }
      }, q.prototype.guessLen13b = function(R, M) {
        var h = Math.max(M, R) | 1, S = h & 1, B = 0;
        for (h = h / 2 | 0; h; h = h >>> 1)
          B++;
        return 1 << B + 1 + S;
      }, q.prototype.conjugate = function(R, M, h) {
        if (!(h <= 1))
          for (var S = 0; S < h / 2; S++) {
            var B = R[S];
            R[S] = R[h - S - 1], R[h - S - 1] = B, B = M[S], M[S] = -M[h - S - 1], M[h - S - 1] = -B;
          }
      }, q.prototype.normalize13b = function(R, M) {
        for (var h = 0, S = 0; S < M / 2; S++) {
          var B = Math.round(R[2 * S + 1] / M) * 8192 + Math.round(R[2 * S] / M) + h;
          R[S] = B & 67108863, B < 67108864 ? h = 0 : h = B / 67108864 | 0;
        }
        return R;
      }, q.prototype.convert13b = function(R, M, h, S) {
        for (var B = 0, T = 0; T < M; T++)
          B = B + (R[T] | 0), h[2 * T] = B & 8191, B = B >>> 13, h[2 * T + 1] = B & 8191, B = B >>> 13;
        for (T = 2 * M; T < S; ++T)
          h[T] = 0;
        a(B === 0), a((B & -8192) === 0);
      }, q.prototype.stub = function(R) {
        for (var M = new Array(R), h = 0; h < R; h++)
          M[h] = 0;
        return M;
      }, q.prototype.mulp = function(R, M, h) {
        var S = 2 * this.guessLen13b(R.length, M.length), B = this.makeRBT(S), T = this.stub(S), k = new Array(S), I = new Array(S), C = new Array(S), $ = new Array(S), w = new Array(S), U = new Array(S), ie = h.words;
        ie.length = S, this.convert13b(R.words, R.length, k, S), this.convert13b(M.words, M.length, $, S), this.transform(k, T, I, C, S, B), this.transform($, T, w, U, S, B);
        for (var le = 0; le < S; le++) {
          var ee = I[le] * w[le] - C[le] * U[le];
          C[le] = I[le] * U[le] + C[le] * w[le], I[le] = ee;
        }
        return this.conjugate(I, C, S), this.transform(I, C, ie, T, S, B), this.conjugate(ie, T, S), this.normalize13b(ie, S), h.negative = R.negative ^ M.negative, h.length = R.length + M.length, h.strip();
      }, n.prototype.mul = function(R) {
        var M = new n(null);
        return M.words = new Array(this.length + R.length), this.mulTo(R, M);
      }, n.prototype.mulf = function(R) {
        var M = new n(null);
        return M.words = new Array(this.length + R.length), b(this, R, M);
      }, n.prototype.imul = function(R) {
        return this.clone().mulTo(R, this);
      }, n.prototype.imuln = function(R) {
        a(typeof R == "number"), a(R < 67108864);
        for (var M = 0, h = 0; h < this.length; h++) {
          var S = (this.words[h] | 0) * R, B = (S & 67108863) + (M & 67108863);
          M >>= 26, M += S / 67108864 | 0, M += B >>> 26, this.words[h] = B & 67108863;
        }
        return M !== 0 && (this.words[h] = M, this.length++), this.length = R === 0 ? 1 : this.length, this;
      }, n.prototype.muln = function(R) {
        return this.clone().imuln(R);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(R) {
        var M = g(R);
        if (M.length === 0) return new n(1);
        for (var h = this, S = 0; S < M.length && M[S] === 0; S++, h = h.sqr())
          ;
        if (++S < M.length)
          for (var B = h.sqr(); S < M.length; S++, B = B.sqr())
            M[S] !== 0 && (h = h.mul(B));
        return h;
      }, n.prototype.iushln = function(R) {
        a(typeof R == "number" && R >= 0);
        var M = R % 26, h = (R - M) / 26, S = 67108863 >>> 26 - M << 26 - M, B;
        if (M !== 0) {
          var T = 0;
          for (B = 0; B < this.length; B++) {
            var k = this.words[B] & S, I = (this.words[B] | 0) - k << M;
            this.words[B] = I | T, T = k >>> 26 - M;
          }
          T && (this.words[B] = T, this.length++);
        }
        if (h !== 0) {
          for (B = this.length - 1; B >= 0; B--)
            this.words[B + h] = this.words[B];
          for (B = 0; B < h; B++)
            this.words[B] = 0;
          this.length += h;
        }
        return this.strip();
      }, n.prototype.ishln = function(R) {
        return a(this.negative === 0), this.iushln(R);
      }, n.prototype.iushrn = function(R, M, h) {
        a(typeof R == "number" && R >= 0);
        var S;
        M ? S = (M - M % 26) / 26 : S = 0;
        var B = R % 26, T = Math.min((R - B) / 26, this.length), k = 67108863 ^ 67108863 >>> B << B, I = h;
        if (S -= T, S = Math.max(0, S), I) {
          for (var C = 0; C < T; C++)
            I.words[C] = this.words[C];
          I.length = T;
        }
        if (T !== 0) if (this.length > T)
          for (this.length -= T, C = 0; C < this.length; C++)
            this.words[C] = this.words[C + T];
        else
          this.words[0] = 0, this.length = 1;
        var $ = 0;
        for (C = this.length - 1; C >= 0 && ($ !== 0 || C >= S); C--) {
          var w = this.words[C] | 0;
          this.words[C] = $ << 26 - B | w >>> B, $ = w & k;
        }
        return I && $ !== 0 && (I.words[I.length++] = $), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, n.prototype.ishrn = function(R, M, h) {
        return a(this.negative === 0), this.iushrn(R, M, h);
      }, n.prototype.shln = function(R) {
        return this.clone().ishln(R);
      }, n.prototype.ushln = function(R) {
        return this.clone().iushln(R);
      }, n.prototype.shrn = function(R) {
        return this.clone().ishrn(R);
      }, n.prototype.ushrn = function(R) {
        return this.clone().iushrn(R);
      }, n.prototype.testn = function(R) {
        a(typeof R == "number" && R >= 0);
        var M = R % 26, h = (R - M) / 26, S = 1 << M;
        if (this.length <= h) return !1;
        var B = this.words[h];
        return !!(B & S);
      }, n.prototype.imaskn = function(R) {
        a(typeof R == "number" && R >= 0);
        var M = R % 26, h = (R - M) / 26;
        if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (M !== 0 && h++, this.length = Math.min(h, this.length), M !== 0) {
          var S = 67108863 ^ 67108863 >>> M << M;
          this.words[this.length - 1] &= S;
        }
        return this.strip();
      }, n.prototype.maskn = function(R) {
        return this.clone().imaskn(R);
      }, n.prototype.iaddn = function(R) {
        return a(typeof R == "number"), a(R < 67108864), R < 0 ? this.isubn(-R) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < R ? (this.words[0] = R - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(R), this.negative = 1, this) : this._iaddn(R);
      }, n.prototype._iaddn = function(R) {
        this.words[0] += R;
        for (var M = 0; M < this.length && this.words[M] >= 67108864; M++)
          this.words[M] -= 67108864, M === this.length - 1 ? this.words[M + 1] = 1 : this.words[M + 1]++;
        return this.length = Math.max(this.length, M + 1), this;
      }, n.prototype.isubn = function(R) {
        if (a(typeof R == "number"), a(R < 67108864), R < 0) return this.iaddn(-R);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(R), this.negative = 1, this;
        if (this.words[0] -= R, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var M = 0; M < this.length && this.words[M] < 0; M++)
            this.words[M] += 67108864, this.words[M + 1] -= 1;
        return this.strip();
      }, n.prototype.addn = function(R) {
        return this.clone().iaddn(R);
      }, n.prototype.subn = function(R) {
        return this.clone().isubn(R);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(R, M, h) {
        var S = R.length + h, B;
        this._expand(S);
        var T, k = 0;
        for (B = 0; B < R.length; B++) {
          T = (this.words[B + h] | 0) + k;
          var I = (R.words[B] | 0) * M;
          T -= I & 67108863, k = (T >> 26) - (I / 67108864 | 0), this.words[B + h] = T & 67108863;
        }
        for (; B < this.length - h; B++)
          T = (this.words[B + h] | 0) + k, k = T >> 26, this.words[B + h] = T & 67108863;
        if (k === 0) return this.strip();
        for (a(k === -1), k = 0, B = 0; B < this.length; B++)
          T = -(this.words[B] | 0) + k, k = T >> 26, this.words[B] = T & 67108863;
        return this.negative = 1, this.strip();
      }, n.prototype._wordDiv = function(R, M) {
        var h = this.length - R.length, S = this.clone(), B = R, T = B.words[B.length - 1] | 0, k = this._countBits(T);
        h = 26 - k, h !== 0 && (B = B.ushln(h), S.iushln(h), T = B.words[B.length - 1] | 0);
        var I = S.length - B.length, C;
        if (M !== "mod") {
          C = new n(null), C.length = I + 1, C.words = new Array(C.length);
          for (var $ = 0; $ < C.length; $++)
            C.words[$] = 0;
        }
        var w = S.clone()._ishlnsubmul(B, 1, I);
        w.negative === 0 && (S = w, C && (C.words[I] = 1));
        for (var U = I - 1; U >= 0; U--) {
          var ie = (S.words[B.length + U] | 0) * 67108864 + (S.words[B.length + U - 1] | 0);
          for (ie = Math.min(ie / T | 0, 67108863), S._ishlnsubmul(B, ie, U); S.negative !== 0; )
            ie--, S.negative = 0, S._ishlnsubmul(B, 1, U), S.isZero() || (S.negative ^= 1);
          C && (C.words[U] = ie);
        }
        return C && C.strip(), S.strip(), M !== "div" && h !== 0 && S.iushrn(h), {
          div: C || null,
          mod: S
        };
      }, n.prototype.divmod = function(R, M, h) {
        if (a(!R.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var S, B, T;
        return this.negative !== 0 && R.negative === 0 ? (T = this.neg().divmod(R, M), M !== "mod" && (S = T.div.neg()), M !== "div" && (B = T.mod.neg(), h && B.negative !== 0 && B.iadd(R)), {
          div: S,
          mod: B
        }) : this.negative === 0 && R.negative !== 0 ? (T = this.divmod(R.neg(), M), M !== "mod" && (S = T.div.neg()), {
          div: S,
          mod: T.mod
        }) : (this.negative & R.negative) !== 0 ? (T = this.neg().divmod(R.neg(), M), M !== "div" && (B = T.mod.neg(), h && B.negative !== 0 && B.isub(R)), {
          div: T.div,
          mod: B
        }) : R.length > this.length || this.cmp(R) < 0 ? {
          div: new n(0),
          mod: this
        } : R.length === 1 ? M === "div" ? {
          div: this.divn(R.words[0]),
          mod: null
        } : M === "mod" ? {
          div: null,
          mod: new n(this.modn(R.words[0]))
        } : {
          div: this.divn(R.words[0]),
          mod: new n(this.modn(R.words[0]))
        } : this._wordDiv(R, M);
      }, n.prototype.div = function(R) {
        return this.divmod(R, "div", !1).div;
      }, n.prototype.mod = function(R) {
        return this.divmod(R, "mod", !1).mod;
      }, n.prototype.umod = function(R) {
        return this.divmod(R, "mod", !0).mod;
      }, n.prototype.divRound = function(R) {
        var M = this.divmod(R);
        if (M.mod.isZero()) return M.div;
        var h = M.div.negative !== 0 ? M.mod.isub(R) : M.mod, S = R.ushrn(1), B = R.andln(1), T = h.cmp(S);
        return T < 0 || B === 1 && T === 0 ? M.div : M.div.negative !== 0 ? M.div.isubn(1) : M.div.iaddn(1);
      }, n.prototype.modn = function(R) {
        a(R <= 67108863);
        for (var M = (1 << 26) % R, h = 0, S = this.length - 1; S >= 0; S--)
          h = (M * h + (this.words[S] | 0)) % R;
        return h;
      }, n.prototype.idivn = function(R) {
        a(R <= 67108863);
        for (var M = 0, h = this.length - 1; h >= 0; h--) {
          var S = (this.words[h] | 0) + M * 67108864;
          this.words[h] = S / R | 0, M = S % R;
        }
        return this.strip();
      }, n.prototype.divn = function(R) {
        return this.clone().idivn(R);
      }, n.prototype.egcd = function(R) {
        a(R.negative === 0), a(!R.isZero());
        var M = this, h = R.clone();
        M.negative !== 0 ? M = M.umod(R) : M = M.clone();
        for (var S = new n(1), B = new n(0), T = new n(0), k = new n(1), I = 0; M.isEven() && h.isEven(); )
          M.iushrn(1), h.iushrn(1), ++I;
        for (var C = h.clone(), $ = M.clone(); !M.isZero(); ) {
          for (var w = 0, U = 1; (M.words[0] & U) === 0 && w < 26; ++w, U <<= 1) ;
          if (w > 0)
            for (M.iushrn(w); w-- > 0; )
              (S.isOdd() || B.isOdd()) && (S.iadd(C), B.isub($)), S.iushrn(1), B.iushrn(1);
          for (var ie = 0, le = 1; (h.words[0] & le) === 0 && ie < 26; ++ie, le <<= 1) ;
          if (ie > 0)
            for (h.iushrn(ie); ie-- > 0; )
              (T.isOdd() || k.isOdd()) && (T.iadd(C), k.isub($)), T.iushrn(1), k.iushrn(1);
          M.cmp(h) >= 0 ? (M.isub(h), S.isub(T), B.isub(k)) : (h.isub(M), T.isub(S), k.isub(B));
        }
        return {
          a: T,
          b: k,
          gcd: h.iushln(I)
        };
      }, n.prototype._invmp = function(R) {
        a(R.negative === 0), a(!R.isZero());
        var M = this, h = R.clone();
        M.negative !== 0 ? M = M.umod(R) : M = M.clone();
        for (var S = new n(1), B = new n(0), T = h.clone(); M.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var k = 0, I = 1; (M.words[0] & I) === 0 && k < 26; ++k, I <<= 1) ;
          if (k > 0)
            for (M.iushrn(k); k-- > 0; )
              S.isOdd() && S.iadd(T), S.iushrn(1);
          for (var C = 0, $ = 1; (h.words[0] & $) === 0 && C < 26; ++C, $ <<= 1) ;
          if (C > 0)
            for (h.iushrn(C); C-- > 0; )
              B.isOdd() && B.iadd(T), B.iushrn(1);
          M.cmp(h) >= 0 ? (M.isub(h), S.isub(B)) : (h.isub(M), B.isub(S));
        }
        var w;
        return M.cmpn(1) === 0 ? w = S : w = B, w.cmpn(0) < 0 && w.iadd(R), w;
      }, n.prototype.gcd = function(R) {
        if (this.isZero()) return R.abs();
        if (R.isZero()) return this.abs();
        var M = this.clone(), h = R.clone();
        M.negative = 0, h.negative = 0;
        for (var S = 0; M.isEven() && h.isEven(); S++)
          M.iushrn(1), h.iushrn(1);
        do {
          for (; M.isEven(); )
            M.iushrn(1);
          for (; h.isEven(); )
            h.iushrn(1);
          var B = M.cmp(h);
          if (B < 0) {
            var T = M;
            M = h, h = T;
          } else if (B === 0 || h.cmpn(1) === 0)
            break;
          M.isub(h);
        } while (!0);
        return h.iushln(S);
      }, n.prototype.invm = function(R) {
        return this.egcd(R).a.umod(R);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(R) {
        return this.words[0] & R;
      }, n.prototype.bincn = function(R) {
        a(typeof R == "number");
        var M = R % 26, h = (R - M) / 26, S = 1 << M;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= S, this;
        for (var B = S, T = h; B !== 0 && T < this.length; T++) {
          var k = this.words[T] | 0;
          k += B, B = k >>> 26, k &= 67108863, this.words[T] = k;
        }
        return B !== 0 && (this.words[T] = B, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(R) {
        var M = R < 0;
        if (this.negative !== 0 && !M) return -1;
        if (this.negative === 0 && M) return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          M && (R = -R), a(R <= 67108863, "Number is too big");
          var S = this.words[0] | 0;
          h = S === R ? 0 : S < R ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, n.prototype.cmp = function(R) {
        if (this.negative !== 0 && R.negative === 0) return -1;
        if (this.negative === 0 && R.negative !== 0) return 1;
        var M = this.ucmp(R);
        return this.negative !== 0 ? -M | 0 : M;
      }, n.prototype.ucmp = function(R) {
        if (this.length > R.length) return 1;
        if (this.length < R.length) return -1;
        for (var M = 0, h = this.length - 1; h >= 0; h--) {
          var S = this.words[h] | 0, B = R.words[h] | 0;
          if (S !== B) {
            S < B ? M = -1 : S > B && (M = 1);
            break;
          }
        }
        return M;
      }, n.prototype.gtn = function(R) {
        return this.cmpn(R) === 1;
      }, n.prototype.gt = function(R) {
        return this.cmp(R) === 1;
      }, n.prototype.gten = function(R) {
        return this.cmpn(R) >= 0;
      }, n.prototype.gte = function(R) {
        return this.cmp(R) >= 0;
      }, n.prototype.ltn = function(R) {
        return this.cmpn(R) === -1;
      }, n.prototype.lt = function(R) {
        return this.cmp(R) === -1;
      }, n.prototype.lten = function(R) {
        return this.cmpn(R) <= 0;
      }, n.prototype.lte = function(R) {
        return this.cmp(R) <= 0;
      }, n.prototype.eqn = function(R) {
        return this.cmpn(R) === 0;
      }, n.prototype.eq = function(R) {
        return this.cmp(R) === 0;
      }, n.red = function(R) {
        return new re(R);
      }, n.prototype.toRed = function(R) {
        return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), R.convertTo(this)._forceRed(R);
      }, n.prototype.fromRed = function() {
        return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(R) {
        return this.red = R, this;
      }, n.prototype.forceRed = function(R) {
        return a(!this.red, "Already a number in reduction context"), this._forceRed(R);
      }, n.prototype.redAdd = function(R) {
        return a(this.red, "redAdd works only with red numbers"), this.red.add(this, R);
      }, n.prototype.redIAdd = function(R) {
        return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, R);
      }, n.prototype.redSub = function(R) {
        return a(this.red, "redSub works only with red numbers"), this.red.sub(this, R);
      }, n.prototype.redISub = function(R) {
        return a(this.red, "redISub works only with red numbers"), this.red.isub(this, R);
      }, n.prototype.redShl = function(R) {
        return a(this.red, "redShl works only with red numbers"), this.red.shl(this, R);
      }, n.prototype.redMul = function(R) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, R), this.red.mul(this, R);
      }, n.prototype.redIMul = function(R) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, R), this.red.imul(this, R);
      }, n.prototype.redSqr = function() {
        return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(R) {
        return a(this.red && !R.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, R);
      };
      var O = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function j(te, R) {
        this.name = te, this.p = new n(R, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      j.prototype._tmp = function() {
        var R = new n(null);
        return R.words = new Array(Math.ceil(this.n / 13)), R;
      }, j.prototype.ireduce = function(R) {
        var M = R, h;
        do
          this.split(M, this.tmp), M = this.imulK(M), M = M.iadd(this.tmp), h = M.bitLength();
        while (h > this.n);
        var S = h < this.n ? -1 : M.ucmp(this.p);
        return S === 0 ? (M.words[0] = 0, M.length = 1) : S > 0 ? M.isub(this.p) : M.strip !== void 0 ? M.strip() : M._strip(), M;
      }, j.prototype.split = function(R, M) {
        R.iushrn(this.n, 0, M);
      }, j.prototype.imulK = function(R) {
        return R.imul(this.k);
      };
      function D() {
        j.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      u(D, j), D.prototype.split = function(R, M) {
        for (var h = 4194303, S = Math.min(R.length, 9), B = 0; B < S; B++)
          M.words[B] = R.words[B];
        if (M.length = S, R.length <= 9) {
          R.words[0] = 0, R.length = 1;
          return;
        }
        var T = R.words[9];
        for (M.words[M.length++] = T & h, B = 10; B < R.length; B++) {
          var k = R.words[B] | 0;
          R.words[B - 10] = (k & h) << 4 | T >>> 22, T = k;
        }
        T >>>= 22, R.words[B - 10] = T, T === 0 && R.length > 10 ? R.length -= 10 : R.length -= 9;
      }, D.prototype.imulK = function(R) {
        R.words[R.length] = 0, R.words[R.length + 1] = 0, R.length += 2;
        for (var M = 0, h = 0; h < R.length; h++) {
          var S = R.words[h] | 0;
          M += S * 977, R.words[h] = M & 67108863, M = S * 64 + (M / 67108864 | 0);
        }
        return R.words[R.length - 1] === 0 && (R.length--, R.words[R.length - 1] === 0 && R.length--), R;
      };
      function G() {
        j.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      u(G, j);
      function V() {
        j.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      u(V, j);
      function Q() {
        j.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      u(Q, j), Q.prototype.imulK = function(R) {
        for (var M = 0, h = 0; h < R.length; h++) {
          var S = (R.words[h] | 0) * 19 + M, B = S & 67108863;
          S >>>= 26, R.words[h] = B, M = S;
        }
        return M !== 0 && (R.words[R.length++] = M), R;
      }, n._prime = function(R) {
        if (O[R]) return O[R];
        var M;
        if (R === "k256")
          M = new D();
        else if (R === "p224")
          M = new G();
        else if (R === "p192")
          M = new V();
        else if (R === "p25519")
          M = new Q();
        else
          throw new Error("Unknown prime " + R);
        return O[R] = M, M;
      };
      function re(te) {
        if (typeof te == "string") {
          var R = n._prime(te);
          this.m = R.p, this.prime = R;
        } else
          a(te.gtn(1), "modulus must be greater than 1"), this.m = te, this.prime = null;
      }
      re.prototype._verify1 = function(R) {
        a(R.negative === 0, "red works only with positives"), a(R.red, "red works only with red numbers");
      }, re.prototype._verify2 = function(R, M) {
        a((R.negative | M.negative) === 0, "red works only with positives"), a(
          R.red && R.red === M.red,
          "red works only with red numbers"
        );
      }, re.prototype.imod = function(R) {
        return this.prime ? this.prime.ireduce(R)._forceRed(this) : R.umod(this.m)._forceRed(this);
      }, re.prototype.neg = function(R) {
        return R.isZero() ? R.clone() : this.m.sub(R)._forceRed(this);
      }, re.prototype.add = function(R, M) {
        this._verify2(R, M);
        var h = R.add(M);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, re.prototype.iadd = function(R, M) {
        this._verify2(R, M);
        var h = R.iadd(M);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, re.prototype.sub = function(R, M) {
        this._verify2(R, M);
        var h = R.sub(M);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, re.prototype.isub = function(R, M) {
        this._verify2(R, M);
        var h = R.isub(M);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, re.prototype.shl = function(R, M) {
        return this._verify1(R), this.imod(R.ushln(M));
      }, re.prototype.imul = function(R, M) {
        return this._verify2(R, M), this.imod(R.imul(M));
      }, re.prototype.mul = function(R, M) {
        return this._verify2(R, M), this.imod(R.mul(M));
      }, re.prototype.isqr = function(R) {
        return this.imul(R, R.clone());
      }, re.prototype.sqr = function(R) {
        return this.mul(R, R);
      }, re.prototype.sqrt = function(R) {
        if (R.isZero()) return R.clone();
        var M = this.m.andln(3);
        if (a(M % 2 === 1), M === 3) {
          var h = this.m.add(new n(1)).iushrn(2);
          return this.pow(R, h);
        }
        for (var S = this.m.subn(1), B = 0; !S.isZero() && S.andln(1) === 0; )
          B++, S.iushrn(1);
        a(!S.isZero());
        var T = new n(1).toRed(this), k = T.redNeg(), I = this.m.subn(1).iushrn(1), C = this.m.bitLength();
        for (C = new n(2 * C * C).toRed(this); this.pow(C, I).cmp(k) !== 0; )
          C.redIAdd(k);
        for (var $ = this.pow(C, S), w = this.pow(R, S.addn(1).iushrn(1)), U = this.pow(R, S), ie = B; U.cmp(T) !== 0; ) {
          for (var le = U, ee = 0; le.cmp(T) !== 0; ee++)
            le = le.redSqr();
          a(ee < ie);
          var F = this.pow($, new n(1).iushln(ie - ee - 1));
          w = w.redMul(F), $ = F.redSqr(), U = U.redMul($), ie = ee;
        }
        return w;
      }, re.prototype.invm = function(R) {
        var M = R._invmp(this.m);
        return M.negative !== 0 ? (M.negative = 0, this.imod(M).redNeg()) : this.imod(M);
      }, re.prototype.pow = function(R, M) {
        if (M.isZero()) return new n(1).toRed(this);
        if (M.cmpn(1) === 0) return R.clone();
        var h = 4, S = new Array(1 << h);
        S[0] = new n(1).toRed(this), S[1] = R;
        for (var B = 2; B < S.length; B++)
          S[B] = this.mul(S[B - 1], R);
        var T = S[0], k = 0, I = 0, C = M.bitLength() % 26;
        for (C === 0 && (C = 26), B = M.length - 1; B >= 0; B--) {
          for (var $ = M.words[B], w = C - 1; w >= 0; w--) {
            var U = $ >> w & 1;
            if (T !== S[0] && (T = this.sqr(T)), U === 0 && k === 0) {
              I = 0;
              continue;
            }
            k <<= 1, k |= U, I++, !(I !== h && (B !== 0 || w !== 0)) && (T = this.mul(T, S[k]), I = 0, k = 0);
          }
          C = 26;
        }
        return T;
      }, re.prototype.convertTo = function(R) {
        var M = R.umod(this.m);
        return M === R ? M.clone() : M;
      }, re.prototype.convertFrom = function(R) {
        var M = R.clone();
        return M.red = null, M;
      }, n.mont = function(R) {
        return new ve(R);
      };
      function ve(te) {
        re.call(this, te), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      u(ve, re), ve.prototype.convertTo = function(R) {
        return this.imod(R.ushln(this.shift));
      }, ve.prototype.convertFrom = function(R) {
        var M = this.imod(R.mul(this.rinv));
        return M.red = null, M;
      }, ve.prototype.imul = function(R, M) {
        if (R.isZero() || M.isZero())
          return R.words[0] = 0, R.length = 1, R;
        var h = R.imul(M), S = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = h.isub(S).iushrn(this.shift), T = B;
        return B.cmp(this.m) >= 0 ? T = B.isub(this.m) : B.cmpn(0) < 0 && (T = B.iadd(this.m)), T._forceRed(this);
      }, ve.prototype.mul = function(R, M) {
        if (R.isZero() || M.isZero()) return new n(0)._forceRed(this);
        var h = R.mul(M), S = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = h.isub(S).iushrn(this.shift), T = B;
        return B.cmp(this.m) >= 0 ? T = B.isub(this.m) : B.cmpn(0) < 0 && (T = B.iadd(this.m)), T._forceRed(this);
      }, ve.prototype.invm = function(R) {
        var M = this.imod(R._invmp(this.m).mul(this.r2));
        return M._forceRed(this);
      };
    })(e, bn$4);
  })(bn$5)), bn$5.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(u) {
    return e || (e = new t(null)), e.generate(u);
  };
  function t(a) {
    this.rand = a;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(u) {
    return this._rand(u);
  }, t.prototype._rand = function(u) {
    if (this.rand.getBytes)
      return this.rand.getBytes(u);
    for (var n = new Uint8Array(u), o = 0; o < n.length; o++)
      n[o] = this.rand.getByte();
    return n;
  }, typeof globalThis == "object")
    globalThis.crypto && globalThis.crypto.getRandomValues ? t.prototype._rand = function(u) {
      var n = new Uint8Array(u);
      return globalThis.crypto.getRandomValues(n), n;
    } : globalThis.msCrypto && globalThis.msCrypto.getRandomValues ? t.prototype._rand = function(u) {
      var n = new Uint8Array(u);
      return globalThis.msCrypto.getRandomValues(n), n;
    } : typeof globalThis == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var r = requireCryptoBrowserify();
      if (typeof r.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(u) {
        return r.randomBytes(u);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var e = requireBn$2(), t = requireBrorand();
  function r(a) {
    this.rand = a || new t.Rand();
  }
  return mr = r, r.create = function(u) {
    return new r(u);
  }, r.prototype._randbelow = function(u) {
    var n = u.bitLength(), o = Math.ceil(n / 8);
    do
      var c = new e(this.rand.generate(o));
    while (c.cmp(u) >= 0);
    return c;
  }, r.prototype._randrange = function(u, n) {
    var o = n.sub(u);
    return u.add(this._randbelow(o));
  }, r.prototype.test = function(u, n, o) {
    var c = u.bitLength(), f = e.mont(u), l = new e(1).toRed(f);
    n || (n = Math.max(1, c / 48 | 0));
    for (var s = u.subn(1), p = 0; !s.testn(p); p++)
      ;
    for (var m = u.shrn(p), g = s.toRed(f), y = !0; n > 0; n--) {
      var v = this._randrange(new e(2), s);
      o && o(v);
      var E = v.toRed(f).redPow(m);
      if (!(E.cmp(l) === 0 || E.cmp(g) === 0)) {
        for (var b = 1; b < p; b++) {
          if (E = E.redSqr(), E.cmp(l) === 0)
            return !1;
          if (E.cmp(g) === 0)
            break;
        }
        if (b === p)
          return !1;
      }
    }
    return y;
  }, r.prototype.getDivisor = function(u, n) {
    var o = u.bitLength(), c = e.mont(u), f = new e(1).toRed(c);
    n || (n = Math.max(1, o / 48 | 0));
    for (var l = u.subn(1), s = 0; !l.testn(s); s++)
      ;
    for (var p = u.shrn(s), m = l.toRed(c); n > 0; n--) {
      var g = this._randrange(new e(2), l), y = u.gcd(g);
      if (y.cmpn(1) !== 0)
        return y;
      var v = g.toRed(c).redPow(p);
      if (!(v.cmp(f) === 0 || v.cmp(m) === 0)) {
        for (var E = 1; E < s; E++) {
          if (v = v.redSqr(), v.cmp(f) === 0)
            return v.fromRed().subn(1).gcd(u);
          if (v.cmp(m) === 0)
            break;
        }
        if (E === s)
          return v = v.redSqr(), v.fromRed().subn(1).gcd(u);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = requireBrowser$i();
  generatePrime = E, E.simpleSieve = y, E.fermatTest = v;
  var t = requireBn$2(), r = new t(24), a = requireMr(), u = new a(), n = new t(1), o = new t(2), c = new t(5);
  new t(16), new t(8);
  var f = new t(10), l = new t(3);
  new t(7);
  var s = new t(11), p = new t(4);
  new t(12);
  var m = null;
  function g() {
    if (m !== null)
      return m;
    var b = 1048576, q = [];
    q[0] = 2;
    for (var O = 1, j = 3; j < b; j += 2) {
      for (var D = Math.ceil(Math.sqrt(j)), G = 0; G < O && q[G] <= D && j % q[G] !== 0; G++)
        ;
      O !== G && q[G] <= D || (q[O++] = j);
    }
    return m = q, q;
  }
  function y(b) {
    for (var q = g(), O = 0; O < q.length; O++)
      if (b.modn(q[O]) === 0)
        return b.cmpn(q[O]) === 0;
    return !0;
  }
  function v(b) {
    var q = t.mont(b);
    return o.toRed(q).redPow(b.subn(1)).fromRed().cmpn(1) === 0;
  }
  function E(b, q) {
    if (b < 16)
      return q === 2 || q === 5 ? new t([140, 123]) : new t([140, 39]);
    q = new t(q);
    for (var O, j; ; ) {
      for (O = new t(e(Math.ceil(b / 8))); O.bitLength() > b; )
        O.ishrn(1);
      if (O.isEven() && O.iadd(n), O.testn(1) || O.iadd(o), q.cmp(o)) {
        if (!q.cmp(c))
          for (; O.mod(f).cmp(l); )
            O.iadd(p);
      } else for (; O.mod(r).cmp(s); )
        O.iadd(p);
      if (j = O.shrn(1), y(j) && y(O) && v(j) && v(O) && u.test(j) && u.test(O))
        return O;
    }
  }
  return generatePrime;
}
const modp1 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18 = { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" }, require$$1$4 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var e = requireBn$2(), t = requireMr(), r = new t(), a = new e(24), u = new e(11), n = new e(10), o = new e(3), c = new e(7), f = requireGeneratePrime(), l = requireBrowser$i();
  dh = y;
  function s(E, b) {
    return b = b || "utf8", Buffer.isBuffer(E) || (E = new Buffer(E, b)), this._pub = new e(E), this;
  }
  function p(E, b) {
    return b = b || "utf8", Buffer.isBuffer(E) || (E = new Buffer(E, b)), this._priv = new e(E), this;
  }
  var m = {};
  function g(E, b) {
    var q = b.toString("hex"), O = [q, E.toString(16)].join("_");
    if (O in m)
      return m[O];
    var j = 0;
    if (E.isEven() || !f.simpleSieve || !f.fermatTest(E) || !r.test(E))
      return j += 1, q === "02" || q === "05" ? j += 8 : j += 4, m[O] = j, j;
    r.test(E.shrn(1)) || (j += 2);
    var D;
    switch (q) {
      case "02":
        E.mod(a).cmp(u) && (j += 8);
        break;
      case "05":
        D = E.mod(n), D.cmp(o) && D.cmp(c) && (j += 8);
        break;
      default:
        j += 4;
    }
    return m[O] = j, j;
  }
  function y(E, b, q) {
    this.setGenerator(b), this.__prime = new e(E), this._prime = e.mont(this.__prime), this._primeLen = E.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, q ? (this.setPublicKey = s, this.setPrivateKey = p) : this._primeCode = 8;
  }
  Object.defineProperty(y.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = g(this.__prime, this.__gen)), this._primeCode;
    }
  }), y.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(l(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, y.prototype.computeSecret = function(E) {
    E = new e(E), E = E.toRed(this._prime);
    var b = E.redPow(this._priv).fromRed(), q = new Buffer(b.toArray()), O = this.getPrime();
    if (q.length < O.length) {
      var j = new Buffer(O.length - q.length);
      j.fill(0), q = Buffer.concat([j, q]);
    }
    return q;
  }, y.prototype.getPublicKey = function(b) {
    return v(this._pub, b);
  }, y.prototype.getPrivateKey = function(b) {
    return v(this._priv, b);
  }, y.prototype.getPrime = function(E) {
    return v(this.__prime, E);
  }, y.prototype.getGenerator = function(E) {
    return v(this._gen, E);
  }, y.prototype.setGenerator = function(E, b) {
    return b = b || "utf8", Buffer.isBuffer(E) || (E = new Buffer(E, b)), this.__gen = E, this._gen = new e(E), this;
  };
  function v(E, b) {
    var q = new Buffer(E.toArray());
    return b ? q.toString(b) : q;
  }
  return dh;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b;
  hasRequiredBrowser$b = 1;
  var e = requireGeneratePrime(), t = require$$1$4, r = requireDh();
  function a(o) {
    var c = new Buffer(t[o].prime, "hex"), f = new Buffer(t[o].gen, "hex");
    return new r(c, f);
  }
  var u = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function n(o, c, f, l) {
    return Buffer.isBuffer(c) || u[c] === void 0 ? n(o, "binary", c, f) : (c = c || "binary", l = l || "binary", f = f || new Buffer([2]), Buffer.isBuffer(f) || (f = new Buffer(f, l)), typeof o == "number" ? new r(e(o, f), f, !0) : (Buffer.isBuffer(o) || (o = new Buffer(o, c)), new r(o, f, !0)));
  }
  return browser$b.DiffieHellmanGroup = browser$b.createDiffieHellmanGroup = browser$b.getDiffieHellman = a, browser$b.createDiffieHellman = browser$b.DiffieHellman = n, browser$b;
}
var readableBrowser$1 = { exports: {} }, isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var e = {}.toString;
  return isarray = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer$1 = { exports: {} }, hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, (function(e, t) {
    var r = requireDist$1(), a = r.Buffer;
    function u(o, c) {
      for (var f in o)
        c[f] = o[f];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (u(r, t), t.Buffer = n);
    function n(o, c, f) {
      return a(o, c, f);
    }
    u(a, n), n.from = function(o, c, f) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return a(o, c, f);
    }, n.alloc = function(o, c, f) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var l = a(o);
      return c !== void 0 ? typeof f == "string" ? l.fill(c, f) : l.fill(c) : l.fill(0), l;
    }, n.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return a(o);
    }, n.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  })(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, (function(e) {
    function t(n, o) {
      if (!(n instanceof o))
        throw new TypeError("Cannot call a class as a function");
    }
    var r = requireSafeBuffer$1().Buffer, a = requireUtil();
    function u(n, o, c) {
      n.copy(o, c);
    }
    e.exports = (function() {
      function n() {
        t(this, n), this.head = null, this.tail = null, this.length = 0;
      }
      return n.prototype.push = function(c) {
        var f = { data: c, next: null };
        this.length > 0 ? this.tail.next = f : this.head = f, this.tail = f, ++this.length;
      }, n.prototype.unshift = function(c) {
        var f = { data: c, next: this.head };
        this.length === 0 && (this.tail = f), this.head = f, ++this.length;
      }, n.prototype.shift = function() {
        if (this.length !== 0) {
          var c = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, c;
        }
      }, n.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, n.prototype.join = function(c) {
        if (this.length === 0) return "";
        for (var f = this.head, l = "" + f.data; f = f.next; )
          l += c + f.data;
        return l;
      }, n.prototype.concat = function(c) {
        if (this.length === 0) return r.alloc(0);
        for (var f = r.allocUnsafe(c >>> 0), l = this.head, s = 0; l; )
          u(l.data, f, s), s += l.data.length, l = l.next;
        return f;
      }, n;
    })(), a && a.inspect && a.inspect.custom && (e.exports.prototype[a.inspect.custom] = function() {
      var n = a.inspect({ length: this.length });
      return this.constructor.name + " " + n;
    });
  })(BufferList)), BufferList.exports;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var e = requireProcessNextickArgs();
  function t(u, n) {
    var o = this, c = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
    return c || f ? (n ? n(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(a, this, u)) : e.nextTick(a, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(l) {
      !n && l ? o._writableState ? o._writableState.errorEmitted || (o._writableState.errorEmitted = !0, e.nextTick(a, o, l)) : e.nextTick(a, o, l) : n && n(l);
    }), this);
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function a(u, n) {
    u.emit("error", n);
  }
  return destroy_1$1 = {
    destroy: t,
    undestroy: r
  }, destroy_1$1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = requireProcessNextickArgs();
  _stream_writable = v;
  function t(T) {
    var k = this;
    this.next = null, this.entry = null, this.finish = function() {
      B(k, T);
    };
  }
  var r = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, a;
  v.WritableState = g;
  var u = Object.create(requireUtil$1());
  u.inherits = requireInherits_browser();
  var n = {
    deprecate: requireBrowser$h()
  }, o = requireStreamBrowser(), c = requireSafeBuffer$1().Buffer, f = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function l(T) {
    return c.from(T);
  }
  function s(T) {
    return c.isBuffer(T) || T instanceof f;
  }
  var p = requireDestroy$1();
  u.inherits(v, o);
  function m() {
  }
  function g(T, k) {
    a = a || require_stream_duplex(), T = T || {};
    var I = k instanceof a;
    this.objectMode = !!T.objectMode, I && (this.objectMode = this.objectMode || !!T.writableObjectMode);
    var C = T.highWaterMark, $ = T.writableHighWaterMark, w = this.objectMode ? 16 : 16 * 1024;
    C || C === 0 ? this.highWaterMark = C : I && ($ || $ === 0) ? this.highWaterMark = $ : this.highWaterMark = w, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var U = T.decodeStrings === !1;
    this.decodeStrings = !U, this.defaultEncoding = T.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ie) {
      V(k, ie);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  g.prototype.getBuffer = function() {
    for (var k = this.bufferedRequest, I = []; k; )
      I.push(k), k = k.next;
    return I;
  }, (function() {
    try {
      Object.defineProperty(g.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var y;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (y = Function.prototype[Symbol.hasInstance], Object.defineProperty(v, Symbol.hasInstance, {
    value: function(T) {
      return y.call(this, T) ? !0 : this !== v ? !1 : T && T._writableState instanceof g;
    }
  })) : y = function(T) {
    return T instanceof this;
  };
  function v(T) {
    if (a = a || require_stream_duplex(), !y.call(v, this) && !(this instanceof a))
      return new v(T);
    this._writableState = new g(T, this), this.writable = !0, T && (typeof T.write == "function" && (this._write = T.write), typeof T.writev == "function" && (this._writev = T.writev), typeof T.destroy == "function" && (this._destroy = T.destroy), typeof T.final == "function" && (this._final = T.final)), o.call(this);
  }
  v.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function E(T, k) {
    var I = new Error("write after end");
    T.emit("error", I), e.nextTick(k, I);
  }
  function b(T, k, I, C) {
    var $ = !0, w = !1;
    return I === null ? w = new TypeError("May not write null values to stream") : typeof I != "string" && I !== void 0 && !k.objectMode && (w = new TypeError("Invalid non-string/buffer chunk")), w && (T.emit("error", w), e.nextTick(C, w), $ = !1), $;
  }
  v.prototype.write = function(T, k, I) {
    var C = this._writableState, $ = !1, w = !C.objectMode && s(T);
    return w && !c.isBuffer(T) && (T = l(T)), typeof k == "function" && (I = k, k = null), w ? k = "buffer" : k || (k = C.defaultEncoding), typeof I != "function" && (I = m), C.ended ? E(this, I) : (w || b(this, C, T, I)) && (C.pendingcb++, $ = O(this, C, w, T, k, I)), $;
  }, v.prototype.cork = function() {
    var T = this._writableState;
    T.corked++;
  }, v.prototype.uncork = function() {
    var T = this._writableState;
    T.corked && (T.corked--, !T.writing && !T.corked && !T.bufferProcessing && T.bufferedRequest && ve(this, T));
  }, v.prototype.setDefaultEncoding = function(k) {
    if (typeof k == "string" && (k = k.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((k + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + k);
    return this._writableState.defaultEncoding = k, this;
  };
  function q(T, k, I) {
    return !T.objectMode && T.decodeStrings !== !1 && typeof k == "string" && (k = c.from(k, I)), k;
  }
  Object.defineProperty(v.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function O(T, k, I, C, $, w) {
    if (!I) {
      var U = q(k, C, $);
      C !== U && (I = !0, $ = "buffer", C = U);
    }
    var ie = k.objectMode ? 1 : C.length;
    k.length += ie;
    var le = k.length < k.highWaterMark;
    if (le || (k.needDrain = !0), k.writing || k.corked) {
      var ee = k.lastBufferedRequest;
      k.lastBufferedRequest = {
        chunk: C,
        encoding: $,
        isBuf: I,
        callback: w,
        next: null
      }, ee ? ee.next = k.lastBufferedRequest : k.bufferedRequest = k.lastBufferedRequest, k.bufferedRequestCount += 1;
    } else
      j(T, k, !1, ie, C, $, w);
    return le;
  }
  function j(T, k, I, C, $, w, U) {
    k.writelen = C, k.writecb = U, k.writing = !0, k.sync = !0, I ? T._writev($, k.onwrite) : T._write($, w, k.onwrite), k.sync = !1;
  }
  function D(T, k, I, C, $) {
    --k.pendingcb, I ? (e.nextTick($, C), e.nextTick(h, T, k), T._writableState.errorEmitted = !0, T.emit("error", C)) : ($(C), T._writableState.errorEmitted = !0, T.emit("error", C), h(T, k));
  }
  function G(T) {
    T.writing = !1, T.writecb = null, T.length -= T.writelen, T.writelen = 0;
  }
  function V(T, k) {
    var I = T._writableState, C = I.sync, $ = I.writecb;
    if (G(I), k) D(T, I, C, k, $);
    else {
      var w = te(I);
      !w && !I.corked && !I.bufferProcessing && I.bufferedRequest && ve(T, I), C ? r(Q, T, I, w, $) : Q(T, I, w, $);
    }
  }
  function Q(T, k, I, C) {
    I || re(T, k), k.pendingcb--, C(), h(T, k);
  }
  function re(T, k) {
    k.length === 0 && k.needDrain && (k.needDrain = !1, T.emit("drain"));
  }
  function ve(T, k) {
    k.bufferProcessing = !0;
    var I = k.bufferedRequest;
    if (T._writev && I && I.next) {
      var C = k.bufferedRequestCount, $ = new Array(C), w = k.corkedRequestsFree;
      w.entry = I;
      for (var U = 0, ie = !0; I; )
        $[U] = I, I.isBuf || (ie = !1), I = I.next, U += 1;
      $.allBuffers = ie, j(T, k, !0, k.length, $, "", w.finish), k.pendingcb++, k.lastBufferedRequest = null, w.next ? (k.corkedRequestsFree = w.next, w.next = null) : k.corkedRequestsFree = new t(k), k.bufferedRequestCount = 0;
    } else {
      for (; I; ) {
        var le = I.chunk, ee = I.encoding, F = I.callback, z = k.objectMode ? 1 : le.length;
        if (j(T, k, !1, z, le, ee, F), I = I.next, k.bufferedRequestCount--, k.writing)
          break;
      }
      I === null && (k.lastBufferedRequest = null);
    }
    k.bufferedRequest = I, k.bufferProcessing = !1;
  }
  v.prototype._write = function(T, k, I) {
    I(new Error("_write() is not implemented"));
  }, v.prototype._writev = null, v.prototype.end = function(T, k, I) {
    var C = this._writableState;
    typeof T == "function" ? (I = T, T = null, k = null) : typeof k == "function" && (I = k, k = null), T != null && this.write(T, k), C.corked && (C.corked = 1, this.uncork()), C.ending || S(this, C, I);
  };
  function te(T) {
    return T.ending && T.length === 0 && T.bufferedRequest === null && !T.finished && !T.writing;
  }
  function R(T, k) {
    T._final(function(I) {
      k.pendingcb--, I && T.emit("error", I), k.prefinished = !0, T.emit("prefinish"), h(T, k);
    });
  }
  function M(T, k) {
    !k.prefinished && !k.finalCalled && (typeof T._final == "function" ? (k.pendingcb++, k.finalCalled = !0, e.nextTick(R, T, k)) : (k.prefinished = !0, T.emit("prefinish")));
  }
  function h(T, k) {
    var I = te(k);
    return I && (M(T, k), k.pendingcb === 0 && (k.finished = !0, T.emit("finish"))), I;
  }
  function S(T, k, I) {
    k.ending = !0, h(T, k), I && (k.finished ? e.nextTick(I) : T.once("finish", I)), k.ended = !0, T.writable = !1;
  }
  function B(T, k, I) {
    var C = T.entry;
    for (T.entry = null; C; ) {
      var $ = C.callback;
      k.pendingcb--, $(I), C = C.next;
    }
    k.corkedRequestsFree.next = T;
  }
  return Object.defineProperty(v.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(T) {
      this._writableState && (this._writableState.destroyed = T);
    }
  }), v.prototype.destroy = p.destroy, v.prototype._undestroy = p.undestroy, v.prototype._destroy = function(T, k) {
    this.end(), k(T);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = requireProcessNextickArgs(), t = Object.keys || function(p) {
    var m = [];
    for (var g in p)
      m.push(g);
    return m;
  };
  _stream_duplex = f;
  var r = Object.create(requireUtil$1());
  r.inherits = requireInherits_browser();
  var a = require_stream_readable(), u = require_stream_writable();
  r.inherits(f, a);
  for (var n = t(u.prototype), o = 0; o < n.length; o++) {
    var c = n[o];
    f.prototype[c] || (f.prototype[c] = u.prototype[c]);
  }
  function f(p) {
    if (!(this instanceof f)) return new f(p);
    a.call(this, p), u.call(this, p), p && p.readable === !1 && (this.readable = !1), p && p.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, p && p.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", l);
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function l() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(s, this);
  }
  function s(p) {
    p.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(p) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = p, this._writableState.destroyed = p);
    }
  }), f.prototype._destroy = function(p, m) {
    this.push(null), this.end(), e.nextTick(m, p);
  }, _stream_duplex;
}
var string_decoder = {}, safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, (function(e, t) {
    var r = requireDist$1(), a = r.Buffer;
    function u(o, c) {
      for (var f in o)
        c[f] = o[f];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (u(r, t), t.Buffer = n);
    function n(o, c, f) {
      return a(o, c, f);
    }
    u(a, n), n.from = function(o, c, f) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return a(o, c, f);
    }, n.alloc = function(o, c, f) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var l = a(o);
      return c !== void 0 ? typeof f == "string" ? l.fill(c, f) : l.fill(c) : l.fill(0), l;
    }, n.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return a(o);
    }, n.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(o);
    };
  })(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var e = requireSafeBuffer().Buffer, t = e.isEncoding || function(b) {
    switch (b = "" + b, b && b.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(b) {
    if (!b) return "utf8";
    for (var q; ; )
      switch (b) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return b;
        default:
          if (q) return;
          b = ("" + b).toLowerCase(), q = !0;
      }
  }
  function a(b) {
    var q = r(b);
    if (typeof q != "string" && (e.isEncoding === t || !t(b))) throw new Error("Unknown encoding: " + b);
    return q || b;
  }
  string_decoder.StringDecoder = u;
  function u(b) {
    this.encoding = a(b);
    var q;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = m, q = 4;
        break;
      case "utf8":
        this.fillLast = f, q = 4;
        break;
      case "base64":
        this.text = g, this.end = y, q = 3;
        break;
      default:
        this.write = v, this.end = E;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(q);
  }
  u.prototype.write = function(b) {
    if (b.length === 0) return "";
    var q, O;
    if (this.lastNeed) {
      if (q = this.fillLast(b), q === void 0) return "";
      O = this.lastNeed, this.lastNeed = 0;
    } else
      O = 0;
    return O < b.length ? q ? q + this.text(b, O) : this.text(b, O) : q || "";
  }, u.prototype.end = s, u.prototype.text = l, u.prototype.fillLast = function(b) {
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
  };
  function n(b) {
    return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
  }
  function o(b, q, O) {
    var j = q.length - 1;
    if (j < O) return 0;
    var D = n(q[j]);
    return D >= 0 ? (D > 0 && (b.lastNeed = D - 1), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (b.lastNeed = D - 2), D) : --j < O || D === -2 ? 0 : (D = n(q[j]), D >= 0 ? (D > 0 && (D === 2 ? D = 0 : b.lastNeed = D - 3), D) : 0));
  }
  function c(b, q, O) {
    if ((q[0] & 192) !== 128)
      return b.lastNeed = 0, "�";
    if (b.lastNeed > 1 && q.length > 1) {
      if ((q[1] & 192) !== 128)
        return b.lastNeed = 1, "�";
      if (b.lastNeed > 2 && q.length > 2 && (q[2] & 192) !== 128)
        return b.lastNeed = 2, "�";
    }
  }
  function f(b) {
    var q = this.lastTotal - this.lastNeed, O = c(this, b);
    if (O !== void 0) return O;
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, q, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, q, 0, b.length), this.lastNeed -= b.length;
  }
  function l(b, q) {
    var O = o(this, b, q);
    if (!this.lastNeed) return b.toString("utf8", q);
    this.lastTotal = O;
    var j = b.length - (O - this.lastNeed);
    return b.copy(this.lastChar, 0, j), b.toString("utf8", q, j);
  }
  function s(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + "�" : q;
  }
  function p(b, q) {
    if ((b.length - q) % 2 === 0) {
      var O = b.toString("utf16le", q);
      if (O) {
        var j = O.charCodeAt(O.length - 1);
        if (j >= 55296 && j <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], O.slice(0, -1);
      }
      return O;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", q, b.length - 1);
  }
  function m(b) {
    var q = b && b.length ? this.write(b) : "";
    if (this.lastNeed) {
      var O = this.lastTotal - this.lastNeed;
      return q + this.lastChar.toString("utf16le", 0, O);
    }
    return q;
  }
  function g(b, q) {
    var O = (b.length - q) % 3;
    return O === 0 ? b.toString("base64", q) : (this.lastNeed = 3 - O, this.lastTotal = 3, O === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", q, b.length - O));
  }
  function y(b) {
    var q = b && b.length ? this.write(b) : "";
    return this.lastNeed ? q + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : q;
  }
  function v(b) {
    return b.toString(this.encoding);
  }
  function E(b) {
    return b && b.length ? this.write(b) : "";
  }
  return string_decoder;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = requireProcessNextickArgs();
  _stream_readable = q;
  var t = requireIsarray(), r;
  q.ReadableState = b, requireEvents().EventEmitter;
  var a = function(F, z) {
    return F.listeners(z).length;
  }, u = requireStreamBrowser(), n = requireSafeBuffer$1().Buffer, o = (typeof globalThis < "u" || typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : {}).Uint8Array || function() {
  };
  function c(F) {
    return n.from(F);
  }
  function f(F) {
    return n.isBuffer(F) || F instanceof o;
  }
  var l = Object.create(requireUtil$1());
  l.inherits = requireInherits_browser();
  var s = requireUtil(), p = void 0;
  s && s.debuglog ? p = s.debuglog("stream") : p = function() {
  };
  var m = requireBufferList(), g = requireDestroy$1(), y;
  l.inherits(q, u);
  var v = ["error", "close", "destroy", "pause", "resume"];
  function E(F, z, se) {
    if (typeof F.prependListener == "function") return F.prependListener(z, se);
    !F._events || !F._events[z] ? F.on(z, se) : t(F._events[z]) ? F._events[z].unshift(se) : F._events[z] = [se, F._events[z]];
  }
  function b(F, z) {
    r = r || require_stream_duplex(), F = F || {};
    var se = z instanceof r;
    this.objectMode = !!F.objectMode, se && (this.objectMode = this.objectMode || !!F.readableObjectMode);
    var he = F.highWaterMark, ae = F.readableHighWaterMark, X = this.objectMode ? 16 : 16 * 1024;
    he || he === 0 ? this.highWaterMark = he : se && (ae || ae === 0) ? this.highWaterMark = ae : this.highWaterMark = X, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = F.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, F.encoding && (y || (y = requireString_decoder().StringDecoder), this.decoder = new y(F.encoding), this.encoding = F.encoding);
  }
  function q(F) {
    if (r = r || require_stream_duplex(), !(this instanceof q)) return new q(F);
    this._readableState = new b(F, this), this.readable = !0, F && (typeof F.read == "function" && (this._read = F.read), typeof F.destroy == "function" && (this._destroy = F.destroy)), u.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(F) {
      this._readableState && (this._readableState.destroyed = F);
    }
  }), q.prototype.destroy = g.destroy, q.prototype._undestroy = g.undestroy, q.prototype._destroy = function(F, z) {
    this.push(null), z(F);
  }, q.prototype.push = function(F, z) {
    var se = this._readableState, he;
    return se.objectMode ? he = !0 : typeof F == "string" && (z = z || se.defaultEncoding, z !== se.encoding && (F = n.from(F, z), z = ""), he = !0), O(this, F, z, !1, he);
  }, q.prototype.unshift = function(F) {
    return O(this, F, null, !0, !1);
  };
  function O(F, z, se, he, ae) {
    var X = F._readableState;
    if (z === null)
      X.reading = !1, ve(F, X);
    else {
      var be;
      ae || (be = D(X, z)), be ? F.emit("error", be) : X.objectMode || z && z.length > 0 ? (typeof z != "string" && !X.objectMode && Object.getPrototypeOf(z) !== n.prototype && (z = c(z)), he ? X.endEmitted ? F.emit("error", new Error("stream.unshift() after end event")) : j(F, X, z, !0) : X.ended ? F.emit("error", new Error("stream.push() after EOF")) : (X.reading = !1, X.decoder && !se ? (z = X.decoder.write(z), X.objectMode || z.length !== 0 ? j(F, X, z, !1) : M(F, X)) : j(F, X, z, !1))) : he || (X.reading = !1);
    }
    return G(X);
  }
  function j(F, z, se, he) {
    z.flowing && z.length === 0 && !z.sync ? (F.emit("data", se), F.read(0)) : (z.length += z.objectMode ? 1 : se.length, he ? z.buffer.unshift(se) : z.buffer.push(se), z.needReadable && te(F)), M(F, z);
  }
  function D(F, z) {
    var se;
    return !f(z) && typeof z != "string" && z !== void 0 && !F.objectMode && (se = new TypeError("Invalid non-string/buffer chunk")), se;
  }
  function G(F) {
    return !F.ended && (F.needReadable || F.length < F.highWaterMark || F.length === 0);
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(F) {
    return y || (y = requireString_decoder().StringDecoder), this._readableState.decoder = new y(F), this._readableState.encoding = F, this;
  };
  var V = 8388608;
  function Q(F) {
    return F >= V ? F = V : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
  }
  function re(F, z) {
    return F <= 0 || z.length === 0 && z.ended ? 0 : z.objectMode ? 1 : F !== F ? z.flowing && z.length ? z.buffer.head.data.length : z.length : (F > z.highWaterMark && (z.highWaterMark = Q(F)), F <= z.length ? F : z.ended ? z.length : (z.needReadable = !0, 0));
  }
  q.prototype.read = function(F) {
    p("read", F), F = parseInt(F, 10);
    var z = this._readableState, se = F;
    if (F !== 0 && (z.emittedReadable = !1), F === 0 && z.needReadable && (z.length >= z.highWaterMark || z.ended))
      return p("read: emitReadable", z.length, z.ended), z.length === 0 && z.ended ? ie(this) : te(this), null;
    if (F = re(F, z), F === 0 && z.ended)
      return z.length === 0 && ie(this), null;
    var he = z.needReadable;
    p("need readable", he), (z.length === 0 || z.length - F < z.highWaterMark) && (he = !0, p("length less than watermark", he)), z.ended || z.reading ? (he = !1, p("reading or ended", he)) : he && (p("do read"), z.reading = !0, z.sync = !0, z.length === 0 && (z.needReadable = !0), this._read(z.highWaterMark), z.sync = !1, z.reading || (F = re(se, z)));
    var ae;
    return F > 0 ? ae = C(F, z) : ae = null, ae === null ? (z.needReadable = !0, F = 0) : z.length -= F, z.length === 0 && (z.ended || (z.needReadable = !0), se !== F && z.ended && ie(this)), ae !== null && this.emit("data", ae), ae;
  };
  function ve(F, z) {
    if (!z.ended) {
      if (z.decoder) {
        var se = z.decoder.end();
        se && se.length && (z.buffer.push(se), z.length += z.objectMode ? 1 : se.length);
      }
      z.ended = !0, te(F);
    }
  }
  function te(F) {
    var z = F._readableState;
    z.needReadable = !1, z.emittedReadable || (p("emitReadable", z.flowing), z.emittedReadable = !0, z.sync ? e.nextTick(R, F) : R(F));
  }
  function R(F) {
    p("emit readable"), F.emit("readable"), I(F);
  }
  function M(F, z) {
    z.readingMore || (z.readingMore = !0, e.nextTick(h, F, z));
  }
  function h(F, z) {
    for (var se = z.length; !z.reading && !z.flowing && !z.ended && z.length < z.highWaterMark && (p("maybeReadMore read 0"), F.read(0), se !== z.length); )
      se = z.length;
    z.readingMore = !1;
  }
  q.prototype._read = function(F) {
    this.emit("error", new Error("_read() is not implemented"));
  }, q.prototype.pipe = function(F, z) {
    var se = this, he = this._readableState;
    switch (he.pipesCount) {
      case 0:
        he.pipes = F;
        break;
      case 1:
        he.pipes = [he.pipes, F];
        break;
      default:
        he.pipes.push(F);
        break;
    }
    he.pipesCount += 1, p("pipe count=%d opts=%j", he.pipesCount, z);
    var ae = (!z || z.end !== !1) && F !== process$1.stdout && F !== process$1.stderr, X = ae ? Re : Je;
    he.endEmitted ? e.nextTick(X) : se.once("end", X), F.on("unpipe", be);
    function be(we, Ae) {
      p("onunpipe"), we === se && Ae && Ae.hasUnpiped === !1 && (Ae.hasUnpiped = !0, De());
    }
    function Re() {
      p("onend"), F.end();
    }
    var Pe = S(se);
    F.on("drain", Pe);
    var Fe = !1;
    function De() {
      p("cleanup"), F.removeListener("close", He), F.removeListener("finish", Qe), F.removeListener("drain", Pe), F.removeListener("error", rt), F.removeListener("unpipe", be), se.removeListener("end", Re), se.removeListener("end", Je), se.removeListener("data", Oe), Fe = !0, he.awaitDrain && (!F._writableState || F._writableState.needDrain) && Pe();
    }
    var je = !1;
    se.on("data", Oe);
    function Oe(we) {
      p("ondata"), je = !1;
      var Ae = F.write(we);
      Ae === !1 && !je && ((he.pipesCount === 1 && he.pipes === F || he.pipesCount > 1 && ee(he.pipes, F) !== -1) && !Fe && (p("false write response, pause", he.awaitDrain), he.awaitDrain++, je = !0), se.pause());
    }
    function rt(we) {
      p("onerror", we), Je(), F.removeListener("error", rt), a(F, "error") === 0 && F.emit("error", we);
    }
    E(F, "error", rt);
    function He() {
      F.removeListener("finish", Qe), Je();
    }
    F.once("close", He);
    function Qe() {
      p("onfinish"), F.removeListener("close", He), Je();
    }
    F.once("finish", Qe);
    function Je() {
      p("unpipe"), se.unpipe(F);
    }
    return F.emit("pipe", se), he.flowing || (p("pipe resume"), se.resume()), F;
  };
  function S(F) {
    return function() {
      var z = F._readableState;
      p("pipeOnDrain", z.awaitDrain), z.awaitDrain && z.awaitDrain--, z.awaitDrain === 0 && a(F, "data") && (z.flowing = !0, I(F));
    };
  }
  q.prototype.unpipe = function(F) {
    var z = this._readableState, se = { hasUnpiped: !1 };
    if (z.pipesCount === 0) return this;
    if (z.pipesCount === 1)
      return F && F !== z.pipes ? this : (F || (F = z.pipes), z.pipes = null, z.pipesCount = 0, z.flowing = !1, F && F.emit("unpipe", this, se), this);
    if (!F) {
      var he = z.pipes, ae = z.pipesCount;
      z.pipes = null, z.pipesCount = 0, z.flowing = !1;
      for (var X = 0; X < ae; X++)
        he[X].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var be = ee(z.pipes, F);
    return be === -1 ? this : (z.pipes.splice(be, 1), z.pipesCount -= 1, z.pipesCount === 1 && (z.pipes = z.pipes[0]), F.emit("unpipe", this, se), this);
  }, q.prototype.on = function(F, z) {
    var se = u.prototype.on.call(this, F, z);
    if (F === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (F === "readable") {
      var he = this._readableState;
      !he.endEmitted && !he.readableListening && (he.readableListening = he.needReadable = !0, he.emittedReadable = !1, he.reading ? he.length && te(this) : e.nextTick(B, this));
    }
    return se;
  }, q.prototype.addListener = q.prototype.on;
  function B(F) {
    p("readable nexttick read 0"), F.read(0);
  }
  q.prototype.resume = function() {
    var F = this._readableState;
    return F.flowing || (p("resume"), F.flowing = !0, T(this, F)), this;
  };
  function T(F, z) {
    z.resumeScheduled || (z.resumeScheduled = !0, e.nextTick(k, F, z));
  }
  function k(F, z) {
    z.reading || (p("resume read 0"), F.read(0)), z.resumeScheduled = !1, z.awaitDrain = 0, F.emit("resume"), I(F), z.flowing && !z.reading && F.read(0);
  }
  q.prototype.pause = function() {
    return p("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function I(F) {
    var z = F._readableState;
    for (p("flow", z.flowing); z.flowing && F.read() !== null; )
      ;
  }
  q.prototype.wrap = function(F) {
    var z = this, se = this._readableState, he = !1;
    F.on("end", function() {
      if (p("wrapped end"), se.decoder && !se.ended) {
        var be = se.decoder.end();
        be && be.length && z.push(be);
      }
      z.push(null);
    }), F.on("data", function(be) {
      if (p("wrapped data"), se.decoder && (be = se.decoder.write(be)), !(se.objectMode && be == null) && !(!se.objectMode && (!be || !be.length))) {
        var Re = z.push(be);
        Re || (he = !0, F.pause());
      }
    });
    for (var ae in F)
      this[ae] === void 0 && typeof F[ae] == "function" && (this[ae] = /* @__PURE__ */ (function(be) {
        return function() {
          return F[be].apply(F, arguments);
        };
      })(ae));
    for (var X = 0; X < v.length; X++)
      F.on(v[X], this.emit.bind(this, v[X]));
    return this._read = function(be) {
      p("wrapped _read", be), he && (he = !1, F.resume());
    }, this;
  }, Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), q._fromList = C;
  function C(F, z) {
    if (z.length === 0) return null;
    var se;
    return z.objectMode ? se = z.buffer.shift() : !F || F >= z.length ? (z.decoder ? se = z.buffer.join("") : z.buffer.length === 1 ? se = z.buffer.head.data : se = z.buffer.concat(z.length), z.buffer.clear()) : se = $(F, z.buffer, z.decoder), se;
  }
  function $(F, z, se) {
    var he;
    return F < z.head.data.length ? (he = z.head.data.slice(0, F), z.head.data = z.head.data.slice(F)) : F === z.head.data.length ? he = z.shift() : he = se ? w(F, z) : U(F, z), he;
  }
  function w(F, z) {
    var se = z.head, he = 1, ae = se.data;
    for (F -= ae.length; se = se.next; ) {
      var X = se.data, be = F > X.length ? X.length : F;
      if (be === X.length ? ae += X : ae += X.slice(0, F), F -= be, F === 0) {
        be === X.length ? (++he, se.next ? z.head = se.next : z.head = z.tail = null) : (z.head = se, se.data = X.slice(be));
        break;
      }
      ++he;
    }
    return z.length -= he, ae;
  }
  function U(F, z) {
    var se = n.allocUnsafe(F), he = z.head, ae = 1;
    for (he.data.copy(se), F -= he.data.length; he = he.next; ) {
      var X = he.data, be = F > X.length ? X.length : F;
      if (X.copy(se, se.length - F, 0, be), F -= be, F === 0) {
        be === X.length ? (++ae, he.next ? z.head = he.next : z.head = z.tail = null) : (z.head = he, he.data = X.slice(be));
        break;
      }
      ++ae;
    }
    return z.length -= ae, se;
  }
  function ie(F) {
    var z = F._readableState;
    if (z.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    z.endEmitted || (z.ended = !0, e.nextTick(le, z, F));
  }
  function le(F, z) {
    !F.endEmitted && F.length === 0 && (F.endEmitted = !0, z.readable = !1, z.emit("end"));
  }
  function ee(F, z) {
    for (var se = 0, he = F.length; se < he; se++)
      if (F[se] === z) return se;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = a;
  var e = require_stream_duplex(), t = Object.create(requireUtil$1());
  t.inherits = requireInherits_browser(), t.inherits(a, e);
  function r(o, c) {
    var f = this._transformState;
    f.transforming = !1;
    var l = f.writecb;
    if (!l)
      return this.emit("error", new Error("write callback called multiple times"));
    f.writechunk = null, f.writecb = null, c != null && this.push(c), l(o);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  function a(o) {
    if (!(this instanceof a)) return new a(o);
    e.call(this, o), this._transformState = {
      afterTransform: r.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, o && (typeof o.transform == "function" && (this._transform = o.transform), typeof o.flush == "function" && (this._flush = o.flush)), this.on("prefinish", u);
  }
  function u() {
    var o = this;
    typeof this._flush == "function" ? this._flush(function(c, f) {
      n(o, c, f);
    }) : n(this, null, null);
  }
  a.prototype.push = function(o, c) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, o, c);
  }, a.prototype._transform = function(o, c, f) {
    throw new Error("_transform() is not implemented");
  }, a.prototype._write = function(o, c, f) {
    var l = this._transformState;
    if (l.writecb = f, l.writechunk = o, l.writeencoding = c, !l.transforming) {
      var s = this._readableState;
      (l.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  }, a.prototype._read = function(o) {
    var c = this._transformState;
    c.writechunk !== null && c.writecb && !c.transforming ? (c.transforming = !0, this._transform(c.writechunk, c.writeencoding, c.afterTransform)) : c.needTransform = !0;
  }, a.prototype._destroy = function(o, c) {
    var f = this;
    e.prototype._destroy.call(this, o, function(l) {
      c(l), f.emit("close");
    });
  };
  function n(o, c, f) {
    if (c) return o.emit("error", c);
    if (f != null && o.push(f), o._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (o._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return o.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = r;
  var e = require_stream_transform(), t = Object.create(requireUtil$1());
  t.inherits = requireInherits_browser(), t.inherits(r, e);
  function r(a) {
    if (!(this instanceof r)) return new r(a);
    e.call(this, a);
  }
  return r.prototype._transform = function(a, u, n) {
    n(null, a);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, (function(e, t) {
    t = e.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  })(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var sign = { exports: {} }, bn$3 = { exports: {} }, bn$2 = bn$3.exports, hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, (function(e) {
    (function(t, r) {
      function a(M, h) {
        if (!M) throw new Error(h || "Assertion failed");
      }
      function u(M, h) {
        M.super_ = h;
        var S = function() {
        };
        S.prototype = h.prototype, M.prototype = new S(), M.prototype.constructor = M;
      }
      function n(M, h, S) {
        if (n.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && ((h === "le" || h === "be") && (S = h, h = 10), this._init(M || 0, h || 10, S || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var o;
      try {
        typeof globalThis < "u" && typeof globalThis.Buffer < "u" ? o = globalThis.Buffer : o = requireDist$1().Buffer;
      } catch {
      }
      n.isBN = function(h) {
        return h instanceof n ? !0 : h !== null && typeof h == "object" && h.constructor.wordSize === n.wordSize && Array.isArray(h.words);
      }, n.max = function(h, S) {
        return h.cmp(S) > 0 ? h : S;
      }, n.min = function(h, S) {
        return h.cmp(S) < 0 ? h : S;
      }, n.prototype._init = function(h, S, B) {
        if (typeof h == "number")
          return this._initNumber(h, S, B);
        if (typeof h == "object")
          return this._initArray(h, S, B);
        S === "hex" && (S = 16), a(S === (S | 0) && S >= 2 && S <= 36), h = h.toString().replace(/\s+/g, "");
        var T = 0;
        h[0] === "-" && (T++, this.negative = 1), T < h.length && (S === 16 ? this._parseHex(h, T, B) : (this._parseBase(h, S, T), B === "le" && this._initArray(this.toArray(), S, B)));
      }, n.prototype._initNumber = function(h, S, B) {
        h < 0 && (this.negative = 1, h = -h), h < 67108864 ? (this.words = [h & 67108863], this.length = 1) : h < 4503599627370496 ? (this.words = [
          h & 67108863,
          h / 67108864 & 67108863
        ], this.length = 2) : (a(h < 9007199254740992), this.words = [
          h & 67108863,
          h / 67108864 & 67108863,
          1
        ], this.length = 3), B === "le" && this._initArray(this.toArray(), S, B);
      }, n.prototype._initArray = function(h, S, B) {
        if (a(typeof h.length == "number"), h.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(h.length / 3), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var k, I, C = 0;
        if (B === "be")
          for (T = h.length - 1, k = 0; T >= 0; T -= 3)
            I = h[T] | h[T - 1] << 8 | h[T - 2] << 16, this.words[k] |= I << C & 67108863, this.words[k + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, k++);
        else if (B === "le")
          for (T = 0, k = 0; T < h.length; T += 3)
            I = h[T] | h[T + 1] << 8 | h[T + 2] << 16, this.words[k] |= I << C & 67108863, this.words[k + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, k++);
        return this._strip();
      };
      function c(M, h) {
        var S = M.charCodeAt(h);
        if (S >= 48 && S <= 57)
          return S - 48;
        if (S >= 65 && S <= 70)
          return S - 55;
        if (S >= 97 && S <= 102)
          return S - 87;
        a(!1, "Invalid character in " + M);
      }
      function f(M, h, S) {
        var B = c(M, S);
        return S - 1 >= h && (B |= c(M, S - 1) << 4), B;
      }
      n.prototype._parseHex = function(h, S, B) {
        this.length = Math.ceil((h.length - S) / 6), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var k = 0, I = 0, C;
        if (B === "be")
          for (T = h.length - 1; T >= S; T -= 2)
            C = f(h, S, T) << k, this.words[I] |= C & 67108863, k >= 18 ? (k -= 18, I += 1, this.words[I] |= C >>> 26) : k += 8;
        else {
          var $ = h.length - S;
          for (T = $ % 2 === 0 ? S + 1 : S; T < h.length; T += 2)
            C = f(h, S, T) << k, this.words[I] |= C & 67108863, k >= 18 ? (k -= 18, I += 1, this.words[I] |= C >>> 26) : k += 8;
        }
        this._strip();
      };
      function l(M, h, S, B) {
        for (var T = 0, k = 0, I = Math.min(M.length, S), C = h; C < I; C++) {
          var $ = M.charCodeAt(C) - 48;
          T *= B, $ >= 49 ? k = $ - 49 + 10 : $ >= 17 ? k = $ - 17 + 10 : k = $, a($ >= 0 && k < B, "Invalid character"), T += k;
        }
        return T;
      }
      n.prototype._parseBase = function(h, S, B) {
        this.words = [0], this.length = 1;
        for (var T = 0, k = 1; k <= 67108863; k *= S)
          T++;
        T--, k = k / S | 0;
        for (var I = h.length - B, C = I % T, $ = Math.min(I, I - C) + B, w = 0, U = B; U < $; U += T)
          w = l(h, U, U + T, S), this.imuln(k), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        if (C !== 0) {
          var ie = 1;
          for (w = l(h, U, h.length, S), U = 0; U < C; U++)
            ie *= S;
          this.imuln(ie), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        }
        this._strip();
      }, n.prototype.copy = function(h) {
        h.words = new Array(this.length);
        for (var S = 0; S < this.length; S++)
          h.words[S] = this.words[S];
        h.length = this.length, h.negative = this.negative, h.red = this.red;
      };
      function s(M, h) {
        M.words = h.words, M.length = h.length, M.negative = h.negative, M.red = h.red;
      }
      if (n.prototype._move = function(h) {
        s(h, this);
      }, n.prototype.clone = function() {
        var h = new n(null);
        return this.copy(h), h;
      }, n.prototype._expand = function(h) {
        for (; this.length < h; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
        } catch {
          n.prototype.inspect = p;
        }
      else
        n.prototype.inspect = p;
      function p() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var m = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], g = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], y = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(h, S) {
        h = h || 10, S = S | 0 || 1;
        var B;
        if (h === 16 || h === "hex") {
          B = "";
          for (var T = 0, k = 0, I = 0; I < this.length; I++) {
            var C = this.words[I], $ = ((C << T | k) & 16777215).toString(16);
            k = C >>> 24 - T & 16777215, T += 2, T >= 26 && (T -= 26, I--), k !== 0 || I !== this.length - 1 ? B = m[6 - $.length] + $ + B : B = $ + B;
          }
          for (k !== 0 && (B = k.toString(16) + B); B.length % S !== 0; )
            B = "0" + B;
          return this.negative !== 0 && (B = "-" + B), B;
        }
        if (h === (h | 0) && h >= 2 && h <= 36) {
          var w = g[h], U = y[h];
          B = "";
          var ie = this.clone();
          for (ie.negative = 0; !ie.isZero(); ) {
            var le = ie.modrn(U).toString(h);
            ie = ie.idivn(U), ie.isZero() ? B = le + B : B = m[w - le.length] + le + B;
          }
          for (this.isZero() && (B = "0" + B); B.length % S !== 0; )
            B = "0" + B;
          return this.negative !== 0 && (B = "-" + B), B;
        }
        a(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var h = this.words[0];
        return this.length === 2 ? h += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? h += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -h : h;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (n.prototype.toBuffer = function(h, S) {
        return this.toArrayLike(o, h, S);
      }), n.prototype.toArray = function(h, S) {
        return this.toArrayLike(Array, h, S);
      };
      var v = function(h, S) {
        return h.allocUnsafe ? h.allocUnsafe(S) : new h(S);
      };
      n.prototype.toArrayLike = function(h, S, B) {
        this._strip();
        var T = this.byteLength(), k = B || Math.max(1, T);
        a(T <= k, "byte array longer than desired length"), a(k > 0, "Requested array length <= 0");
        var I = v(h, k), C = S === "le" ? "LE" : "BE";
        return this["_toArrayLike" + C](I, T), I;
      }, n.prototype._toArrayLikeLE = function(h, S) {
        for (var B = 0, T = 0, k = 0, I = 0; k < this.length; k++) {
          var C = this.words[k] << I | T;
          h[B++] = C & 255, B < h.length && (h[B++] = C >> 8 & 255), B < h.length && (h[B++] = C >> 16 & 255), I === 6 ? (B < h.length && (h[B++] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (B < h.length)
          for (h[B++] = T; B < h.length; )
            h[B++] = 0;
      }, n.prototype._toArrayLikeBE = function(h, S) {
        for (var B = h.length - 1, T = 0, k = 0, I = 0; k < this.length; k++) {
          var C = this.words[k] << I | T;
          h[B--] = C & 255, B >= 0 && (h[B--] = C >> 8 & 255), B >= 0 && (h[B--] = C >> 16 & 255), I === 6 ? (B >= 0 && (h[B--] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (B >= 0)
          for (h[B--] = T; B >= 0; )
            h[B--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(h) {
        return 32 - Math.clz32(h);
      } : n.prototype._countBits = function(h) {
        var S = h, B = 0;
        return S >= 4096 && (B += 13, S >>>= 13), S >= 64 && (B += 7, S >>>= 7), S >= 8 && (B += 4, S >>>= 4), S >= 2 && (B += 2, S >>>= 2), B + S;
      }, n.prototype._zeroBits = function(h) {
        if (h === 0) return 26;
        var S = h, B = 0;
        return (S & 8191) === 0 && (B += 13, S >>>= 13), (S & 127) === 0 && (B += 7, S >>>= 7), (S & 15) === 0 && (B += 4, S >>>= 4), (S & 3) === 0 && (B += 2, S >>>= 2), (S & 1) === 0 && B++, B;
      }, n.prototype.bitLength = function() {
        var h = this.words[this.length - 1], S = this._countBits(h);
        return (this.length - 1) * 26 + S;
      };
      function E(M) {
        for (var h = new Array(M.bitLength()), S = 0; S < h.length; S++) {
          var B = S / 26 | 0, T = S % 26;
          h[S] = M.words[B] >>> T & 1;
        }
        return h;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var h = 0, S = 0; S < this.length; S++) {
          var B = this._zeroBits(this.words[S]);
          if (h += B, B !== 26) break;
        }
        return h;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(h) {
        return this.negative !== 0 ? this.abs().inotn(h).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(h) {
        return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(h) {
        for (; this.length < h.length; )
          this.words[this.length++] = 0;
        for (var S = 0; S < h.length; S++)
          this.words[S] = this.words[S] | h.words[S];
        return this._strip();
      }, n.prototype.ior = function(h) {
        return a((this.negative | h.negative) === 0), this.iuor(h);
      }, n.prototype.or = function(h) {
        return this.length > h.length ? this.clone().ior(h) : h.clone().ior(this);
      }, n.prototype.uor = function(h) {
        return this.length > h.length ? this.clone().iuor(h) : h.clone().iuor(this);
      }, n.prototype.iuand = function(h) {
        var S;
        this.length > h.length ? S = h : S = this;
        for (var B = 0; B < S.length; B++)
          this.words[B] = this.words[B] & h.words[B];
        return this.length = S.length, this._strip();
      }, n.prototype.iand = function(h) {
        return a((this.negative | h.negative) === 0), this.iuand(h);
      }, n.prototype.and = function(h) {
        return this.length > h.length ? this.clone().iand(h) : h.clone().iand(this);
      }, n.prototype.uand = function(h) {
        return this.length > h.length ? this.clone().iuand(h) : h.clone().iuand(this);
      }, n.prototype.iuxor = function(h) {
        var S, B;
        this.length > h.length ? (S = this, B = h) : (S = h, B = this);
        for (var T = 0; T < B.length; T++)
          this.words[T] = S.words[T] ^ B.words[T];
        if (this !== S)
          for (; T < S.length; T++)
            this.words[T] = S.words[T];
        return this.length = S.length, this._strip();
      }, n.prototype.ixor = function(h) {
        return a((this.negative | h.negative) === 0), this.iuxor(h);
      }, n.prototype.xor = function(h) {
        return this.length > h.length ? this.clone().ixor(h) : h.clone().ixor(this);
      }, n.prototype.uxor = function(h) {
        return this.length > h.length ? this.clone().iuxor(h) : h.clone().iuxor(this);
      }, n.prototype.inotn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = Math.ceil(h / 26) | 0, B = h % 26;
        this._expand(S), B > 0 && S--;
        for (var T = 0; T < S; T++)
          this.words[T] = ~this.words[T] & 67108863;
        return B > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - B), this._strip();
      }, n.prototype.notn = function(h) {
        return this.clone().inotn(h);
      }, n.prototype.setn = function(h, S) {
        a(typeof h == "number" && h >= 0);
        var B = h / 26 | 0, T = h % 26;
        return this._expand(B + 1), S ? this.words[B] = this.words[B] | 1 << T : this.words[B] = this.words[B] & ~(1 << T), this._strip();
      }, n.prototype.iadd = function(h) {
        var S;
        if (this.negative !== 0 && h.negative === 0)
          return this.negative = 0, S = this.isub(h), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && h.negative !== 0)
          return h.negative = 0, S = this.isub(h), h.negative = 1, S._normSign();
        var B, T;
        this.length > h.length ? (B = this, T = h) : (B = h, T = this);
        for (var k = 0, I = 0; I < T.length; I++)
          S = (B.words[I] | 0) + (T.words[I] | 0) + k, this.words[I] = S & 67108863, k = S >>> 26;
        for (; k !== 0 && I < B.length; I++)
          S = (B.words[I] | 0) + k, this.words[I] = S & 67108863, k = S >>> 26;
        if (this.length = B.length, k !== 0)
          this.words[this.length] = k, this.length++;
        else if (B !== this)
          for (; I < B.length; I++)
            this.words[I] = B.words[I];
        return this;
      }, n.prototype.add = function(h) {
        var S;
        return h.negative !== 0 && this.negative === 0 ? (h.negative = 0, S = this.sub(h), h.negative ^= 1, S) : h.negative === 0 && this.negative !== 0 ? (this.negative = 0, S = h.sub(this), this.negative = 1, S) : this.length > h.length ? this.clone().iadd(h) : h.clone().iadd(this);
      }, n.prototype.isub = function(h) {
        if (h.negative !== 0) {
          h.negative = 0;
          var S = this.iadd(h);
          return h.negative = 1, S._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(h), this.negative = 1, this._normSign();
        var B = this.cmp(h);
        if (B === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var T, k;
        B > 0 ? (T = this, k = h) : (T = h, k = this);
        for (var I = 0, C = 0; C < k.length; C++)
          S = (T.words[C] | 0) - (k.words[C] | 0) + I, I = S >> 26, this.words[C] = S & 67108863;
        for (; I !== 0 && C < T.length; C++)
          S = (T.words[C] | 0) + I, I = S >> 26, this.words[C] = S & 67108863;
        if (I === 0 && C < T.length && T !== this)
          for (; C < T.length; C++)
            this.words[C] = T.words[C];
        return this.length = Math.max(this.length, C), T !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(h) {
        return this.clone().isub(h);
      };
      function b(M, h, S) {
        S.negative = h.negative ^ M.negative;
        var B = M.length + h.length | 0;
        S.length = B, B = B - 1 | 0;
        var T = M.words[0] | 0, k = h.words[0] | 0, I = T * k, C = I & 67108863, $ = I / 67108864 | 0;
        S.words[0] = C;
        for (var w = 1; w < B; w++) {
          for (var U = $ >>> 26, ie = $ & 67108863, le = Math.min(w, h.length - 1), ee = Math.max(0, w - M.length + 1); ee <= le; ee++) {
            var F = w - ee | 0;
            T = M.words[F] | 0, k = h.words[ee] | 0, I = T * k + ie, U += I / 67108864 | 0, ie = I & 67108863;
          }
          S.words[w] = ie | 0, $ = U | 0;
        }
        return $ !== 0 ? S.words[w] = $ | 0 : S.length--, S._strip();
      }
      var q = function(h, S, B) {
        var T = h.words, k = S.words, I = B.words, C = 0, $, w, U, ie = T[0] | 0, le = ie & 8191, ee = ie >>> 13, F = T[1] | 0, z = F & 8191, se = F >>> 13, he = T[2] | 0, ae = he & 8191, X = he >>> 13, be = T[3] | 0, Re = be & 8191, Pe = be >>> 13, Fe = T[4] | 0, De = Fe & 8191, je = Fe >>> 13, Oe = T[5] | 0, rt = Oe & 8191, He = Oe >>> 13, Qe = T[6] | 0, Je = Qe & 8191, we = Qe >>> 13, Ae = T[7] | 0, ze = Ae & 8191, Ue = Ae >>> 13, Ge = T[8] | 0, Xe = Ge & 8191, oe = Ge >>> 13, L = T[9] | 0, H = L & 8191, ue = L >>> 13, xe = k[0] | 0, pe = xe & 8191, ce = xe >>> 13, Y = k[1] | 0, Te = Y & 8191, Ne = Y >>> 13, K = k[2] | 0, Se = K & 8191, Ce = K >>> 13, de = k[3] | 0, _e = de & 8191, Me = de >>> 13, tt = k[4] | 0, We = tt & 8191, ne = tt >>> 13, W = k[5] | 0, J = W & 8191, me = W >>> 13, Ee = k[6] | 0, ke = Ee & 8191, Ie = Ee >>> 13, at = k[7] | 0, ot = at & 8191, it = at >>> 13, ct = k[8] | 0, nt = ct & 8191, st = ct >>> 13, yt = k[9] | 0, ft = yt & 8191, dt = yt >>> 13;
        B.negative = h.negative ^ S.negative, B.length = 19, $ = Math.imul(le, pe), w = Math.imul(le, ce), w = w + Math.imul(ee, pe) | 0, U = Math.imul(ee, ce);
        var Ut = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, $ = Math.imul(z, pe), w = Math.imul(z, ce), w = w + Math.imul(se, pe) | 0, U = Math.imul(se, ce), $ = $ + Math.imul(le, Te) | 0, w = w + Math.imul(le, Ne) | 0, w = w + Math.imul(ee, Te) | 0, U = U + Math.imul(ee, Ne) | 0;
        var Lt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, $ = Math.imul(ae, pe), w = Math.imul(ae, ce), w = w + Math.imul(X, pe) | 0, U = Math.imul(X, ce), $ = $ + Math.imul(z, Te) | 0, w = w + Math.imul(z, Ne) | 0, w = w + Math.imul(se, Te) | 0, U = U + Math.imul(se, Ne) | 0, $ = $ + Math.imul(le, Se) | 0, w = w + Math.imul(le, Ce) | 0, w = w + Math.imul(ee, Se) | 0, U = U + Math.imul(ee, Ce) | 0;
        var Dt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, $ = Math.imul(Re, pe), w = Math.imul(Re, ce), w = w + Math.imul(Pe, pe) | 0, U = Math.imul(Pe, ce), $ = $ + Math.imul(ae, Te) | 0, w = w + Math.imul(ae, Ne) | 0, w = w + Math.imul(X, Te) | 0, U = U + Math.imul(X, Ne) | 0, $ = $ + Math.imul(z, Se) | 0, w = w + Math.imul(z, Ce) | 0, w = w + Math.imul(se, Se) | 0, U = U + Math.imul(se, Ce) | 0, $ = $ + Math.imul(le, _e) | 0, w = w + Math.imul(le, Me) | 0, w = w + Math.imul(ee, _e) | 0, U = U + Math.imul(ee, Me) | 0;
        var Yt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, $ = Math.imul(De, pe), w = Math.imul(De, ce), w = w + Math.imul(je, pe) | 0, U = Math.imul(je, ce), $ = $ + Math.imul(Re, Te) | 0, w = w + Math.imul(Re, Ne) | 0, w = w + Math.imul(Pe, Te) | 0, U = U + Math.imul(Pe, Ne) | 0, $ = $ + Math.imul(ae, Se) | 0, w = w + Math.imul(ae, Ce) | 0, w = w + Math.imul(X, Se) | 0, U = U + Math.imul(X, Ce) | 0, $ = $ + Math.imul(z, _e) | 0, w = w + Math.imul(z, Me) | 0, w = w + Math.imul(se, _e) | 0, U = U + Math.imul(se, Me) | 0, $ = $ + Math.imul(le, We) | 0, w = w + Math.imul(le, ne) | 0, w = w + Math.imul(ee, We) | 0, U = U + Math.imul(ee, ne) | 0;
        var Kt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, $ = Math.imul(rt, pe), w = Math.imul(rt, ce), w = w + Math.imul(He, pe) | 0, U = Math.imul(He, ce), $ = $ + Math.imul(De, Te) | 0, w = w + Math.imul(De, Ne) | 0, w = w + Math.imul(je, Te) | 0, U = U + Math.imul(je, Ne) | 0, $ = $ + Math.imul(Re, Se) | 0, w = w + Math.imul(Re, Ce) | 0, w = w + Math.imul(Pe, Se) | 0, U = U + Math.imul(Pe, Ce) | 0, $ = $ + Math.imul(ae, _e) | 0, w = w + Math.imul(ae, Me) | 0, w = w + Math.imul(X, _e) | 0, U = U + Math.imul(X, Me) | 0, $ = $ + Math.imul(z, We) | 0, w = w + Math.imul(z, ne) | 0, w = w + Math.imul(se, We) | 0, U = U + Math.imul(se, ne) | 0, $ = $ + Math.imul(le, J) | 0, w = w + Math.imul(le, me) | 0, w = w + Math.imul(ee, J) | 0, U = U + Math.imul(ee, me) | 0;
        var Wt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, $ = Math.imul(Je, pe), w = Math.imul(Je, ce), w = w + Math.imul(we, pe) | 0, U = Math.imul(we, ce), $ = $ + Math.imul(rt, Te) | 0, w = w + Math.imul(rt, Ne) | 0, w = w + Math.imul(He, Te) | 0, U = U + Math.imul(He, Ne) | 0, $ = $ + Math.imul(De, Se) | 0, w = w + Math.imul(De, Ce) | 0, w = w + Math.imul(je, Se) | 0, U = U + Math.imul(je, Ce) | 0, $ = $ + Math.imul(Re, _e) | 0, w = w + Math.imul(Re, Me) | 0, w = w + Math.imul(Pe, _e) | 0, U = U + Math.imul(Pe, Me) | 0, $ = $ + Math.imul(ae, We) | 0, w = w + Math.imul(ae, ne) | 0, w = w + Math.imul(X, We) | 0, U = U + Math.imul(X, ne) | 0, $ = $ + Math.imul(z, J) | 0, w = w + Math.imul(z, me) | 0, w = w + Math.imul(se, J) | 0, U = U + Math.imul(se, me) | 0, $ = $ + Math.imul(le, ke) | 0, w = w + Math.imul(le, Ie) | 0, w = w + Math.imul(ee, ke) | 0, U = U + Math.imul(ee, Ie) | 0;
        var or = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, $ = Math.imul(ze, pe), w = Math.imul(ze, ce), w = w + Math.imul(Ue, pe) | 0, U = Math.imul(Ue, ce), $ = $ + Math.imul(Je, Te) | 0, w = w + Math.imul(Je, Ne) | 0, w = w + Math.imul(we, Te) | 0, U = U + Math.imul(we, Ne) | 0, $ = $ + Math.imul(rt, Se) | 0, w = w + Math.imul(rt, Ce) | 0, w = w + Math.imul(He, Se) | 0, U = U + Math.imul(He, Ce) | 0, $ = $ + Math.imul(De, _e) | 0, w = w + Math.imul(De, Me) | 0, w = w + Math.imul(je, _e) | 0, U = U + Math.imul(je, Me) | 0, $ = $ + Math.imul(Re, We) | 0, w = w + Math.imul(Re, ne) | 0, w = w + Math.imul(Pe, We) | 0, U = U + Math.imul(Pe, ne) | 0, $ = $ + Math.imul(ae, J) | 0, w = w + Math.imul(ae, me) | 0, w = w + Math.imul(X, J) | 0, U = U + Math.imul(X, me) | 0, $ = $ + Math.imul(z, ke) | 0, w = w + Math.imul(z, Ie) | 0, w = w + Math.imul(se, ke) | 0, U = U + Math.imul(se, Ie) | 0, $ = $ + Math.imul(le, ot) | 0, w = w + Math.imul(le, it) | 0, w = w + Math.imul(ee, ot) | 0, U = U + Math.imul(ee, it) | 0;
        var Gt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, $ = Math.imul(Xe, pe), w = Math.imul(Xe, ce), w = w + Math.imul(oe, pe) | 0, U = Math.imul(oe, ce), $ = $ + Math.imul(ze, Te) | 0, w = w + Math.imul(ze, Ne) | 0, w = w + Math.imul(Ue, Te) | 0, U = U + Math.imul(Ue, Ne) | 0, $ = $ + Math.imul(Je, Se) | 0, w = w + Math.imul(Je, Ce) | 0, w = w + Math.imul(we, Se) | 0, U = U + Math.imul(we, Ce) | 0, $ = $ + Math.imul(rt, _e) | 0, w = w + Math.imul(rt, Me) | 0, w = w + Math.imul(He, _e) | 0, U = U + Math.imul(He, Me) | 0, $ = $ + Math.imul(De, We) | 0, w = w + Math.imul(De, ne) | 0, w = w + Math.imul(je, We) | 0, U = U + Math.imul(je, ne) | 0, $ = $ + Math.imul(Re, J) | 0, w = w + Math.imul(Re, me) | 0, w = w + Math.imul(Pe, J) | 0, U = U + Math.imul(Pe, me) | 0, $ = $ + Math.imul(ae, ke) | 0, w = w + Math.imul(ae, Ie) | 0, w = w + Math.imul(X, ke) | 0, U = U + Math.imul(X, Ie) | 0, $ = $ + Math.imul(z, ot) | 0, w = w + Math.imul(z, it) | 0, w = w + Math.imul(se, ot) | 0, U = U + Math.imul(se, it) | 0, $ = $ + Math.imul(le, nt) | 0, w = w + Math.imul(le, st) | 0, w = w + Math.imul(ee, nt) | 0, U = U + Math.imul(ee, st) | 0;
        var cr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, $ = Math.imul(H, pe), w = Math.imul(H, ce), w = w + Math.imul(ue, pe) | 0, U = Math.imul(ue, ce), $ = $ + Math.imul(Xe, Te) | 0, w = w + Math.imul(Xe, Ne) | 0, w = w + Math.imul(oe, Te) | 0, U = U + Math.imul(oe, Ne) | 0, $ = $ + Math.imul(ze, Se) | 0, w = w + Math.imul(ze, Ce) | 0, w = w + Math.imul(Ue, Se) | 0, U = U + Math.imul(Ue, Ce) | 0, $ = $ + Math.imul(Je, _e) | 0, w = w + Math.imul(Je, Me) | 0, w = w + Math.imul(we, _e) | 0, U = U + Math.imul(we, Me) | 0, $ = $ + Math.imul(rt, We) | 0, w = w + Math.imul(rt, ne) | 0, w = w + Math.imul(He, We) | 0, U = U + Math.imul(He, ne) | 0, $ = $ + Math.imul(De, J) | 0, w = w + Math.imul(De, me) | 0, w = w + Math.imul(je, J) | 0, U = U + Math.imul(je, me) | 0, $ = $ + Math.imul(Re, ke) | 0, w = w + Math.imul(Re, Ie) | 0, w = w + Math.imul(Pe, ke) | 0, U = U + Math.imul(Pe, Ie) | 0, $ = $ + Math.imul(ae, ot) | 0, w = w + Math.imul(ae, it) | 0, w = w + Math.imul(X, ot) | 0, U = U + Math.imul(X, it) | 0, $ = $ + Math.imul(z, nt) | 0, w = w + Math.imul(z, st) | 0, w = w + Math.imul(se, nt) | 0, U = U + Math.imul(se, st) | 0, $ = $ + Math.imul(le, ft) | 0, w = w + Math.imul(le, dt) | 0, w = w + Math.imul(ee, ft) | 0, U = U + Math.imul(ee, dt) | 0;
        var ur = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, $ = Math.imul(H, Te), w = Math.imul(H, Ne), w = w + Math.imul(ue, Te) | 0, U = Math.imul(ue, Ne), $ = $ + Math.imul(Xe, Se) | 0, w = w + Math.imul(Xe, Ce) | 0, w = w + Math.imul(oe, Se) | 0, U = U + Math.imul(oe, Ce) | 0, $ = $ + Math.imul(ze, _e) | 0, w = w + Math.imul(ze, Me) | 0, w = w + Math.imul(Ue, _e) | 0, U = U + Math.imul(Ue, Me) | 0, $ = $ + Math.imul(Je, We) | 0, w = w + Math.imul(Je, ne) | 0, w = w + Math.imul(we, We) | 0, U = U + Math.imul(we, ne) | 0, $ = $ + Math.imul(rt, J) | 0, w = w + Math.imul(rt, me) | 0, w = w + Math.imul(He, J) | 0, U = U + Math.imul(He, me) | 0, $ = $ + Math.imul(De, ke) | 0, w = w + Math.imul(De, Ie) | 0, w = w + Math.imul(je, ke) | 0, U = U + Math.imul(je, Ie) | 0, $ = $ + Math.imul(Re, ot) | 0, w = w + Math.imul(Re, it) | 0, w = w + Math.imul(Pe, ot) | 0, U = U + Math.imul(Pe, it) | 0, $ = $ + Math.imul(ae, nt) | 0, w = w + Math.imul(ae, st) | 0, w = w + Math.imul(X, nt) | 0, U = U + Math.imul(X, st) | 0, $ = $ + Math.imul(z, ft) | 0, w = w + Math.imul(z, dt) | 0, w = w + Math.imul(se, ft) | 0, U = U + Math.imul(se, dt) | 0;
        var lr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, $ = Math.imul(H, Se), w = Math.imul(H, Ce), w = w + Math.imul(ue, Se) | 0, U = Math.imul(ue, Ce), $ = $ + Math.imul(Xe, _e) | 0, w = w + Math.imul(Xe, Me) | 0, w = w + Math.imul(oe, _e) | 0, U = U + Math.imul(oe, Me) | 0, $ = $ + Math.imul(ze, We) | 0, w = w + Math.imul(ze, ne) | 0, w = w + Math.imul(Ue, We) | 0, U = U + Math.imul(Ue, ne) | 0, $ = $ + Math.imul(Je, J) | 0, w = w + Math.imul(Je, me) | 0, w = w + Math.imul(we, J) | 0, U = U + Math.imul(we, me) | 0, $ = $ + Math.imul(rt, ke) | 0, w = w + Math.imul(rt, Ie) | 0, w = w + Math.imul(He, ke) | 0, U = U + Math.imul(He, Ie) | 0, $ = $ + Math.imul(De, ot) | 0, w = w + Math.imul(De, it) | 0, w = w + Math.imul(je, ot) | 0, U = U + Math.imul(je, it) | 0, $ = $ + Math.imul(Re, nt) | 0, w = w + Math.imul(Re, st) | 0, w = w + Math.imul(Pe, nt) | 0, U = U + Math.imul(Pe, st) | 0, $ = $ + Math.imul(ae, ft) | 0, w = w + Math.imul(ae, dt) | 0, w = w + Math.imul(X, ft) | 0, U = U + Math.imul(X, dt) | 0;
        var er = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, $ = Math.imul(H, _e), w = Math.imul(H, Me), w = w + Math.imul(ue, _e) | 0, U = Math.imul(ue, Me), $ = $ + Math.imul(Xe, We) | 0, w = w + Math.imul(Xe, ne) | 0, w = w + Math.imul(oe, We) | 0, U = U + Math.imul(oe, ne) | 0, $ = $ + Math.imul(ze, J) | 0, w = w + Math.imul(ze, me) | 0, w = w + Math.imul(Ue, J) | 0, U = U + Math.imul(Ue, me) | 0, $ = $ + Math.imul(Je, ke) | 0, w = w + Math.imul(Je, Ie) | 0, w = w + Math.imul(we, ke) | 0, U = U + Math.imul(we, Ie) | 0, $ = $ + Math.imul(rt, ot) | 0, w = w + Math.imul(rt, it) | 0, w = w + Math.imul(He, ot) | 0, U = U + Math.imul(He, it) | 0, $ = $ + Math.imul(De, nt) | 0, w = w + Math.imul(De, st) | 0, w = w + Math.imul(je, nt) | 0, U = U + Math.imul(je, st) | 0, $ = $ + Math.imul(Re, ft) | 0, w = w + Math.imul(Re, dt) | 0, w = w + Math.imul(Pe, ft) | 0, U = U + Math.imul(Pe, dt) | 0;
        var tr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, $ = Math.imul(H, We), w = Math.imul(H, ne), w = w + Math.imul(ue, We) | 0, U = Math.imul(ue, ne), $ = $ + Math.imul(Xe, J) | 0, w = w + Math.imul(Xe, me) | 0, w = w + Math.imul(oe, J) | 0, U = U + Math.imul(oe, me) | 0, $ = $ + Math.imul(ze, ke) | 0, w = w + Math.imul(ze, Ie) | 0, w = w + Math.imul(Ue, ke) | 0, U = U + Math.imul(Ue, Ie) | 0, $ = $ + Math.imul(Je, ot) | 0, w = w + Math.imul(Je, it) | 0, w = w + Math.imul(we, ot) | 0, U = U + Math.imul(we, it) | 0, $ = $ + Math.imul(rt, nt) | 0, w = w + Math.imul(rt, st) | 0, w = w + Math.imul(He, nt) | 0, U = U + Math.imul(He, st) | 0, $ = $ + Math.imul(De, ft) | 0, w = w + Math.imul(De, dt) | 0, w = w + Math.imul(je, ft) | 0, U = U + Math.imul(je, dt) | 0;
        var rr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, $ = Math.imul(H, J), w = Math.imul(H, me), w = w + Math.imul(ue, J) | 0, U = Math.imul(ue, me), $ = $ + Math.imul(Xe, ke) | 0, w = w + Math.imul(Xe, Ie) | 0, w = w + Math.imul(oe, ke) | 0, U = U + Math.imul(oe, Ie) | 0, $ = $ + Math.imul(ze, ot) | 0, w = w + Math.imul(ze, it) | 0, w = w + Math.imul(Ue, ot) | 0, U = U + Math.imul(Ue, it) | 0, $ = $ + Math.imul(Je, nt) | 0, w = w + Math.imul(Je, st) | 0, w = w + Math.imul(we, nt) | 0, U = U + Math.imul(we, st) | 0, $ = $ + Math.imul(rt, ft) | 0, w = w + Math.imul(rt, dt) | 0, w = w + Math.imul(He, ft) | 0, U = U + Math.imul(He, dt) | 0;
        var fr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, $ = Math.imul(H, ke), w = Math.imul(H, Ie), w = w + Math.imul(ue, ke) | 0, U = Math.imul(ue, Ie), $ = $ + Math.imul(Xe, ot) | 0, w = w + Math.imul(Xe, it) | 0, w = w + Math.imul(oe, ot) | 0, U = U + Math.imul(oe, it) | 0, $ = $ + Math.imul(ze, nt) | 0, w = w + Math.imul(ze, st) | 0, w = w + Math.imul(Ue, nt) | 0, U = U + Math.imul(Ue, st) | 0, $ = $ + Math.imul(Je, ft) | 0, w = w + Math.imul(Je, dt) | 0, w = w + Math.imul(we, ft) | 0, U = U + Math.imul(we, dt) | 0;
        var pr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, $ = Math.imul(H, ot), w = Math.imul(H, it), w = w + Math.imul(ue, ot) | 0, U = Math.imul(ue, it), $ = $ + Math.imul(Xe, nt) | 0, w = w + Math.imul(Xe, st) | 0, w = w + Math.imul(oe, nt) | 0, U = U + Math.imul(oe, st) | 0, $ = $ + Math.imul(ze, ft) | 0, w = w + Math.imul(ze, dt) | 0, w = w + Math.imul(Ue, ft) | 0, U = U + Math.imul(Ue, dt) | 0;
        var dr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, $ = Math.imul(H, nt), w = Math.imul(H, st), w = w + Math.imul(ue, nt) | 0, U = Math.imul(ue, st), $ = $ + Math.imul(Xe, ft) | 0, w = w + Math.imul(Xe, dt) | 0, w = w + Math.imul(oe, ft) | 0, U = U + Math.imul(oe, dt) | 0;
        var Lr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, $ = Math.imul(H, ft), w = Math.imul(H, dt), w = w + Math.imul(ue, ft) | 0, U = Math.imul(ue, dt);
        var Ir = (C + $ | 0) + ((w & 8191) << 13) | 0;
        return C = (U + (w >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, I[0] = Ut, I[1] = Lt, I[2] = Dt, I[3] = Yt, I[4] = Kt, I[5] = Wt, I[6] = or, I[7] = Gt, I[8] = cr, I[9] = ur, I[10] = lr, I[11] = er, I[12] = tr, I[13] = rr, I[14] = fr, I[15] = pr, I[16] = dr, I[17] = Lr, I[18] = Ir, C !== 0 && (I[19] = C, B.length++), B;
      };
      Math.imul || (q = b);
      function O(M, h, S) {
        S.negative = h.negative ^ M.negative, S.length = M.length + h.length;
        for (var B = 0, T = 0, k = 0; k < S.length - 1; k++) {
          var I = T;
          T = 0;
          for (var C = B & 67108863, $ = Math.min(k, h.length - 1), w = Math.max(0, k - M.length + 1); w <= $; w++) {
            var U = k - w, ie = M.words[U] | 0, le = h.words[w] | 0, ee = ie * le, F = ee & 67108863;
            I = I + (ee / 67108864 | 0) | 0, F = F + C | 0, C = F & 67108863, I = I + (F >>> 26) | 0, T += I >>> 26, I &= 67108863;
          }
          S.words[k] = C, B = I, I = T;
        }
        return B !== 0 ? S.words[k] = B : S.length--, S._strip();
      }
      function j(M, h, S) {
        return O(M, h, S);
      }
      n.prototype.mulTo = function(h, S) {
        var B, T = this.length + h.length;
        return this.length === 10 && h.length === 10 ? B = q(this, h, S) : T < 63 ? B = b(this, h, S) : T < 1024 ? B = O(this, h, S) : B = j(this, h, S), B;
      }, n.prototype.mul = function(h) {
        var S = new n(null);
        return S.words = new Array(this.length + h.length), this.mulTo(h, S);
      }, n.prototype.mulf = function(h) {
        var S = new n(null);
        return S.words = new Array(this.length + h.length), j(this, h, S);
      }, n.prototype.imul = function(h) {
        return this.clone().mulTo(h, this);
      }, n.prototype.imuln = function(h) {
        var S = h < 0;
        S && (h = -h), a(typeof h == "number"), a(h < 67108864);
        for (var B = 0, T = 0; T < this.length; T++) {
          var k = (this.words[T] | 0) * h, I = (k & 67108863) + (B & 67108863);
          B >>= 26, B += k / 67108864 | 0, B += I >>> 26, this.words[T] = I & 67108863;
        }
        return B !== 0 && (this.words[T] = B, this.length++), this.length = h === 0 ? 1 : this.length, S ? this.ineg() : this;
      }, n.prototype.muln = function(h) {
        return this.clone().imuln(h);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(h) {
        var S = E(h);
        if (S.length === 0) return new n(1);
        for (var B = this, T = 0; T < S.length && S[T] === 0; T++, B = B.sqr())
          ;
        if (++T < S.length)
          for (var k = B.sqr(); T < S.length; T++, k = k.sqr())
            S[T] !== 0 && (B = B.mul(k));
        return B;
      }, n.prototype.iushln = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26, T = 67108863 >>> 26 - S << 26 - S, k;
        if (S !== 0) {
          var I = 0;
          for (k = 0; k < this.length; k++) {
            var C = this.words[k] & T, $ = (this.words[k] | 0) - C << S;
            this.words[k] = $ | I, I = C >>> 26 - S;
          }
          I && (this.words[k] = I, this.length++);
        }
        if (B !== 0) {
          for (k = this.length - 1; k >= 0; k--)
            this.words[k + B] = this.words[k];
          for (k = 0; k < B; k++)
            this.words[k] = 0;
          this.length += B;
        }
        return this._strip();
      }, n.prototype.ishln = function(h) {
        return a(this.negative === 0), this.iushln(h);
      }, n.prototype.iushrn = function(h, S, B) {
        a(typeof h == "number" && h >= 0);
        var T;
        S ? T = (S - S % 26) / 26 : T = 0;
        var k = h % 26, I = Math.min((h - k) / 26, this.length), C = 67108863 ^ 67108863 >>> k << k, $ = B;
        if (T -= I, T = Math.max(0, T), $) {
          for (var w = 0; w < I; w++)
            $.words[w] = this.words[w];
          $.length = I;
        }
        if (I !== 0) if (this.length > I)
          for (this.length -= I, w = 0; w < this.length; w++)
            this.words[w] = this.words[w + I];
        else
          this.words[0] = 0, this.length = 1;
        var U = 0;
        for (w = this.length - 1; w >= 0 && (U !== 0 || w >= T); w--) {
          var ie = this.words[w] | 0;
          this.words[w] = U << 26 - k | ie >>> k, U = ie & C;
        }
        return $ && U !== 0 && ($.words[$.length++] = U), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(h, S, B) {
        return a(this.negative === 0), this.iushrn(h, S, B);
      }, n.prototype.shln = function(h) {
        return this.clone().ishln(h);
      }, n.prototype.ushln = function(h) {
        return this.clone().iushln(h);
      }, n.prototype.shrn = function(h) {
        return this.clone().ishrn(h);
      }, n.prototype.ushrn = function(h) {
        return this.clone().iushrn(h);
      }, n.prototype.testn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26, T = 1 << S;
        if (this.length <= B) return !1;
        var k = this.words[B];
        return !!(k & T);
      }, n.prototype.imaskn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26;
        if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= B)
          return this;
        if (S !== 0 && B++, this.length = Math.min(B, this.length), S !== 0) {
          var T = 67108863 ^ 67108863 >>> S << S;
          this.words[this.length - 1] &= T;
        }
        return this._strip();
      }, n.prototype.maskn = function(h) {
        return this.clone().imaskn(h);
      }, n.prototype.iaddn = function(h) {
        return a(typeof h == "number"), a(h < 67108864), h < 0 ? this.isubn(-h) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= h ? (this.words[0] = h - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(h), this.negative = 1, this) : this._iaddn(h);
      }, n.prototype._iaddn = function(h) {
        this.words[0] += h;
        for (var S = 0; S < this.length && this.words[S] >= 67108864; S++)
          this.words[S] -= 67108864, S === this.length - 1 ? this.words[S + 1] = 1 : this.words[S + 1]++;
        return this.length = Math.max(this.length, S + 1), this;
      }, n.prototype.isubn = function(h) {
        if (a(typeof h == "number"), a(h < 67108864), h < 0) return this.iaddn(-h);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(h), this.negative = 1, this;
        if (this.words[0] -= h, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var S = 0; S < this.length && this.words[S] < 0; S++)
            this.words[S] += 67108864, this.words[S + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(h) {
        return this.clone().iaddn(h);
      }, n.prototype.subn = function(h) {
        return this.clone().isubn(h);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(h, S, B) {
        var T = h.length + B, k;
        this._expand(T);
        var I, C = 0;
        for (k = 0; k < h.length; k++) {
          I = (this.words[k + B] | 0) + C;
          var $ = (h.words[k] | 0) * S;
          I -= $ & 67108863, C = (I >> 26) - ($ / 67108864 | 0), this.words[k + B] = I & 67108863;
        }
        for (; k < this.length - B; k++)
          I = (this.words[k + B] | 0) + C, C = I >> 26, this.words[k + B] = I & 67108863;
        if (C === 0) return this._strip();
        for (a(C === -1), C = 0, k = 0; k < this.length; k++)
          I = -(this.words[k] | 0) + C, C = I >> 26, this.words[k] = I & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(h, S) {
        var B = this.length - h.length, T = this.clone(), k = h, I = k.words[k.length - 1] | 0, C = this._countBits(I);
        B = 26 - C, B !== 0 && (k = k.ushln(B), T.iushln(B), I = k.words[k.length - 1] | 0);
        var $ = T.length - k.length, w;
        if (S !== "mod") {
          w = new n(null), w.length = $ + 1, w.words = new Array(w.length);
          for (var U = 0; U < w.length; U++)
            w.words[U] = 0;
        }
        var ie = T.clone()._ishlnsubmul(k, 1, $);
        ie.negative === 0 && (T = ie, w && (w.words[$] = 1));
        for (var le = $ - 1; le >= 0; le--) {
          var ee = (T.words[k.length + le] | 0) * 67108864 + (T.words[k.length + le - 1] | 0);
          for (ee = Math.min(ee / I | 0, 67108863), T._ishlnsubmul(k, ee, le); T.negative !== 0; )
            ee--, T.negative = 0, T._ishlnsubmul(k, 1, le), T.isZero() || (T.negative ^= 1);
          w && (w.words[le] = ee);
        }
        return w && w._strip(), T._strip(), S !== "div" && B !== 0 && T.iushrn(B), {
          div: w || null,
          mod: T
        };
      }, n.prototype.divmod = function(h, S, B) {
        if (a(!h.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var T, k, I;
        return this.negative !== 0 && h.negative === 0 ? (I = this.neg().divmod(h, S), S !== "mod" && (T = I.div.neg()), S !== "div" && (k = I.mod.neg(), B && k.negative !== 0 && k.iadd(h)), {
          div: T,
          mod: k
        }) : this.negative === 0 && h.negative !== 0 ? (I = this.divmod(h.neg(), S), S !== "mod" && (T = I.div.neg()), {
          div: T,
          mod: I.mod
        }) : (this.negative & h.negative) !== 0 ? (I = this.neg().divmod(h.neg(), S), S !== "div" && (k = I.mod.neg(), B && k.negative !== 0 && k.isub(h)), {
          div: I.div,
          mod: k
        }) : h.length > this.length || this.cmp(h) < 0 ? {
          div: new n(0),
          mod: this
        } : h.length === 1 ? S === "div" ? {
          div: this.divn(h.words[0]),
          mod: null
        } : S === "mod" ? {
          div: null,
          mod: new n(this.modrn(h.words[0]))
        } : {
          div: this.divn(h.words[0]),
          mod: new n(this.modrn(h.words[0]))
        } : this._wordDiv(h, S);
      }, n.prototype.div = function(h) {
        return this.divmod(h, "div", !1).div;
      }, n.prototype.mod = function(h) {
        return this.divmod(h, "mod", !1).mod;
      }, n.prototype.umod = function(h) {
        return this.divmod(h, "mod", !0).mod;
      }, n.prototype.divRound = function(h) {
        var S = this.divmod(h);
        if (S.mod.isZero()) return S.div;
        var B = S.div.negative !== 0 ? S.mod.isub(h) : S.mod, T = h.ushrn(1), k = h.andln(1), I = B.cmp(T);
        return I < 0 || k === 1 && I === 0 ? S.div : S.div.negative !== 0 ? S.div.isubn(1) : S.div.iaddn(1);
      }, n.prototype.modrn = function(h) {
        var S = h < 0;
        S && (h = -h), a(h <= 67108863);
        for (var B = (1 << 26) % h, T = 0, k = this.length - 1; k >= 0; k--)
          T = (B * T + (this.words[k] | 0)) % h;
        return S ? -T : T;
      }, n.prototype.modn = function(h) {
        return this.modrn(h);
      }, n.prototype.idivn = function(h) {
        var S = h < 0;
        S && (h = -h), a(h <= 67108863);
        for (var B = 0, T = this.length - 1; T >= 0; T--) {
          var k = (this.words[T] | 0) + B * 67108864;
          this.words[T] = k / h | 0, B = k % h;
        }
        return this._strip(), S ? this.ineg() : this;
      }, n.prototype.divn = function(h) {
        return this.clone().idivn(h);
      }, n.prototype.egcd = function(h) {
        a(h.negative === 0), a(!h.isZero());
        var S = this, B = h.clone();
        S.negative !== 0 ? S = S.umod(h) : S = S.clone();
        for (var T = new n(1), k = new n(0), I = new n(0), C = new n(1), $ = 0; S.isEven() && B.isEven(); )
          S.iushrn(1), B.iushrn(1), ++$;
        for (var w = B.clone(), U = S.clone(); !S.isZero(); ) {
          for (var ie = 0, le = 1; (S.words[0] & le) === 0 && ie < 26; ++ie, le <<= 1) ;
          if (ie > 0)
            for (S.iushrn(ie); ie-- > 0; )
              (T.isOdd() || k.isOdd()) && (T.iadd(w), k.isub(U)), T.iushrn(1), k.iushrn(1);
          for (var ee = 0, F = 1; (B.words[0] & F) === 0 && ee < 26; ++ee, F <<= 1) ;
          if (ee > 0)
            for (B.iushrn(ee); ee-- > 0; )
              (I.isOdd() || C.isOdd()) && (I.iadd(w), C.isub(U)), I.iushrn(1), C.iushrn(1);
          S.cmp(B) >= 0 ? (S.isub(B), T.isub(I), k.isub(C)) : (B.isub(S), I.isub(T), C.isub(k));
        }
        return {
          a: I,
          b: C,
          gcd: B.iushln($)
        };
      }, n.prototype._invmp = function(h) {
        a(h.negative === 0), a(!h.isZero());
        var S = this, B = h.clone();
        S.negative !== 0 ? S = S.umod(h) : S = S.clone();
        for (var T = new n(1), k = new n(0), I = B.clone(); S.cmpn(1) > 0 && B.cmpn(1) > 0; ) {
          for (var C = 0, $ = 1; (S.words[0] & $) === 0 && C < 26; ++C, $ <<= 1) ;
          if (C > 0)
            for (S.iushrn(C); C-- > 0; )
              T.isOdd() && T.iadd(I), T.iushrn(1);
          for (var w = 0, U = 1; (B.words[0] & U) === 0 && w < 26; ++w, U <<= 1) ;
          if (w > 0)
            for (B.iushrn(w); w-- > 0; )
              k.isOdd() && k.iadd(I), k.iushrn(1);
          S.cmp(B) >= 0 ? (S.isub(B), T.isub(k)) : (B.isub(S), k.isub(T));
        }
        var ie;
        return S.cmpn(1) === 0 ? ie = T : ie = k, ie.cmpn(0) < 0 && ie.iadd(h), ie;
      }, n.prototype.gcd = function(h) {
        if (this.isZero()) return h.abs();
        if (h.isZero()) return this.abs();
        var S = this.clone(), B = h.clone();
        S.negative = 0, B.negative = 0;
        for (var T = 0; S.isEven() && B.isEven(); T++)
          S.iushrn(1), B.iushrn(1);
        do {
          for (; S.isEven(); )
            S.iushrn(1);
          for (; B.isEven(); )
            B.iushrn(1);
          var k = S.cmp(B);
          if (k < 0) {
            var I = S;
            S = B, B = I;
          } else if (k === 0 || B.cmpn(1) === 0)
            break;
          S.isub(B);
        } while (!0);
        return B.iushln(T);
      }, n.prototype.invm = function(h) {
        return this.egcd(h).a.umod(h);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(h) {
        return this.words[0] & h;
      }, n.prototype.bincn = function(h) {
        a(typeof h == "number");
        var S = h % 26, B = (h - S) / 26, T = 1 << S;
        if (this.length <= B)
          return this._expand(B + 1), this.words[B] |= T, this;
        for (var k = T, I = B; k !== 0 && I < this.length; I++) {
          var C = this.words[I] | 0;
          C += k, k = C >>> 26, C &= 67108863, this.words[I] = C;
        }
        return k !== 0 && (this.words[I] = k, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(h) {
        var S = h < 0;
        if (this.negative !== 0 && !S) return -1;
        if (this.negative === 0 && S) return 1;
        this._strip();
        var B;
        if (this.length > 1)
          B = 1;
        else {
          S && (h = -h), a(h <= 67108863, "Number is too big");
          var T = this.words[0] | 0;
          B = T === h ? 0 : T < h ? -1 : 1;
        }
        return this.negative !== 0 ? -B | 0 : B;
      }, n.prototype.cmp = function(h) {
        if (this.negative !== 0 && h.negative === 0) return -1;
        if (this.negative === 0 && h.negative !== 0) return 1;
        var S = this.ucmp(h);
        return this.negative !== 0 ? -S | 0 : S;
      }, n.prototype.ucmp = function(h) {
        if (this.length > h.length) return 1;
        if (this.length < h.length) return -1;
        for (var S = 0, B = this.length - 1; B >= 0; B--) {
          var T = this.words[B] | 0, k = h.words[B] | 0;
          if (T !== k) {
            T < k ? S = -1 : T > k && (S = 1);
            break;
          }
        }
        return S;
      }, n.prototype.gtn = function(h) {
        return this.cmpn(h) === 1;
      }, n.prototype.gt = function(h) {
        return this.cmp(h) === 1;
      }, n.prototype.gten = function(h) {
        return this.cmpn(h) >= 0;
      }, n.prototype.gte = function(h) {
        return this.cmp(h) >= 0;
      }, n.prototype.ltn = function(h) {
        return this.cmpn(h) === -1;
      }, n.prototype.lt = function(h) {
        return this.cmp(h) === -1;
      }, n.prototype.lten = function(h) {
        return this.cmpn(h) <= 0;
      }, n.prototype.lte = function(h) {
        return this.cmp(h) <= 0;
      }, n.prototype.eqn = function(h) {
        return this.cmpn(h) === 0;
      }, n.prototype.eq = function(h) {
        return this.cmp(h) === 0;
      }, n.red = function(h) {
        return new te(h);
      }, n.prototype.toRed = function(h) {
        return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), h.convertTo(this)._forceRed(h);
      }, n.prototype.fromRed = function() {
        return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(h) {
        return this.red = h, this;
      }, n.prototype.forceRed = function(h) {
        return a(!this.red, "Already a number in reduction context"), this._forceRed(h);
      }, n.prototype.redAdd = function(h) {
        return a(this.red, "redAdd works only with red numbers"), this.red.add(this, h);
      }, n.prototype.redIAdd = function(h) {
        return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, h);
      }, n.prototype.redSub = function(h) {
        return a(this.red, "redSub works only with red numbers"), this.red.sub(this, h);
      }, n.prototype.redISub = function(h) {
        return a(this.red, "redISub works only with red numbers"), this.red.isub(this, h);
      }, n.prototype.redShl = function(h) {
        return a(this.red, "redShl works only with red numbers"), this.red.shl(this, h);
      }, n.prototype.redMul = function(h) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.mul(this, h);
      }, n.prototype.redIMul = function(h) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.imul(this, h);
      }, n.prototype.redSqr = function() {
        return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(h) {
        return a(this.red && !h.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, h);
      };
      var D = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function G(M, h) {
        this.name = M, this.p = new n(h, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      G.prototype._tmp = function() {
        var h = new n(null);
        return h.words = new Array(Math.ceil(this.n / 13)), h;
      }, G.prototype.ireduce = function(h) {
        var S = h, B;
        do
          this.split(S, this.tmp), S = this.imulK(S), S = S.iadd(this.tmp), B = S.bitLength();
        while (B > this.n);
        var T = B < this.n ? -1 : S.ucmp(this.p);
        return T === 0 ? (S.words[0] = 0, S.length = 1) : T > 0 ? S.isub(this.p) : S.strip !== void 0 ? S.strip() : S._strip(), S;
      }, G.prototype.split = function(h, S) {
        h.iushrn(this.n, 0, S);
      }, G.prototype.imulK = function(h) {
        return h.imul(this.k);
      };
      function V() {
        G.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      u(V, G), V.prototype.split = function(h, S) {
        for (var B = 4194303, T = Math.min(h.length, 9), k = 0; k < T; k++)
          S.words[k] = h.words[k];
        if (S.length = T, h.length <= 9) {
          h.words[0] = 0, h.length = 1;
          return;
        }
        var I = h.words[9];
        for (S.words[S.length++] = I & B, k = 10; k < h.length; k++) {
          var C = h.words[k] | 0;
          h.words[k - 10] = (C & B) << 4 | I >>> 22, I = C;
        }
        I >>>= 22, h.words[k - 10] = I, I === 0 && h.length > 10 ? h.length -= 10 : h.length -= 9;
      }, V.prototype.imulK = function(h) {
        h.words[h.length] = 0, h.words[h.length + 1] = 0, h.length += 2;
        for (var S = 0, B = 0; B < h.length; B++) {
          var T = h.words[B] | 0;
          S += T * 977, h.words[B] = S & 67108863, S = T * 64 + (S / 67108864 | 0);
        }
        return h.words[h.length - 1] === 0 && (h.length--, h.words[h.length - 1] === 0 && h.length--), h;
      };
      function Q() {
        G.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      u(Q, G);
      function re() {
        G.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      u(re, G);
      function ve() {
        G.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      u(ve, G), ve.prototype.imulK = function(h) {
        for (var S = 0, B = 0; B < h.length; B++) {
          var T = (h.words[B] | 0) * 19 + S, k = T & 67108863;
          T >>>= 26, h.words[B] = k, S = T;
        }
        return S !== 0 && (h.words[h.length++] = S), h;
      }, n._prime = function(h) {
        if (D[h]) return D[h];
        var S;
        if (h === "k256")
          S = new V();
        else if (h === "p224")
          S = new Q();
        else if (h === "p192")
          S = new re();
        else if (h === "p25519")
          S = new ve();
        else
          throw new Error("Unknown prime " + h);
        return D[h] = S, S;
      };
      function te(M) {
        if (typeof M == "string") {
          var h = n._prime(M);
          this.m = h.p, this.prime = h;
        } else
          a(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      te.prototype._verify1 = function(h) {
        a(h.negative === 0, "red works only with positives"), a(h.red, "red works only with red numbers");
      }, te.prototype._verify2 = function(h, S) {
        a((h.negative | S.negative) === 0, "red works only with positives"), a(
          h.red && h.red === S.red,
          "red works only with red numbers"
        );
      }, te.prototype.imod = function(h) {
        return this.prime ? this.prime.ireduce(h)._forceRed(this) : (s(h, h.umod(this.m)._forceRed(this)), h);
      }, te.prototype.neg = function(h) {
        return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
      }, te.prototype.add = function(h, S) {
        this._verify2(h, S);
        var B = h.add(S);
        return B.cmp(this.m) >= 0 && B.isub(this.m), B._forceRed(this);
      }, te.prototype.iadd = function(h, S) {
        this._verify2(h, S);
        var B = h.iadd(S);
        return B.cmp(this.m) >= 0 && B.isub(this.m), B;
      }, te.prototype.sub = function(h, S) {
        this._verify2(h, S);
        var B = h.sub(S);
        return B.cmpn(0) < 0 && B.iadd(this.m), B._forceRed(this);
      }, te.prototype.isub = function(h, S) {
        this._verify2(h, S);
        var B = h.isub(S);
        return B.cmpn(0) < 0 && B.iadd(this.m), B;
      }, te.prototype.shl = function(h, S) {
        return this._verify1(h), this.imod(h.ushln(S));
      }, te.prototype.imul = function(h, S) {
        return this._verify2(h, S), this.imod(h.imul(S));
      }, te.prototype.mul = function(h, S) {
        return this._verify2(h, S), this.imod(h.mul(S));
      }, te.prototype.isqr = function(h) {
        return this.imul(h, h.clone());
      }, te.prototype.sqr = function(h) {
        return this.mul(h, h);
      }, te.prototype.sqrt = function(h) {
        if (h.isZero()) return h.clone();
        var S = this.m.andln(3);
        if (a(S % 2 === 1), S === 3) {
          var B = this.m.add(new n(1)).iushrn(2);
          return this.pow(h, B);
        }
        for (var T = this.m.subn(1), k = 0; !T.isZero() && T.andln(1) === 0; )
          k++, T.iushrn(1);
        a(!T.isZero());
        var I = new n(1).toRed(this), C = I.redNeg(), $ = this.m.subn(1).iushrn(1), w = this.m.bitLength();
        for (w = new n(2 * w * w).toRed(this); this.pow(w, $).cmp(C) !== 0; )
          w.redIAdd(C);
        for (var U = this.pow(w, T), ie = this.pow(h, T.addn(1).iushrn(1)), le = this.pow(h, T), ee = k; le.cmp(I) !== 0; ) {
          for (var F = le, z = 0; F.cmp(I) !== 0; z++)
            F = F.redSqr();
          a(z < ee);
          var se = this.pow(U, new n(1).iushln(ee - z - 1));
          ie = ie.redMul(se), U = se.redSqr(), le = le.redMul(U), ee = z;
        }
        return ie;
      }, te.prototype.invm = function(h) {
        var S = h._invmp(this.m);
        return S.negative !== 0 ? (S.negative = 0, this.imod(S).redNeg()) : this.imod(S);
      }, te.prototype.pow = function(h, S) {
        if (S.isZero()) return new n(1).toRed(this);
        if (S.cmpn(1) === 0) return h.clone();
        var B = 4, T = new Array(1 << B);
        T[0] = new n(1).toRed(this), T[1] = h;
        for (var k = 2; k < T.length; k++)
          T[k] = this.mul(T[k - 1], h);
        var I = T[0], C = 0, $ = 0, w = S.bitLength() % 26;
        for (w === 0 && (w = 26), k = S.length - 1; k >= 0; k--) {
          for (var U = S.words[k], ie = w - 1; ie >= 0; ie--) {
            var le = U >> ie & 1;
            if (I !== T[0] && (I = this.sqr(I)), le === 0 && C === 0) {
              $ = 0;
              continue;
            }
            C <<= 1, C |= le, $++, !($ !== B && (k !== 0 || ie !== 0)) && (I = this.mul(I, T[C]), $ = 0, C = 0);
          }
          w = 26;
        }
        return I;
      }, te.prototype.convertTo = function(h) {
        var S = h.umod(this.m);
        return S === h ? S.clone() : S;
      }, te.prototype.convertFrom = function(h) {
        var S = h.clone();
        return S.red = null, S;
      }, n.mont = function(h) {
        return new R(h);
      };
      function R(M) {
        te.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      u(R, te), R.prototype.convertTo = function(h) {
        return this.imod(h.ushln(this.shift));
      }, R.prototype.convertFrom = function(h) {
        var S = this.imod(h.mul(this.rinv));
        return S.red = null, S;
      }, R.prototype.imul = function(h, S) {
        if (h.isZero() || S.isZero())
          return h.words[0] = 0, h.length = 1, h;
        var B = h.imul(S), T = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = B.isub(T).iushrn(this.shift), I = k;
        return k.cmp(this.m) >= 0 ? I = k.isub(this.m) : k.cmpn(0) < 0 && (I = k.iadd(this.m)), I._forceRed(this);
      }, R.prototype.mul = function(h, S) {
        if (h.isZero() || S.isZero()) return new n(0)._forceRed(this);
        var B = h.mul(S), T = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = B.isub(T).iushrn(this.shift), I = k;
        return k.cmp(this.m) >= 0 ? I = k.isub(this.m) : k.cmpn(0) < 0 && (I = k.iadd(this.m)), I._forceRed(this);
      }, R.prototype.invm = function(h) {
        var S = this.imod(h._invmp(this.m).mul(this.r2));
        return S._forceRed(this);
      };
    })(e, bn$2);
  })(bn$3)), bn$3.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var e = requireBn$1(), t = requireBrowser$i(), r = requireSafeBuffer$4().Buffer;
  function a(o) {
    var c = o.modulus.byteLength(), f;
    do
      f = new e(t(c));
    while (f.cmp(o.modulus) >= 0 || !f.umod(o.prime1) || !f.umod(o.prime2));
    return f;
  }
  function u(o) {
    var c = a(o), f = c.toRed(e.mont(o.modulus)).redPow(new e(o.publicExponent)).fromRed();
    return { blinder: f, unblinder: c.invm(o.modulus) };
  }
  function n(o, c) {
    var f = u(c), l = c.modulus.byteLength(), s = new e(o).mul(f.blinder).umod(c.modulus), p = s.toRed(e.mont(c.prime1)), m = s.toRed(e.mont(c.prime2)), g = c.coefficient, y = c.prime1, v = c.prime2, E = p.redPow(c.exponent1).fromRed(), b = m.redPow(c.exponent2).fromRed(), q = E.isub(b).imul(g).umod(y).imul(v);
    return b.iadd(q).imul(f.unblinder).umod(c.modulus).toArrayLike(r, "be", l);
  }
  return n.getr = a, browserifyRsa = n, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0$7 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  return hasRequiredUtils$3 || (hasRequiredUtils$3 = 1, (function(e) {
    var t = e;
    function r(n, o) {
      if (Array.isArray(n))
        return n.slice();
      if (!n)
        return [];
      var c = [];
      if (typeof n != "string") {
        for (var f = 0; f < n.length; f++)
          c[f] = n[f] | 0;
        return c;
      }
      if (o === "hex") {
        n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n);
        for (var f = 0; f < n.length; f += 2)
          c.push(parseInt(n[f] + n[f + 1], 16));
      } else
        for (var f = 0; f < n.length; f++) {
          var l = n.charCodeAt(f), s = l >> 8, p = l & 255;
          s ? c.push(s, p) : c.push(p);
        }
      return c;
    }
    t.toArray = r;
    function a(n) {
      return n.length === 1 ? "0" + n : n;
    }
    t.zero2 = a;
    function u(n) {
      for (var o = "", c = 0; c < n.length; c++)
        o += a(n[c].toString(16));
      return o;
    }
    t.toHex = u, t.encode = function(o, c) {
      return c === "hex" ? u(o) : o;
    };
  })(utils$2)), utils$2;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, (function(e) {
    var t = e, r = requireBn$2(), a = requireMinimalisticAssert(), u = requireUtils$3();
    t.assert = a, t.toArray = u.toArray, t.zero2 = u.zero2, t.toHex = u.toHex, t.encode = u.encode;
    function n(s, p, m) {
      var g = new Array(Math.max(s.bitLength(), m) + 1), y;
      for (y = 0; y < g.length; y += 1)
        g[y] = 0;
      var v = 1 << p + 1, E = s.clone();
      for (y = 0; y < g.length; y++) {
        var b, q = E.andln(v - 1);
        E.isOdd() ? (q > (v >> 1) - 1 ? b = (v >> 1) - q : b = q, E.isubn(b)) : b = 0, g[y] = b, E.iushrn(1);
      }
      return g;
    }
    t.getNAF = n;
    function o(s, p) {
      var m = [
        [],
        []
      ];
      s = s.clone(), p = p.clone();
      for (var g = 0, y = 0, v; s.cmpn(-g) > 0 || p.cmpn(-y) > 0; ) {
        var E = s.andln(3) + g & 3, b = p.andln(3) + y & 3;
        E === 3 && (E = -1), b === 3 && (b = -1);
        var q;
        (E & 1) === 0 ? q = 0 : (v = s.andln(7) + g & 7, (v === 3 || v === 5) && b === 2 ? q = -E : q = E), m[0].push(q);
        var O;
        (b & 1) === 0 ? O = 0 : (v = p.andln(7) + y & 7, (v === 3 || v === 5) && E === 2 ? O = -b : O = b), m[1].push(O), 2 * g === q + 1 && (g = 1 - g), 2 * y === O + 1 && (y = 1 - y), s.iushrn(1), p.iushrn(1);
      }
      return m;
    }
    t.getJSF = o;
    function c(s, p, m) {
      var g = "_" + p;
      s.prototype[p] = function() {
        return this[g] !== void 0 ? this[g] : this[g] = m.call(this);
      };
    }
    t.cachedProperty = c;
    function f(s) {
      return typeof s == "string" ? t.toArray(s, "hex") : s;
    }
    t.parseBytes = f;
    function l(s) {
      return new r(s, "hex", "le");
    }
    t.intFromLE = l;
  })(utils$3)), utils$3;
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$1;
  hasRequiredBase$1 = 1;
  var e = requireBn$2(), t = requireUtils$2(), r = t.getNAF, a = t.getJSF, u = t.assert;
  function n(c, f) {
    this.type = c, this.p = new e(f.p, 16), this.red = f.prime ? e.red(f.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = f.n && new e(f.n, 16), this.g = f.g && this.pointFromJSON(f.g, f.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var l = this.n && this.p.div(this.n);
    !l || l.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1 = n, n.prototype.point = function() {
    throw new Error("Not implemented");
  }, n.prototype.validate = function() {
    throw new Error("Not implemented");
  }, n.prototype._fixedNafMul = function(f, l) {
    u(f.precomputed);
    var s = f._getDoubles(), p = r(l, 1, this._bitLength), m = (1 << s.step + 1) - (s.step % 2 === 0 ? 2 : 1);
    m /= 3;
    var g = [], y, v;
    for (y = 0; y < p.length; y += s.step) {
      v = 0;
      for (var E = y + s.step - 1; E >= y; E--)
        v = (v << 1) + p[E];
      g.push(v);
    }
    for (var b = this.jpoint(null, null, null), q = this.jpoint(null, null, null), O = m; O > 0; O--) {
      for (y = 0; y < g.length; y++)
        v = g[y], v === O ? q = q.mixedAdd(s.points[y]) : v === -O && (q = q.mixedAdd(s.points[y].neg()));
      b = b.add(q);
    }
    return b.toP();
  }, n.prototype._wnafMul = function(f, l) {
    var s = 4, p = f._getNAFPoints(s);
    s = p.wnd;
    for (var m = p.points, g = r(l, s, this._bitLength), y = this.jpoint(null, null, null), v = g.length - 1; v >= 0; v--) {
      for (var E = 0; v >= 0 && g[v] === 0; v--)
        E++;
      if (v >= 0 && E++, y = y.dblp(E), v < 0)
        break;
      var b = g[v];
      u(b !== 0), f.type === "affine" ? b > 0 ? y = y.mixedAdd(m[b - 1 >> 1]) : y = y.mixedAdd(m[-b - 1 >> 1].neg()) : b > 0 ? y = y.add(m[b - 1 >> 1]) : y = y.add(m[-b - 1 >> 1].neg());
    }
    return f.type === "affine" ? y.toP() : y;
  }, n.prototype._wnafMulAdd = function(f, l, s, p, m) {
    var g = this._wnafT1, y = this._wnafT2, v = this._wnafT3, E = 0, b, q, O;
    for (b = 0; b < p; b++) {
      O = l[b];
      var j = O._getNAFPoints(f);
      g[b] = j.wnd, y[b] = j.points;
    }
    for (b = p - 1; b >= 1; b -= 2) {
      var D = b - 1, G = b;
      if (g[D] !== 1 || g[G] !== 1) {
        v[D] = r(s[D], g[D], this._bitLength), v[G] = r(s[G], g[G], this._bitLength), E = Math.max(v[D].length, E), E = Math.max(v[G].length, E);
        continue;
      }
      var V = [
        l[D],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        l[G]
        /* 7 */
      ];
      l[D].y.cmp(l[G].y) === 0 ? (V[1] = l[D].add(l[G]), V[2] = l[D].toJ().mixedAdd(l[G].neg())) : l[D].y.cmp(l[G].y.redNeg()) === 0 ? (V[1] = l[D].toJ().mixedAdd(l[G]), V[2] = l[D].add(l[G].neg())) : (V[1] = l[D].toJ().mixedAdd(l[G]), V[2] = l[D].toJ().mixedAdd(l[G].neg()));
      var Q = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], re = a(s[D], s[G]);
      for (E = Math.max(re[0].length, E), v[D] = new Array(E), v[G] = new Array(E), q = 0; q < E; q++) {
        var ve = re[0][q] | 0, te = re[1][q] | 0;
        v[D][q] = Q[(ve + 1) * 3 + (te + 1)], v[G][q] = 0, y[D] = V;
      }
    }
    var R = this.jpoint(null, null, null), M = this._wnafT4;
    for (b = E; b >= 0; b--) {
      for (var h = 0; b >= 0; ) {
        var S = !0;
        for (q = 0; q < p; q++)
          M[q] = v[q][b] | 0, M[q] !== 0 && (S = !1);
        if (!S)
          break;
        h++, b--;
      }
      if (b >= 0 && h++, R = R.dblp(h), b < 0)
        break;
      for (q = 0; q < p; q++) {
        var B = M[q];
        B !== 0 && (B > 0 ? O = y[q][B - 1 >> 1] : B < 0 && (O = y[q][-B - 1 >> 1].neg()), O.type === "affine" ? R = R.mixedAdd(O) : R = R.add(O));
      }
    }
    for (b = 0; b < p; b++)
      y[b] = null;
    return m ? R : R.toP();
  };
  function o(c, f) {
    this.curve = c, this.type = f, this.precomputed = null;
  }
  return n.BasePoint = o, o.prototype.eq = function() {
    throw new Error("Not implemented");
  }, o.prototype.validate = function() {
    return this.curve.validate(this);
  }, n.prototype.decodePoint = function(f, l) {
    f = t.toArray(f, l);
    var s = this.p.byteLength();
    if ((f[0] === 4 || f[0] === 6 || f[0] === 7) && f.length - 1 === 2 * s) {
      f[0] === 6 ? u(f[f.length - 1] % 2 === 0) : f[0] === 7 && u(f[f.length - 1] % 2 === 1);
      var p = this.point(
        f.slice(1, 1 + s),
        f.slice(1 + s, 1 + 2 * s)
      );
      return p;
    } else if ((f[0] === 2 || f[0] === 3) && f.length - 1 === s)
      return this.pointFromX(f.slice(1, 1 + s), f[0] === 3);
    throw new Error("Unknown point format");
  }, o.prototype.encodeCompressed = function(f) {
    return this.encode(f, !0);
  }, o.prototype._encode = function(f) {
    var l = this.curve.p.byteLength(), s = this.getX().toArray("be", l);
    return f ? [this.getY().isEven() ? 2 : 3].concat(s) : [4].concat(s, this.getY().toArray("be", l));
  }, o.prototype.encode = function(f, l) {
    return t.encode(this._encode(l), f);
  }, o.prototype.precompute = function(f) {
    if (this.precomputed)
      return this;
    var l = {
      doubles: null,
      naf: null,
      beta: null
    };
    return l.naf = this._getNAFPoints(8), l.doubles = this._getDoubles(4, f), l.beta = this._getBeta(), this.precomputed = l, this;
  }, o.prototype._hasDoubles = function(f) {
    if (!this.precomputed)
      return !1;
    var l = this.precomputed.doubles;
    return l ? l.points.length >= Math.ceil((f.bitLength() + 1) / l.step) : !1;
  }, o.prototype._getDoubles = function(f, l) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var s = [this], p = this, m = 0; m < l; m += f) {
      for (var g = 0; g < f; g++)
        p = p.dbl();
      s.push(p);
    }
    return {
      step: f,
      points: s
    };
  }, o.prototype._getNAFPoints = function(f) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var l = [this], s = (1 << f) - 1, p = s === 1 ? null : this.dbl(), m = 1; m < s; m++)
      l[m] = l[m - 1].add(p);
    return {
      wnd: f,
      points: l
    };
  }, o.prototype._getBeta = function() {
    return null;
  }, o.prototype.dblp = function(f) {
    for (var l = this, s = 0; s < f; s++)
      l = l.dbl();
    return l;
  }, base$1;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var e = requireUtils$2(), t = requireBn$2(), r = requireInherits_browser(), a = requireBase$1(), u = e.assert;
  function n(f) {
    a.call(this, "short", f), this.a = new t(f.a, 16).toRed(this.red), this.b = new t(f.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(f), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  r(n, a), short = n, n.prototype._getEndomorphism = function(l) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var s, p;
      if (l.beta)
        s = new t(l.beta, 16).toRed(this.red);
      else {
        var m = this._getEndoRoots(this.p);
        s = m[0].cmp(m[1]) < 0 ? m[0] : m[1], s = s.toRed(this.red);
      }
      if (l.lambda)
        p = new t(l.lambda, 16);
      else {
        var g = this._getEndoRoots(this.n);
        this.g.mul(g[0]).x.cmp(this.g.x.redMul(s)) === 0 ? p = g[0] : (p = g[1], u(this.g.mul(p).x.cmp(this.g.x.redMul(s)) === 0));
      }
      var y;
      return l.basis ? y = l.basis.map(function(v) {
        return {
          a: new t(v.a, 16),
          b: new t(v.b, 16)
        };
      }) : y = this._getEndoBasis(p), {
        beta: s,
        lambda: p,
        basis: y
      };
    }
  }, n.prototype._getEndoRoots = function(l) {
    var s = l === this.p ? this.red : t.mont(l), p = new t(2).toRed(s).redInvm(), m = p.redNeg(), g = new t(3).toRed(s).redNeg().redSqrt().redMul(p), y = m.redAdd(g).fromRed(), v = m.redSub(g).fromRed();
    return [y, v];
  }, n.prototype._getEndoBasis = function(l) {
    for (var s = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), p = l, m = this.n.clone(), g = new t(1), y = new t(0), v = new t(0), E = new t(1), b, q, O, j, D, G, V, Q = 0, re, ve; p.cmpn(0) !== 0; ) {
      var te = m.div(p);
      re = m.sub(te.mul(p)), ve = v.sub(te.mul(g));
      var R = E.sub(te.mul(y));
      if (!O && re.cmp(s) < 0)
        b = V.neg(), q = g, O = re.neg(), j = ve;
      else if (O && ++Q === 2)
        break;
      V = re, m = p, p = re, v = g, g = ve, E = y, y = R;
    }
    D = re.neg(), G = ve;
    var M = O.sqr().add(j.sqr()), h = D.sqr().add(G.sqr());
    return h.cmp(M) >= 0 && (D = b, G = q), O.negative && (O = O.neg(), j = j.neg()), D.negative && (D = D.neg(), G = G.neg()), [
      { a: O, b: j },
      { a: D, b: G }
    ];
  }, n.prototype._endoSplit = function(l) {
    var s = this.endo.basis, p = s[0], m = s[1], g = m.b.mul(l).divRound(this.n), y = p.b.neg().mul(l).divRound(this.n), v = g.mul(p.a), E = y.mul(m.a), b = g.mul(p.b), q = y.mul(m.b), O = l.sub(v).sub(E), j = b.add(q).neg();
    return { k1: O, k2: j };
  }, n.prototype.pointFromX = function(l, s) {
    l = new t(l, 16), l.red || (l = l.toRed(this.red));
    var p = l.redSqr().redMul(l).redIAdd(l.redMul(this.a)).redIAdd(this.b), m = p.redSqrt();
    if (m.redSqr().redSub(p).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var g = m.fromRed().isOdd();
    return (s && !g || !s && g) && (m = m.redNeg()), this.point(l, m);
  }, n.prototype.validate = function(l) {
    if (l.inf)
      return !0;
    var s = l.x, p = l.y, m = this.a.redMul(s), g = s.redSqr().redMul(s).redIAdd(m).redIAdd(this.b);
    return p.redSqr().redISub(g).cmpn(0) === 0;
  }, n.prototype._endoWnafMulAdd = function(l, s, p) {
    for (var m = this._endoWnafT1, g = this._endoWnafT2, y = 0; y < l.length; y++) {
      var v = this._endoSplit(s[y]), E = l[y], b = E._getBeta();
      v.k1.negative && (v.k1.ineg(), E = E.neg(!0)), v.k2.negative && (v.k2.ineg(), b = b.neg(!0)), m[y * 2] = E, m[y * 2 + 1] = b, g[y * 2] = v.k1, g[y * 2 + 1] = v.k2;
    }
    for (var q = this._wnafMulAdd(1, m, g, y * 2, p), O = 0; O < y * 2; O++)
      m[O] = null, g[O] = null;
    return q;
  };
  function o(f, l, s, p) {
    a.BasePoint.call(this, f, "affine"), l === null && s === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(l, 16), this.y = new t(s, 16), p && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  r(o, a.BasePoint), n.prototype.point = function(l, s, p) {
    return new o(this, l, s, p);
  }, n.prototype.pointFromJSON = function(l, s) {
    return o.fromJSON(this, l, s);
  }, o.prototype._getBeta = function() {
    if (this.curve.endo) {
      var l = this.precomputed;
      if (l && l.beta)
        return l.beta;
      var s = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (l) {
        var p = this.curve, m = function(g) {
          return p.point(g.x.redMul(p.endo.beta), g.y);
        };
        l.beta = s, s.precomputed = {
          beta: null,
          naf: l.naf && {
            wnd: l.naf.wnd,
            points: l.naf.points.map(m)
          },
          doubles: l.doubles && {
            step: l.doubles.step,
            points: l.doubles.points.map(m)
          }
        };
      }
      return s;
    }
  }, o.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, o.fromJSON = function(l, s, p) {
    typeof s == "string" && (s = JSON.parse(s));
    var m = l.point(s[0], s[1], p);
    if (!s[2])
      return m;
    function g(v) {
      return l.point(v[0], v[1], p);
    }
    var y = s[2];
    return m.precomputed = {
      beta: null,
      doubles: y.doubles && {
        step: y.doubles.step,
        points: [m].concat(y.doubles.points.map(g))
      },
      naf: y.naf && {
        wnd: y.naf.wnd,
        points: [m].concat(y.naf.points.map(g))
      }
    }, m;
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.inf;
  }, o.prototype.add = function(l) {
    if (this.inf)
      return l;
    if (l.inf)
      return this;
    if (this.eq(l))
      return this.dbl();
    if (this.neg().eq(l))
      return this.curve.point(null, null);
    if (this.x.cmp(l.x) === 0)
      return this.curve.point(null, null);
    var s = this.y.redSub(l.y);
    s.cmpn(0) !== 0 && (s = s.redMul(this.x.redSub(l.x).redInvm()));
    var p = s.redSqr().redISub(this.x).redISub(l.x), m = s.redMul(this.x.redSub(p)).redISub(this.y);
    return this.curve.point(p, m);
  }, o.prototype.dbl = function() {
    if (this.inf)
      return this;
    var l = this.y.redAdd(this.y);
    if (l.cmpn(0) === 0)
      return this.curve.point(null, null);
    var s = this.curve.a, p = this.x.redSqr(), m = l.redInvm(), g = p.redAdd(p).redIAdd(p).redIAdd(s).redMul(m), y = g.redSqr().redISub(this.x.redAdd(this.x)), v = g.redMul(this.x.redSub(y)).redISub(this.y);
    return this.curve.point(y, v);
  }, o.prototype.getX = function() {
    return this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.y.fromRed();
  }, o.prototype.mul = function(l) {
    return l = new t(l, 16), this.isInfinity() ? this : this._hasDoubles(l) ? this.curve._fixedNafMul(this, l) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [l]) : this.curve._wnafMul(this, l);
  }, o.prototype.mulAdd = function(l, s, p) {
    var m = [this, s], g = [l, p];
    return this.curve.endo ? this.curve._endoWnafMulAdd(m, g) : this.curve._wnafMulAdd(1, m, g, 2);
  }, o.prototype.jmulAdd = function(l, s, p) {
    var m = [this, s], g = [l, p];
    return this.curve.endo ? this.curve._endoWnafMulAdd(m, g, !0) : this.curve._wnafMulAdd(1, m, g, 2, !0);
  }, o.prototype.eq = function(l) {
    return this === l || this.inf === l.inf && (this.inf || this.x.cmp(l.x) === 0 && this.y.cmp(l.y) === 0);
  }, o.prototype.neg = function(l) {
    if (this.inf)
      return this;
    var s = this.curve.point(this.x, this.y.redNeg());
    if (l && this.precomputed) {
      var p = this.precomputed, m = function(g) {
        return g.neg();
      };
      s.precomputed = {
        naf: p.naf && {
          wnd: p.naf.wnd,
          points: p.naf.points.map(m)
        },
        doubles: p.doubles && {
          step: p.doubles.step,
          points: p.doubles.points.map(m)
        }
      };
    }
    return s;
  }, o.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var l = this.curve.jpoint(this.x, this.y, this.curve.one);
    return l;
  };
  function c(f, l, s, p) {
    a.BasePoint.call(this, f, "jacobian"), l === null && s === null && p === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(l, 16), this.y = new t(s, 16), this.z = new t(p, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return r(c, a.BasePoint), n.prototype.jpoint = function(l, s, p) {
    return new c(this, l, s, p);
  }, c.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var l = this.z.redInvm(), s = l.redSqr(), p = this.x.redMul(s), m = this.y.redMul(s).redMul(l);
    return this.curve.point(p, m);
  }, c.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, c.prototype.add = function(l) {
    if (this.isInfinity())
      return l;
    if (l.isInfinity())
      return this;
    var s = l.z.redSqr(), p = this.z.redSqr(), m = this.x.redMul(s), g = l.x.redMul(p), y = this.y.redMul(s.redMul(l.z)), v = l.y.redMul(p.redMul(this.z)), E = m.redSub(g), b = y.redSub(v);
    if (E.cmpn(0) === 0)
      return b.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var q = E.redSqr(), O = q.redMul(E), j = m.redMul(q), D = b.redSqr().redIAdd(O).redISub(j).redISub(j), G = b.redMul(j.redISub(D)).redISub(y.redMul(O)), V = this.z.redMul(l.z).redMul(E);
    return this.curve.jpoint(D, G, V);
  }, c.prototype.mixedAdd = function(l) {
    if (this.isInfinity())
      return l.toJ();
    if (l.isInfinity())
      return this;
    var s = this.z.redSqr(), p = this.x, m = l.x.redMul(s), g = this.y, y = l.y.redMul(s).redMul(this.z), v = p.redSub(m), E = g.redSub(y);
    if (v.cmpn(0) === 0)
      return E.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var b = v.redSqr(), q = b.redMul(v), O = p.redMul(b), j = E.redSqr().redIAdd(q).redISub(O).redISub(O), D = E.redMul(O.redISub(j)).redISub(g.redMul(q)), G = this.z.redMul(v);
    return this.curve.jpoint(j, D, G);
  }, c.prototype.dblp = function(l) {
    if (l === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!l)
      return this.dbl();
    var s;
    if (this.curve.zeroA || this.curve.threeA) {
      var p = this;
      for (s = 0; s < l; s++)
        p = p.dbl();
      return p;
    }
    var m = this.curve.a, g = this.curve.tinv, y = this.x, v = this.y, E = this.z, b = E.redSqr().redSqr(), q = v.redAdd(v);
    for (s = 0; s < l; s++) {
      var O = y.redSqr(), j = q.redSqr(), D = j.redSqr(), G = O.redAdd(O).redIAdd(O).redIAdd(m.redMul(b)), V = y.redMul(j), Q = G.redSqr().redISub(V.redAdd(V)), re = V.redISub(Q), ve = G.redMul(re);
      ve = ve.redIAdd(ve).redISub(D);
      var te = q.redMul(E);
      s + 1 < l && (b = b.redMul(D)), y = Q, E = te, q = ve;
    }
    return this.curve.jpoint(y, q.redMul(g), E);
  }, c.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, c.prototype._zeroDbl = function() {
    var l, s, p;
    if (this.zOne) {
      var m = this.x.redSqr(), g = this.y.redSqr(), y = g.redSqr(), v = this.x.redAdd(g).redSqr().redISub(m).redISub(y);
      v = v.redIAdd(v);
      var E = m.redAdd(m).redIAdd(m), b = E.redSqr().redISub(v).redISub(v), q = y.redIAdd(y);
      q = q.redIAdd(q), q = q.redIAdd(q), l = b, s = E.redMul(v.redISub(b)).redISub(q), p = this.y.redAdd(this.y);
    } else {
      var O = this.x.redSqr(), j = this.y.redSqr(), D = j.redSqr(), G = this.x.redAdd(j).redSqr().redISub(O).redISub(D);
      G = G.redIAdd(G);
      var V = O.redAdd(O).redIAdd(O), Q = V.redSqr(), re = D.redIAdd(D);
      re = re.redIAdd(re), re = re.redIAdd(re), l = Q.redISub(G).redISub(G), s = V.redMul(G.redISub(l)).redISub(re), p = this.y.redMul(this.z), p = p.redIAdd(p);
    }
    return this.curve.jpoint(l, s, p);
  }, c.prototype._threeDbl = function() {
    var l, s, p;
    if (this.zOne) {
      var m = this.x.redSqr(), g = this.y.redSqr(), y = g.redSqr(), v = this.x.redAdd(g).redSqr().redISub(m).redISub(y);
      v = v.redIAdd(v);
      var E = m.redAdd(m).redIAdd(m).redIAdd(this.curve.a), b = E.redSqr().redISub(v).redISub(v);
      l = b;
      var q = y.redIAdd(y);
      q = q.redIAdd(q), q = q.redIAdd(q), s = E.redMul(v.redISub(b)).redISub(q), p = this.y.redAdd(this.y);
    } else {
      var O = this.z.redSqr(), j = this.y.redSqr(), D = this.x.redMul(j), G = this.x.redSub(O).redMul(this.x.redAdd(O));
      G = G.redAdd(G).redIAdd(G);
      var V = D.redIAdd(D);
      V = V.redIAdd(V);
      var Q = V.redAdd(V);
      l = G.redSqr().redISub(Q), p = this.y.redAdd(this.z).redSqr().redISub(j).redISub(O);
      var re = j.redSqr();
      re = re.redIAdd(re), re = re.redIAdd(re), re = re.redIAdd(re), s = G.redMul(V.redISub(l)).redISub(re);
    }
    return this.curve.jpoint(l, s, p);
  }, c.prototype._dbl = function() {
    var l = this.curve.a, s = this.x, p = this.y, m = this.z, g = m.redSqr().redSqr(), y = s.redSqr(), v = p.redSqr(), E = y.redAdd(y).redIAdd(y).redIAdd(l.redMul(g)), b = s.redAdd(s);
    b = b.redIAdd(b);
    var q = b.redMul(v), O = E.redSqr().redISub(q.redAdd(q)), j = q.redISub(O), D = v.redSqr();
    D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
    var G = E.redMul(j).redISub(D), V = p.redAdd(p).redMul(m);
    return this.curve.jpoint(O, G, V);
  }, c.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var l = this.x.redSqr(), s = this.y.redSqr(), p = this.z.redSqr(), m = s.redSqr(), g = l.redAdd(l).redIAdd(l), y = g.redSqr(), v = this.x.redAdd(s).redSqr().redISub(l).redISub(m);
    v = v.redIAdd(v), v = v.redAdd(v).redIAdd(v), v = v.redISub(y);
    var E = v.redSqr(), b = m.redIAdd(m);
    b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b);
    var q = g.redIAdd(v).redSqr().redISub(y).redISub(E).redISub(b), O = s.redMul(q);
    O = O.redIAdd(O), O = O.redIAdd(O);
    var j = this.x.redMul(E).redISub(O);
    j = j.redIAdd(j), j = j.redIAdd(j);
    var D = this.y.redMul(q.redMul(b.redISub(q)).redISub(v.redMul(E)));
    D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
    var G = this.z.redAdd(v).redSqr().redISub(p).redISub(E);
    return this.curve.jpoint(j, D, G);
  }, c.prototype.mul = function(l, s) {
    return l = new t(l, s), this.curve._wnafMul(this, l);
  }, c.prototype.eq = function(l) {
    if (l.type === "affine")
      return this.eq(l.toJ());
    if (this === l)
      return !0;
    var s = this.z.redSqr(), p = l.z.redSqr();
    if (this.x.redMul(p).redISub(l.x.redMul(s)).cmpn(0) !== 0)
      return !1;
    var m = s.redMul(this.z), g = p.redMul(l.z);
    return this.y.redMul(g).redISub(l.y.redMul(m)).cmpn(0) === 0;
  }, c.prototype.eqXToP = function(l) {
    var s = this.z.redSqr(), p = l.toRed(this.curve.red).redMul(s);
    if (this.x.cmp(p) === 0)
      return !0;
    for (var m = l.clone(), g = this.curve.redN.redMul(s); ; ) {
      if (m.iadd(this.curve.n), m.cmp(this.curve.p) >= 0)
        return !1;
      if (p.redIAdd(g), this.x.cmp(p) === 0)
        return !0;
    }
  }, c.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, c.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var e = requireBn$2(), t = requireInherits_browser(), r = requireBase$1(), a = requireUtils$2();
  function u(o) {
    r.call(this, "mont", o), this.a = new e(o.a, 16).toRed(this.red), this.b = new e(o.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(u, r), mont = u, u.prototype.validate = function(c) {
    var f = c.normalize().x, l = f.redSqr(), s = l.redMul(f).redAdd(l.redMul(this.a)).redAdd(f), p = s.redSqrt();
    return p.redSqr().cmp(s) === 0;
  };
  function n(o, c, f) {
    r.BasePoint.call(this, o, "projective"), c === null && f === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(c, 16), this.z = new e(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(n, r.BasePoint), u.prototype.decodePoint = function(c, f) {
    return this.point(a.toArray(c, f), 1);
  }, u.prototype.point = function(c, f) {
    return new n(this, c, f);
  }, u.prototype.pointFromJSON = function(c) {
    return n.fromJSON(this, c);
  }, n.prototype.precompute = function() {
  }, n.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, n.fromJSON = function(c, f) {
    return new n(c, f[0], f[1] || c.one);
  }, n.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, n.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, n.prototype.dbl = function() {
    var c = this.x.redAdd(this.z), f = c.redSqr(), l = this.x.redSub(this.z), s = l.redSqr(), p = f.redSub(s), m = f.redMul(s), g = p.redMul(s.redAdd(this.curve.a24.redMul(p)));
    return this.curve.point(m, g);
  }, n.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.diffAdd = function(c, f) {
    var l = this.x.redAdd(this.z), s = this.x.redSub(this.z), p = c.x.redAdd(c.z), m = c.x.redSub(c.z), g = m.redMul(l), y = p.redMul(s), v = f.z.redMul(g.redAdd(y).redSqr()), E = f.x.redMul(g.redISub(y).redSqr());
    return this.curve.point(v, E);
  }, n.prototype.mul = function(c) {
    for (var f = c.clone(), l = this, s = this.curve.point(null, null), p = this, m = []; f.cmpn(0) !== 0; f.iushrn(1))
      m.push(f.andln(1));
    for (var g = m.length - 1; g >= 0; g--)
      m[g] === 0 ? (l = l.diffAdd(s, p), s = s.dbl()) : (s = l.diffAdd(s, p), l = l.dbl());
    return s;
  }, n.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, n.prototype.eq = function(c) {
    return this.getX().cmp(c.getX()) === 0;
  }, n.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, n.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var e = requireUtils$2(), t = requireBn$2(), r = requireInherits_browser(), a = requireBase$1(), u = e.assert;
  function n(c) {
    this.twisted = (c.a | 0) !== 1, this.mOneA = this.twisted && (c.a | 0) === -1, this.extended = this.mOneA, a.call(this, "edwards", c), this.a = new t(c.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(c.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(c.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), u(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (c.c | 0) === 1;
  }
  r(n, a), edwards = n, n.prototype._mulA = function(f) {
    return this.mOneA ? f.redNeg() : this.a.redMul(f);
  }, n.prototype._mulC = function(f) {
    return this.oneC ? f : this.c.redMul(f);
  }, n.prototype.jpoint = function(f, l, s, p) {
    return this.point(f, l, s, p);
  }, n.prototype.pointFromX = function(f, l) {
    f = new t(f, 16), f.red || (f = f.toRed(this.red));
    var s = f.redSqr(), p = this.c2.redSub(this.a.redMul(s)), m = this.one.redSub(this.c2.redMul(this.d).redMul(s)), g = p.redMul(m.redInvm()), y = g.redSqrt();
    if (y.redSqr().redSub(g).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var v = y.fromRed().isOdd();
    return (l && !v || !l && v) && (y = y.redNeg()), this.point(f, y);
  }, n.prototype.pointFromY = function(f, l) {
    f = new t(f, 16), f.red || (f = f.toRed(this.red));
    var s = f.redSqr(), p = s.redSub(this.c2), m = s.redMul(this.d).redMul(this.c2).redSub(this.a), g = p.redMul(m.redInvm());
    if (g.cmp(this.zero) === 0) {
      if (l)
        throw new Error("invalid point");
      return this.point(this.zero, f);
    }
    var y = g.redSqrt();
    if (y.redSqr().redSub(g).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return y.fromRed().isOdd() !== l && (y = y.redNeg()), this.point(y, f);
  }, n.prototype.validate = function(f) {
    if (f.isInfinity())
      return !0;
    f.normalize();
    var l = f.x.redSqr(), s = f.y.redSqr(), p = l.redMul(this.a).redAdd(s), m = this.c2.redMul(this.one.redAdd(this.d.redMul(l).redMul(s)));
    return p.cmp(m) === 0;
  };
  function o(c, f, l, s, p) {
    a.BasePoint.call(this, c, "projective"), f === null && l === null && s === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(f, 16), this.y = new t(l, 16), this.z = s ? new t(s, 16) : this.curve.one, this.t = p && new t(p, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return r(o, a.BasePoint), n.prototype.pointFromJSON = function(f) {
    return o.fromJSON(this, f);
  }, n.prototype.point = function(f, l, s, p) {
    return new o(this, f, l, s, p);
  }, o.fromJSON = function(f, l) {
    return new o(f, l[0], l[1], l[2]);
  }, o.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, o.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, o.prototype._extDbl = function() {
    var f = this.x.redSqr(), l = this.y.redSqr(), s = this.z.redSqr();
    s = s.redIAdd(s);
    var p = this.curve._mulA(f), m = this.x.redAdd(this.y).redSqr().redISub(f).redISub(l), g = p.redAdd(l), y = g.redSub(s), v = p.redSub(l), E = m.redMul(y), b = g.redMul(v), q = m.redMul(v), O = y.redMul(g);
    return this.curve.point(E, b, O, q);
  }, o.prototype._projDbl = function() {
    var f = this.x.redAdd(this.y).redSqr(), l = this.x.redSqr(), s = this.y.redSqr(), p, m, g, y, v, E;
    if (this.curve.twisted) {
      y = this.curve._mulA(l);
      var b = y.redAdd(s);
      this.zOne ? (p = f.redSub(l).redSub(s).redMul(b.redSub(this.curve.two)), m = b.redMul(y.redSub(s)), g = b.redSqr().redSub(b).redSub(b)) : (v = this.z.redSqr(), E = b.redSub(v).redISub(v), p = f.redSub(l).redISub(s).redMul(E), m = b.redMul(y.redSub(s)), g = b.redMul(E));
    } else
      y = l.redAdd(s), v = this.curve._mulC(this.z).redSqr(), E = y.redSub(v).redSub(v), p = this.curve._mulC(f.redISub(y)).redMul(E), m = this.curve._mulC(y).redMul(l.redISub(s)), g = y.redMul(E);
    return this.curve.point(p, m, g);
  }, o.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, o.prototype._extAdd = function(f) {
    var l = this.y.redSub(this.x).redMul(f.y.redSub(f.x)), s = this.y.redAdd(this.x).redMul(f.y.redAdd(f.x)), p = this.t.redMul(this.curve.dd).redMul(f.t), m = this.z.redMul(f.z.redAdd(f.z)), g = s.redSub(l), y = m.redSub(p), v = m.redAdd(p), E = s.redAdd(l), b = g.redMul(y), q = v.redMul(E), O = g.redMul(E), j = y.redMul(v);
    return this.curve.point(b, q, j, O);
  }, o.prototype._projAdd = function(f) {
    var l = this.z.redMul(f.z), s = l.redSqr(), p = this.x.redMul(f.x), m = this.y.redMul(f.y), g = this.curve.d.redMul(p).redMul(m), y = s.redSub(g), v = s.redAdd(g), E = this.x.redAdd(this.y).redMul(f.x.redAdd(f.y)).redISub(p).redISub(m), b = l.redMul(y).redMul(E), q, O;
    return this.curve.twisted ? (q = l.redMul(v).redMul(m.redSub(this.curve._mulA(p))), O = y.redMul(v)) : (q = l.redMul(v).redMul(m.redSub(p)), O = this.curve._mulC(y).redMul(v)), this.curve.point(b, q, O);
  }, o.prototype.add = function(f) {
    return this.isInfinity() ? f : f.isInfinity() ? this : this.curve.extended ? this._extAdd(f) : this._projAdd(f);
  }, o.prototype.mul = function(f) {
    return this._hasDoubles(f) ? this.curve._fixedNafMul(this, f) : this.curve._wnafMul(this, f);
  }, o.prototype.mulAdd = function(f, l, s) {
    return this.curve._wnafMulAdd(1, [this, l], [f, s], 2, !1);
  }, o.prototype.jmulAdd = function(f, l, s) {
    return this.curve._wnafMulAdd(1, [this, l], [f, s], 2, !0);
  }, o.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var f = this.z.redInvm();
    return this.x = this.x.redMul(f), this.y = this.y.redMul(f), this.t && (this.t = this.t.redMul(f)), this.z = this.curve.one, this.zOne = !0, this;
  }, o.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, o.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, o.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, o.prototype.eq = function(f) {
    return this === f || this.getX().cmp(f.getX()) === 0 && this.getY().cmp(f.getY()) === 0;
  }, o.prototype.eqXToP = function(f) {
    var l = f.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(l) === 0)
      return !0;
    for (var s = f.clone(), p = this.curve.redN.redMul(this.z); ; ) {
      if (s.iadd(this.curve.n), s.cmp(this.curve.p) >= 0)
        return !1;
      if (l.redIAdd(p), this.x.cmp(l) === 0)
        return !0;
    }
  }, o.prototype.toP = o.prototype.normalize, o.prototype.mixedAdd = o.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, (function(e) {
    var t = e;
    t.base = requireBase$1(), t.short = requireShort(), t.mont = requireMont(), t.edwards = requireEdwards();
  })(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser();
  utils$1.inherits = t;
  function r(R, M) {
    return (R.charCodeAt(M) & 64512) !== 55296 || M < 0 || M + 1 >= R.length ? !1 : (R.charCodeAt(M + 1) & 64512) === 56320;
  }
  function a(R, M) {
    if (Array.isArray(R))
      return R.slice();
    if (!R)
      return [];
    var h = [];
    if (typeof R == "string")
      if (M) {
        if (M === "hex")
          for (R = R.replace(/[^a-z0-9]+/ig, ""), R.length % 2 !== 0 && (R = "0" + R), B = 0; B < R.length; B += 2)
            h.push(parseInt(R[B] + R[B + 1], 16));
      } else for (var S = 0, B = 0; B < R.length; B++) {
        var T = R.charCodeAt(B);
        T < 128 ? h[S++] = T : T < 2048 ? (h[S++] = T >> 6 | 192, h[S++] = T & 63 | 128) : r(R, B) ? (T = 65536 + ((T & 1023) << 10) + (R.charCodeAt(++B) & 1023), h[S++] = T >> 18 | 240, h[S++] = T >> 12 & 63 | 128, h[S++] = T >> 6 & 63 | 128, h[S++] = T & 63 | 128) : (h[S++] = T >> 12 | 224, h[S++] = T >> 6 & 63 | 128, h[S++] = T & 63 | 128);
      }
    else
      for (B = 0; B < R.length; B++)
        h[B] = R[B] | 0;
    return h;
  }
  utils$1.toArray = a;
  function u(R) {
    for (var M = "", h = 0; h < R.length; h++)
      M += c(R[h].toString(16));
    return M;
  }
  utils$1.toHex = u;
  function n(R) {
    var M = R >>> 24 | R >>> 8 & 65280 | R << 8 & 16711680 | (R & 255) << 24;
    return M >>> 0;
  }
  utils$1.htonl = n;
  function o(R, M) {
    for (var h = "", S = 0; S < R.length; S++) {
      var B = R[S];
      M === "little" && (B = n(B)), h += f(B.toString(16));
    }
    return h;
  }
  utils$1.toHex32 = o;
  function c(R) {
    return R.length === 1 ? "0" + R : R;
  }
  utils$1.zero2 = c;
  function f(R) {
    return R.length === 7 ? "0" + R : R.length === 6 ? "00" + R : R.length === 5 ? "000" + R : R.length === 4 ? "0000" + R : R.length === 3 ? "00000" + R : R.length === 2 ? "000000" + R : R.length === 1 ? "0000000" + R : R;
  }
  utils$1.zero8 = f;
  function l(R, M, h, S) {
    var B = h - M;
    e(B % 4 === 0);
    for (var T = new Array(B / 4), k = 0, I = M; k < T.length; k++, I += 4) {
      var C;
      S === "big" ? C = R[I] << 24 | R[I + 1] << 16 | R[I + 2] << 8 | R[I + 3] : C = R[I + 3] << 24 | R[I + 2] << 16 | R[I + 1] << 8 | R[I], T[k] = C >>> 0;
    }
    return T;
  }
  utils$1.join32 = l;
  function s(R, M) {
    for (var h = new Array(R.length * 4), S = 0, B = 0; S < R.length; S++, B += 4) {
      var T = R[S];
      M === "big" ? (h[B] = T >>> 24, h[B + 1] = T >>> 16 & 255, h[B + 2] = T >>> 8 & 255, h[B + 3] = T & 255) : (h[B + 3] = T >>> 24, h[B + 2] = T >>> 16 & 255, h[B + 1] = T >>> 8 & 255, h[B] = T & 255);
    }
    return h;
  }
  utils$1.split32 = s;
  function p(R, M) {
    return R >>> M | R << 32 - M;
  }
  utils$1.rotr32 = p;
  function m(R, M) {
    return R << M | R >>> 32 - M;
  }
  utils$1.rotl32 = m;
  function g(R, M) {
    return R + M >>> 0;
  }
  utils$1.sum32 = g;
  function y(R, M, h) {
    return R + M + h >>> 0;
  }
  utils$1.sum32_3 = y;
  function v(R, M, h, S) {
    return R + M + h + S >>> 0;
  }
  utils$1.sum32_4 = v;
  function E(R, M, h, S, B) {
    return R + M + h + S + B >>> 0;
  }
  utils$1.sum32_5 = E;
  function b(R, M, h, S) {
    var B = R[M], T = R[M + 1], k = S + T >>> 0, I = (k < S ? 1 : 0) + h + B;
    R[M] = I >>> 0, R[M + 1] = k;
  }
  utils$1.sum64 = b;
  function q(R, M, h, S) {
    var B = M + S >>> 0, T = (B < M ? 1 : 0) + R + h;
    return T >>> 0;
  }
  utils$1.sum64_hi = q;
  function O(R, M, h, S) {
    var B = M + S;
    return B >>> 0;
  }
  utils$1.sum64_lo = O;
  function j(R, M, h, S, B, T, k, I) {
    var C = 0, $ = M;
    $ = $ + S >>> 0, C += $ < M ? 1 : 0, $ = $ + T >>> 0, C += $ < T ? 1 : 0, $ = $ + I >>> 0, C += $ < I ? 1 : 0;
    var w = R + h + B + k + C;
    return w >>> 0;
  }
  utils$1.sum64_4_hi = j;
  function D(R, M, h, S, B, T, k, I) {
    var C = M + S + T + I;
    return C >>> 0;
  }
  utils$1.sum64_4_lo = D;
  function G(R, M, h, S, B, T, k, I, C, $) {
    var w = 0, U = M;
    U = U + S >>> 0, w += U < M ? 1 : 0, U = U + T >>> 0, w += U < T ? 1 : 0, U = U + I >>> 0, w += U < I ? 1 : 0, U = U + $ >>> 0, w += U < $ ? 1 : 0;
    var ie = R + h + B + k + C + w;
    return ie >>> 0;
  }
  utils$1.sum64_5_hi = G;
  function V(R, M, h, S, B, T, k, I, C, $) {
    var w = M + S + T + I + $;
    return w >>> 0;
  }
  utils$1.sum64_5_lo = V;
  function Q(R, M, h) {
    var S = M << 32 - h | R >>> h;
    return S >>> 0;
  }
  utils$1.rotr64_hi = Q;
  function re(R, M, h) {
    var S = R << 32 - h | M >>> h;
    return S >>> 0;
  }
  utils$1.rotr64_lo = re;
  function ve(R, M, h) {
    return R >>> h;
  }
  utils$1.shr64_hi = ve;
  function te(R, M, h) {
    var S = R << 32 - h | M >>> h;
    return S >>> 0;
  }
  return utils$1.shr64_lo = te, utils$1;
}
var common$4 = {}, hasRequiredCommon$4;
function requireCommon$4() {
  if (hasRequiredCommon$4) return common$4;
  hasRequiredCommon$4 = 1;
  var e = requireUtils$1(), t = requireMinimalisticAssert();
  function r() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$4.BlockHash = r, r.prototype.update = function(u, n) {
    if (u = e.toArray(u, n), this.pending ? this.pending = this.pending.concat(u) : this.pending = u, this.pendingTotal += u.length, this.pending.length >= this._delta8) {
      u = this.pending;
      var o = u.length % this._delta8;
      this.pending = u.slice(u.length - o, u.length), this.pending.length === 0 && (this.pending = null), u = e.join32(u, 0, u.length - o, this.endian);
      for (var c = 0; c < u.length; c += this._delta32)
        this._update(u, c, c + this._delta32);
    }
    return this;
  }, r.prototype.digest = function(u) {
    return this.update(this._pad()), t(this.pending === null), this._digest(u);
  }, r.prototype._pad = function() {
    var u = this.pendingTotal, n = this._delta8, o = n - (u + this.padLength) % n, c = new Array(o + this.padLength);
    c[0] = 128;
    for (var f = 1; f < o; f++)
      c[f] = 0;
    if (u <<= 3, this.endian === "big") {
      for (var l = 8; l < this.padLength; l++)
        c[f++] = 0;
      c[f++] = 0, c[f++] = 0, c[f++] = 0, c[f++] = 0, c[f++] = u >>> 24 & 255, c[f++] = u >>> 16 & 255, c[f++] = u >>> 8 & 255, c[f++] = u & 255;
    } else
      for (c[f++] = u & 255, c[f++] = u >>> 8 & 255, c[f++] = u >>> 16 & 255, c[f++] = u >>> 24 & 255, c[f++] = 0, c[f++] = 0, c[f++] = 0, c[f++] = 0, l = 8; l < this.padLength; l++)
        c[f++] = 0;
    return c;
  }, common$4;
}
var sha = {}, common$3 = {}, hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3) return common$3;
  hasRequiredCommon$3 = 1;
  var e = requireUtils$1(), t = e.rotr32;
  function r(s, p, m, g) {
    if (s === 0)
      return a(p, m, g);
    if (s === 1 || s === 3)
      return n(p, m, g);
    if (s === 2)
      return u(p, m, g);
  }
  common$3.ft_1 = r;
  function a(s, p, m) {
    return s & p ^ ~s & m;
  }
  common$3.ch32 = a;
  function u(s, p, m) {
    return s & p ^ s & m ^ p & m;
  }
  common$3.maj32 = u;
  function n(s, p, m) {
    return s ^ p ^ m;
  }
  common$3.p32 = n;
  function o(s) {
    return t(s, 2) ^ t(s, 13) ^ t(s, 22);
  }
  common$3.s0_256 = o;
  function c(s) {
    return t(s, 6) ^ t(s, 11) ^ t(s, 25);
  }
  common$3.s1_256 = c;
  function f(s) {
    return t(s, 7) ^ t(s, 18) ^ s >>> 3;
  }
  common$3.g0_256 = f;
  function l(s) {
    return t(s, 17) ^ t(s, 19) ^ s >>> 10;
  }
  return common$3.g1_256 = l, common$3;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var e = requireUtils$1(), t = requireCommon$4(), r = requireCommon$3(), a = e.rotl32, u = e.sum32, n = e.sum32_5, o = r.ft_1, c = t.BlockHash, f = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function l() {
    if (!(this instanceof l))
      return new l();
    c.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(l, c), _1 = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 80, l.padLength = 64, l.prototype._update = function(p, m) {
    for (var g = this.W, y = 0; y < 16; y++)
      g[y] = p[m + y];
    for (; y < g.length; y++)
      g[y] = a(g[y - 3] ^ g[y - 8] ^ g[y - 14] ^ g[y - 16], 1);
    var v = this.h[0], E = this.h[1], b = this.h[2], q = this.h[3], O = this.h[4];
    for (y = 0; y < g.length; y++) {
      var j = ~~(y / 20), D = n(a(v, 5), o(j, E, b, q), O, g[y], f[j]);
      O = q, q = b, b = a(E, 30), E = v, v = D;
    }
    this.h[0] = u(this.h[0], v), this.h[1] = u(this.h[1], E), this.h[2] = u(this.h[2], b), this.h[3] = u(this.h[3], q), this.h[4] = u(this.h[4], O);
  }, l.prototype._digest = function(p) {
    return p === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var e = requireUtils$1(), t = requireCommon$4(), r = requireCommon$3(), a = requireMinimalisticAssert(), u = e.sum32, n = e.sum32_4, o = e.sum32_5, c = r.ch32, f = r.maj32, l = r.s0_256, s = r.s1_256, p = r.g0_256, m = r.g1_256, g = t.BlockHash, y = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function v() {
    if (!(this instanceof v))
      return new v();
    g.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = y, this.W = new Array(64);
  }
  return e.inherits(v, g), _256 = v, v.blockSize = 512, v.outSize = 256, v.hmacStrength = 192, v.padLength = 64, v.prototype._update = function(b, q) {
    for (var O = this.W, j = 0; j < 16; j++)
      O[j] = b[q + j];
    for (; j < O.length; j++)
      O[j] = n(m(O[j - 2]), O[j - 7], p(O[j - 15]), O[j - 16]);
    var D = this.h[0], G = this.h[1], V = this.h[2], Q = this.h[3], re = this.h[4], ve = this.h[5], te = this.h[6], R = this.h[7];
    for (a(this.k.length === O.length), j = 0; j < O.length; j++) {
      var M = o(R, s(re), c(re, ve, te), this.k[j], O[j]), h = u(l(D), f(D, G, V));
      R = te, te = ve, ve = re, re = u(Q, M), Q = V, V = G, G = D, D = u(M, h);
    }
    this.h[0] = u(this.h[0], D), this.h[1] = u(this.h[1], G), this.h[2] = u(this.h[2], V), this.h[3] = u(this.h[3], Q), this.h[4] = u(this.h[4], re), this.h[5] = u(this.h[5], ve), this.h[6] = u(this.h[6], te), this.h[7] = u(this.h[7], R);
  }, v.prototype._digest = function(b) {
    return b === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var e = requireUtils$1(), t = require_256();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(r, t), _224 = r, r.blockSize = 512, r.outSize = 224, r.hmacStrength = 192, r.padLength = 64, r.prototype._digest = function(u) {
    return u === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var e = requireUtils$1(), t = requireCommon$4(), r = requireMinimalisticAssert(), a = e.rotr64_hi, u = e.rotr64_lo, n = e.shr64_hi, o = e.shr64_lo, c = e.sum64, f = e.sum64_hi, l = e.sum64_lo, s = e.sum64_4_hi, p = e.sum64_4_lo, m = e.sum64_5_hi, g = e.sum64_5_lo, y = t.BlockHash, v = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function E() {
    if (!(this instanceof E))
      return new E();
    y.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = v, this.W = new Array(160);
  }
  e.inherits(E, y), _512 = E, E.blockSize = 1024, E.outSize = 512, E.hmacStrength = 192, E.padLength = 128, E.prototype._prepareBlock = function(h, S) {
    for (var B = this.W, T = 0; T < 32; T++)
      B[T] = h[S + T];
    for (; T < B.length; T += 2) {
      var k = te(B[T - 4], B[T - 3]), I = R(B[T - 4], B[T - 3]), C = B[T - 14], $ = B[T - 13], w = re(B[T - 30], B[T - 29]), U = ve(B[T - 30], B[T - 29]), ie = B[T - 32], le = B[T - 31];
      B[T] = s(
        k,
        I,
        C,
        $,
        w,
        U,
        ie,
        le
      ), B[T + 1] = p(
        k,
        I,
        C,
        $,
        w,
        U,
        ie,
        le
      );
    }
  }, E.prototype._update = function(h, S) {
    this._prepareBlock(h, S);
    var B = this.W, T = this.h[0], k = this.h[1], I = this.h[2], C = this.h[3], $ = this.h[4], w = this.h[5], U = this.h[6], ie = this.h[7], le = this.h[8], ee = this.h[9], F = this.h[10], z = this.h[11], se = this.h[12], he = this.h[13], ae = this.h[14], X = this.h[15];
    r(this.k.length === B.length);
    for (var be = 0; be < B.length; be += 2) {
      var Re = ae, Pe = X, Fe = V(le, ee), De = Q(le, ee), je = b(le, ee, F, z, se), Oe = q(le, ee, F, z, se, he), rt = this.k[be], He = this.k[be + 1], Qe = B[be], Je = B[be + 1], we = m(
        Re,
        Pe,
        Fe,
        De,
        je,
        Oe,
        rt,
        He,
        Qe,
        Je
      ), Ae = g(
        Re,
        Pe,
        Fe,
        De,
        je,
        Oe,
        rt,
        He,
        Qe,
        Je
      );
      Re = D(T, k), Pe = G(T, k), Fe = O(T, k, I, C, $), De = j(T, k, I, C, $, w);
      var ze = f(Re, Pe, Fe, De), Ue = l(Re, Pe, Fe, De);
      ae = se, X = he, se = F, he = z, F = le, z = ee, le = f(U, ie, we, Ae), ee = l(ie, ie, we, Ae), U = $, ie = w, $ = I, w = C, I = T, C = k, T = f(we, Ae, ze, Ue), k = l(we, Ae, ze, Ue);
    }
    c(this.h, 0, T, k), c(this.h, 2, I, C), c(this.h, 4, $, w), c(this.h, 6, U, ie), c(this.h, 8, le, ee), c(this.h, 10, F, z), c(this.h, 12, se, he), c(this.h, 14, ae, X);
  }, E.prototype._digest = function(h) {
    return h === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function b(M, h, S, B, T) {
    var k = M & S ^ ~M & T;
    return k < 0 && (k += 4294967296), k;
  }
  function q(M, h, S, B, T, k) {
    var I = h & B ^ ~h & k;
    return I < 0 && (I += 4294967296), I;
  }
  function O(M, h, S, B, T) {
    var k = M & S ^ M & T ^ S & T;
    return k < 0 && (k += 4294967296), k;
  }
  function j(M, h, S, B, T, k) {
    var I = h & B ^ h & k ^ B & k;
    return I < 0 && (I += 4294967296), I;
  }
  function D(M, h) {
    var S = a(M, h, 28), B = a(h, M, 2), T = a(h, M, 7), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function G(M, h) {
    var S = u(M, h, 28), B = u(h, M, 2), T = u(h, M, 7), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function V(M, h) {
    var S = a(M, h, 14), B = a(M, h, 18), T = a(h, M, 9), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function Q(M, h) {
    var S = u(M, h, 14), B = u(M, h, 18), T = u(h, M, 9), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function re(M, h) {
    var S = a(M, h, 1), B = a(M, h, 8), T = n(M, h, 7), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function ve(M, h) {
    var S = u(M, h, 1), B = u(M, h, 8), T = o(M, h, 7), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function te(M, h) {
    var S = a(M, h, 19), B = a(h, M, 29), T = n(M, h, 6), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  function R(M, h) {
    var S = u(M, h, 19), B = u(h, M, 29), T = o(M, h, 6), k = S ^ B ^ T;
    return k < 0 && (k += 4294967296), k;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var e = requireUtils$1(), t = require_512();
  function r() {
    if (!(this instanceof r))
      return new r();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(r, t), _384 = r, r.blockSize = 1024, r.outSize = 384, r.hmacStrength = 192, r.padLength = 128, r.prototype._digest = function(u) {
    return u === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var e = requireUtils$1(), t = requireCommon$4(), r = e.rotl32, a = e.sum32, u = e.sum32_3, n = e.sum32_4, o = t.BlockHash;
  function c() {
    if (!(this instanceof c))
      return new c();
    o.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(c, o), ripemd.ripemd160 = c, c.blockSize = 512, c.outSize = 160, c.hmacStrength = 192, c.padLength = 64, c.prototype._update = function(E, b) {
    for (var q = this.h[0], O = this.h[1], j = this.h[2], D = this.h[3], G = this.h[4], V = q, Q = O, re = j, ve = D, te = G, R = 0; R < 80; R++) {
      var M = a(
        r(
          n(q, f(R, O, j, D), E[p[R] + b], l(R)),
          g[R]
        ),
        G
      );
      q = G, G = D, D = r(j, 10), j = O, O = M, M = a(
        r(
          n(V, f(79 - R, Q, re, ve), E[m[R] + b], s(R)),
          y[R]
        ),
        te
      ), V = te, te = ve, ve = r(re, 10), re = Q, Q = M;
    }
    M = u(this.h[1], j, ve), this.h[1] = u(this.h[2], D, te), this.h[2] = u(this.h[3], G, V), this.h[3] = u(this.h[4], q, Q), this.h[4] = u(this.h[0], O, re), this.h[0] = M;
  }, c.prototype._digest = function(E) {
    return E === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function f(v, E, b, q) {
    return v <= 15 ? E ^ b ^ q : v <= 31 ? E & b | ~E & q : v <= 47 ? (E | ~b) ^ q : v <= 63 ? E & q | b & ~q : E ^ (b | ~q);
  }
  function l(v) {
    return v <= 15 ? 0 : v <= 31 ? 1518500249 : v <= 47 ? 1859775393 : v <= 63 ? 2400959708 : 2840853838;
  }
  function s(v) {
    return v <= 15 ? 1352829926 : v <= 31 ? 1548603684 : v <= 47 ? 1836072691 : v <= 63 ? 2053994217 : 0;
  }
  var p = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], m = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], g = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], y = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var e = requireUtils$1(), t = requireMinimalisticAssert();
  function r(a, u, n) {
    if (!(this instanceof r))
      return new r(a, u, n);
    this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(u, n));
  }
  return hmac = r, r.prototype._init = function(u) {
    u.length > this.blockSize && (u = new this.Hash().update(u).digest()), t(u.length <= this.blockSize);
    for (var n = u.length; n < this.blockSize; n++)
      u.push(0);
    for (n = 0; n < u.length; n++)
      u[n] ^= 54;
    for (this.inner = new this.Hash().update(u), n = 0; n < u.length; n++)
      u[n] ^= 106;
    this.outer = new this.Hash().update(u);
  }, r.prototype.update = function(u, n) {
    return this.inner.update(u, n), this;
  }, r.prototype.digest = function(u) {
    return this.outer.update(this.inner.digest()), this.outer.digest(u);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, (function(e) {
    var t = e;
    t.utils = requireUtils$1(), t.common = requireCommon$4(), t.sha = requireSha(), t.ripemd = requireRipemd(), t.hmac = requireHmac(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  })(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, (function(e) {
    var t = e, r = requireHash(), a = requireCurve(), u = requireUtils$2(), n = u.assert;
    function o(l) {
      l.type === "short" ? this.curve = new a.short(l) : l.type === "edwards" ? this.curve = new a.edwards(l) : this.curve = new a.mont(l), this.g = this.curve.g, this.n = this.curve.n, this.hash = l.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = o;
    function c(l, s) {
      Object.defineProperty(t, l, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var p = new o(s);
          return Object.defineProperty(t, l, {
            configurable: !0,
            enumerable: !0,
            value: p
          }), p;
        }
      });
    }
    c("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: r.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), c("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: r.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), c("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: r.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), c("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: r.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), c("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: r.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), c("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), c("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: r.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var f;
    try {
      f = requireSecp256k1();
    } catch {
      f = void 0;
    }
    c("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: r.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        f
      ]
    });
  })(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var e = requireHash(), t = requireUtils$3(), r = requireMinimalisticAssert();
  function a(u) {
    if (!(this instanceof a))
      return new a(u);
    this.hash = u.hash, this.predResist = !!u.predResist, this.outLen = this.hash.outSize, this.minEntropy = u.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var n = t.toArray(u.entropy, u.entropyEnc || "hex"), o = t.toArray(u.nonce, u.nonceEnc || "hex"), c = t.toArray(u.pers, u.persEnc || "hex");
    r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(n, o, c);
  }
  return hmacDrbg = a, a.prototype._init = function(n, o, c) {
    var f = n.concat(o).concat(c);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var l = 0; l < this.V.length; l++)
      this.K[l] = 0, this.V[l] = 1;
    this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, a.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, a.prototype._update = function(n) {
    var o = this._hmac().update(this.V).update([0]);
    n && (o = o.update(n)), this.K = o.digest(), this.V = this._hmac().update(this.V).digest(), n && (this.K = this._hmac().update(this.V).update([1]).update(n).digest(), this.V = this._hmac().update(this.V).digest());
  }, a.prototype.reseed = function(n, o, c, f) {
    typeof o != "string" && (f = c, c = o, o = null), n = t.toArray(n, o), c = t.toArray(c, f), r(
      n.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(n.concat(c || [])), this._reseed = 1;
  }, a.prototype.generate = function(n, o, c, f) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof o != "string" && (f = c, c = o, o = null), c && (c = t.toArray(c, f || "hex"), this._update(c));
    for (var l = []; l.length < n; )
      this.V = this._hmac().update(this.V).digest(), l = l.concat(this.V);
    var s = l.slice(0, n);
    return this._update(c), this._reseed++, t.encode(s, o);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var e = requireBn$2(), t = requireUtils$2(), r = t.assert;
  function a(u, n) {
    this.ec = u, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc);
  }
  return key$1 = a, a.fromPublic = function(n, o, c) {
    return o instanceof a ? o : new a(n, {
      pub: o,
      pubEnc: c
    });
  }, a.fromPrivate = function(n, o, c) {
    return o instanceof a ? o : new a(n, {
      priv: o,
      privEnc: c
    });
  }, a.prototype.validate = function() {
    var n = this.getPublic();
    return n.isInfinity() ? { result: !1, reason: "Invalid public key" } : n.validate() ? n.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, a.prototype.getPublic = function(n, o) {
    return typeof n == "string" && (o = n, n = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), o ? this.pub.encode(o, n) : this.pub;
  }, a.prototype.getPrivate = function(n) {
    return n === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, a.prototype._importPrivate = function(n, o) {
    this.priv = new e(n, o || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, a.prototype._importPublic = function(n, o) {
    if (n.x || n.y) {
      this.ec.curve.type === "mont" ? r(n.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && r(n.x && n.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(n.x, n.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(n, o);
  }, a.prototype.derive = function(n) {
    return n.validate() || r(n.validate(), "public point not validated"), n.mul(this.priv).getX();
  }, a.prototype.sign = function(n, o, c) {
    return this.ec.sign(n, this, o, c);
  }, a.prototype.verify = function(n, o, c) {
    return this.ec.verify(n, o, this, void 0, c);
  }, a.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var e = requireBn$2(), t = requireUtils$2(), r = t.assert;
  function a(f, l) {
    if (f instanceof a)
      return f;
    this._importDER(f, l) || (r(f.r && f.s, "Signature without r or s"), this.r = new e(f.r, 16), this.s = new e(f.s, 16), f.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = f.recoveryParam);
  }
  signature$1 = a;
  function u() {
    this.place = 0;
  }
  function n(f, l) {
    var s = f[l.place++];
    if (!(s & 128))
      return s;
    var p = s & 15;
    if (p === 0 || p > 4 || f[l.place] === 0)
      return !1;
    for (var m = 0, g = 0, y = l.place; g < p; g++, y++)
      m <<= 8, m |= f[y], m >>>= 0;
    return m <= 127 ? !1 : (l.place = y, m);
  }
  function o(f) {
    for (var l = 0, s = f.length - 1; !f[l] && !(f[l + 1] & 128) && l < s; )
      l++;
    return l === 0 ? f : f.slice(l);
  }
  a.prototype._importDER = function(l, s) {
    l = t.toArray(l, s);
    var p = new u();
    if (l[p.place++] !== 48)
      return !1;
    var m = n(l, p);
    if (m === !1 || m + p.place !== l.length || l[p.place++] !== 2)
      return !1;
    var g = n(l, p);
    if (g === !1 || (l[p.place] & 128) !== 0)
      return !1;
    var y = l.slice(p.place, g + p.place);
    if (p.place += g, l[p.place++] !== 2)
      return !1;
    var v = n(l, p);
    if (v === !1 || l.length !== v + p.place || (l[p.place] & 128) !== 0)
      return !1;
    var E = l.slice(p.place, v + p.place);
    if (y[0] === 0)
      if (y[1] & 128)
        y = y.slice(1);
      else
        return !1;
    if (E[0] === 0)
      if (E[1] & 128)
        E = E.slice(1);
      else
        return !1;
    return this.r = new e(y), this.s = new e(E), this.recoveryParam = null, !0;
  };
  function c(f, l) {
    if (l < 128) {
      f.push(l);
      return;
    }
    var s = 1 + (Math.log(l) / Math.LN2 >>> 3);
    for (f.push(s | 128); --s; )
      f.push(l >>> (s << 3) & 255);
    f.push(l);
  }
  return a.prototype.toDER = function(l) {
    var s = this.r.toArray(), p = this.s.toArray();
    for (s[0] & 128 && (s = [0].concat(s)), p[0] & 128 && (p = [0].concat(p)), s = o(s), p = o(p); !p[0] && !(p[1] & 128); )
      p = p.slice(1);
    var m = [2];
    c(m, s.length), m = m.concat(s), m.push(2), c(m, p.length);
    var g = m.concat(p), y = [48];
    return c(y, g.length), y = y.concat(g), t.encode(y, l);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var e = requireBn$2(), t = requireHmacDrbg(), r = requireUtils$2(), a = requireCurves(), u = requireBrorand(), n = r.assert, o = requireKey$1(), c = requireSignature$1();
  function f(l) {
    if (!(this instanceof f))
      return new f(l);
    typeof l == "string" && (n(
      Object.prototype.hasOwnProperty.call(a, l),
      "Unknown curve " + l
    ), l = a[l]), l instanceof a.PresetCurve && (l = { curve: l }), this.curve = l.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = l.curve.g, this.g.precompute(l.curve.n.bitLength() + 1), this.hash = l.hash || l.curve.hash;
  }
  return ec = f, f.prototype.keyPair = function(s) {
    return new o(this, s);
  }, f.prototype.keyFromPrivate = function(s, p) {
    return o.fromPrivate(this, s, p);
  }, f.prototype.keyFromPublic = function(s, p) {
    return o.fromPublic(this, s, p);
  }, f.prototype.genKeyPair = function(s) {
    s || (s = {});
    for (var p = new t({
      hash: this.hash,
      pers: s.pers,
      persEnc: s.persEnc || "utf8",
      entropy: s.entropy || u(this.hash.hmacStrength),
      entropyEnc: s.entropy && s.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), m = this.n.byteLength(), g = this.n.sub(new e(2)); ; ) {
      var y = new e(p.generate(m));
      if (!(y.cmp(g) > 0))
        return y.iaddn(1), this.keyFromPrivate(y);
    }
  }, f.prototype._truncateToN = function(s, p, m) {
    var g;
    if (e.isBN(s) || typeof s == "number")
      s = new e(s, 16), g = s.byteLength();
    else if (typeof s == "object")
      g = s.length, s = new e(s, 16);
    else {
      var y = s.toString();
      g = y.length + 1 >>> 1, s = new e(y, 16);
    }
    typeof m != "number" && (m = g * 8);
    var v = m - this.n.bitLength();
    return v > 0 && (s = s.ushrn(v)), !p && s.cmp(this.n) >= 0 ? s.sub(this.n) : s;
  }, f.prototype.sign = function(s, p, m, g) {
    if (typeof m == "object" && (g = m, m = null), g || (g = {}), typeof s != "string" && typeof s != "number" && !e.isBN(s)) {
      n(
        typeof s == "object" && s && typeof s.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), n(s.length >>> 0 === s.length);
      for (var y = 0; y < s.length; y++) n((s[y] & 255) === s[y]);
    }
    p = this.keyFromPrivate(p, m), s = this._truncateToN(s, !1, g.msgBitLength), n(!s.isNeg(), "Can not sign a negative message");
    var v = this.n.byteLength(), E = p.getPrivate().toArray("be", v), b = s.toArray("be", v);
    n(new e(b).eq(s), "Can not sign message");
    for (var q = new t({
      hash: this.hash,
      entropy: E,
      nonce: b,
      pers: g.pers,
      persEnc: g.persEnc || "utf8"
    }), O = this.n.sub(new e(1)), j = 0; ; j++) {
      var D = g.k ? g.k(j) : new e(q.generate(this.n.byteLength()));
      if (D = this._truncateToN(D, !0), !(D.cmpn(1) <= 0 || D.cmp(O) >= 0)) {
        var G = this.g.mul(D);
        if (!G.isInfinity()) {
          var V = G.getX(), Q = V.umod(this.n);
          if (Q.cmpn(0) !== 0) {
            var re = D.invm(this.n).mul(Q.mul(p.getPrivate()).iadd(s));
            if (re = re.umod(this.n), re.cmpn(0) !== 0) {
              var ve = (G.getY().isOdd() ? 1 : 0) | (V.cmp(Q) !== 0 ? 2 : 0);
              return g.canonical && re.cmp(this.nh) > 0 && (re = this.n.sub(re), ve ^= 1), new c({ r: Q, s: re, recoveryParam: ve });
            }
          }
        }
      }
    }
  }, f.prototype.verify = function(s, p, m, g, y) {
    y || (y = {}), s = this._truncateToN(s, !1, y.msgBitLength), m = this.keyFromPublic(m, g), p = new c(p, "hex");
    var v = p.r, E = p.s;
    if (v.cmpn(1) < 0 || v.cmp(this.n) >= 0 || E.cmpn(1) < 0 || E.cmp(this.n) >= 0)
      return !1;
    var b = E.invm(this.n), q = b.mul(s).umod(this.n), O = b.mul(v).umod(this.n), j;
    return this.curve._maxwellTrick ? (j = this.g.jmulAdd(q, m.getPublic(), O), j.isInfinity() ? !1 : j.eqXToP(v)) : (j = this.g.mulAdd(q, m.getPublic(), O), j.isInfinity() ? !1 : j.getX().umod(this.n).cmp(v) === 0);
  }, f.prototype.recoverPubKey = function(l, s, p, m) {
    n((3 & p) === p, "The recovery param is more than two bits"), s = new c(s, m);
    var g = this.n, y = new e(l), v = s.r, E = s.s, b = p & 1, q = p >> 1;
    if (v.cmp(this.curve.p.umod(this.curve.n)) >= 0 && q)
      throw new Error("Unable to find sencond key candinate");
    q ? v = this.curve.pointFromX(v.add(this.curve.n), b) : v = this.curve.pointFromX(v, b);
    var O = s.r.invm(g), j = g.sub(y).mul(O).umod(g), D = E.mul(O).umod(g);
    return this.g.mulAdd(j, v, D);
  }, f.prototype.getKeyRecoveryParam = function(l, s, p, m) {
    if (s = new c(s, m), s.recoveryParam !== null)
      return s.recoveryParam;
    for (var g = 0; g < 4; g++) {
      var y;
      try {
        y = this.recoverPubKey(l, s, g);
      } catch {
        continue;
      }
      if (y.eq(p))
        return g;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var e = requireUtils$2(), t = e.assert, r = e.parseBytes, a = e.cachedProperty;
  function u(n, o) {
    this.eddsa = n, this._secret = r(o.secret), n.isPoint(o.pub) ? this._pub = o.pub : this._pubBytes = r(o.pub);
  }
  return u.fromPublic = function(o, c) {
    return c instanceof u ? c : new u(o, { pub: c });
  }, u.fromSecret = function(o, c) {
    return c instanceof u ? c : new u(o, { secret: c });
  }, u.prototype.secret = function() {
    return this._secret;
  }, a(u, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), a(u, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), a(u, "privBytes", function() {
    var o = this.eddsa, c = this.hash(), f = o.encodingLength - 1, l = c.slice(0, o.encodingLength);
    return l[0] &= 248, l[f] &= 127, l[f] |= 64, l;
  }), a(u, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), a(u, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), a(u, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), u.prototype.sign = function(o) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
  }, u.prototype.verify = function(o, c) {
    return this.eddsa.verify(o, c, this);
  }, u.prototype.getSecret = function(o) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), o);
  }, u.prototype.getPublic = function(o) {
    return e.encode(this.pubBytes(), o);
  }, key = u, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var e = requireBn$2(), t = requireUtils$2(), r = t.assert, a = t.cachedProperty, u = t.parseBytes;
  function n(o, c) {
    this.eddsa = o, typeof c != "object" && (c = u(c)), Array.isArray(c) && (r(c.length === o.encodingLength * 2, "Signature has invalid size"), c = {
      R: c.slice(0, o.encodingLength),
      S: c.slice(o.encodingLength)
    }), r(c.R && c.S, "Signature without R or S"), o.isPoint(c.R) && (this._R = c.R), c.S instanceof e && (this._S = c.S), this._Rencoded = Array.isArray(c.R) ? c.R : c.Rencoded, this._Sencoded = Array.isArray(c.S) ? c.S : c.Sencoded;
  }
  return a(n, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), a(n, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), a(n, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), a(n, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), n.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, n.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = n, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var e = requireHash(), t = requireCurves(), r = requireUtils$2(), a = r.assert, u = r.parseBytes, n = requireKey(), o = requireSignature();
  function c(f) {
    if (a(f === "ed25519", "only tested with ed25519 so far"), !(this instanceof c))
      return new c(f);
    f = t[f].curve, this.curve = f, this.g = f.g, this.g.precompute(f.n.bitLength() + 1), this.pointClass = f.point().constructor, this.encodingLength = Math.ceil(f.n.bitLength() / 8), this.hash = e.sha512;
  }
  return eddsa = c, c.prototype.sign = function(l, s) {
    l = u(l);
    var p = this.keyFromSecret(s), m = this.hashInt(p.messagePrefix(), l), g = this.g.mul(m), y = this.encodePoint(g), v = this.hashInt(y, p.pubBytes(), l).mul(p.priv()), E = m.add(v).umod(this.curve.n);
    return this.makeSignature({ R: g, S: E, Rencoded: y });
  }, c.prototype.verify = function(l, s, p) {
    if (l = u(l), s = this.makeSignature(s), s.S().gte(s.eddsa.curve.n) || s.S().isNeg())
      return !1;
    var m = this.keyFromPublic(p), g = this.hashInt(s.Rencoded(), m.pubBytes(), l), y = this.g.mul(s.S()), v = s.R().add(m.pub().mul(g));
    return v.eq(y);
  }, c.prototype.hashInt = function() {
    for (var l = this.hash(), s = 0; s < arguments.length; s++)
      l.update(arguments[s]);
    return r.intFromLE(l.digest()).umod(this.curve.n);
  }, c.prototype.keyFromPublic = function(l) {
    return n.fromPublic(this, l);
  }, c.prototype.keyFromSecret = function(l) {
    return n.fromSecret(this, l);
  }, c.prototype.makeSignature = function(l) {
    return l instanceof o ? l : new o(this, l);
  }, c.prototype.encodePoint = function(l) {
    var s = l.getY().toArray("le", this.encodingLength);
    return s[this.encodingLength - 1] |= l.getX().isOdd() ? 128 : 0, s;
  }, c.prototype.decodePoint = function(l) {
    l = r.parseBytes(l);
    var s = l.length - 1, p = l.slice(0, s).concat(l[s] & -129), m = (l[s] & 128) !== 0, g = r.intFromLE(p);
    return this.curve.pointFromY(g, m);
  }, c.prototype.encodeInt = function(l) {
    return l.toArray("le", this.encodingLength);
  }, c.prototype.decodeInt = function(l) {
    return r.intFromLE(l);
  }, c.prototype.isPoint = function(l) {
    return l instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, (function(e) {
    var t = e;
    t.version = require$$0$7.version, t.utils = requireUtils$2(), t.rand = requireBrorand(), t.curve = requireCurve(), t.curves = requireCurves(), t.ec = requireEc(), t.eddsa = requireEddsa();
  })(elliptic)), elliptic;
}
var bn$1 = { exports: {} }, bn = bn$1.exports, hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, (function(e) {
    (function(t, r) {
      function a(M, h) {
        if (!M) throw new Error(h || "Assertion failed");
      }
      function u(M, h) {
        M.super_ = h;
        var S = function() {
        };
        S.prototype = h.prototype, M.prototype = new S(), M.prototype.constructor = M;
      }
      function n(M, h, S) {
        if (n.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && ((h === "le" || h === "be") && (S = h, h = 10), this._init(M || 0, h || 10, S || "be"));
      }
      typeof t == "object" ? t.exports = n : r.BN = n, n.BN = n, n.wordSize = 26;
      var o;
      try {
        typeof globalThis < "u" && typeof globalThis.Buffer < "u" ? o = globalThis.Buffer : o = requireDist$1().Buffer;
      } catch {
      }
      n.isBN = function(h) {
        return h instanceof n ? !0 : h !== null && typeof h == "object" && h.constructor.wordSize === n.wordSize && Array.isArray(h.words);
      }, n.max = function(h, S) {
        return h.cmp(S) > 0 ? h : S;
      }, n.min = function(h, S) {
        return h.cmp(S) < 0 ? h : S;
      }, n.prototype._init = function(h, S, B) {
        if (typeof h == "number")
          return this._initNumber(h, S, B);
        if (typeof h == "object")
          return this._initArray(h, S, B);
        S === "hex" && (S = 16), a(S === (S | 0) && S >= 2 && S <= 36), h = h.toString().replace(/\s+/g, "");
        var T = 0;
        h[0] === "-" && (T++, this.negative = 1), T < h.length && (S === 16 ? this._parseHex(h, T, B) : (this._parseBase(h, S, T), B === "le" && this._initArray(this.toArray(), S, B)));
      }, n.prototype._initNumber = function(h, S, B) {
        h < 0 && (this.negative = 1, h = -h), h < 67108864 ? (this.words = [h & 67108863], this.length = 1) : h < 4503599627370496 ? (this.words = [
          h & 67108863,
          h / 67108864 & 67108863
        ], this.length = 2) : (a(h < 9007199254740992), this.words = [
          h & 67108863,
          h / 67108864 & 67108863,
          1
        ], this.length = 3), B === "le" && this._initArray(this.toArray(), S, B);
      }, n.prototype._initArray = function(h, S, B) {
        if (a(typeof h.length == "number"), h.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(h.length / 3), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var k, I, C = 0;
        if (B === "be")
          for (T = h.length - 1, k = 0; T >= 0; T -= 3)
            I = h[T] | h[T - 1] << 8 | h[T - 2] << 16, this.words[k] |= I << C & 67108863, this.words[k + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, k++);
        else if (B === "le")
          for (T = 0, k = 0; T < h.length; T += 3)
            I = h[T] | h[T + 1] << 8 | h[T + 2] << 16, this.words[k] |= I << C & 67108863, this.words[k + 1] = I >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, k++);
        return this._strip();
      };
      function c(M, h) {
        var S = M.charCodeAt(h);
        if (S >= 48 && S <= 57)
          return S - 48;
        if (S >= 65 && S <= 70)
          return S - 55;
        if (S >= 97 && S <= 102)
          return S - 87;
        a(!1, "Invalid character in " + M);
      }
      function f(M, h, S) {
        var B = c(M, S);
        return S - 1 >= h && (B |= c(M, S - 1) << 4), B;
      }
      n.prototype._parseHex = function(h, S, B) {
        this.length = Math.ceil((h.length - S) / 6), this.words = new Array(this.length);
        for (var T = 0; T < this.length; T++)
          this.words[T] = 0;
        var k = 0, I = 0, C;
        if (B === "be")
          for (T = h.length - 1; T >= S; T -= 2)
            C = f(h, S, T) << k, this.words[I] |= C & 67108863, k >= 18 ? (k -= 18, I += 1, this.words[I] |= C >>> 26) : k += 8;
        else {
          var $ = h.length - S;
          for (T = $ % 2 === 0 ? S + 1 : S; T < h.length; T += 2)
            C = f(h, S, T) << k, this.words[I] |= C & 67108863, k >= 18 ? (k -= 18, I += 1, this.words[I] |= C >>> 26) : k += 8;
        }
        this._strip();
      };
      function l(M, h, S, B) {
        for (var T = 0, k = 0, I = Math.min(M.length, S), C = h; C < I; C++) {
          var $ = M.charCodeAt(C) - 48;
          T *= B, $ >= 49 ? k = $ - 49 + 10 : $ >= 17 ? k = $ - 17 + 10 : k = $, a($ >= 0 && k < B, "Invalid character"), T += k;
        }
        return T;
      }
      n.prototype._parseBase = function(h, S, B) {
        this.words = [0], this.length = 1;
        for (var T = 0, k = 1; k <= 67108863; k *= S)
          T++;
        T--, k = k / S | 0;
        for (var I = h.length - B, C = I % T, $ = Math.min(I, I - C) + B, w = 0, U = B; U < $; U += T)
          w = l(h, U, U + T, S), this.imuln(k), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        if (C !== 0) {
          var ie = 1;
          for (w = l(h, U, h.length, S), U = 0; U < C; U++)
            ie *= S;
          this.imuln(ie), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        }
        this._strip();
      }, n.prototype.copy = function(h) {
        h.words = new Array(this.length);
        for (var S = 0; S < this.length; S++)
          h.words[S] = this.words[S];
        h.length = this.length, h.negative = this.negative, h.red = this.red;
      };
      function s(M, h) {
        M.words = h.words, M.length = h.length, M.negative = h.negative, M.red = h.red;
      }
      if (n.prototype._move = function(h) {
        s(h, this);
      }, n.prototype.clone = function() {
        var h = new n(null);
        return this.copy(h), h;
      }, n.prototype._expand = function(h) {
        for (; this.length < h; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
        } catch {
          n.prototype.inspect = p;
        }
      else
        n.prototype.inspect = p;
      function p() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var m = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], g = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], y = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(h, S) {
        h = h || 10, S = S | 0 || 1;
        var B;
        if (h === 16 || h === "hex") {
          B = "";
          for (var T = 0, k = 0, I = 0; I < this.length; I++) {
            var C = this.words[I], $ = ((C << T | k) & 16777215).toString(16);
            k = C >>> 24 - T & 16777215, T += 2, T >= 26 && (T -= 26, I--), k !== 0 || I !== this.length - 1 ? B = m[6 - $.length] + $ + B : B = $ + B;
          }
          for (k !== 0 && (B = k.toString(16) + B); B.length % S !== 0; )
            B = "0" + B;
          return this.negative !== 0 && (B = "-" + B), B;
        }
        if (h === (h | 0) && h >= 2 && h <= 36) {
          var w = g[h], U = y[h];
          B = "";
          var ie = this.clone();
          for (ie.negative = 0; !ie.isZero(); ) {
            var le = ie.modrn(U).toString(h);
            ie = ie.idivn(U), ie.isZero() ? B = le + B : B = m[w - le.length] + le + B;
          }
          for (this.isZero() && (B = "0" + B); B.length % S !== 0; )
            B = "0" + B;
          return this.negative !== 0 && (B = "-" + B), B;
        }
        a(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var h = this.words[0];
        return this.length === 2 ? h += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? h += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -h : h;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (n.prototype.toBuffer = function(h, S) {
        return this.toArrayLike(o, h, S);
      }), n.prototype.toArray = function(h, S) {
        return this.toArrayLike(Array, h, S);
      };
      var v = function(h, S) {
        return h.allocUnsafe ? h.allocUnsafe(S) : new h(S);
      };
      n.prototype.toArrayLike = function(h, S, B) {
        this._strip();
        var T = this.byteLength(), k = B || Math.max(1, T);
        a(T <= k, "byte array longer than desired length"), a(k > 0, "Requested array length <= 0");
        var I = v(h, k), C = S === "le" ? "LE" : "BE";
        return this["_toArrayLike" + C](I, T), I;
      }, n.prototype._toArrayLikeLE = function(h, S) {
        for (var B = 0, T = 0, k = 0, I = 0; k < this.length; k++) {
          var C = this.words[k] << I | T;
          h[B++] = C & 255, B < h.length && (h[B++] = C >> 8 & 255), B < h.length && (h[B++] = C >> 16 & 255), I === 6 ? (B < h.length && (h[B++] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (B < h.length)
          for (h[B++] = T; B < h.length; )
            h[B++] = 0;
      }, n.prototype._toArrayLikeBE = function(h, S) {
        for (var B = h.length - 1, T = 0, k = 0, I = 0; k < this.length; k++) {
          var C = this.words[k] << I | T;
          h[B--] = C & 255, B >= 0 && (h[B--] = C >> 8 & 255), B >= 0 && (h[B--] = C >> 16 & 255), I === 6 ? (B >= 0 && (h[B--] = C >> 24 & 255), T = 0, I = 0) : (T = C >>> 24, I += 2);
        }
        if (B >= 0)
          for (h[B--] = T; B >= 0; )
            h[B--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(h) {
        return 32 - Math.clz32(h);
      } : n.prototype._countBits = function(h) {
        var S = h, B = 0;
        return S >= 4096 && (B += 13, S >>>= 13), S >= 64 && (B += 7, S >>>= 7), S >= 8 && (B += 4, S >>>= 4), S >= 2 && (B += 2, S >>>= 2), B + S;
      }, n.prototype._zeroBits = function(h) {
        if (h === 0) return 26;
        var S = h, B = 0;
        return (S & 8191) === 0 && (B += 13, S >>>= 13), (S & 127) === 0 && (B += 7, S >>>= 7), (S & 15) === 0 && (B += 4, S >>>= 4), (S & 3) === 0 && (B += 2, S >>>= 2), (S & 1) === 0 && B++, B;
      }, n.prototype.bitLength = function() {
        var h = this.words[this.length - 1], S = this._countBits(h);
        return (this.length - 1) * 26 + S;
      };
      function E(M) {
        for (var h = new Array(M.bitLength()), S = 0; S < h.length; S++) {
          var B = S / 26 | 0, T = S % 26;
          h[S] = M.words[B] >>> T & 1;
        }
        return h;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var h = 0, S = 0; S < this.length; S++) {
          var B = this._zeroBits(this.words[S]);
          if (h += B, B !== 26) break;
        }
        return h;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(h) {
        return this.negative !== 0 ? this.abs().inotn(h).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(h) {
        return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(h) {
        for (; this.length < h.length; )
          this.words[this.length++] = 0;
        for (var S = 0; S < h.length; S++)
          this.words[S] = this.words[S] | h.words[S];
        return this._strip();
      }, n.prototype.ior = function(h) {
        return a((this.negative | h.negative) === 0), this.iuor(h);
      }, n.prototype.or = function(h) {
        return this.length > h.length ? this.clone().ior(h) : h.clone().ior(this);
      }, n.prototype.uor = function(h) {
        return this.length > h.length ? this.clone().iuor(h) : h.clone().iuor(this);
      }, n.prototype.iuand = function(h) {
        var S;
        this.length > h.length ? S = h : S = this;
        for (var B = 0; B < S.length; B++)
          this.words[B] = this.words[B] & h.words[B];
        return this.length = S.length, this._strip();
      }, n.prototype.iand = function(h) {
        return a((this.negative | h.negative) === 0), this.iuand(h);
      }, n.prototype.and = function(h) {
        return this.length > h.length ? this.clone().iand(h) : h.clone().iand(this);
      }, n.prototype.uand = function(h) {
        return this.length > h.length ? this.clone().iuand(h) : h.clone().iuand(this);
      }, n.prototype.iuxor = function(h) {
        var S, B;
        this.length > h.length ? (S = this, B = h) : (S = h, B = this);
        for (var T = 0; T < B.length; T++)
          this.words[T] = S.words[T] ^ B.words[T];
        if (this !== S)
          for (; T < S.length; T++)
            this.words[T] = S.words[T];
        return this.length = S.length, this._strip();
      }, n.prototype.ixor = function(h) {
        return a((this.negative | h.negative) === 0), this.iuxor(h);
      }, n.prototype.xor = function(h) {
        return this.length > h.length ? this.clone().ixor(h) : h.clone().ixor(this);
      }, n.prototype.uxor = function(h) {
        return this.length > h.length ? this.clone().iuxor(h) : h.clone().iuxor(this);
      }, n.prototype.inotn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = Math.ceil(h / 26) | 0, B = h % 26;
        this._expand(S), B > 0 && S--;
        for (var T = 0; T < S; T++)
          this.words[T] = ~this.words[T] & 67108863;
        return B > 0 && (this.words[T] = ~this.words[T] & 67108863 >> 26 - B), this._strip();
      }, n.prototype.notn = function(h) {
        return this.clone().inotn(h);
      }, n.prototype.setn = function(h, S) {
        a(typeof h == "number" && h >= 0);
        var B = h / 26 | 0, T = h % 26;
        return this._expand(B + 1), S ? this.words[B] = this.words[B] | 1 << T : this.words[B] = this.words[B] & ~(1 << T), this._strip();
      }, n.prototype.iadd = function(h) {
        var S;
        if (this.negative !== 0 && h.negative === 0)
          return this.negative = 0, S = this.isub(h), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && h.negative !== 0)
          return h.negative = 0, S = this.isub(h), h.negative = 1, S._normSign();
        var B, T;
        this.length > h.length ? (B = this, T = h) : (B = h, T = this);
        for (var k = 0, I = 0; I < T.length; I++)
          S = (B.words[I] | 0) + (T.words[I] | 0) + k, this.words[I] = S & 67108863, k = S >>> 26;
        for (; k !== 0 && I < B.length; I++)
          S = (B.words[I] | 0) + k, this.words[I] = S & 67108863, k = S >>> 26;
        if (this.length = B.length, k !== 0)
          this.words[this.length] = k, this.length++;
        else if (B !== this)
          for (; I < B.length; I++)
            this.words[I] = B.words[I];
        return this;
      }, n.prototype.add = function(h) {
        var S;
        return h.negative !== 0 && this.negative === 0 ? (h.negative = 0, S = this.sub(h), h.negative ^= 1, S) : h.negative === 0 && this.negative !== 0 ? (this.negative = 0, S = h.sub(this), this.negative = 1, S) : this.length > h.length ? this.clone().iadd(h) : h.clone().iadd(this);
      }, n.prototype.isub = function(h) {
        if (h.negative !== 0) {
          h.negative = 0;
          var S = this.iadd(h);
          return h.negative = 1, S._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(h), this.negative = 1, this._normSign();
        var B = this.cmp(h);
        if (B === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var T, k;
        B > 0 ? (T = this, k = h) : (T = h, k = this);
        for (var I = 0, C = 0; C < k.length; C++)
          S = (T.words[C] | 0) - (k.words[C] | 0) + I, I = S >> 26, this.words[C] = S & 67108863;
        for (; I !== 0 && C < T.length; C++)
          S = (T.words[C] | 0) + I, I = S >> 26, this.words[C] = S & 67108863;
        if (I === 0 && C < T.length && T !== this)
          for (; C < T.length; C++)
            this.words[C] = T.words[C];
        return this.length = Math.max(this.length, C), T !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(h) {
        return this.clone().isub(h);
      };
      function b(M, h, S) {
        S.negative = h.negative ^ M.negative;
        var B = M.length + h.length | 0;
        S.length = B, B = B - 1 | 0;
        var T = M.words[0] | 0, k = h.words[0] | 0, I = T * k, C = I & 67108863, $ = I / 67108864 | 0;
        S.words[0] = C;
        for (var w = 1; w < B; w++) {
          for (var U = $ >>> 26, ie = $ & 67108863, le = Math.min(w, h.length - 1), ee = Math.max(0, w - M.length + 1); ee <= le; ee++) {
            var F = w - ee | 0;
            T = M.words[F] | 0, k = h.words[ee] | 0, I = T * k + ie, U += I / 67108864 | 0, ie = I & 67108863;
          }
          S.words[w] = ie | 0, $ = U | 0;
        }
        return $ !== 0 ? S.words[w] = $ | 0 : S.length--, S._strip();
      }
      var q = function(h, S, B) {
        var T = h.words, k = S.words, I = B.words, C = 0, $, w, U, ie = T[0] | 0, le = ie & 8191, ee = ie >>> 13, F = T[1] | 0, z = F & 8191, se = F >>> 13, he = T[2] | 0, ae = he & 8191, X = he >>> 13, be = T[3] | 0, Re = be & 8191, Pe = be >>> 13, Fe = T[4] | 0, De = Fe & 8191, je = Fe >>> 13, Oe = T[5] | 0, rt = Oe & 8191, He = Oe >>> 13, Qe = T[6] | 0, Je = Qe & 8191, we = Qe >>> 13, Ae = T[7] | 0, ze = Ae & 8191, Ue = Ae >>> 13, Ge = T[8] | 0, Xe = Ge & 8191, oe = Ge >>> 13, L = T[9] | 0, H = L & 8191, ue = L >>> 13, xe = k[0] | 0, pe = xe & 8191, ce = xe >>> 13, Y = k[1] | 0, Te = Y & 8191, Ne = Y >>> 13, K = k[2] | 0, Se = K & 8191, Ce = K >>> 13, de = k[3] | 0, _e = de & 8191, Me = de >>> 13, tt = k[4] | 0, We = tt & 8191, ne = tt >>> 13, W = k[5] | 0, J = W & 8191, me = W >>> 13, Ee = k[6] | 0, ke = Ee & 8191, Ie = Ee >>> 13, at = k[7] | 0, ot = at & 8191, it = at >>> 13, ct = k[8] | 0, nt = ct & 8191, st = ct >>> 13, yt = k[9] | 0, ft = yt & 8191, dt = yt >>> 13;
        B.negative = h.negative ^ S.negative, B.length = 19, $ = Math.imul(le, pe), w = Math.imul(le, ce), w = w + Math.imul(ee, pe) | 0, U = Math.imul(ee, ce);
        var Ut = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, $ = Math.imul(z, pe), w = Math.imul(z, ce), w = w + Math.imul(se, pe) | 0, U = Math.imul(se, ce), $ = $ + Math.imul(le, Te) | 0, w = w + Math.imul(le, Ne) | 0, w = w + Math.imul(ee, Te) | 0, U = U + Math.imul(ee, Ne) | 0;
        var Lt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, $ = Math.imul(ae, pe), w = Math.imul(ae, ce), w = w + Math.imul(X, pe) | 0, U = Math.imul(X, ce), $ = $ + Math.imul(z, Te) | 0, w = w + Math.imul(z, Ne) | 0, w = w + Math.imul(se, Te) | 0, U = U + Math.imul(se, Ne) | 0, $ = $ + Math.imul(le, Se) | 0, w = w + Math.imul(le, Ce) | 0, w = w + Math.imul(ee, Se) | 0, U = U + Math.imul(ee, Ce) | 0;
        var Dt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, $ = Math.imul(Re, pe), w = Math.imul(Re, ce), w = w + Math.imul(Pe, pe) | 0, U = Math.imul(Pe, ce), $ = $ + Math.imul(ae, Te) | 0, w = w + Math.imul(ae, Ne) | 0, w = w + Math.imul(X, Te) | 0, U = U + Math.imul(X, Ne) | 0, $ = $ + Math.imul(z, Se) | 0, w = w + Math.imul(z, Ce) | 0, w = w + Math.imul(se, Se) | 0, U = U + Math.imul(se, Ce) | 0, $ = $ + Math.imul(le, _e) | 0, w = w + Math.imul(le, Me) | 0, w = w + Math.imul(ee, _e) | 0, U = U + Math.imul(ee, Me) | 0;
        var Yt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, $ = Math.imul(De, pe), w = Math.imul(De, ce), w = w + Math.imul(je, pe) | 0, U = Math.imul(je, ce), $ = $ + Math.imul(Re, Te) | 0, w = w + Math.imul(Re, Ne) | 0, w = w + Math.imul(Pe, Te) | 0, U = U + Math.imul(Pe, Ne) | 0, $ = $ + Math.imul(ae, Se) | 0, w = w + Math.imul(ae, Ce) | 0, w = w + Math.imul(X, Se) | 0, U = U + Math.imul(X, Ce) | 0, $ = $ + Math.imul(z, _e) | 0, w = w + Math.imul(z, Me) | 0, w = w + Math.imul(se, _e) | 0, U = U + Math.imul(se, Me) | 0, $ = $ + Math.imul(le, We) | 0, w = w + Math.imul(le, ne) | 0, w = w + Math.imul(ee, We) | 0, U = U + Math.imul(ee, ne) | 0;
        var Kt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, $ = Math.imul(rt, pe), w = Math.imul(rt, ce), w = w + Math.imul(He, pe) | 0, U = Math.imul(He, ce), $ = $ + Math.imul(De, Te) | 0, w = w + Math.imul(De, Ne) | 0, w = w + Math.imul(je, Te) | 0, U = U + Math.imul(je, Ne) | 0, $ = $ + Math.imul(Re, Se) | 0, w = w + Math.imul(Re, Ce) | 0, w = w + Math.imul(Pe, Se) | 0, U = U + Math.imul(Pe, Ce) | 0, $ = $ + Math.imul(ae, _e) | 0, w = w + Math.imul(ae, Me) | 0, w = w + Math.imul(X, _e) | 0, U = U + Math.imul(X, Me) | 0, $ = $ + Math.imul(z, We) | 0, w = w + Math.imul(z, ne) | 0, w = w + Math.imul(se, We) | 0, U = U + Math.imul(se, ne) | 0, $ = $ + Math.imul(le, J) | 0, w = w + Math.imul(le, me) | 0, w = w + Math.imul(ee, J) | 0, U = U + Math.imul(ee, me) | 0;
        var Wt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, $ = Math.imul(Je, pe), w = Math.imul(Je, ce), w = w + Math.imul(we, pe) | 0, U = Math.imul(we, ce), $ = $ + Math.imul(rt, Te) | 0, w = w + Math.imul(rt, Ne) | 0, w = w + Math.imul(He, Te) | 0, U = U + Math.imul(He, Ne) | 0, $ = $ + Math.imul(De, Se) | 0, w = w + Math.imul(De, Ce) | 0, w = w + Math.imul(je, Se) | 0, U = U + Math.imul(je, Ce) | 0, $ = $ + Math.imul(Re, _e) | 0, w = w + Math.imul(Re, Me) | 0, w = w + Math.imul(Pe, _e) | 0, U = U + Math.imul(Pe, Me) | 0, $ = $ + Math.imul(ae, We) | 0, w = w + Math.imul(ae, ne) | 0, w = w + Math.imul(X, We) | 0, U = U + Math.imul(X, ne) | 0, $ = $ + Math.imul(z, J) | 0, w = w + Math.imul(z, me) | 0, w = w + Math.imul(se, J) | 0, U = U + Math.imul(se, me) | 0, $ = $ + Math.imul(le, ke) | 0, w = w + Math.imul(le, Ie) | 0, w = w + Math.imul(ee, ke) | 0, U = U + Math.imul(ee, Ie) | 0;
        var or = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, $ = Math.imul(ze, pe), w = Math.imul(ze, ce), w = w + Math.imul(Ue, pe) | 0, U = Math.imul(Ue, ce), $ = $ + Math.imul(Je, Te) | 0, w = w + Math.imul(Je, Ne) | 0, w = w + Math.imul(we, Te) | 0, U = U + Math.imul(we, Ne) | 0, $ = $ + Math.imul(rt, Se) | 0, w = w + Math.imul(rt, Ce) | 0, w = w + Math.imul(He, Se) | 0, U = U + Math.imul(He, Ce) | 0, $ = $ + Math.imul(De, _e) | 0, w = w + Math.imul(De, Me) | 0, w = w + Math.imul(je, _e) | 0, U = U + Math.imul(je, Me) | 0, $ = $ + Math.imul(Re, We) | 0, w = w + Math.imul(Re, ne) | 0, w = w + Math.imul(Pe, We) | 0, U = U + Math.imul(Pe, ne) | 0, $ = $ + Math.imul(ae, J) | 0, w = w + Math.imul(ae, me) | 0, w = w + Math.imul(X, J) | 0, U = U + Math.imul(X, me) | 0, $ = $ + Math.imul(z, ke) | 0, w = w + Math.imul(z, Ie) | 0, w = w + Math.imul(se, ke) | 0, U = U + Math.imul(se, Ie) | 0, $ = $ + Math.imul(le, ot) | 0, w = w + Math.imul(le, it) | 0, w = w + Math.imul(ee, ot) | 0, U = U + Math.imul(ee, it) | 0;
        var Gt = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, $ = Math.imul(Xe, pe), w = Math.imul(Xe, ce), w = w + Math.imul(oe, pe) | 0, U = Math.imul(oe, ce), $ = $ + Math.imul(ze, Te) | 0, w = w + Math.imul(ze, Ne) | 0, w = w + Math.imul(Ue, Te) | 0, U = U + Math.imul(Ue, Ne) | 0, $ = $ + Math.imul(Je, Se) | 0, w = w + Math.imul(Je, Ce) | 0, w = w + Math.imul(we, Se) | 0, U = U + Math.imul(we, Ce) | 0, $ = $ + Math.imul(rt, _e) | 0, w = w + Math.imul(rt, Me) | 0, w = w + Math.imul(He, _e) | 0, U = U + Math.imul(He, Me) | 0, $ = $ + Math.imul(De, We) | 0, w = w + Math.imul(De, ne) | 0, w = w + Math.imul(je, We) | 0, U = U + Math.imul(je, ne) | 0, $ = $ + Math.imul(Re, J) | 0, w = w + Math.imul(Re, me) | 0, w = w + Math.imul(Pe, J) | 0, U = U + Math.imul(Pe, me) | 0, $ = $ + Math.imul(ae, ke) | 0, w = w + Math.imul(ae, Ie) | 0, w = w + Math.imul(X, ke) | 0, U = U + Math.imul(X, Ie) | 0, $ = $ + Math.imul(z, ot) | 0, w = w + Math.imul(z, it) | 0, w = w + Math.imul(se, ot) | 0, U = U + Math.imul(se, it) | 0, $ = $ + Math.imul(le, nt) | 0, w = w + Math.imul(le, st) | 0, w = w + Math.imul(ee, nt) | 0, U = U + Math.imul(ee, st) | 0;
        var cr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, $ = Math.imul(H, pe), w = Math.imul(H, ce), w = w + Math.imul(ue, pe) | 0, U = Math.imul(ue, ce), $ = $ + Math.imul(Xe, Te) | 0, w = w + Math.imul(Xe, Ne) | 0, w = w + Math.imul(oe, Te) | 0, U = U + Math.imul(oe, Ne) | 0, $ = $ + Math.imul(ze, Se) | 0, w = w + Math.imul(ze, Ce) | 0, w = w + Math.imul(Ue, Se) | 0, U = U + Math.imul(Ue, Ce) | 0, $ = $ + Math.imul(Je, _e) | 0, w = w + Math.imul(Je, Me) | 0, w = w + Math.imul(we, _e) | 0, U = U + Math.imul(we, Me) | 0, $ = $ + Math.imul(rt, We) | 0, w = w + Math.imul(rt, ne) | 0, w = w + Math.imul(He, We) | 0, U = U + Math.imul(He, ne) | 0, $ = $ + Math.imul(De, J) | 0, w = w + Math.imul(De, me) | 0, w = w + Math.imul(je, J) | 0, U = U + Math.imul(je, me) | 0, $ = $ + Math.imul(Re, ke) | 0, w = w + Math.imul(Re, Ie) | 0, w = w + Math.imul(Pe, ke) | 0, U = U + Math.imul(Pe, Ie) | 0, $ = $ + Math.imul(ae, ot) | 0, w = w + Math.imul(ae, it) | 0, w = w + Math.imul(X, ot) | 0, U = U + Math.imul(X, it) | 0, $ = $ + Math.imul(z, nt) | 0, w = w + Math.imul(z, st) | 0, w = w + Math.imul(se, nt) | 0, U = U + Math.imul(se, st) | 0, $ = $ + Math.imul(le, ft) | 0, w = w + Math.imul(le, dt) | 0, w = w + Math.imul(ee, ft) | 0, U = U + Math.imul(ee, dt) | 0;
        var ur = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, $ = Math.imul(H, Te), w = Math.imul(H, Ne), w = w + Math.imul(ue, Te) | 0, U = Math.imul(ue, Ne), $ = $ + Math.imul(Xe, Se) | 0, w = w + Math.imul(Xe, Ce) | 0, w = w + Math.imul(oe, Se) | 0, U = U + Math.imul(oe, Ce) | 0, $ = $ + Math.imul(ze, _e) | 0, w = w + Math.imul(ze, Me) | 0, w = w + Math.imul(Ue, _e) | 0, U = U + Math.imul(Ue, Me) | 0, $ = $ + Math.imul(Je, We) | 0, w = w + Math.imul(Je, ne) | 0, w = w + Math.imul(we, We) | 0, U = U + Math.imul(we, ne) | 0, $ = $ + Math.imul(rt, J) | 0, w = w + Math.imul(rt, me) | 0, w = w + Math.imul(He, J) | 0, U = U + Math.imul(He, me) | 0, $ = $ + Math.imul(De, ke) | 0, w = w + Math.imul(De, Ie) | 0, w = w + Math.imul(je, ke) | 0, U = U + Math.imul(je, Ie) | 0, $ = $ + Math.imul(Re, ot) | 0, w = w + Math.imul(Re, it) | 0, w = w + Math.imul(Pe, ot) | 0, U = U + Math.imul(Pe, it) | 0, $ = $ + Math.imul(ae, nt) | 0, w = w + Math.imul(ae, st) | 0, w = w + Math.imul(X, nt) | 0, U = U + Math.imul(X, st) | 0, $ = $ + Math.imul(z, ft) | 0, w = w + Math.imul(z, dt) | 0, w = w + Math.imul(se, ft) | 0, U = U + Math.imul(se, dt) | 0;
        var lr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, $ = Math.imul(H, Se), w = Math.imul(H, Ce), w = w + Math.imul(ue, Se) | 0, U = Math.imul(ue, Ce), $ = $ + Math.imul(Xe, _e) | 0, w = w + Math.imul(Xe, Me) | 0, w = w + Math.imul(oe, _e) | 0, U = U + Math.imul(oe, Me) | 0, $ = $ + Math.imul(ze, We) | 0, w = w + Math.imul(ze, ne) | 0, w = w + Math.imul(Ue, We) | 0, U = U + Math.imul(Ue, ne) | 0, $ = $ + Math.imul(Je, J) | 0, w = w + Math.imul(Je, me) | 0, w = w + Math.imul(we, J) | 0, U = U + Math.imul(we, me) | 0, $ = $ + Math.imul(rt, ke) | 0, w = w + Math.imul(rt, Ie) | 0, w = w + Math.imul(He, ke) | 0, U = U + Math.imul(He, Ie) | 0, $ = $ + Math.imul(De, ot) | 0, w = w + Math.imul(De, it) | 0, w = w + Math.imul(je, ot) | 0, U = U + Math.imul(je, it) | 0, $ = $ + Math.imul(Re, nt) | 0, w = w + Math.imul(Re, st) | 0, w = w + Math.imul(Pe, nt) | 0, U = U + Math.imul(Pe, st) | 0, $ = $ + Math.imul(ae, ft) | 0, w = w + Math.imul(ae, dt) | 0, w = w + Math.imul(X, ft) | 0, U = U + Math.imul(X, dt) | 0;
        var er = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, $ = Math.imul(H, _e), w = Math.imul(H, Me), w = w + Math.imul(ue, _e) | 0, U = Math.imul(ue, Me), $ = $ + Math.imul(Xe, We) | 0, w = w + Math.imul(Xe, ne) | 0, w = w + Math.imul(oe, We) | 0, U = U + Math.imul(oe, ne) | 0, $ = $ + Math.imul(ze, J) | 0, w = w + Math.imul(ze, me) | 0, w = w + Math.imul(Ue, J) | 0, U = U + Math.imul(Ue, me) | 0, $ = $ + Math.imul(Je, ke) | 0, w = w + Math.imul(Je, Ie) | 0, w = w + Math.imul(we, ke) | 0, U = U + Math.imul(we, Ie) | 0, $ = $ + Math.imul(rt, ot) | 0, w = w + Math.imul(rt, it) | 0, w = w + Math.imul(He, ot) | 0, U = U + Math.imul(He, it) | 0, $ = $ + Math.imul(De, nt) | 0, w = w + Math.imul(De, st) | 0, w = w + Math.imul(je, nt) | 0, U = U + Math.imul(je, st) | 0, $ = $ + Math.imul(Re, ft) | 0, w = w + Math.imul(Re, dt) | 0, w = w + Math.imul(Pe, ft) | 0, U = U + Math.imul(Pe, dt) | 0;
        var tr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, $ = Math.imul(H, We), w = Math.imul(H, ne), w = w + Math.imul(ue, We) | 0, U = Math.imul(ue, ne), $ = $ + Math.imul(Xe, J) | 0, w = w + Math.imul(Xe, me) | 0, w = w + Math.imul(oe, J) | 0, U = U + Math.imul(oe, me) | 0, $ = $ + Math.imul(ze, ke) | 0, w = w + Math.imul(ze, Ie) | 0, w = w + Math.imul(Ue, ke) | 0, U = U + Math.imul(Ue, Ie) | 0, $ = $ + Math.imul(Je, ot) | 0, w = w + Math.imul(Je, it) | 0, w = w + Math.imul(we, ot) | 0, U = U + Math.imul(we, it) | 0, $ = $ + Math.imul(rt, nt) | 0, w = w + Math.imul(rt, st) | 0, w = w + Math.imul(He, nt) | 0, U = U + Math.imul(He, st) | 0, $ = $ + Math.imul(De, ft) | 0, w = w + Math.imul(De, dt) | 0, w = w + Math.imul(je, ft) | 0, U = U + Math.imul(je, dt) | 0;
        var rr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, $ = Math.imul(H, J), w = Math.imul(H, me), w = w + Math.imul(ue, J) | 0, U = Math.imul(ue, me), $ = $ + Math.imul(Xe, ke) | 0, w = w + Math.imul(Xe, Ie) | 0, w = w + Math.imul(oe, ke) | 0, U = U + Math.imul(oe, Ie) | 0, $ = $ + Math.imul(ze, ot) | 0, w = w + Math.imul(ze, it) | 0, w = w + Math.imul(Ue, ot) | 0, U = U + Math.imul(Ue, it) | 0, $ = $ + Math.imul(Je, nt) | 0, w = w + Math.imul(Je, st) | 0, w = w + Math.imul(we, nt) | 0, U = U + Math.imul(we, st) | 0, $ = $ + Math.imul(rt, ft) | 0, w = w + Math.imul(rt, dt) | 0, w = w + Math.imul(He, ft) | 0, U = U + Math.imul(He, dt) | 0;
        var fr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, $ = Math.imul(H, ke), w = Math.imul(H, Ie), w = w + Math.imul(ue, ke) | 0, U = Math.imul(ue, Ie), $ = $ + Math.imul(Xe, ot) | 0, w = w + Math.imul(Xe, it) | 0, w = w + Math.imul(oe, ot) | 0, U = U + Math.imul(oe, it) | 0, $ = $ + Math.imul(ze, nt) | 0, w = w + Math.imul(ze, st) | 0, w = w + Math.imul(Ue, nt) | 0, U = U + Math.imul(Ue, st) | 0, $ = $ + Math.imul(Je, ft) | 0, w = w + Math.imul(Je, dt) | 0, w = w + Math.imul(we, ft) | 0, U = U + Math.imul(we, dt) | 0;
        var pr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, $ = Math.imul(H, ot), w = Math.imul(H, it), w = w + Math.imul(ue, ot) | 0, U = Math.imul(ue, it), $ = $ + Math.imul(Xe, nt) | 0, w = w + Math.imul(Xe, st) | 0, w = w + Math.imul(oe, nt) | 0, U = U + Math.imul(oe, st) | 0, $ = $ + Math.imul(ze, ft) | 0, w = w + Math.imul(ze, dt) | 0, w = w + Math.imul(Ue, ft) | 0, U = U + Math.imul(Ue, dt) | 0;
        var dr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, $ = Math.imul(H, nt), w = Math.imul(H, st), w = w + Math.imul(ue, nt) | 0, U = Math.imul(ue, st), $ = $ + Math.imul(Xe, ft) | 0, w = w + Math.imul(Xe, dt) | 0, w = w + Math.imul(oe, ft) | 0, U = U + Math.imul(oe, dt) | 0;
        var Lr = (C + $ | 0) + ((w & 8191) << 13) | 0;
        C = (U + (w >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, $ = Math.imul(H, ft), w = Math.imul(H, dt), w = w + Math.imul(ue, ft) | 0, U = Math.imul(ue, dt);
        var Ir = (C + $ | 0) + ((w & 8191) << 13) | 0;
        return C = (U + (w >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, I[0] = Ut, I[1] = Lt, I[2] = Dt, I[3] = Yt, I[4] = Kt, I[5] = Wt, I[6] = or, I[7] = Gt, I[8] = cr, I[9] = ur, I[10] = lr, I[11] = er, I[12] = tr, I[13] = rr, I[14] = fr, I[15] = pr, I[16] = dr, I[17] = Lr, I[18] = Ir, C !== 0 && (I[19] = C, B.length++), B;
      };
      Math.imul || (q = b);
      function O(M, h, S) {
        S.negative = h.negative ^ M.negative, S.length = M.length + h.length;
        for (var B = 0, T = 0, k = 0; k < S.length - 1; k++) {
          var I = T;
          T = 0;
          for (var C = B & 67108863, $ = Math.min(k, h.length - 1), w = Math.max(0, k - M.length + 1); w <= $; w++) {
            var U = k - w, ie = M.words[U] | 0, le = h.words[w] | 0, ee = ie * le, F = ee & 67108863;
            I = I + (ee / 67108864 | 0) | 0, F = F + C | 0, C = F & 67108863, I = I + (F >>> 26) | 0, T += I >>> 26, I &= 67108863;
          }
          S.words[k] = C, B = I, I = T;
        }
        return B !== 0 ? S.words[k] = B : S.length--, S._strip();
      }
      function j(M, h, S) {
        return O(M, h, S);
      }
      n.prototype.mulTo = function(h, S) {
        var B, T = this.length + h.length;
        return this.length === 10 && h.length === 10 ? B = q(this, h, S) : T < 63 ? B = b(this, h, S) : T < 1024 ? B = O(this, h, S) : B = j(this, h, S), B;
      }, n.prototype.mul = function(h) {
        var S = new n(null);
        return S.words = new Array(this.length + h.length), this.mulTo(h, S);
      }, n.prototype.mulf = function(h) {
        var S = new n(null);
        return S.words = new Array(this.length + h.length), j(this, h, S);
      }, n.prototype.imul = function(h) {
        return this.clone().mulTo(h, this);
      }, n.prototype.imuln = function(h) {
        var S = h < 0;
        S && (h = -h), a(typeof h == "number"), a(h < 67108864);
        for (var B = 0, T = 0; T < this.length; T++) {
          var k = (this.words[T] | 0) * h, I = (k & 67108863) + (B & 67108863);
          B >>= 26, B += k / 67108864 | 0, B += I >>> 26, this.words[T] = I & 67108863;
        }
        return B !== 0 && (this.words[T] = B, this.length++), this.length = h === 0 ? 1 : this.length, S ? this.ineg() : this;
      }, n.prototype.muln = function(h) {
        return this.clone().imuln(h);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(h) {
        var S = E(h);
        if (S.length === 0) return new n(1);
        for (var B = this, T = 0; T < S.length && S[T] === 0; T++, B = B.sqr())
          ;
        if (++T < S.length)
          for (var k = B.sqr(); T < S.length; T++, k = k.sqr())
            S[T] !== 0 && (B = B.mul(k));
        return B;
      }, n.prototype.iushln = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26, T = 67108863 >>> 26 - S << 26 - S, k;
        if (S !== 0) {
          var I = 0;
          for (k = 0; k < this.length; k++) {
            var C = this.words[k] & T, $ = (this.words[k] | 0) - C << S;
            this.words[k] = $ | I, I = C >>> 26 - S;
          }
          I && (this.words[k] = I, this.length++);
        }
        if (B !== 0) {
          for (k = this.length - 1; k >= 0; k--)
            this.words[k + B] = this.words[k];
          for (k = 0; k < B; k++)
            this.words[k] = 0;
          this.length += B;
        }
        return this._strip();
      }, n.prototype.ishln = function(h) {
        return a(this.negative === 0), this.iushln(h);
      }, n.prototype.iushrn = function(h, S, B) {
        a(typeof h == "number" && h >= 0);
        var T;
        S ? T = (S - S % 26) / 26 : T = 0;
        var k = h % 26, I = Math.min((h - k) / 26, this.length), C = 67108863 ^ 67108863 >>> k << k, $ = B;
        if (T -= I, T = Math.max(0, T), $) {
          for (var w = 0; w < I; w++)
            $.words[w] = this.words[w];
          $.length = I;
        }
        if (I !== 0) if (this.length > I)
          for (this.length -= I, w = 0; w < this.length; w++)
            this.words[w] = this.words[w + I];
        else
          this.words[0] = 0, this.length = 1;
        var U = 0;
        for (w = this.length - 1; w >= 0 && (U !== 0 || w >= T); w--) {
          var ie = this.words[w] | 0;
          this.words[w] = U << 26 - k | ie >>> k, U = ie & C;
        }
        return $ && U !== 0 && ($.words[$.length++] = U), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(h, S, B) {
        return a(this.negative === 0), this.iushrn(h, S, B);
      }, n.prototype.shln = function(h) {
        return this.clone().ishln(h);
      }, n.prototype.ushln = function(h) {
        return this.clone().iushln(h);
      }, n.prototype.shrn = function(h) {
        return this.clone().ishrn(h);
      }, n.prototype.ushrn = function(h) {
        return this.clone().iushrn(h);
      }, n.prototype.testn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26, T = 1 << S;
        if (this.length <= B) return !1;
        var k = this.words[B];
        return !!(k & T);
      }, n.prototype.imaskn = function(h) {
        a(typeof h == "number" && h >= 0);
        var S = h % 26, B = (h - S) / 26;
        if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= B)
          return this;
        if (S !== 0 && B++, this.length = Math.min(B, this.length), S !== 0) {
          var T = 67108863 ^ 67108863 >>> S << S;
          this.words[this.length - 1] &= T;
        }
        return this._strip();
      }, n.prototype.maskn = function(h) {
        return this.clone().imaskn(h);
      }, n.prototype.iaddn = function(h) {
        return a(typeof h == "number"), a(h < 67108864), h < 0 ? this.isubn(-h) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= h ? (this.words[0] = h - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(h), this.negative = 1, this) : this._iaddn(h);
      }, n.prototype._iaddn = function(h) {
        this.words[0] += h;
        for (var S = 0; S < this.length && this.words[S] >= 67108864; S++)
          this.words[S] -= 67108864, S === this.length - 1 ? this.words[S + 1] = 1 : this.words[S + 1]++;
        return this.length = Math.max(this.length, S + 1), this;
      }, n.prototype.isubn = function(h) {
        if (a(typeof h == "number"), a(h < 67108864), h < 0) return this.iaddn(-h);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(h), this.negative = 1, this;
        if (this.words[0] -= h, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var S = 0; S < this.length && this.words[S] < 0; S++)
            this.words[S] += 67108864, this.words[S + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(h) {
        return this.clone().iaddn(h);
      }, n.prototype.subn = function(h) {
        return this.clone().isubn(h);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(h, S, B) {
        var T = h.length + B, k;
        this._expand(T);
        var I, C = 0;
        for (k = 0; k < h.length; k++) {
          I = (this.words[k + B] | 0) + C;
          var $ = (h.words[k] | 0) * S;
          I -= $ & 67108863, C = (I >> 26) - ($ / 67108864 | 0), this.words[k + B] = I & 67108863;
        }
        for (; k < this.length - B; k++)
          I = (this.words[k + B] | 0) + C, C = I >> 26, this.words[k + B] = I & 67108863;
        if (C === 0) return this._strip();
        for (a(C === -1), C = 0, k = 0; k < this.length; k++)
          I = -(this.words[k] | 0) + C, C = I >> 26, this.words[k] = I & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(h, S) {
        var B = this.length - h.length, T = this.clone(), k = h, I = k.words[k.length - 1] | 0, C = this._countBits(I);
        B = 26 - C, B !== 0 && (k = k.ushln(B), T.iushln(B), I = k.words[k.length - 1] | 0);
        var $ = T.length - k.length, w;
        if (S !== "mod") {
          w = new n(null), w.length = $ + 1, w.words = new Array(w.length);
          for (var U = 0; U < w.length; U++)
            w.words[U] = 0;
        }
        var ie = T.clone()._ishlnsubmul(k, 1, $);
        ie.negative === 0 && (T = ie, w && (w.words[$] = 1));
        for (var le = $ - 1; le >= 0; le--) {
          var ee = (T.words[k.length + le] | 0) * 67108864 + (T.words[k.length + le - 1] | 0);
          for (ee = Math.min(ee / I | 0, 67108863), T._ishlnsubmul(k, ee, le); T.negative !== 0; )
            ee--, T.negative = 0, T._ishlnsubmul(k, 1, le), T.isZero() || (T.negative ^= 1);
          w && (w.words[le] = ee);
        }
        return w && w._strip(), T._strip(), S !== "div" && B !== 0 && T.iushrn(B), {
          div: w || null,
          mod: T
        };
      }, n.prototype.divmod = function(h, S, B) {
        if (a(!h.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var T, k, I;
        return this.negative !== 0 && h.negative === 0 ? (I = this.neg().divmod(h, S), S !== "mod" && (T = I.div.neg()), S !== "div" && (k = I.mod.neg(), B && k.negative !== 0 && k.iadd(h)), {
          div: T,
          mod: k
        }) : this.negative === 0 && h.negative !== 0 ? (I = this.divmod(h.neg(), S), S !== "mod" && (T = I.div.neg()), {
          div: T,
          mod: I.mod
        }) : (this.negative & h.negative) !== 0 ? (I = this.neg().divmod(h.neg(), S), S !== "div" && (k = I.mod.neg(), B && k.negative !== 0 && k.isub(h)), {
          div: I.div,
          mod: k
        }) : h.length > this.length || this.cmp(h) < 0 ? {
          div: new n(0),
          mod: this
        } : h.length === 1 ? S === "div" ? {
          div: this.divn(h.words[0]),
          mod: null
        } : S === "mod" ? {
          div: null,
          mod: new n(this.modrn(h.words[0]))
        } : {
          div: this.divn(h.words[0]),
          mod: new n(this.modrn(h.words[0]))
        } : this._wordDiv(h, S);
      }, n.prototype.div = function(h) {
        return this.divmod(h, "div", !1).div;
      }, n.prototype.mod = function(h) {
        return this.divmod(h, "mod", !1).mod;
      }, n.prototype.umod = function(h) {
        return this.divmod(h, "mod", !0).mod;
      }, n.prototype.divRound = function(h) {
        var S = this.divmod(h);
        if (S.mod.isZero()) return S.div;
        var B = S.div.negative !== 0 ? S.mod.isub(h) : S.mod, T = h.ushrn(1), k = h.andln(1), I = B.cmp(T);
        return I < 0 || k === 1 && I === 0 ? S.div : S.div.negative !== 0 ? S.div.isubn(1) : S.div.iaddn(1);
      }, n.prototype.modrn = function(h) {
        var S = h < 0;
        S && (h = -h), a(h <= 67108863);
        for (var B = (1 << 26) % h, T = 0, k = this.length - 1; k >= 0; k--)
          T = (B * T + (this.words[k] | 0)) % h;
        return S ? -T : T;
      }, n.prototype.modn = function(h) {
        return this.modrn(h);
      }, n.prototype.idivn = function(h) {
        var S = h < 0;
        S && (h = -h), a(h <= 67108863);
        for (var B = 0, T = this.length - 1; T >= 0; T--) {
          var k = (this.words[T] | 0) + B * 67108864;
          this.words[T] = k / h | 0, B = k % h;
        }
        return this._strip(), S ? this.ineg() : this;
      }, n.prototype.divn = function(h) {
        return this.clone().idivn(h);
      }, n.prototype.egcd = function(h) {
        a(h.negative === 0), a(!h.isZero());
        var S = this, B = h.clone();
        S.negative !== 0 ? S = S.umod(h) : S = S.clone();
        for (var T = new n(1), k = new n(0), I = new n(0), C = new n(1), $ = 0; S.isEven() && B.isEven(); )
          S.iushrn(1), B.iushrn(1), ++$;
        for (var w = B.clone(), U = S.clone(); !S.isZero(); ) {
          for (var ie = 0, le = 1; (S.words[0] & le) === 0 && ie < 26; ++ie, le <<= 1) ;
          if (ie > 0)
            for (S.iushrn(ie); ie-- > 0; )
              (T.isOdd() || k.isOdd()) && (T.iadd(w), k.isub(U)), T.iushrn(1), k.iushrn(1);
          for (var ee = 0, F = 1; (B.words[0] & F) === 0 && ee < 26; ++ee, F <<= 1) ;
          if (ee > 0)
            for (B.iushrn(ee); ee-- > 0; )
              (I.isOdd() || C.isOdd()) && (I.iadd(w), C.isub(U)), I.iushrn(1), C.iushrn(1);
          S.cmp(B) >= 0 ? (S.isub(B), T.isub(I), k.isub(C)) : (B.isub(S), I.isub(T), C.isub(k));
        }
        return {
          a: I,
          b: C,
          gcd: B.iushln($)
        };
      }, n.prototype._invmp = function(h) {
        a(h.negative === 0), a(!h.isZero());
        var S = this, B = h.clone();
        S.negative !== 0 ? S = S.umod(h) : S = S.clone();
        for (var T = new n(1), k = new n(0), I = B.clone(); S.cmpn(1) > 0 && B.cmpn(1) > 0; ) {
          for (var C = 0, $ = 1; (S.words[0] & $) === 0 && C < 26; ++C, $ <<= 1) ;
          if (C > 0)
            for (S.iushrn(C); C-- > 0; )
              T.isOdd() && T.iadd(I), T.iushrn(1);
          for (var w = 0, U = 1; (B.words[0] & U) === 0 && w < 26; ++w, U <<= 1) ;
          if (w > 0)
            for (B.iushrn(w); w-- > 0; )
              k.isOdd() && k.iadd(I), k.iushrn(1);
          S.cmp(B) >= 0 ? (S.isub(B), T.isub(k)) : (B.isub(S), k.isub(T));
        }
        var ie;
        return S.cmpn(1) === 0 ? ie = T : ie = k, ie.cmpn(0) < 0 && ie.iadd(h), ie;
      }, n.prototype.gcd = function(h) {
        if (this.isZero()) return h.abs();
        if (h.isZero()) return this.abs();
        var S = this.clone(), B = h.clone();
        S.negative = 0, B.negative = 0;
        for (var T = 0; S.isEven() && B.isEven(); T++)
          S.iushrn(1), B.iushrn(1);
        do {
          for (; S.isEven(); )
            S.iushrn(1);
          for (; B.isEven(); )
            B.iushrn(1);
          var k = S.cmp(B);
          if (k < 0) {
            var I = S;
            S = B, B = I;
          } else if (k === 0 || B.cmpn(1) === 0)
            break;
          S.isub(B);
        } while (!0);
        return B.iushln(T);
      }, n.prototype.invm = function(h) {
        return this.egcd(h).a.umod(h);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(h) {
        return this.words[0] & h;
      }, n.prototype.bincn = function(h) {
        a(typeof h == "number");
        var S = h % 26, B = (h - S) / 26, T = 1 << S;
        if (this.length <= B)
          return this._expand(B + 1), this.words[B] |= T, this;
        for (var k = T, I = B; k !== 0 && I < this.length; I++) {
          var C = this.words[I] | 0;
          C += k, k = C >>> 26, C &= 67108863, this.words[I] = C;
        }
        return k !== 0 && (this.words[I] = k, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(h) {
        var S = h < 0;
        if (this.negative !== 0 && !S) return -1;
        if (this.negative === 0 && S) return 1;
        this._strip();
        var B;
        if (this.length > 1)
          B = 1;
        else {
          S && (h = -h), a(h <= 67108863, "Number is too big");
          var T = this.words[0] | 0;
          B = T === h ? 0 : T < h ? -1 : 1;
        }
        return this.negative !== 0 ? -B | 0 : B;
      }, n.prototype.cmp = function(h) {
        if (this.negative !== 0 && h.negative === 0) return -1;
        if (this.negative === 0 && h.negative !== 0) return 1;
        var S = this.ucmp(h);
        return this.negative !== 0 ? -S | 0 : S;
      }, n.prototype.ucmp = function(h) {
        if (this.length > h.length) return 1;
        if (this.length < h.length) return -1;
        for (var S = 0, B = this.length - 1; B >= 0; B--) {
          var T = this.words[B] | 0, k = h.words[B] | 0;
          if (T !== k) {
            T < k ? S = -1 : T > k && (S = 1);
            break;
          }
        }
        return S;
      }, n.prototype.gtn = function(h) {
        return this.cmpn(h) === 1;
      }, n.prototype.gt = function(h) {
        return this.cmp(h) === 1;
      }, n.prototype.gten = function(h) {
        return this.cmpn(h) >= 0;
      }, n.prototype.gte = function(h) {
        return this.cmp(h) >= 0;
      }, n.prototype.ltn = function(h) {
        return this.cmpn(h) === -1;
      }, n.prototype.lt = function(h) {
        return this.cmp(h) === -1;
      }, n.prototype.lten = function(h) {
        return this.cmpn(h) <= 0;
      }, n.prototype.lte = function(h) {
        return this.cmp(h) <= 0;
      }, n.prototype.eqn = function(h) {
        return this.cmpn(h) === 0;
      }, n.prototype.eq = function(h) {
        return this.cmp(h) === 0;
      }, n.red = function(h) {
        return new te(h);
      }, n.prototype.toRed = function(h) {
        return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), h.convertTo(this)._forceRed(h);
      }, n.prototype.fromRed = function() {
        return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(h) {
        return this.red = h, this;
      }, n.prototype.forceRed = function(h) {
        return a(!this.red, "Already a number in reduction context"), this._forceRed(h);
      }, n.prototype.redAdd = function(h) {
        return a(this.red, "redAdd works only with red numbers"), this.red.add(this, h);
      }, n.prototype.redIAdd = function(h) {
        return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, h);
      }, n.prototype.redSub = function(h) {
        return a(this.red, "redSub works only with red numbers"), this.red.sub(this, h);
      }, n.prototype.redISub = function(h) {
        return a(this.red, "redISub works only with red numbers"), this.red.isub(this, h);
      }, n.prototype.redShl = function(h) {
        return a(this.red, "redShl works only with red numbers"), this.red.shl(this, h);
      }, n.prototype.redMul = function(h) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.mul(this, h);
      }, n.prototype.redIMul = function(h) {
        return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.imul(this, h);
      }, n.prototype.redSqr = function() {
        return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(h) {
        return a(this.red && !h.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, h);
      };
      var D = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function G(M, h) {
        this.name = M, this.p = new n(h, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      G.prototype._tmp = function() {
        var h = new n(null);
        return h.words = new Array(Math.ceil(this.n / 13)), h;
      }, G.prototype.ireduce = function(h) {
        var S = h, B;
        do
          this.split(S, this.tmp), S = this.imulK(S), S = S.iadd(this.tmp), B = S.bitLength();
        while (B > this.n);
        var T = B < this.n ? -1 : S.ucmp(this.p);
        return T === 0 ? (S.words[0] = 0, S.length = 1) : T > 0 ? S.isub(this.p) : S.strip !== void 0 ? S.strip() : S._strip(), S;
      }, G.prototype.split = function(h, S) {
        h.iushrn(this.n, 0, S);
      }, G.prototype.imulK = function(h) {
        return h.imul(this.k);
      };
      function V() {
        G.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      u(V, G), V.prototype.split = function(h, S) {
        for (var B = 4194303, T = Math.min(h.length, 9), k = 0; k < T; k++)
          S.words[k] = h.words[k];
        if (S.length = T, h.length <= 9) {
          h.words[0] = 0, h.length = 1;
          return;
        }
        var I = h.words[9];
        for (S.words[S.length++] = I & B, k = 10; k < h.length; k++) {
          var C = h.words[k] | 0;
          h.words[k - 10] = (C & B) << 4 | I >>> 22, I = C;
        }
        I >>>= 22, h.words[k - 10] = I, I === 0 && h.length > 10 ? h.length -= 10 : h.length -= 9;
      }, V.prototype.imulK = function(h) {
        h.words[h.length] = 0, h.words[h.length + 1] = 0, h.length += 2;
        for (var S = 0, B = 0; B < h.length; B++) {
          var T = h.words[B] | 0;
          S += T * 977, h.words[B] = S & 67108863, S = T * 64 + (S / 67108864 | 0);
        }
        return h.words[h.length - 1] === 0 && (h.length--, h.words[h.length - 1] === 0 && h.length--), h;
      };
      function Q() {
        G.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      u(Q, G);
      function re() {
        G.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      u(re, G);
      function ve() {
        G.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      u(ve, G), ve.prototype.imulK = function(h) {
        for (var S = 0, B = 0; B < h.length; B++) {
          var T = (h.words[B] | 0) * 19 + S, k = T & 67108863;
          T >>>= 26, h.words[B] = k, S = T;
        }
        return S !== 0 && (h.words[h.length++] = S), h;
      }, n._prime = function(h) {
        if (D[h]) return D[h];
        var S;
        if (h === "k256")
          S = new V();
        else if (h === "p224")
          S = new Q();
        else if (h === "p192")
          S = new re();
        else if (h === "p25519")
          S = new ve();
        else
          throw new Error("Unknown prime " + h);
        return D[h] = S, S;
      };
      function te(M) {
        if (typeof M == "string") {
          var h = n._prime(M);
          this.m = h.p, this.prime = h;
        } else
          a(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      te.prototype._verify1 = function(h) {
        a(h.negative === 0, "red works only with positives"), a(h.red, "red works only with red numbers");
      }, te.prototype._verify2 = function(h, S) {
        a((h.negative | S.negative) === 0, "red works only with positives"), a(
          h.red && h.red === S.red,
          "red works only with red numbers"
        );
      }, te.prototype.imod = function(h) {
        return this.prime ? this.prime.ireduce(h)._forceRed(this) : (s(h, h.umod(this.m)._forceRed(this)), h);
      }, te.prototype.neg = function(h) {
        return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
      }, te.prototype.add = function(h, S) {
        this._verify2(h, S);
        var B = h.add(S);
        return B.cmp(this.m) >= 0 && B.isub(this.m), B._forceRed(this);
      }, te.prototype.iadd = function(h, S) {
        this._verify2(h, S);
        var B = h.iadd(S);
        return B.cmp(this.m) >= 0 && B.isub(this.m), B;
      }, te.prototype.sub = function(h, S) {
        this._verify2(h, S);
        var B = h.sub(S);
        return B.cmpn(0) < 0 && B.iadd(this.m), B._forceRed(this);
      }, te.prototype.isub = function(h, S) {
        this._verify2(h, S);
        var B = h.isub(S);
        return B.cmpn(0) < 0 && B.iadd(this.m), B;
      }, te.prototype.shl = function(h, S) {
        return this._verify1(h), this.imod(h.ushln(S));
      }, te.prototype.imul = function(h, S) {
        return this._verify2(h, S), this.imod(h.imul(S));
      }, te.prototype.mul = function(h, S) {
        return this._verify2(h, S), this.imod(h.mul(S));
      }, te.prototype.isqr = function(h) {
        return this.imul(h, h.clone());
      }, te.prototype.sqr = function(h) {
        return this.mul(h, h);
      }, te.prototype.sqrt = function(h) {
        if (h.isZero()) return h.clone();
        var S = this.m.andln(3);
        if (a(S % 2 === 1), S === 3) {
          var B = this.m.add(new n(1)).iushrn(2);
          return this.pow(h, B);
        }
        for (var T = this.m.subn(1), k = 0; !T.isZero() && T.andln(1) === 0; )
          k++, T.iushrn(1);
        a(!T.isZero());
        var I = new n(1).toRed(this), C = I.redNeg(), $ = this.m.subn(1).iushrn(1), w = this.m.bitLength();
        for (w = new n(2 * w * w).toRed(this); this.pow(w, $).cmp(C) !== 0; )
          w.redIAdd(C);
        for (var U = this.pow(w, T), ie = this.pow(h, T.addn(1).iushrn(1)), le = this.pow(h, T), ee = k; le.cmp(I) !== 0; ) {
          for (var F = le, z = 0; F.cmp(I) !== 0; z++)
            F = F.redSqr();
          a(z < ee);
          var se = this.pow(U, new n(1).iushln(ee - z - 1));
          ie = ie.redMul(se), U = se.redSqr(), le = le.redMul(U), ee = z;
        }
        return ie;
      }, te.prototype.invm = function(h) {
        var S = h._invmp(this.m);
        return S.negative !== 0 ? (S.negative = 0, this.imod(S).redNeg()) : this.imod(S);
      }, te.prototype.pow = function(h, S) {
        if (S.isZero()) return new n(1).toRed(this);
        if (S.cmpn(1) === 0) return h.clone();
        var B = 4, T = new Array(1 << B);
        T[0] = new n(1).toRed(this), T[1] = h;
        for (var k = 2; k < T.length; k++)
          T[k] = this.mul(T[k - 1], h);
        var I = T[0], C = 0, $ = 0, w = S.bitLength() % 26;
        for (w === 0 && (w = 26), k = S.length - 1; k >= 0; k--) {
          for (var U = S.words[k], ie = w - 1; ie >= 0; ie--) {
            var le = U >> ie & 1;
            if (I !== T[0] && (I = this.sqr(I)), le === 0 && C === 0) {
              $ = 0;
              continue;
            }
            C <<= 1, C |= le, $++, !($ !== B && (k !== 0 || ie !== 0)) && (I = this.mul(I, T[C]), $ = 0, C = 0);
          }
          w = 26;
        }
        return I;
      }, te.prototype.convertTo = function(h) {
        var S = h.umod(this.m);
        return S === h ? S.clone() : S;
      }, te.prototype.convertFrom = function(h) {
        var S = h.clone();
        return S.red = null, S;
      }, n.mont = function(h) {
        return new R(h);
      };
      function R(M) {
        te.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      u(R, te), R.prototype.convertTo = function(h) {
        return this.imod(h.ushln(this.shift));
      }, R.prototype.convertFrom = function(h) {
        var S = this.imod(h.mul(this.rinv));
        return S.red = null, S;
      }, R.prototype.imul = function(h, S) {
        if (h.isZero() || S.isZero())
          return h.words[0] = 0, h.length = 1, h;
        var B = h.imul(S), T = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = B.isub(T).iushrn(this.shift), I = k;
        return k.cmp(this.m) >= 0 ? I = k.isub(this.m) : k.cmpn(0) < 0 && (I = k.iadd(this.m)), I._forceRed(this);
      }, R.prototype.mul = function(h, S) {
        if (h.isZero() || S.isZero()) return new n(0)._forceRed(this);
        var B = h.mul(S), T = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), k = B.isub(T).iushrn(this.shift), I = k;
        return k.cmp(this.m) >= 0 ? I = k.isub(this.m) : k.cmpn(0) < 0 && (I = k.iadd(this.m)), I._forceRed(this);
      }, R.prototype.invm = function(h) {
        var S = this.imod(h._invmp(this.m).mul(this.r2));
        return S._forceRed(this);
      };
    })(e, bn);
  })(bn$1)), bn$1.exports;
}
var asn1$1 = {}, asn1 = {}, api$1 = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, (function(exports) {
    var indexOf = function(e, t) {
      if (e.indexOf) return e.indexOf(t);
      for (var r = 0; r < e.length; r++)
        if (e[r] === t) return r;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys) return Object.keys(e);
      var t = [];
      for (var r in e) t.push(r);
      return t;
    }, forEach = function(e, t) {
      if (e.forEach) return e.forEach(t);
      for (var r = 0; r < e.length; r++)
        t(e[r], r, e);
    }, defineProp = (function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, t, r) {
          Object.defineProperty(e, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: r
          });
        };
      } catch {
        return function(t, r, a) {
          t[r] = a;
        };
      }
    })(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(t) {
      if (!(this instanceof Script)) return new Script(t);
      this.code = t;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var r = t.contentWindow, a = r.eval, u = r.execScript;
      !a && u && (u.call(r, "null"), a = r.eval), forEach(Object_keys(e), function(c) {
        r[c] = e[c];
      }), forEach(globals, function(c) {
        e[c] && (r[c] = e[c]);
      });
      var n = Object_keys(r), o = a.call(r, this.code);
      return forEach(Object_keys(r), function(c) {
        (c in e || indexOf(n, c) === -1) && (e[c] = r[c]);
      }), forEach(globals, function(c) {
        c in e || defineProp(e, c, r[c]);
      }), document.body.removeChild(t), o;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var t = Script.createContext(e), r = this.runInContext(t);
      return e && forEach(Object_keys(t), function(a) {
        e[a] = t[a];
      }), r;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(t) {
        var r = Script(t);
        return r[e].apply(r, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var t = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(r) {
        t[r] = e[r];
      }), t;
    };
  })(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, (function(e) {
    var t = requireAsn1$1(), r = requireInherits_browser(), a = e;
    a.define = function(o, c) {
      return new u(o, c);
    };
    function u(n, o) {
      this.name = n, this.body = o, this.decoders = {}, this.encoders = {};
    }
    u.prototype._createNamed = function(o) {
      var c;
      try {
        c = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        c = function(l) {
          this._initNamed(l);
        };
      }
      return r(c, o), c.prototype._initNamed = function(l) {
        o.call(this, l);
      }, new c(this);
    }, u.prototype._getDecoder = function(o) {
      return o = o || "der", this.decoders.hasOwnProperty(o) || (this.decoders[o] = this._createNamed(t.decoders[o])), this.decoders[o];
    }, u.prototype.decode = function(o, c, f) {
      return this._getDecoder(c).decode(o, f);
    }, u.prototype._getEncoder = function(o) {
      return o = o || "der", this.encoders.hasOwnProperty(o) || (this.encoders[o] = this._createNamed(t.encoders[o])), this.encoders[o];
    }, u.prototype.encode = function(o, c, f) {
      return this._getEncoder(c).encode(o, f);
    };
  })(api$1)), api$1;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var e = requireInherits_browser();
  function t(a) {
    this._reporterState = {
      obj: null,
      path: [],
      options: a || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(u) {
    return u instanceof r;
  }, t.prototype.save = function() {
    var u = this._reporterState;
    return { obj: u.obj, pathLen: u.path.length };
  }, t.prototype.restore = function(u) {
    var n = this._reporterState;
    n.obj = u.obj, n.path = n.path.slice(0, u.pathLen);
  }, t.prototype.enterKey = function(u) {
    return this._reporterState.path.push(u);
  }, t.prototype.exitKey = function(u) {
    var n = this._reporterState;
    n.path = n.path.slice(0, u - 1);
  }, t.prototype.leaveKey = function(u, n, o) {
    var c = this._reporterState;
    this.exitKey(u), c.obj !== null && (c.obj[n] = o);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var u = this._reporterState, n = u.obj;
    return u.obj = {}, n;
  }, t.prototype.leaveObject = function(u) {
    var n = this._reporterState, o = n.obj;
    return n.obj = u, o;
  }, t.prototype.error = function(u) {
    var n, o = this._reporterState, c = u instanceof r;
    if (c ? n = u : n = new r(o.path.map(function(f) {
      return "[" + JSON.stringify(f) + "]";
    }).join(""), u.message || u, u.stack), !o.options.partial)
      throw n;
    return c || o.errors.push(n), n;
  }, t.prototype.wrapResult = function(u) {
    var n = this._reporterState;
    return n.options.partial ? {
      result: this.isError(u) ? null : u,
      errors: n.errors
    } : u;
  };
  function r(a, u) {
    this.path = a, this.rethrow(u);
  }
  return e(r, Error), r.prototype.rethrow = function(u) {
    if (this.message = u + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, r), !this.stack)
      try {
        throw new Error(this.message);
      } catch (n) {
        this.stack = n.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var e = requireInherits_browser(), t = requireBase().Reporter, r = requireDist$1().Buffer;
  function a(n, o) {
    if (t.call(this, o), !r.isBuffer(n)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = n, this.offset = 0, this.length = n.length;
  }
  e(a, t), buffer.DecoderBuffer = a, a.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, a.prototype.restore = function(o) {
    var c = new a(this.base);
    return c.offset = o.offset, c.length = this.offset, this.offset = o.offset, t.prototype.restore.call(this, o.reporter), c;
  }, a.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, a.prototype.readUInt8 = function(o) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
  }, a.prototype.skip = function(o, c) {
    if (!(this.offset + o <= this.length))
      return this.error(c || "DecoderBuffer overrun");
    var f = new a(this.base);
    return f._reporterState = this._reporterState, f.offset = this.offset, f.length = this.offset + o, this.offset += o, f;
  }, a.prototype.raw = function(o) {
    return this.base.slice(o ? o.offset : this.offset, this.length);
  };
  function u(n, o) {
    if (Array.isArray(n))
      this.length = 0, this.value = n.map(function(c) {
        return c instanceof u || (c = new u(c, o)), this.length += c.length, c;
      }, this);
    else if (typeof n == "number") {
      if (!(0 <= n && n <= 255))
        return o.error("non-byte EncoderBuffer value");
      this.value = n, this.length = 1;
    } else if (typeof n == "string")
      this.value = n, this.length = r.byteLength(n);
    else if (r.isBuffer(n))
      this.value = n, this.length = n.length;
    else
      return o.error("Unsupported type: " + typeof n);
  }
  return buffer.EncoderBuffer = u, u.prototype.join = function(o, c) {
    return o || (o = new r(this.length)), c || (c = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(f) {
      f.join(o, c), c += f.length;
    }) : (typeof this.value == "number" ? o[c] = this.value : typeof this.value == "string" ? o.write(this.value, c) : r.isBuffer(this.value) && this.value.copy(o, c), c += this.length)), o;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, t = requireBase().EncoderBuffer, r = requireBase().DecoderBuffer, a = requireMinimalisticAssert(), u = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], n = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(u), o = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function c(l, s) {
    var p = {};
    this._baseState = p, p.enc = l, p.parent = s || null, p.children = null, p.tag = null, p.args = null, p.reverseArgs = null, p.choice = null, p.optional = !1, p.any = !1, p.obj = !1, p.use = null, p.useDecoder = null, p.key = null, p.default = null, p.explicit = null, p.implicit = null, p.contains = null, p.parent || (p.children = [], this._wrap());
  }
  node = c;
  var f = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return c.prototype.clone = function() {
    var s = this._baseState, p = {};
    f.forEach(function(g) {
      p[g] = s[g];
    });
    var m = new this.constructor(p.parent);
    return m._baseState = p, m;
  }, c.prototype._wrap = function() {
    var s = this._baseState;
    n.forEach(function(p) {
      this[p] = function() {
        var g = new this.constructor(this);
        return s.children.push(g), g[p].apply(g, arguments);
      };
    }, this);
  }, c.prototype._init = function(s) {
    var p = this._baseState;
    a(p.parent === null), s.call(this), p.children = p.children.filter(function(m) {
      return m._baseState.parent === this;
    }, this), a.equal(p.children.length, 1, "Root node can have only one child");
  }, c.prototype._useArgs = function(s) {
    var p = this._baseState, m = s.filter(function(g) {
      return g instanceof this.constructor;
    }, this);
    s = s.filter(function(g) {
      return !(g instanceof this.constructor);
    }, this), m.length !== 0 && (a(p.children === null), p.children = m, m.forEach(function(g) {
      g._baseState.parent = this;
    }, this)), s.length !== 0 && (a(p.args === null), p.args = s, p.reverseArgs = s.map(function(g) {
      if (typeof g != "object" || g.constructor !== Object)
        return g;
      var y = {};
      return Object.keys(g).forEach(function(v) {
        v == (v | 0) && (v |= 0);
        var E = g[v];
        y[E] = v;
      }), y;
    }));
  }, o.forEach(function(l) {
    c.prototype[l] = function() {
      var p = this._baseState;
      throw new Error(l + " not implemented for encoding: " + p.enc);
    };
  }), u.forEach(function(l) {
    c.prototype[l] = function() {
      var p = this._baseState, m = Array.prototype.slice.call(arguments);
      return a(p.tag === null), p.tag = l, this._useArgs(m), this;
    };
  }), c.prototype.use = function(s) {
    a(s);
    var p = this._baseState;
    return a(p.use === null), p.use = s, this;
  }, c.prototype.optional = function() {
    var s = this._baseState;
    return s.optional = !0, this;
  }, c.prototype.def = function(s) {
    var p = this._baseState;
    return a(p.default === null), p.default = s, p.optional = !0, this;
  }, c.prototype.explicit = function(s) {
    var p = this._baseState;
    return a(p.explicit === null && p.implicit === null), p.explicit = s, this;
  }, c.prototype.implicit = function(s) {
    var p = this._baseState;
    return a(p.explicit === null && p.implicit === null), p.implicit = s, this;
  }, c.prototype.obj = function() {
    var s = this._baseState, p = Array.prototype.slice.call(arguments);
    return s.obj = !0, p.length !== 0 && this._useArgs(p), this;
  }, c.prototype.key = function(s) {
    var p = this._baseState;
    return a(p.key === null), p.key = s, this;
  }, c.prototype.any = function() {
    var s = this._baseState;
    return s.any = !0, this;
  }, c.prototype.choice = function(s) {
    var p = this._baseState;
    return a(p.choice === null), p.choice = s, this._useArgs(Object.keys(s).map(function(m) {
      return s[m];
    })), this;
  }, c.prototype.contains = function(s) {
    var p = this._baseState;
    return a(p.use === null), p.contains = s, this;
  }, c.prototype._decode = function(s, p) {
    var m = this._baseState;
    if (m.parent === null)
      return s.wrapResult(m.children[0]._decode(s, p));
    var g = m.default, y = !0, v = null;
    if (m.key !== null && (v = s.enterKey(m.key)), m.optional) {
      var E = null;
      if (m.explicit !== null ? E = m.explicit : m.implicit !== null ? E = m.implicit : m.tag !== null && (E = m.tag), E === null && !m.any) {
        var b = s.save();
        try {
          m.choice === null ? this._decodeGeneric(m.tag, s, p) : this._decodeChoice(s, p), y = !0;
        } catch {
          y = !1;
        }
        s.restore(b);
      } else if (y = this._peekTag(s, E, m.any), s.isError(y))
        return y;
    }
    var q;
    if (m.obj && y && (q = s.enterObject()), y) {
      if (m.explicit !== null) {
        var O = this._decodeTag(s, m.explicit);
        if (s.isError(O))
          return O;
        s = O;
      }
      var j = s.offset;
      if (m.use === null && m.choice === null) {
        if (m.any)
          var b = s.save();
        var D = this._decodeTag(
          s,
          m.implicit !== null ? m.implicit : m.tag,
          m.any
        );
        if (s.isError(D))
          return D;
        m.any ? g = s.raw(b) : s = D;
      }
      if (p && p.track && m.tag !== null && p.track(s.path(), j, s.length, "tagged"), p && p.track && m.tag !== null && p.track(s.path(), s.offset, s.length, "content"), m.any ? g = g : m.choice === null ? g = this._decodeGeneric(m.tag, s, p) : g = this._decodeChoice(s, p), s.isError(g))
        return g;
      if (!m.any && m.choice === null && m.children !== null && m.children.forEach(function(Q) {
        Q._decode(s, p);
      }), m.contains && (m.tag === "octstr" || m.tag === "bitstr")) {
        var G = new r(g);
        g = this._getUse(m.contains, s._reporterState.obj)._decode(G, p);
      }
    }
    return m.obj && y && (g = s.leaveObject(q)), m.key !== null && (g !== null || y === !0) ? s.leaveKey(v, m.key, g) : v !== null && s.exitKey(v), g;
  }, c.prototype._decodeGeneric = function(s, p, m) {
    var g = this._baseState;
    return s === "seq" || s === "set" ? null : s === "seqof" || s === "setof" ? this._decodeList(p, s, g.args[0], m) : /str$/.test(s) ? this._decodeStr(p, s, m) : s === "objid" && g.args ? this._decodeObjid(p, g.args[0], g.args[1], m) : s === "objid" ? this._decodeObjid(p, null, null, m) : s === "gentime" || s === "utctime" ? this._decodeTime(p, s, m) : s === "null_" ? this._decodeNull(p, m) : s === "bool" ? this._decodeBool(p, m) : s === "objDesc" ? this._decodeStr(p, s, m) : s === "int" || s === "enum" ? this._decodeInt(p, g.args && g.args[0], m) : g.use !== null ? this._getUse(g.use, p._reporterState.obj)._decode(p, m) : p.error("unknown tag: " + s);
  }, c.prototype._getUse = function(s, p) {
    var m = this._baseState;
    return m.useDecoder = this._use(s, p), a(m.useDecoder._baseState.parent === null), m.useDecoder = m.useDecoder._baseState.children[0], m.implicit !== m.useDecoder._baseState.implicit && (m.useDecoder = m.useDecoder.clone(), m.useDecoder._baseState.implicit = m.implicit), m.useDecoder;
  }, c.prototype._decodeChoice = function(s, p) {
    var m = this._baseState, g = null, y = !1;
    return Object.keys(m.choice).some(function(v) {
      var E = s.save(), b = m.choice[v];
      try {
        var q = b._decode(s, p);
        if (s.isError(q))
          return !1;
        g = { type: v, value: q }, y = !0;
      } catch {
        return s.restore(E), !1;
      }
      return !0;
    }, this), y ? g : s.error("Choice not matched");
  }, c.prototype._createEncoderBuffer = function(s) {
    return new t(s, this.reporter);
  }, c.prototype._encode = function(s, p, m) {
    var g = this._baseState;
    if (!(g.default !== null && g.default === s)) {
      var y = this._encodeValue(s, p, m);
      if (y !== void 0 && !this._skipDefault(y, p, m))
        return y;
    }
  }, c.prototype._encodeValue = function(s, p, m) {
    var g = this._baseState;
    if (g.parent === null)
      return g.children[0]._encode(s, p || new e());
    var b = null;
    if (this.reporter = p, g.optional && s === void 0)
      if (g.default !== null)
        s = g.default;
      else
        return;
    var y = null, v = !1;
    if (g.any)
      b = this._createEncoderBuffer(s);
    else if (g.choice)
      b = this._encodeChoice(s, p);
    else if (g.contains)
      y = this._getUse(g.contains, m)._encode(s, p), v = !0;
    else if (g.children)
      y = g.children.map(function(j) {
        if (j._baseState.tag === "null_")
          return j._encode(null, p, s);
        if (j._baseState.key === null)
          return p.error("Child should have a key");
        var D = p.enterKey(j._baseState.key);
        if (typeof s != "object")
          return p.error("Child expected, but input is not object");
        var G = j._encode(s[j._baseState.key], p, s);
        return p.leaveKey(D), G;
      }, this).filter(function(j) {
        return j;
      }), y = this._createEncoderBuffer(y);
    else if (g.tag === "seqof" || g.tag === "setof") {
      if (!(g.args && g.args.length === 1))
        return p.error("Too many args for : " + g.tag);
      if (!Array.isArray(s))
        return p.error("seqof/setof, but data is not Array");
      var E = this.clone();
      E._baseState.implicit = null, y = this._createEncoderBuffer(s.map(function(j) {
        var D = this._baseState;
        return this._getUse(D.args[0], s)._encode(j, p);
      }, E));
    } else g.use !== null ? b = this._getUse(g.use, m)._encode(s, p) : (y = this._encodePrimitive(g.tag, s), v = !0);
    var b;
    if (!g.any && g.choice === null) {
      var q = g.implicit !== null ? g.implicit : g.tag, O = g.implicit === null ? "universal" : "context";
      q === null ? g.use === null && p.error("Tag could be omitted only for .use()") : g.use === null && (b = this._encodeComposite(q, v, O, y));
    }
    return g.explicit !== null && (b = this._encodeComposite(g.explicit, !1, "context", b)), b;
  }, c.prototype._encodeChoice = function(s, p) {
    var m = this._baseState, g = m.choice[s.type];
    return g || a(
      !1,
      s.type + " not found in " + JSON.stringify(Object.keys(m.choice))
    ), g._encode(s.value, p);
  }, c.prototype._encodePrimitive = function(s, p) {
    var m = this._baseState;
    if (/str$/.test(s))
      return this._encodeStr(p, s);
    if (s === "objid" && m.args)
      return this._encodeObjid(p, m.reverseArgs[0], m.args[1]);
    if (s === "objid")
      return this._encodeObjid(p, null, null);
    if (s === "gentime" || s === "utctime")
      return this._encodeTime(p, s);
    if (s === "null_")
      return this._encodeNull();
    if (s === "int" || s === "enum")
      return this._encodeInt(p, m.args && m.reverseArgs[0]);
    if (s === "bool")
      return this._encodeBool(p);
    if (s === "objDesc")
      return this._encodeStr(p, s);
    throw new Error("Unsupported tag: " + s);
  }, c.prototype._isNumstr = function(s) {
    return /^[0-9 ]*$/.test(s);
  }, c.prototype._isPrintstr = function(s) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(s);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, (function(e) {
    var t = e;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  })(base)), base;
}
var constants$1 = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, (function(e) {
    var t = requireConstants$1();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t._reverse(e.tag);
  })(der)), der;
}
var hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, (function(e) {
    var t = e;
    t._reverse = function(a) {
      var u = {};
      return Object.keys(a).forEach(function(n) {
        (n | 0) == n && (n = n | 0);
        var o = a[n];
        u[o] = n;
      }), u;
    }, t.der = requireDer$2();
  })(constants$1)), constants$1;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var e = requireInherits_browser(), t = requireAsn1$1(), r = t.base, a = t.bignum, u = t.constants.der;
  function n(l) {
    this.enc = "der", this.name = l.name, this.entity = l, this.tree = new o(), this.tree._init(l.body);
  }
  der_1$1 = n, n.prototype.decode = function(s, p) {
    return s instanceof r.DecoderBuffer || (s = new r.DecoderBuffer(s, p)), this.tree._decode(s, p);
  };
  function o(l) {
    r.Node.call(this, "der", l);
  }
  e(o, r.Node), o.prototype._peekTag = function(s, p, m) {
    if (s.isEmpty())
      return !1;
    var g = s.save(), y = c(s, 'Failed to peek tag: "' + p + '"');
    return s.isError(y) ? y : (s.restore(g), y.tag === p || y.tagStr === p || y.tagStr + "of" === p || m);
  }, o.prototype._decodeTag = function(s, p, m) {
    var g = c(
      s,
      'Failed to decode tag of "' + p + '"'
    );
    if (s.isError(g))
      return g;
    var y = f(
      s,
      g.primitive,
      'Failed to get length of "' + p + '"'
    );
    if (s.isError(y))
      return y;
    if (!m && g.tag !== p && g.tagStr !== p && g.tagStr + "of" !== p)
      return s.error('Failed to match tag: "' + p + '"');
    if (g.primitive || y !== null)
      return s.skip(y, 'Failed to match body of: "' + p + '"');
    var v = s.save(), E = this._skipUntilEnd(
      s,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return s.isError(E) ? E : (y = s.offset - v.offset, s.restore(v), s.skip(y, 'Failed to match body of: "' + p + '"'));
  }, o.prototype._skipUntilEnd = function(s, p) {
    for (; ; ) {
      var m = c(s, p);
      if (s.isError(m))
        return m;
      var g = f(s, m.primitive, p);
      if (s.isError(g))
        return g;
      var y;
      if (m.primitive || g !== null ? y = s.skip(g) : y = this._skipUntilEnd(s, p), s.isError(y))
        return y;
      if (m.tagStr === "end")
        break;
    }
  }, o.prototype._decodeList = function(s, p, m, g) {
    for (var y = []; !s.isEmpty(); ) {
      var v = this._peekTag(s, "end");
      if (s.isError(v))
        return v;
      var E = m.decode(s, "der", g);
      if (s.isError(E) && v)
        break;
      y.push(E);
    }
    return y;
  }, o.prototype._decodeStr = function(s, p) {
    if (p === "bitstr") {
      var m = s.readUInt8();
      return s.isError(m) ? m : { unused: m, data: s.raw() };
    } else if (p === "bmpstr") {
      var g = s.raw();
      if (g.length % 2 === 1)
        return s.error("Decoding of string type: bmpstr length mismatch");
      for (var y = "", v = 0; v < g.length / 2; v++)
        y += String.fromCharCode(g.readUInt16BE(v * 2));
      return y;
    } else if (p === "numstr") {
      var E = s.raw().toString("ascii");
      return this._isNumstr(E) ? E : s.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (p === "octstr")
        return s.raw();
      if (p === "objDesc")
        return s.raw();
      if (p === "printstr") {
        var b = s.raw().toString("ascii");
        return this._isPrintstr(b) ? b : s.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(p) ? s.raw().toString() : s.error("Decoding of string type: " + p + " unsupported");
    }
  }, o.prototype._decodeObjid = function(s, p, m) {
    for (var g, y = [], v = 0; !s.isEmpty(); ) {
      var E = s.readUInt8();
      v <<= 7, v |= E & 127, (E & 128) === 0 && (y.push(v), v = 0);
    }
    E & 128 && y.push(v);
    var b = y[0] / 40 | 0, q = y[0] % 40;
    if (m ? g = y : g = [b, q].concat(y.slice(1)), p) {
      var O = p[g.join(" ")];
      O === void 0 && (O = p[g.join(".")]), O !== void 0 && (g = O);
    }
    return g;
  }, o.prototype._decodeTime = function(s, p) {
    var m = s.raw().toString();
    if (p === "gentime")
      var g = m.slice(0, 4) | 0, y = m.slice(4, 6) | 0, v = m.slice(6, 8) | 0, E = m.slice(8, 10) | 0, b = m.slice(10, 12) | 0, q = m.slice(12, 14) | 0;
    else if (p === "utctime") {
      var g = m.slice(0, 2) | 0, y = m.slice(2, 4) | 0, v = m.slice(4, 6) | 0, E = m.slice(6, 8) | 0, b = m.slice(8, 10) | 0, q = m.slice(10, 12) | 0;
      g < 70 ? g = 2e3 + g : g = 1900 + g;
    } else
      return s.error("Decoding " + p + " time is not supported yet");
    return Date.UTC(g, y - 1, v, E, b, q, 0);
  }, o.prototype._decodeNull = function(s) {
    return null;
  }, o.prototype._decodeBool = function(s) {
    var p = s.readUInt8();
    return s.isError(p) ? p : p !== 0;
  }, o.prototype._decodeInt = function(s, p) {
    var m = s.raw(), g = new a(m);
    return p && (g = p[g.toString(10)] || g), g;
  }, o.prototype._use = function(s, p) {
    return typeof s == "function" && (s = s(p)), s._getDecoder("der").tree;
  };
  function c(l, s) {
    var p = l.readUInt8(s);
    if (l.isError(p))
      return p;
    var m = u.tagClass[p >> 6], g = (p & 32) === 0;
    if ((p & 31) === 31) {
      var y = p;
      for (p = 0; (y & 128) === 128; ) {
        if (y = l.readUInt8(s), l.isError(y))
          return y;
        p <<= 7, p |= y & 127;
      }
    } else
      p &= 31;
    var v = u.tag[p];
    return {
      cls: m,
      primitive: g,
      tag: p,
      tagStr: v
    };
  }
  function f(l, s, p) {
    var m = l.readUInt8(p);
    if (l.isError(m))
      return m;
    if (!s && m === 128)
      return null;
    if ((m & 128) === 0)
      return m;
    var g = m & 127;
    if (g > 4)
      return l.error("length octect is too long");
    m = 0;
    for (var y = 0; y < g; y++) {
      m <<= 8;
      var v = l.readUInt8(p);
      if (l.isError(v))
        return v;
      m |= v;
    }
    return m;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var e = requireInherits_browser(), t = requireDist$1().Buffer, r = requireDer$1();
  function a(u) {
    r.call(this, u), this.enc = "pem";
  }
  return e(a, r), pem$1 = a, a.prototype.decode = function(n, o) {
    for (var c = n.toString().split(/[\r\n]+/g), f = o.label.toUpperCase(), l = /^-----(BEGIN|END) ([^-]+)-----$/, s = -1, p = -1, m = 0; m < c.length; m++) {
      var g = c[m].match(l);
      if (g !== null && g[2] === f)
        if (s === -1) {
          if (g[1] !== "BEGIN")
            break;
          s = m;
        } else {
          if (g[1] !== "END")
            break;
          p = m;
          break;
        }
    }
    if (s === -1 || p === -1)
      throw new Error("PEM section not found for: " + f);
    var y = c.slice(s + 1, p).join("");
    y.replace(/[^a-z0-9\+\/=]+/gi, "");
    var v = new t(y, "base64");
    return r.prototype.decode.call(this, v, o);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, (function(e) {
    var t = e;
    t.der = requireDer$1(), t.pem = requirePem$1();
  })(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var e = requireInherits_browser(), t = requireDist$1().Buffer, r = requireAsn1$1(), a = r.base, u = r.constants.der;
  function n(l) {
    this.enc = "der", this.name = l.name, this.entity = l, this.tree = new o(), this.tree._init(l.body);
  }
  der_1 = n, n.prototype.encode = function(s, p) {
    return this.tree._encode(s, p).join();
  };
  function o(l) {
    a.Node.call(this, "der", l);
  }
  e(o, a.Node), o.prototype._encodeComposite = function(s, p, m, g) {
    var y = f(s, p, m, this.reporter);
    if (g.length < 128) {
      var b = new t(2);
      return b[0] = y, b[1] = g.length, this._createEncoderBuffer([b, g]);
    }
    for (var v = 1, E = g.length; E >= 256; E >>= 8)
      v++;
    var b = new t(2 + v);
    b[0] = y, b[1] = 128 | v;
    for (var E = 1 + v, q = g.length; q > 0; E--, q >>= 8)
      b[E] = q & 255;
    return this._createEncoderBuffer([b, g]);
  }, o.prototype._encodeStr = function(s, p) {
    if (p === "bitstr")
      return this._createEncoderBuffer([s.unused | 0, s.data]);
    if (p === "bmpstr") {
      for (var m = new t(s.length * 2), g = 0; g < s.length; g++)
        m.writeUInt16BE(s.charCodeAt(g), g * 2);
      return this._createEncoderBuffer(m);
    } else return p === "numstr" ? this._isNumstr(s) ? this._createEncoderBuffer(s) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : p === "printstr" ? this._isPrintstr(s) ? this._createEncoderBuffer(s) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(p) ? this._createEncoderBuffer(s) : p === "objDesc" ? this._createEncoderBuffer(s) : this.reporter.error("Encoding of string type: " + p + " unsupported");
  }, o.prototype._encodeObjid = function(s, p, m) {
    if (typeof s == "string") {
      if (!p)
        return this.reporter.error("string objid given, but no values map found");
      if (!p.hasOwnProperty(s))
        return this.reporter.error("objid not found in values map");
      s = p[s].split(/[\s\.]+/g);
      for (var g = 0; g < s.length; g++)
        s[g] |= 0;
    } else if (Array.isArray(s)) {
      s = s.slice();
      for (var g = 0; g < s.length; g++)
        s[g] |= 0;
    }
    if (!Array.isArray(s))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(s));
    if (!m) {
      if (s[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      s.splice(0, 2, s[0] * 40 + s[1]);
    }
    for (var y = 0, g = 0; g < s.length; g++) {
      var v = s[g];
      for (y++; v >= 128; v >>= 7)
        y++;
    }
    for (var E = new t(y), b = E.length - 1, g = s.length - 1; g >= 0; g--) {
      var v = s[g];
      for (E[b--] = v & 127; (v >>= 7) > 0; )
        E[b--] = 128 | v & 127;
    }
    return this._createEncoderBuffer(E);
  };
  function c(l) {
    return l < 10 ? "0" + l : l;
  }
  o.prototype._encodeTime = function(s, p) {
    var m, g = new Date(s);
    return p === "gentime" ? m = [
      c(g.getFullYear()),
      c(g.getUTCMonth() + 1),
      c(g.getUTCDate()),
      c(g.getUTCHours()),
      c(g.getUTCMinutes()),
      c(g.getUTCSeconds()),
      "Z"
    ].join("") : p === "utctime" ? m = [
      c(g.getFullYear() % 100),
      c(g.getUTCMonth() + 1),
      c(g.getUTCDate()),
      c(g.getUTCHours()),
      c(g.getUTCMinutes()),
      c(g.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + p + " time is not supported yet"), this._encodeStr(m, "octstr");
  }, o.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, o.prototype._encodeInt = function(s, p) {
    if (typeof s == "string") {
      if (!p)
        return this.reporter.error("String int or enum given, but no values map");
      if (!p.hasOwnProperty(s))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(s));
      s = p[s];
    }
    if (typeof s != "number" && !t.isBuffer(s)) {
      var m = s.toArray();
      !s.sign && m[0] & 128 && m.unshift(0), s = new t(m);
    }
    if (t.isBuffer(s)) {
      var g = s.length;
      s.length === 0 && g++;
      var v = new t(g);
      return s.copy(v), s.length === 0 && (v[0] = 0), this._createEncoderBuffer(v);
    }
    if (s < 128)
      return this._createEncoderBuffer(s);
    if (s < 256)
      return this._createEncoderBuffer([0, s]);
    for (var g = 1, y = s; y >= 256; y >>= 8)
      g++;
    for (var v = new Array(g), y = v.length - 1; y >= 0; y--)
      v[y] = s & 255, s >>= 8;
    return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(new t(v));
  }, o.prototype._encodeBool = function(s) {
    return this._createEncoderBuffer(s ? 255 : 0);
  }, o.prototype._use = function(s, p) {
    return typeof s == "function" && (s = s(p)), s._getEncoder("der").tree;
  }, o.prototype._skipDefault = function(s, p, m) {
    var g = this._baseState, y;
    if (g.default === null)
      return !1;
    var v = s.join();
    if (g.defaultBuffer === void 0 && (g.defaultBuffer = this._encodeValue(g.default, p, m).join()), v.length !== g.defaultBuffer.length)
      return !1;
    for (y = 0; y < v.length; y++)
      if (v[y] !== g.defaultBuffer[y])
        return !1;
    return !0;
  };
  function f(l, s, p, m) {
    var g;
    if (l === "seqof" ? l = "seq" : l === "setof" && (l = "set"), u.tagByName.hasOwnProperty(l))
      g = u.tagByName[l];
    else if (typeof l == "number" && (l | 0) === l)
      g = l;
    else
      return m.error("Unknown tag: " + l);
    return g >= 31 ? m.error("Multi-octet tag encoding unsupported") : (s || (g |= 32), g |= u.tagClassByName[p || "universal"] << 6, g);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var e = requireInherits_browser(), t = requireDer();
  function r(a) {
    t.call(this, a), this.enc = "pem";
  }
  return e(r, t), pem = r, r.prototype.encode = function(u, n) {
    for (var o = t.prototype.encode.call(this, u), c = o.toString("base64"), f = ["-----BEGIN " + n.label + "-----"], l = 0; l < c.length; l += 64)
      f.push(c.slice(l, l + 64));
    return f.push("-----END " + n.label + "-----"), f.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, (function(e) {
    var t = e;
    t.der = requireDer(), t.pem = requirePem();
  })(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, (function(e) {
    var t = e;
    t.bignum = requireBn$2(), t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants$1(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  })(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var e = requireAsn1$1(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), r = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), a = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), u = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(a),
      this.key("subjectPublicKey").bitstr()
    );
  }), n = e.define("RelativeDistinguishedName", function() {
    this.setof(r);
  }), o = e.define("RDNSequence", function() {
    this.seqof(n);
  }), c = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(o)
    });
  }), f = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), l = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), s = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(a),
      this.key("issuer").use(c),
      this.key("validity").use(f),
      this.key("subject").use(c),
      this.key("subjectPublicKeyInfo").use(u),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(l).optional()
    );
  }), p = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(s),
      this.key("signatureAlgorithm").use(a),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = p, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var e = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var r = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = r;
  var a = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), u = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(a),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = u;
  var n = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(a),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = n;
  var o = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = o;
  var c = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = c, asn1$1.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var f = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), l = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(f),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = l, asn1$1.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1$3 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, a = requireEvp_bytestokey(), u = requireBrowser$d(), n = requireSafeBuffer$4().Buffer;
  return fixProc = function(o, c) {
    var f = o.toString(), l = f.match(e), s;
    if (l) {
      var m = "aes" + l[1], g = n.from(l[2], "hex"), y = n.from(l[3].replace(/[\r\n]/g, ""), "base64"), v = a(c, g.slice(0, 8), parseInt(l[1], 10)).key, E = [], b = u.createDecipheriv(m, v, g);
      E.push(b.update(y)), E.push(b.final()), s = n.concat(E);
    } else {
      var p = f.match(r);
      s = n.from(p[2].replace(/[\r\n]/g, ""), "base64");
    }
    var q = f.match(t)[1];
    return {
      tag: q,
      data: s
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var e = requireAsn1(), t = require$$1$3, r = requireFixProc(), a = requireBrowser$d(), u = requireBrowser$e().pbkdf2Sync, n = requireSafeBuffer$4().Buffer;
  function o(f, l) {
    var s = f.algorithm.decrypt.kde.kdeparams.salt, p = parseInt(f.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), m = t[f.algorithm.decrypt.cipher.algo.join(".")], g = f.algorithm.decrypt.cipher.iv, y = f.subjectPrivateKey, v = parseInt(m.split("-")[1], 10) / 8, E = u(l, s, p, v, "sha1"), b = a.createDecipheriv(m, E, g), q = [];
    return q.push(b.update(y)), q.push(b.final()), n.concat(q);
  }
  function c(f) {
    var l;
    typeof f == "object" && !n.isBuffer(f) && (l = f.passphrase, f = f.key), typeof f == "string" && (f = n.from(f));
    var s = r(f, l), p = s.tag, m = s.data, g, y;
    switch (p) {
      case "CERTIFICATE":
        y = e.certificate.decode(m, "der").tbsCertificate.subjectPublicKeyInfo;
      // falls through
      case "PUBLIC KEY":
        switch (y || (y = e.PublicKey.decode(m, "der")), g = y.algorithm.algorithm.join("."), g) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(y.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return y.subjectPrivateKey = y.subjectPublicKey, {
              type: "ec",
              data: y
            };
          case "1.2.840.10040.4.1":
            return y.algorithm.params.pub_key = e.DSAparam.decode(y.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: y.algorithm.params
            };
          default:
            throw new Error("unknown key id " + g);
        }
      // throw new Error('unknown key type ' + type)
      case "ENCRYPTED PRIVATE KEY":
        m = e.EncryptedPrivateKey.decode(m, "der"), m = o(m, l);
      // falls through
      case "PRIVATE KEY":
        switch (y = e.PrivateKey.decode(m, "der"), g = y.algorithm.algorithm.join("."), g) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(y.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: y.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(y.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return y.algorithm.params.priv_key = e.DSAparam.decode(y.subjectPrivateKey, "der"), {
              type: "dsa",
              params: y.algorithm.params
            };
          default:
            throw new Error("unknown key id " + g);
        }
      // throw new Error('unknown key type ' + type)
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(m, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(m, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(m, "der")
        };
      case "EC PRIVATE KEY":
        return m = e.ECPrivateKey.decode(m, "der"), {
          curve: m.parameters.value,
          privateKey: m.privateKey
        };
      default:
        throw new Error("unknown key type " + p);
    }
  }
  return c.signature = e.signature, parseAsn1 = c, parseAsn1;
}
const require$$4$1 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireBrowser$f(), r = /* @__PURE__ */ requireBrowserifyRsa(), a = requireElliptic().ec, u = requireBn(), n = requireParseAsn1(), o = require$$4$1, c = 1;
  function f(b, q, O, j, D) {
    var G = n(q);
    if (G.curve) {
      if (j !== "ecdsa" && j !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return l(b, G);
    } else if (G.type === "dsa") {
      if (j !== "dsa")
        throw new Error("wrong private key type");
      return s(b, G, O);
    }
    if (j !== "rsa" && j !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (q.padding !== void 0 && q.padding !== c)
      throw new Error("illegal or unsupported padding mode");
    b = e.concat([D, b]);
    for (var V = G.modulus.byteLength(), Q = [0, 1]; b.length + Q.length + 1 < V; )
      Q.push(255);
    Q.push(0);
    for (var re = -1; ++re < b.length; )
      Q.push(b[re]);
    var ve = r(Q, G);
    return ve;
  }
  function l(b, q) {
    var O = o[q.curve.join(".")];
    if (!O)
      throw new Error("unknown curve " + q.curve.join("."));
    var j = new a(O), D = j.keyFromPrivate(q.privateKey), G = D.sign(b);
    return e.from(G.toDER());
  }
  function s(b, q, O) {
    for (var j = q.params.priv_key, D = q.params.p, G = q.params.q, V = q.params.g, Q = new u(0), re, ve = g(b, G).mod(G), te = !1, R = m(j, G, b, O); te === !1; )
      re = v(G, R, O), Q = E(V, re, D, G), te = re.invm(G).imul(ve.add(j.mul(Q))).mod(G), te.cmpn(0) === 0 && (te = !1, Q = new u(0));
    return p(Q, te);
  }
  function p(b, q) {
    b = b.toArray(), q = q.toArray(), b[0] & 128 && (b = [0].concat(b)), q[0] & 128 && (q = [0].concat(q));
    var O = b.length + q.length + 4, j = [
      48,
      O,
      2,
      b.length
    ];
    return j = j.concat(b, [2, q.length], q), e.from(j);
  }
  function m(b, q, O, j) {
    if (b = e.from(b.toArray()), b.length < q.byteLength()) {
      var D = e.alloc(q.byteLength() - b.length);
      b = e.concat([D, b]);
    }
    var G = O.length, V = y(O, q), Q = e.alloc(G);
    Q.fill(1);
    var re = e.alloc(G);
    return re = t(j, re).update(Q).update(e.from([0])).update(b).update(V).digest(), Q = t(j, re).update(Q).digest(), re = t(j, re).update(Q).update(e.from([1])).update(b).update(V).digest(), Q = t(j, re).update(Q).digest(), { k: re, v: Q };
  }
  function g(b, q) {
    var O = new u(b), j = (b.length << 3) - q.bitLength();
    return j > 0 && O.ishrn(j), O;
  }
  function y(b, q) {
    b = g(b, q), b = b.mod(q);
    var O = e.from(b.toArray());
    if (O.length < q.byteLength()) {
      var j = e.alloc(q.byteLength() - O.length);
      O = e.concat([j, O]);
    }
    return O;
  }
  function v(b, q, O) {
    var j, D;
    do {
      for (j = e.alloc(0); j.length * 8 < b.bitLength(); )
        q.v = t(O, q.k).update(q.v).digest(), j = e.concat([j, q.v]);
      D = g(j, b), q.k = t(O, q.k).update(q.v).update(e.from([0])).digest(), q.v = t(O, q.k).update(q.v).digest();
    } while (D.cmp(b) !== -1);
    return D;
  }
  function E(b, q, O, j) {
    return b.toRed(u.mont(O)).redPow(q).fromRed().mod(j);
  }
  return sign.exports = f, sign.exports.getKey = m, sign.exports.makeKey = v, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireBn(), r = requireElliptic().ec, a = requireParseAsn1(), u = require$$4$1;
  function n(l, s, p, m, g) {
    var y = a(p);
    if (y.type === "ec") {
      if (m !== "ecdsa" && m !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return o(l, s, y);
    } else if (y.type === "dsa") {
      if (m !== "dsa")
        throw new Error("wrong public key type");
      return c(l, s, y);
    }
    if (m !== "rsa" && m !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    s = e.concat([g, s]);
    for (var v = y.modulus.byteLength(), E = [1], b = 0; s.length + E.length + 2 < v; )
      E.push(255), b += 1;
    E.push(0);
    for (var q = -1; ++q < s.length; )
      E.push(s[q]);
    E = e.from(E);
    var O = t.mont(y.modulus);
    l = new t(l).toRed(O), l = l.redPow(new t(y.publicExponent)), l = e.from(l.fromRed().toArray());
    var j = b < 8 ? 1 : 0;
    for (v = Math.min(l.length, E.length), l.length !== E.length && (j = 1), q = -1; ++q < v; )
      j |= l[q] ^ E[q];
    return j === 0;
  }
  function o(l, s, p) {
    var m = u[p.data.algorithm.curve.join(".")];
    if (!m)
      throw new Error("unknown curve " + p.data.algorithm.curve.join("."));
    var g = new r(m), y = p.data.subjectPrivateKey.data;
    return g.verify(s, l, y);
  }
  function c(l, s, p) {
    var m = p.data.p, g = p.data.q, y = p.data.g, v = p.data.pub_key, E = a.signature.decode(l, "der"), b = E.s, q = E.r;
    f(b, g), f(q, g);
    var O = t.mont(m), j = b.invm(g), D = y.toRed(O).redPow(new t(s).mul(j).mod(g)).fromRed().mul(v.toRed(O).redPow(q.mul(j).mod(g)).fromRed()).mod(m).mod(g);
    return D.cmp(q) === 0;
  }
  function f(l, s) {
    if (l.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (l.cmp(s) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = n, verify_1;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1;
  var e = requireSafeBuffer$4().Buffer, t = requireBrowser$g(), r = requireReadableBrowser$1(), a = requireInherits_browser(), u = requireSign(), n = requireVerify(), o = require$$6;
  Object.keys(o).forEach(function(p) {
    o[p].id = e.from(o[p].id, "hex"), o[p.toLowerCase()] = o[p];
  });
  function c(p) {
    r.Writable.call(this);
    var m = o[p];
    if (!m)
      throw new Error("Unknown message digest");
    this._hashType = m.hash, this._hash = t(m.hash), this._tag = m.id, this._signType = m.sign;
  }
  a(c, r.Writable), c.prototype._write = function(m, g, y) {
    this._hash.update(m), y();
  }, c.prototype.update = function(m, g) {
    return this._hash.update(typeof m == "string" ? e.from(m, g) : m), this;
  }, c.prototype.sign = function(m, g) {
    this.end();
    var y = this._hash.digest(), v = u(y, m, this._hashType, this._signType, this._tag);
    return g ? v.toString(g) : v;
  };
  function f(p) {
    r.Writable.call(this);
    var m = o[p];
    if (!m)
      throw new Error("Unknown message digest");
    this._hash = t(m.hash), this._tag = m.id, this._signType = m.sign;
  }
  a(f, r.Writable), f.prototype._write = function(m, g, y) {
    this._hash.update(m), y();
  }, f.prototype.update = function(m, g) {
    return this._hash.update(typeof m == "string" ? e.from(m, g) : m), this;
  }, f.prototype.verify = function(m, g, y) {
    var v = typeof g == "string" ? e.from(g, y) : g;
    this.end();
    var E = this._hash.digest();
    return n(v, E, m, this._signType, this._tag);
  };
  function l(p) {
    return new c(p);
  }
  function s(p) {
    return new f(p);
  }
  return browser$a = {
    Sign: l,
    Verify: s,
    createSign: l,
    createVerify: s
  }, browser$a;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var e = requireElliptic(), t = requireBn$2();
  browser$9 = function(o) {
    return new a(o);
  };
  var r = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
  function a(n) {
    this.curveType = r[n], this.curveType || (this.curveType = {
      name: n
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  a.prototype.generateKeys = function(n, o) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(n, o);
  }, a.prototype.computeSecret = function(n, o, c) {
    o = o || "utf8", Buffer.isBuffer(n) || (n = new Buffer(n, o));
    var f = this.curve.keyFromPublic(n).getPublic(), l = f.mul(this.keys.getPrivate()).getX();
    return u(l, c, this.curveType.byteLength);
  }, a.prototype.getPublicKey = function(n, o) {
    var c = this.keys.getPublic(o === "compressed", !0);
    return o === "hybrid" && (c[c.length - 1] % 2 ? c[0] = 7 : c[0] = 6), u(c, n);
  }, a.prototype.getPrivateKey = function(n) {
    return u(this.keys.getPrivate(), n);
  }, a.prototype.setPublicKey = function(n, o) {
    return o = o || "utf8", Buffer.isBuffer(n) || (n = new Buffer(n, o)), this.keys._importPublic(n), this;
  }, a.prototype.setPrivateKey = function(n, o) {
    o = o || "utf8", Buffer.isBuffer(n) || (n = new Buffer(n, o));
    var c = new t(n);
    return c = c.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(c), this;
  };
  function u(n, o, c) {
    Array.isArray(n) || (n = n.toArray());
    var f = new Buffer(n);
    if (c && f.length < c) {
      var l = new Buffer(c - f.length);
      l.fill(0), f = Buffer.concat([l, f]);
    }
    return o ? f.toString(o) : f;
  }
  return browser$9;
}
var browser$8 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var e = requireBrowser$g(), t = requireSafeBuffer$4().Buffer;
  mgf = function(a, u) {
    for (var n = t.alloc(0), o = 0, c; n.length < u; )
      c = r(o++), n = t.concat([n, e("sha1").update(a).update(c).digest()]);
    return n.slice(0, u);
  };
  function r(a) {
    var u = t.allocUnsafe(4);
    return u.writeUInt32BE(a, 0), u;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(t, r) {
    for (var a = t.length, u = -1; ++u < a; )
      t[u] ^= r[u];
    return t;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var e = requireBn$2(), t = requireSafeBuffer$4().Buffer;
  function r(a, u) {
    return t.from(a.toRed(e.mont(u.modulus)).redPow(new e(u.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = r, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var e = requireParseAsn1(), t = requireBrowser$i(), r = requireBrowser$g(), a = requireMgf(), u = requireXor(), n = requireBn$2(), o = requireWithPublic(), c = /* @__PURE__ */ requireBrowserifyRsa(), f = requireSafeBuffer$4().Buffer;
  publicEncrypt = function(g, y, v) {
    var E;
    g.padding ? E = g.padding : v ? E = 1 : E = 4;
    var b = e(g), q;
    if (E === 4)
      q = l(b, y);
    else if (E === 1)
      q = s(b, y, v);
    else if (E === 3) {
      if (q = new n(y), q.cmp(b.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return v ? c(q, b) : o(q, b);
  };
  function l(m, g) {
    var y = m.modulus.byteLength(), v = g.length, E = r("sha1").update(f.alloc(0)).digest(), b = E.length, q = 2 * b;
    if (v > y - q - 2)
      throw new Error("message too long");
    var O = f.alloc(y - v - q - 2), j = y - b - 1, D = t(b), G = u(f.concat([E, O, f.alloc(1, 1), g], j), a(D, j)), V = u(D, a(G, b));
    return new n(f.concat([f.alloc(1), V, G], y));
  }
  function s(m, g, y) {
    var v = g.length, E = m.modulus.byteLength();
    if (v > E - 11)
      throw new Error("message too long");
    var b;
    return y ? b = f.alloc(E - v - 3, 255) : b = p(E - v - 3), new n(f.concat([f.from([0, y ? 1 : 2]), b, f.alloc(1), g], E));
  }
  function p(m) {
    for (var g = f.allocUnsafe(m), y = 0, v = t(m * 2), E = 0, b; y < m; )
      E === v.length && (v = t(m * 2), E = 0), b = v[E++], b && (g[y++] = b);
    return g;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var e = requireParseAsn1(), t = requireMgf(), r = requireXor(), a = requireBn$2(), u = /* @__PURE__ */ requireBrowserifyRsa(), n = requireBrowser$g(), o = requireWithPublic(), c = requireSafeBuffer$4().Buffer;
  privateDecrypt = function(m, g, y) {
    var v;
    m.padding ? v = m.padding : y ? v = 1 : v = 4;
    var E = e(m), b = E.modulus.byteLength();
    if (g.length > b || new a(g).cmp(E.modulus) >= 0)
      throw new Error("decryption error");
    var q;
    y ? q = o(new a(g), E) : q = u(g, E);
    var O = c.alloc(b - q.length);
    if (q = c.concat([O, q], b), v === 4)
      return f(E, q);
    if (v === 1)
      return l(E, q, y);
    if (v === 3)
      return q;
    throw new Error("unknown padding");
  };
  function f(p, m) {
    var g = p.modulus.byteLength(), y = n("sha1").update(c.alloc(0)).digest(), v = y.length;
    if (m[0] !== 0)
      throw new Error("decryption error");
    var E = m.slice(1, v + 1), b = m.slice(v + 1), q = r(E, t(b, v)), O = r(b, t(q, g - v - 1));
    if (s(y, O.slice(0, v)))
      throw new Error("decryption error");
    for (var j = v; O[j] === 0; )
      j++;
    if (O[j++] !== 1)
      throw new Error("decryption error");
    return O.slice(j);
  }
  function l(p, m, g) {
    for (var y = m.slice(0, 2), v = 2, E = 0; m[v++] !== 0; )
      if (v >= m.length) {
        E++;
        break;
      }
    var b = m.slice(2, v - 1);
    if ((y.toString("hex") !== "0002" && !g || y.toString("hex") !== "0001" && g) && E++, b.length < 8 && E++, E)
      throw new Error("decryption error");
    return m.slice(v);
  }
  function s(p, m) {
    p = c.from(p), m = c.from(m);
    var g = 0, y = p.length;
    p.length !== m.length && (g++, y = Math.min(p.length, m.length));
    for (var v = -1; ++v < y; )
      g += p[v] ^ m[v];
    return g;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$8;
function requireBrowser$8() {
  return hasRequiredBrowser$8 || (hasRequiredBrowser$8 = 1, (function(e) {
    e.publicEncrypt = requirePublicEncrypt(), e.privateDecrypt = requirePrivateDecrypt(), e.privateEncrypt = function(r, a) {
      return e.publicEncrypt(r, a, !0);
    }, e.publicDecrypt = function(r, a) {
      return e.privateDecrypt(r, a, !0);
    };
  })(browser$8)), browser$8;
}
var browser$7 = {}, hasRequiredBrowser$7;
function requireBrowser$7() {
  if (hasRequiredBrowser$7) return browser$7;
  hasRequiredBrowser$7 = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$4(), r = requireBrowser$i(), a = t.Buffer, u = t.kMaxLength, n = globalThis.crypto || globalThis.msCrypto, o = Math.pow(2, 32) - 1;
  function c(m, g) {
    if (typeof m != "number" || m !== m)
      throw new TypeError("offset must be a number");
    if (m > o || m < 0)
      throw new TypeError("offset must be a uint32");
    if (m > u || m > g)
      throw new RangeError("offset out of range");
  }
  function f(m, g, y) {
    if (typeof m != "number" || m !== m)
      throw new TypeError("size must be a number");
    if (m > o || m < 0)
      throw new TypeError("size must be a uint32");
    if (m + g > y || m > u)
      throw new RangeError("buffer too small");
  }
  n && n.getRandomValues || !process$1.browser ? (browser$7.randomFill = l, browser$7.randomFillSync = p) : (browser$7.randomFill = e, browser$7.randomFillSync = e);
  function l(m, g, y, v) {
    if (!a.isBuffer(m) && !(m instanceof globalThis.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof g == "function")
      v = g, g = 0, y = m.length;
    else if (typeof y == "function")
      v = y, y = m.length - g;
    else if (typeof v != "function")
      throw new TypeError('"cb" argument must be a function');
    return c(g, m.length), f(y, g, m.length), s(m, g, y, v);
  }
  function s(m, g, y, v) {
    if (process$1.browser) {
      var E = m.buffer, b = new Uint8Array(E, g, y);
      if (n.getRandomValues(b), v) {
        process$1.nextTick(function() {
          v(null, m);
        });
        return;
      }
      return m;
    }
    if (v) {
      r(y, function(O, j) {
        if (O)
          return v(O);
        j.copy(m, g), v(null, m);
      });
      return;
    }
    var q = r(y);
    return q.copy(m, g), m;
  }
  function p(m, g, y) {
    if (typeof g > "u" && (g = 0), !a.isBuffer(m) && !(m instanceof globalThis.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return c(g, m.length), y === void 0 && (y = m.length - g), f(y, g, m.length), s(m, g, y);
  }
  return browser$7;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$i(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$g(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$f();
  var e = requireAlgos(), t = Object.keys(e), r = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return r;
  };
  var a = requireBrowser$e();
  cryptoBrowserify.pbkdf2 = a.pbkdf2, cryptoBrowserify.pbkdf2Sync = a.pbkdf2Sync;
  var u = requireBrowser$c();
  cryptoBrowserify.Cipher = u.Cipher, cryptoBrowserify.createCipher = u.createCipher, cryptoBrowserify.Cipheriv = u.Cipheriv, cryptoBrowserify.createCipheriv = u.createCipheriv, cryptoBrowserify.Decipher = u.Decipher, cryptoBrowserify.createDecipher = u.createDecipher, cryptoBrowserify.Decipheriv = u.Decipheriv, cryptoBrowserify.createDecipheriv = u.createDecipheriv, cryptoBrowserify.getCiphers = u.getCiphers, cryptoBrowserify.listCiphers = u.listCiphers;
  var n = requireBrowser$b();
  cryptoBrowserify.DiffieHellmanGroup = n.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = n.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = n.getDiffieHellman, cryptoBrowserify.createDiffieHellman = n.createDiffieHellman, cryptoBrowserify.DiffieHellman = n.DiffieHellman;
  var o = requireBrowser$a();
  cryptoBrowserify.createSign = o.createSign, cryptoBrowserify.Sign = o.Sign, cryptoBrowserify.createVerify = o.createVerify, cryptoBrowserify.Verify = o.Verify, cryptoBrowserify.createECDH = requireBrowser$9();
  var c = requireBrowser$8();
  cryptoBrowserify.publicEncrypt = c.publicEncrypt, cryptoBrowserify.privateEncrypt = c.privateEncrypt, cryptoBrowserify.publicDecrypt = c.publicDecrypt, cryptoBrowserify.privateDecrypt = c.privateDecrypt;
  var f = requireBrowser$7();
  return cryptoBrowserify.randomFill = f.randomFill, cryptoBrowserify.randomFillSync = f.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var cryptoBrowserifyExports = requireCryptoBrowserify();
const crypto$1 = /* @__PURE__ */ getDefaultExportFromCjs(cryptoBrowserifyExports);
var empty = null;
const empty$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: empty
}, Symbol.toStringTag, { value: "Module" })), initRequire$3 = () => {
};
initRequire$3.resolve = () => "";
const require$4 = initRequire$3, createHash = (e, t = {}) => {
  const { length: r = 11, algorithm: a = "sha256" } = t;
  return crypto$1.createHash(a).update(e).digest("hex").slice(0, r);
}, useUserHashKey = (e) => createHash(`${e.Platform}:${e.UserId}`), createEventName = (e, t) => {
  let r = e;
  process$1.platform === "win32" && (r = r.replace(/\\/g, "/"));
  const a = r.split("/").filter((n) => n !== "");
  return a.pop(), `${t}:${a.join(":")}`;
}, stringToNumber = (e, t = 33) => {
  let r = 5381, a = e.length;
  for (; a; )
    r = r * t ^ e.charCodeAt(--a);
  return r >>> 0;
}, getRecursiveDirFiles = (e, t = (r) => fileSuffixResponse.test(r.name)) => {
  let r = [];
  if (!existsSync(e))
    return r;
}, showErrorModule = (e) => {
  if (!e)
    return;
  if (/Cannot find (module|package)/.test(e?.message)) {
    const r = e.stack?.match(/'(.+?)'/);
    if (r) {
      const a = r[1];
      logger.error({
        code: ResultCode.FailInternal,
        message: `缺少模块或依赖 ${a},请安装`,
        data: null
      });
      return;
    }
  }
  logger.error({
    code: ResultCode.FailInternal,
    message: e?.message,
    data: e
  });
}, createExports = (e) => {
  if (e?.exports) {
    if (typeof e.exports == "string")
      return e.exports;
    if (typeof e.exports == "object")
      return e.exports["."] || e.exports["./index.js"];
  }
}, getInputExportPath = (e) => {
  const t = path.join(e ?? process$1.cwd(), "package.json");
  if (fs.existsSync(t)) {
    const r = require$4(t), a = r?.main || createExports(r);
    if (a)
      return a;
  }
}, createResult = (e, t, r) => (e !== ResultCode.Ok && logger.error({
  code: e,
  message: t,
  data: r
}), {
  code: e,
  message: t,
  data: r
});
var browser$6, hasRequiredBrowser$6;
function requireBrowser$6() {
  return hasRequiredBrowser$6 || (hasRequiredBrowser$6 = 1, browser$6 = function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  }), browser$6;
}
var browserExports = requireBrowser$6();
const { parse: $parse, stringify: $stringify } = JSON, { keys: keys$1 } = Object, Primitive = String, primitive = "string", ignore = {}, object = "object", noop = (e, t) => t, primitives = (e) => e instanceof Primitive ? Primitive(e) : e, Primitives = (e, t) => typeof t === primitive ? new Primitive(t) : t, revive = (e, t, r, a) => {
  const u = [];
  for (let n = keys$1(r), { length: o } = n, c = 0; c < o; c++) {
    const f = n[c], l = r[f];
    if (l instanceof Primitive) {
      const s = e[l];
      typeof s === object && !t.has(s) ? (t.add(s), r[f] = ignore, u.push({ k: f, a: [e, t, s, a] })) : r[f] = a.call(r, f, s);
    } else r[f] !== ignore && (r[f] = a.call(r, f, l));
  }
  for (let { length: n } = u, o = 0; o < n; o++) {
    const { k: c, a: f } = u[o];
    r[c] = a.call(r, c, revive.apply(null, f));
  }
  return r;
}, set = (e, t, r) => {
  const a = Primitive(t.push(r) - 1);
  return e.set(r, a), a;
}, parse$2 = (e, t) => {
  const r = $parse(e, Primitives).map(primitives), a = r[0], u = noop, n = typeof a === object && a ? revive(r, /* @__PURE__ */ new Set(), a, u) : a;
  return u.call({ "": n }, "", n);
}, stringify = (e, t, r) => {
  const a = noop, u = /* @__PURE__ */ new Map(), n = [], o = [];
  let c = +set(u, n, a.call({ "": e }, "", e)), f = !c;
  for (; c < n.length; )
    f = !0, o[c] = $stringify(n[c++], l, r);
  return "[" + o.join(",") + "]";
  function l(s, p) {
    if (f)
      return f = !f, p;
    const m = a.call(this, s, p);
    switch (typeof m) {
      case object:
        if (m === null) return m;
      case primitive:
        return u.get(m) || set(u, n, m);
    }
    return m;
  }
};
class ListNode {
  data;
  // 节点数据
  next;
  // 指向下一个节点的指针
  constructor(t) {
    this.data = t, this.next = null;
  }
}
class SinglyLinkedList {
  head;
  // 链表的头节点
  size;
  // 链表的大小
  current;
  // 当前节点指针
  constructor(t) {
    this.head = null, this.size = 0, this.current = null, t && t.forEach((r) => this.append(r));
  }
  // 在链表末尾添加新节点
  append(t) {
    const r = new ListNode(t);
    if (!this.head)
      this.head = r;
    else {
      let a = this.head;
      for (; a.next; )
        a = a.next;
      a.next = r;
    }
    this.size++;
  }
  // 获取下一个节点并移动指针
  popNext() {
    return this.current ? this.current = this.current.next : this.current = this.head, this.current;
  }
  // 删除当前节点
  removeCurrent() {
    if (!this.head)
      return;
    if (this.current === this.head) {
      this.head = this.head.next, this.current = null, this.size--;
      return;
    }
    let t = this.head;
    for (; t && t.next !== this.current; )
      t = t.next;
    t && this.current && (t.next = this.current.next, this.current = null, this.size--);
  }
  // 获取链表的大小
  getSize() {
    return this.size;
  }
}
var browser$5 = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var e = 1e3, t = e * 60, r = t * 60, a = r * 24, u = a * 7, n = a * 365.25;
  ms = function(s, p) {
    p = p || {};
    var m = typeof s;
    if (m === "string" && s.length > 0)
      return o(s);
    if (m === "number" && isFinite(s))
      return p.long ? f(s) : c(s);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(s)
    );
  };
  function o(s) {
    if (s = String(s), !(s.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        s
      );
      if (p) {
        var m = parseFloat(p[1]), g = (p[2] || "ms").toLowerCase();
        switch (g) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return m * n;
          case "weeks":
          case "week":
          case "w":
            return m * u;
          case "days":
          case "day":
          case "d":
            return m * a;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return m * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return m * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return m * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return m;
          default:
            return;
        }
      }
    }
  }
  function c(s) {
    var p = Math.abs(s);
    return p >= a ? Math.round(s / a) + "d" : p >= r ? Math.round(s / r) + "h" : p >= t ? Math.round(s / t) + "m" : p >= e ? Math.round(s / e) + "s" : s + "ms";
  }
  function f(s) {
    var p = Math.abs(s);
    return p >= a ? l(s, p, a, "day") : p >= r ? l(s, p, r, "hour") : p >= t ? l(s, p, t, "minute") : p >= e ? l(s, p, e, "second") : s + " ms";
  }
  function l(s, p, m, g) {
    var y = p >= m * 1.5;
    return Math.round(s / m) + " " + g + (y ? "s" : "");
  }
  return ms;
}
var common$2, hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  function e(t) {
    a.debug = a, a.default = a, a.coerce = l, a.disable = c, a.enable = n, a.enabled = f, a.humanize = requireMs(), a.destroy = s, Object.keys(t).forEach((p) => {
      a[p] = t[p];
    }), a.names = [], a.skips = [], a.formatters = {};
    function r(p) {
      let m = 0;
      for (let g = 0; g < p.length; g++)
        m = (m << 5) - m + p.charCodeAt(g), m |= 0;
      return a.colors[Math.abs(m) % a.colors.length];
    }
    a.selectColor = r;
    function a(p) {
      let m, g = null, y, v;
      function E(...b) {
        if (!E.enabled)
          return;
        const q = E, O = Number(/* @__PURE__ */ new Date()), j = O - (m || O);
        q.diff = j, q.prev = m, q.curr = O, m = O, b[0] = a.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
        let D = 0;
        b[0] = b[0].replace(/%([a-zA-Z%])/g, (V, Q) => {
          if (V === "%%")
            return "%";
          D++;
          const re = a.formatters[Q];
          if (typeof re == "function") {
            const ve = b[D];
            V = re.call(q, ve), b.splice(D, 1), D--;
          }
          return V;
        }), a.formatArgs.call(q, b), (q.log || a.log).apply(q, b);
      }
      return E.namespace = p, E.useColors = a.useColors(), E.color = a.selectColor(p), E.extend = u, E.destroy = a.destroy, Object.defineProperty(E, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => g !== null ? g : (y !== a.namespaces && (y = a.namespaces, v = a.enabled(p)), v),
        set: (b) => {
          g = b;
        }
      }), typeof a.init == "function" && a.init(E), E;
    }
    function u(p, m) {
      const g = a(this.namespace + (typeof m > "u" ? ":" : m) + p);
      return g.log = this.log, g;
    }
    function n(p) {
      a.save(p), a.namespaces = p, a.names = [], a.skips = [];
      const m = (typeof p == "string" ? p : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const g of m)
        g[0] === "-" ? a.skips.push(g.slice(1)) : a.names.push(g);
    }
    function o(p, m) {
      let g = 0, y = 0, v = -1, E = 0;
      for (; g < p.length; )
        if (y < m.length && (m[y] === p[g] || m[y] === "*"))
          m[y] === "*" ? (v = y, E = g, y++) : (g++, y++);
        else if (v !== -1)
          y = v + 1, E++, g = E;
        else
          return !1;
      for (; y < m.length && m[y] === "*"; )
        y++;
      return y === m.length;
    }
    function c() {
      const p = [
        ...a.names,
        ...a.skips.map((m) => "-" + m)
      ].join(",");
      return a.enable(""), p;
    }
    function f(p) {
      for (const m of a.skips)
        if (o(p, m))
          return !1;
      for (const m of a.names)
        if (o(p, m))
          return !0;
      return !1;
    }
    function l(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    function s() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return a.enable(a.load()), a;
  }
  return common$2 = e, common$2;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  return hasRequiredBrowser$5 || (hasRequiredBrowser$5 = 1, (function(e, t) {
    t.formatArgs = a, t.save = u, t.load = n, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
      let f = !1;
      return () => {
        f || (f = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof globalThis < "u" && globalThis.process && (globalThis.process.type === "renderer" || globalThis.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let f;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof globalThis < "u" && globalThis.console && (globalThis.console.firebug || globalThis.console.exception && globalThis.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (f = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(f[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function a(f) {
      if (f[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + f[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const l = "color: " + this.color;
      f.splice(1, 0, l, "color: inherit");
      let s = 0, p = 0;
      f[0].replace(/%[a-zA-Z%]/g, (m) => {
        m !== "%%" && (s++, m === "%c" && (p = s));
      }), f.splice(p, 0, l);
    }
    t.log = console.debug || console.log || (() => {
    });
    function u(f) {
      try {
        f ? t.storage.setItem("debug", f) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function n() {
      let f;
      try {
        f = t.storage.getItem("debug");
      } catch {
      }
      return !f && typeof process$1 < "u" && "env" in process$1 && (f = process$1.env.DEBUG), f;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = requireCommon$2()(t);
    const { formatters: c } = e.exports;
    c.j = function(f) {
      try {
        return JSON.stringify(f);
      } catch (l) {
        return "[UnexpectedJSONParseError]: " + l.message;
      }
    };
  })(browser$5, browser$5.exports)), browser$5.exports;
}
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(fs$1);
var rfdc_1, hasRequiredRfdc;
function requireRfdc() {
  if (hasRequiredRfdc) return rfdc_1;
  hasRequiredRfdc = 1, rfdc_1 = t;
  function e(a) {
    return a instanceof Buffer ? Buffer.from(a) : new a.constructor(a.buffer.slice(), a.byteOffset, a.length);
  }
  function t(a) {
    if (a = a || {}, a.circles) return r(a);
    const u = /* @__PURE__ */ new Map();
    if (u.set(Date, (l) => new Date(l)), u.set(Map, (l, s) => new Map(o(Array.from(l), s))), u.set(Set, (l, s) => new Set(o(Array.from(l), s))), a.constructorHandlers)
      for (const l of a.constructorHandlers)
        u.set(l[0], l[1]);
    let n = null;
    return a.proto ? f : c;
    function o(l, s) {
      const p = Object.keys(l), m = new Array(p.length);
      for (let g = 0; g < p.length; g++) {
        const y = p[g], v = l[y];
        typeof v != "object" || v === null ? m[y] = v : v.constructor !== Object && (n = u.get(v.constructor)) ? m[y] = n(v, s) : ArrayBuffer.isView(v) ? m[y] = e(v) : m[y] = s(v);
      }
      return m;
    }
    function c(l) {
      if (typeof l != "object" || l === null) return l;
      if (Array.isArray(l)) return o(l, c);
      if (l.constructor !== Object && (n = u.get(l.constructor)))
        return n(l, c);
      const s = {};
      for (const p in l) {
        if (Object.hasOwnProperty.call(l, p) === !1) continue;
        const m = l[p];
        typeof m != "object" || m === null ? s[p] = m : m.constructor !== Object && (n = u.get(m.constructor)) ? s[p] = n(m, c) : ArrayBuffer.isView(m) ? s[p] = e(m) : s[p] = c(m);
      }
      return s;
    }
    function f(l) {
      if (typeof l != "object" || l === null) return l;
      if (Array.isArray(l)) return o(l, f);
      if (l.constructor !== Object && (n = u.get(l.constructor)))
        return n(l, f);
      const s = {};
      for (const p in l) {
        const m = l[p];
        typeof m != "object" || m === null ? s[p] = m : m.constructor !== Object && (n = u.get(m.constructor)) ? s[p] = n(m, f) : ArrayBuffer.isView(m) ? s[p] = e(m) : s[p] = f(m);
      }
      return s;
    }
  }
  function r(a) {
    const u = [], n = [], o = /* @__PURE__ */ new Map();
    if (o.set(Date, (p) => new Date(p)), o.set(Map, (p, m) => new Map(f(Array.from(p), m))), o.set(Set, (p, m) => new Set(f(Array.from(p), m))), a.constructorHandlers)
      for (const p of a.constructorHandlers)
        o.set(p[0], p[1]);
    let c = null;
    return a.proto ? s : l;
    function f(p, m) {
      const g = Object.keys(p), y = new Array(g.length);
      for (let v = 0; v < g.length; v++) {
        const E = g[v], b = p[E];
        if (typeof b != "object" || b === null)
          y[E] = b;
        else if (b.constructor !== Object && (c = o.get(b.constructor)))
          y[E] = c(b, m);
        else if (ArrayBuffer.isView(b))
          y[E] = e(b);
        else {
          const q = u.indexOf(b);
          q !== -1 ? y[E] = n[q] : y[E] = m(b);
        }
      }
      return y;
    }
    function l(p) {
      if (typeof p != "object" || p === null) return p;
      if (Array.isArray(p)) return f(p, l);
      if (p.constructor !== Object && (c = o.get(p.constructor)))
        return c(p, l);
      const m = {};
      u.push(p), n.push(m);
      for (const g in p) {
        if (Object.hasOwnProperty.call(p, g) === !1) continue;
        const y = p[g];
        if (typeof y != "object" || y === null)
          m[g] = y;
        else if (y.constructor !== Object && (c = o.get(y.constructor)))
          m[g] = c(y, l);
        else if (ArrayBuffer.isView(y))
          m[g] = e(y);
        else {
          const v = u.indexOf(y);
          v !== -1 ? m[g] = n[v] : m[g] = l(y);
        }
      }
      return u.pop(), n.pop(), m;
    }
    function s(p) {
      if (typeof p != "object" || p === null) return p;
      if (Array.isArray(p)) return f(p, s);
      if (p.constructor !== Object && (c = o.get(p.constructor)))
        return c(p, s);
      const m = {};
      u.push(p), n.push(m);
      for (const g in p) {
        const y = p[g];
        if (typeof y != "object" || y === null)
          m[g] = y;
        else if (y.constructor !== Object && (c = o.get(y.constructor)))
          m[g] = c(y, s);
        else if (ArrayBuffer.isView(y))
          m[g] = e(y);
        else {
          const v = u.indexOf(y);
          v !== -1 ? m[g] = n[v] : m[g] = s(y);
        }
      }
      return u.pop(), n.pop(), m;
    }
  }
  return rfdc_1;
}
var configuration, hasRequiredConfiguration;
function requireConfiguration() {
  if (hasRequiredConfiguration) return configuration;
  hasRequiredConfiguration = 1;
  const e = requireUtil(), t = requireBrowser$5()("log4js:configuration"), r = [], a = [], u = (m) => !m, n = (m) => m && typeof m == "object" && !Array.isArray(m), o = (m) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(m), c = (m) => m && typeof m == "number" && Number.isInteger(m), f = (m) => {
    a.push(m), t(`Added listener, now ${a.length} listeners`);
  }, l = (m) => {
    r.push(m), t(
      `Added pre-processing listener, now ${r.length} listeners`
    );
  }, s = (m, g, y) => {
    (Array.isArray(g) ? g : [g]).forEach((E) => {
      if (E)
        throw new Error(
          `Problem with log4js configuration: (${e.inspect(m, {
            depth: 5
          })}) - ${y}`
        );
    });
  };
  return configuration = {
    configure: (m) => {
      t("New configuration to be validated: ", m), s(m, u(n(m)), "must be an object."), t(`Calling pre-processing listeners (${r.length})`), r.forEach((g) => g(m)), t("Configuration pre-processing finished."), t(`Calling configuration listeners (${a.length})`), a.forEach((g) => g(m)), t("Configuration finished.");
    },
    addListener: f,
    addPreProcessingListener: l,
    throwExceptionIf: s,
    anObject: n,
    anInteger: c,
    validIdentifier: o,
    not: u
  }, configuration;
}
var lib$3 = { exports: {} }, hasRequiredLib$3;
function requireLib$3() {
  return hasRequiredLib$3 || (hasRequiredLib$3 = 1, (function(e) {
    function t(l, s) {
      for (var p = l.toString(); p.length < s; )
        p = "0" + p;
      return p;
    }
    function r(l) {
      return t(l, 2);
    }
    function a(l) {
      var s = Math.abs(l), p = String(Math.floor(s / 60)), m = String(s % 60);
      return p = ("0" + p).slice(-2), m = ("0" + m).slice(-2), l === 0 ? "Z" : (l < 0 ? "+" : "-") + p + ":" + m;
    }
    function u(l, s) {
      typeof l != "string" && (s = l, l = e.exports.ISO8601_FORMAT), s || (s = e.exports.now());
      var p = r(s.getDate()), m = r(s.getMonth() + 1), g = r(s.getFullYear()), y = r(g.substring(2, 4)), v = l.indexOf("yyyy") > -1 ? g : y, E = r(s.getHours()), b = r(s.getMinutes()), q = r(s.getSeconds()), O = t(s.getMilliseconds(), 3), j = a(s.getTimezoneOffset()), D = l.replace(/dd/g, p).replace(/MM/g, m).replace(/y{1,4}/g, v).replace(/hh/g, E).replace(/mm/g, b).replace(/ss/g, q).replace(/SSS/g, O).replace(/O/g, j);
      return D;
    }
    function n(l, s, p, m) {
      l["set" + (m ? "" : "UTC") + s](p);
    }
    function o(l, s, p) {
      var m = l.indexOf("O") < 0, g = !1, y = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(j, D) {
            n(j, "FullYear", D, m);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(j, D) {
            n(j, "Month", D - 1, m), j.getMonth() !== D - 1 && (g = !0);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(j, D) {
            g && n(j, "Month", j.getMonth() - 1, m), n(j, "Date", D, m);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(j, D) {
            n(j, "Hours", D, m);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(j, D) {
            n(j, "Minutes", D, m);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(j, D) {
            n(j, "Seconds", D, m);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(j, D) {
            n(j, "Milliseconds", D, m);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
          fn: function(j, D) {
            D === "Z" ? D = 0 : D = D.replace(":", "");
            var G = Math.abs(D), V = (D > 0 ? -1 : 1) * (G % 100 + Math.floor(G / 100) * 60);
            j.setUTCMinutes(j.getUTCMinutes() + V);
          }
        }
      ], v = y.reduce(
        function(j, D) {
          return D.pattern.test(j.regexp) ? (D.index = j.regexp.match(D.pattern).index, j.regexp = j.regexp.replace(D.pattern, "(" + D.regexp + ")")) : D.index = -1, j;
        },
        { regexp: l, index: [] }
      ), E = y.filter(function(j) {
        return j.index > -1;
      });
      E.sort(function(j, D) {
        return j.index - D.index;
      });
      var b = new RegExp(v.regexp), q = b.exec(s);
      if (q) {
        var O = p || e.exports.now();
        return E.forEach(function(j, D) {
          j.fn(O, q[D + 1]);
        }), O;
      }
      throw new Error(
        "String '" + s + "' could not be parsed as '" + l + "'"
      );
    }
    function c(l, s, p) {
      if (!l)
        throw new Error("pattern must be supplied");
      return o(l, s, p);
    }
    function f() {
      return /* @__PURE__ */ new Date();
    }
    e.exports = u, e.exports.asString = u, e.exports.parse = c, e.exports.now = f, e.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS", e.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO", e.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS", e.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  })(lib$3)), lib$3.exports;
}
var browser$4 = {}, hasRequiredBrowser$4;
function requireBrowser$4() {
  return hasRequiredBrowser$4 || (hasRequiredBrowser$4 = 1, browser$4.endianness = function() {
    return "LE";
  }, browser$4.hostname = function() {
    return typeof location < "u" ? location.hostname : "";
  }, browser$4.loadavg = function() {
    return [];
  }, browser$4.uptime = function() {
    return 0;
  }, browser$4.freemem = function() {
    return Number.MAX_VALUE;
  }, browser$4.totalmem = function() {
    return Number.MAX_VALUE;
  }, browser$4.cpus = function() {
    return [];
  }, browser$4.type = function() {
    return "Browser";
  }, browser$4.release = function() {
    return typeof navigator < "u" ? navigator.appVersion : "";
  }, browser$4.networkInterfaces = browser$4.getNetworkInterfaces = function() {
    return {};
  }, browser$4.arch = function() {
    return "javascript";
  }, browser$4.platform = function() {
    return "browser";
  }, browser$4.tmpdir = browser$4.tmpDir = function() {
    return "/tmp";
  }, browser$4.EOL = `
`, browser$4.homedir = function() {
    return "/";
  }), browser$4;
}
var punycode$2 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode$1 = punycode$2.exports, hasRequiredPunycode;
function requirePunycode() {
  return hasRequiredPunycode || (hasRequiredPunycode = 1, (function(e, t) {
    (function(r) {
      var a = t && !t.nodeType && t, u = e && !e.nodeType && e, n = typeof globalThis == "object" && globalThis;
      (n.global === n || n.window === n || n.self === n) && (r = n);
      var o, c = 2147483647, f = 36, l = 1, s = 26, p = 38, m = 700, g = 72, y = 128, v = "-", E = /^xn--/, b = /[^\x20-\x7E]/, q = /[\x2E\u3002\uFF0E\uFF61]/g, O = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, j = f - l, D = Math.floor, G = String.fromCharCode, V;
      function Q(C) {
        throw new RangeError(O[C]);
      }
      function re(C, $) {
        for (var w = C.length, U = []; w--; )
          U[w] = $(C[w]);
        return U;
      }
      function ve(C, $) {
        var w = C.split("@"), U = "";
        w.length > 1 && (U = w[0] + "@", C = w[1]), C = C.replace(q, ".");
        var ie = C.split("."), le = re(ie, $).join(".");
        return U + le;
      }
      function te(C) {
        for (var $ = [], w = 0, U = C.length, ie, le; w < U; )
          ie = C.charCodeAt(w++), ie >= 55296 && ie <= 56319 && w < U ? (le = C.charCodeAt(w++), (le & 64512) == 56320 ? $.push(((ie & 1023) << 10) + (le & 1023) + 65536) : ($.push(ie), w--)) : $.push(ie);
        return $;
      }
      function R(C) {
        return re(C, function($) {
          var w = "";
          return $ > 65535 && ($ -= 65536, w += G($ >>> 10 & 1023 | 55296), $ = 56320 | $ & 1023), w += G($), w;
        }).join("");
      }
      function M(C) {
        return C - 48 < 10 ? C - 22 : C - 65 < 26 ? C - 65 : C - 97 < 26 ? C - 97 : f;
      }
      function h(C, $) {
        return C + 22 + 75 * (C < 26) - (($ != 0) << 5);
      }
      function S(C, $, w) {
        var U = 0;
        for (C = w ? D(C / m) : C >> 1, C += D(C / $); C > j * s >> 1; U += f)
          C = D(C / j);
        return D(U + (j + 1) * C / (C + p));
      }
      function B(C) {
        var $ = [], w = C.length, U, ie = 0, le = y, ee = g, F, z, se, he, ae, X, be, Re, Pe;
        for (F = C.lastIndexOf(v), F < 0 && (F = 0), z = 0; z < F; ++z)
          C.charCodeAt(z) >= 128 && Q("not-basic"), $.push(C.charCodeAt(z));
        for (se = F > 0 ? F + 1 : 0; se < w; ) {
          for (he = ie, ae = 1, X = f; se >= w && Q("invalid-input"), be = M(C.charCodeAt(se++)), (be >= f || be > D((c - ie) / ae)) && Q("overflow"), ie += be * ae, Re = X <= ee ? l : X >= ee + s ? s : X - ee, !(be < Re); X += f)
            Pe = f - Re, ae > D(c / Pe) && Q("overflow"), ae *= Pe;
          U = $.length + 1, ee = S(ie - he, U, he == 0), D(ie / U) > c - le && Q("overflow"), le += D(ie / U), ie %= U, $.splice(ie++, 0, le);
        }
        return R($);
      }
      function T(C) {
        var $, w, U, ie, le, ee, F, z, se, he, ae, X = [], be, Re, Pe, Fe;
        for (C = te(C), be = C.length, $ = y, w = 0, le = g, ee = 0; ee < be; ++ee)
          ae = C[ee], ae < 128 && X.push(G(ae));
        for (U = ie = X.length, ie && X.push(v); U < be; ) {
          for (F = c, ee = 0; ee < be; ++ee)
            ae = C[ee], ae >= $ && ae < F && (F = ae);
          for (Re = U + 1, F - $ > D((c - w) / Re) && Q("overflow"), w += (F - $) * Re, $ = F, ee = 0; ee < be; ++ee)
            if (ae = C[ee], ae < $ && ++w > c && Q("overflow"), ae == $) {
              for (z = w, se = f; he = se <= le ? l : se >= le + s ? s : se - le, !(z < he); se += f)
                Fe = z - he, Pe = f - he, X.push(
                  G(h(he + Fe % Pe, 0))
                ), z = D(Fe / Pe);
              X.push(G(h(z, 0))), le = S(w, Re, U == ie), w = 0, ++U;
            }
          ++w, ++$;
        }
        return X.join("");
      }
      function k(C) {
        return ve(C, function($) {
          return E.test($) ? B($.slice(4).toLowerCase()) : $;
        });
      }
      function I(C) {
        return ve(C, function($) {
          return b.test($) ? "xn--" + T($) : $;
        });
      }
      if (o = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: te,
          encode: R
        },
        decode: B,
        encode: T,
        toASCII: I,
        toUnicode: k
      }, a && u)
        if (e.exports == a)
          u.exports = o;
        else
          for (V in o)
            o.hasOwnProperty(V) && (a[V] = o[V]);
      else
        r.punycode = o;
    })(punycode$1);
  })(punycode$2, punycode$2.exports)), punycode$2.exports;
}
var punycodeExports = requirePunycode();
const require$$0$6 = /* @__PURE__ */ getDefaultExportFromCjs(punycodeExports), __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$4 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var objectInspect, hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var e = typeof Map == "function" && Map.prototype, t = Object.getOwnPropertyDescriptor && e ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, r = e && t && typeof t.get == "function" ? t.get : null, a = e && Map.prototype.forEach, u = typeof Set == "function" && Set.prototype, n = Object.getOwnPropertyDescriptor && u ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, o = u && n && typeof n.get == "function" ? n.get : null, c = u && Set.prototype.forEach, f = typeof WeakMap == "function" && WeakMap.prototype, l = f ? WeakMap.prototype.has : null, s = typeof WeakSet == "function" && WeakSet.prototype, p = s ? WeakSet.prototype.has : null, m = typeof WeakRef == "function" && WeakRef.prototype, g = m ? WeakRef.prototype.deref : null, y = Boolean.prototype.valueOf, v = Object.prototype.toString, E = Function.prototype.toString, b = String.prototype.match, q = String.prototype.slice, O = String.prototype.replace, j = String.prototype.toUpperCase, D = String.prototype.toLowerCase, G = RegExp.prototype.test, V = Array.prototype.concat, Q = Array.prototype.join, re = Array.prototype.slice, ve = Math.floor, te = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, R = Object.getOwnPropertySymbols, M = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, h = typeof Symbol == "function" && typeof Symbol.iterator == "object", S = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === h || !0) ? Symbol.toStringTag : null, B = Object.prototype.propertyIsEnumerable, T = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(ce) {
    return ce.__proto__;
  } : null);
  function k(ce, Y) {
    if (ce === 1 / 0 || ce === -1 / 0 || ce !== ce || ce && ce > -1e3 && ce < 1e3 || G.call(/e/, Y))
      return Y;
    var Te = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof ce == "number") {
      var Ne = ce < 0 ? -ve(-ce) : ve(ce);
      if (Ne !== ce) {
        var K = String(Ne), Se = q.call(Y, K.length + 1);
        return O.call(K, Te, "$&_") + "." + O.call(O.call(Se, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return O.call(Y, Te, "$&_");
  }
  var I = require$$4, C = I.custom, $ = Re(C) ? C : null, w = {
    __proto__: null,
    double: '"',
    single: "'"
  }, U = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function ce(Y, Te, Ne, K) {
    var Se = Te || {};
    if (De(Se, "quoteStyle") && !De(w, Se.quoteStyle))
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (De(Se, "maxStringLength") && (typeof Se.maxStringLength == "number" ? Se.maxStringLength < 0 && Se.maxStringLength !== 1 / 0 : Se.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var Ce = De(Se, "customInspect") ? Se.customInspect : !0;
    if (typeof Ce != "boolean" && Ce !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (De(Se, "indent") && Se.indent !== null && Se.indent !== "	" && !(parseInt(Se.indent, 10) === Se.indent && Se.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (De(Se, "numericSeparator") && typeof Se.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var de = Se.numericSeparator;
    if (typeof Y > "u")
      return "undefined";
    if (Y === null)
      return "null";
    if (typeof Y == "boolean")
      return Y ? "true" : "false";
    if (typeof Y == "string")
      return Ue(Y, Se);
    if (typeof Y == "number") {
      if (Y === 0)
        return 1 / 0 / Y > 0 ? "0" : "-0";
      var _e = String(Y);
      return de ? k(Y, _e) : _e;
    }
    if (typeof Y == "bigint") {
      var Me = String(Y) + "n";
      return de ? k(Y, Me) : Me;
    }
    var tt = typeof Se.depth > "u" ? 5 : Se.depth;
    if (typeof Ne > "u" && (Ne = 0), Ne >= tt && tt > 0 && typeof Y == "object")
      return F(Y) ? "[Array]" : "[Object]";
    var We = ue(Se, Ne);
    if (typeof K > "u")
      K = [];
    else if (rt(K, Y) >= 0)
      return "[Circular]";
    function ne(Lt, Dt, Yt) {
      if (Dt && (K = re.call(K), K.push(Dt)), Yt) {
        var Kt = {
          depth: Se.depth
        };
        return De(Se, "quoteStyle") && (Kt.quoteStyle = Se.quoteStyle), ce(Lt, Kt, Ne + 1, K);
      }
      return ce(Lt, Se, Ne + 1, K);
    }
    if (typeof Y == "function" && !se(Y)) {
      var W = Oe(Y), J = pe(Y, ne);
      return "[Function" + (W ? ": " + W : " (anonymous)") + "]" + (J.length > 0 ? " { " + Q.call(J, ", ") + " }" : "");
    }
    if (Re(Y)) {
      var me = h ? O.call(String(Y), /^(Symbol\(.*\))_[^)]*$/, "$1") : M.call(Y);
      return typeof Y == "object" && !h ? Xe(me) : me;
    }
    if (ze(Y)) {
      for (var Ee = "<" + D.call(String(Y.nodeName)), ke = Y.attributes || [], Ie = 0; Ie < ke.length; Ie++)
        Ee += " " + ke[Ie].name + "=" + ie(le(ke[Ie].value), "double", Se);
      return Ee += ">", Y.childNodes && Y.childNodes.length && (Ee += "..."), Ee += "</" + D.call(String(Y.nodeName)) + ">", Ee;
    }
    if (F(Y)) {
      if (Y.length === 0)
        return "[]";
      var at = pe(Y, ne);
      return We && !H(at) ? "[" + xe(at, We) + "]" : "[ " + Q.call(at, ", ") + " ]";
    }
    if (he(Y)) {
      var ot = pe(Y, ne);
      return !("cause" in Error.prototype) && "cause" in Y && !B.call(Y, "cause") ? "{ [" + String(Y) + "] " + Q.call(V.call("[cause]: " + ne(Y.cause), ot), ", ") + " }" : ot.length === 0 ? "[" + String(Y) + "]" : "{ [" + String(Y) + "] " + Q.call(ot, ", ") + " }";
    }
    if (typeof Y == "object" && Ce) {
      if ($ && typeof Y[$] == "function" && I)
        return I(Y, { depth: tt - Ne });
      if (Ce !== "symbol" && typeof Y.inspect == "function")
        return Y.inspect();
    }
    if (He(Y)) {
      var it = [];
      return a && a.call(Y, function(Lt, Dt) {
        it.push(ne(Dt, Y, !0) + " => " + ne(Lt, Y));
      }), L("Map", r.call(Y), it, We);
    }
    if (we(Y)) {
      var ct = [];
      return c && c.call(Y, function(Lt) {
        ct.push(ne(Lt, Y));
      }), L("Set", o.call(Y), ct, We);
    }
    if (Qe(Y))
      return oe("WeakMap");
    if (Ae(Y))
      return oe("WeakSet");
    if (Je(Y))
      return oe("WeakRef");
    if (X(Y))
      return Xe(ne(Number(Y)));
    if (Pe(Y))
      return Xe(ne(te.call(Y)));
    if (be(Y))
      return Xe(y.call(Y));
    if (ae(Y))
      return Xe(ne(String(Y)));
    if (typeof globalThis < "u" && Y === globalThis)
      return "{ [object Window] }";
    if (typeof globalThis < "u" && Y === globalThis || typeof globalThis < "u" && Y === globalThis)
      return "{ [object globalThis] }";
    if (!z(Y) && !se(Y)) {
      var nt = pe(Y, ne), st = T ? T(Y) === Object.prototype : Y instanceof Object || Y.constructor === Object, yt = Y instanceof Object ? "" : "null prototype", ft = !st && S && Object(Y) === Y && S in Y ? q.call(je(Y), 8, -1) : yt ? "Object" : "", dt = st || typeof Y.constructor != "function" ? "" : Y.constructor.name ? Y.constructor.name + " " : "", Ut = dt + (ft || yt ? "[" + Q.call(V.call([], ft || [], yt || []), ": ") + "] " : "");
      return nt.length === 0 ? Ut + "{}" : We ? Ut + "{" + xe(nt, We) + "}" : Ut + "{ " + Q.call(nt, ", ") + " }";
    }
    return String(Y);
  };
  function ie(ce, Y, Te) {
    var Ne = Te.quoteStyle || Y, K = w[Ne];
    return K + ce + K;
  }
  function le(ce) {
    return O.call(String(ce), /"/g, "&quot;");
  }
  function ee(ce) {
    return !S || !(typeof ce == "object" && (S in ce || typeof ce[S] < "u"));
  }
  function F(ce) {
    return je(ce) === "[object Array]" && ee(ce);
  }
  function z(ce) {
    return je(ce) === "[object Date]" && ee(ce);
  }
  function se(ce) {
    return je(ce) === "[object RegExp]" && ee(ce);
  }
  function he(ce) {
    return je(ce) === "[object Error]" && ee(ce);
  }
  function ae(ce) {
    return je(ce) === "[object String]" && ee(ce);
  }
  function X(ce) {
    return je(ce) === "[object Number]" && ee(ce);
  }
  function be(ce) {
    return je(ce) === "[object Boolean]" && ee(ce);
  }
  function Re(ce) {
    if (h)
      return ce && typeof ce == "object" && ce instanceof Symbol;
    if (typeof ce == "symbol")
      return !0;
    if (!ce || typeof ce != "object" || !M)
      return !1;
    try {
      return M.call(ce), !0;
    } catch {
    }
    return !1;
  }
  function Pe(ce) {
    if (!ce || typeof ce != "object" || !te)
      return !1;
    try {
      return te.call(ce), !0;
    } catch {
    }
    return !1;
  }
  var Fe = Object.prototype.hasOwnProperty || function(ce) {
    return ce in this;
  };
  function De(ce, Y) {
    return Fe.call(ce, Y);
  }
  function je(ce) {
    return v.call(ce);
  }
  function Oe(ce) {
    if (ce.name)
      return ce.name;
    var Y = b.call(E.call(ce), /^function\s*([\w$]+)/);
    return Y ? Y[1] : null;
  }
  function rt(ce, Y) {
    if (ce.indexOf)
      return ce.indexOf(Y);
    for (var Te = 0, Ne = ce.length; Te < Ne; Te++)
      if (ce[Te] === Y)
        return Te;
    return -1;
  }
  function He(ce) {
    if (!r || !ce || typeof ce != "object")
      return !1;
    try {
      r.call(ce);
      try {
        o.call(ce);
      } catch {
        return !0;
      }
      return ce instanceof Map;
    } catch {
    }
    return !1;
  }
  function Qe(ce) {
    if (!l || !ce || typeof ce != "object")
      return !1;
    try {
      l.call(ce, l);
      try {
        p.call(ce, p);
      } catch {
        return !0;
      }
      return ce instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function Je(ce) {
    if (!g || !ce || typeof ce != "object")
      return !1;
    try {
      return g.call(ce), !0;
    } catch {
    }
    return !1;
  }
  function we(ce) {
    if (!o || !ce || typeof ce != "object")
      return !1;
    try {
      o.call(ce);
      try {
        r.call(ce);
      } catch {
        return !0;
      }
      return ce instanceof Set;
    } catch {
    }
    return !1;
  }
  function Ae(ce) {
    if (!p || !ce || typeof ce != "object")
      return !1;
    try {
      p.call(ce, p);
      try {
        l.call(ce, l);
      } catch {
        return !0;
      }
      return ce instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function ze(ce) {
    return !ce || typeof ce != "object" ? !1 : typeof HTMLElement < "u" && ce instanceof HTMLElement ? !0 : typeof ce.nodeName == "string" && typeof ce.getAttribute == "function";
  }
  function Ue(ce, Y) {
    if (ce.length > Y.maxStringLength) {
      var Te = ce.length - Y.maxStringLength, Ne = "... " + Te + " more character" + (Te > 1 ? "s" : "");
      return Ue(q.call(ce, 0, Y.maxStringLength), Y) + Ne;
    }
    var K = U[Y.quoteStyle || "single"];
    K.lastIndex = 0;
    var Se = O.call(O.call(ce, K, "\\$1"), /[\x00-\x1f]/g, Ge);
    return ie(Se, "single", Y);
  }
  function Ge(ce) {
    var Y = ce.charCodeAt(0), Te = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[Y];
    return Te ? "\\" + Te : "\\x" + (Y < 16 ? "0" : "") + j.call(Y.toString(16));
  }
  function Xe(ce) {
    return "Object(" + ce + ")";
  }
  function oe(ce) {
    return ce + " { ? }";
  }
  function L(ce, Y, Te, Ne) {
    var K = Ne ? xe(Te, Ne) : Q.call(Te, ", ");
    return ce + " (" + Y + ") {" + K + "}";
  }
  function H(ce) {
    for (var Y = 0; Y < ce.length; Y++)
      if (rt(ce[Y], `
`) >= 0)
        return !1;
    return !0;
  }
  function ue(ce, Y) {
    var Te;
    if (ce.indent === "	")
      Te = "	";
    else if (typeof ce.indent == "number" && ce.indent > 0)
      Te = Q.call(Array(ce.indent + 1), " ");
    else
      return null;
    return {
      base: Te,
      prev: Q.call(Array(Y + 1), Te)
    };
  }
  function xe(ce, Y) {
    if (ce.length === 0)
      return "";
    var Te = `
` + Y.prev + Y.base;
    return Te + Q.call(ce, "," + Te) + `
` + Y.prev;
  }
  function pe(ce, Y) {
    var Te = F(ce), Ne = [];
    if (Te) {
      Ne.length = ce.length;
      for (var K = 0; K < ce.length; K++)
        Ne[K] = De(ce, K) ? Y(ce[K], ce) : "";
    }
    var Se = typeof R == "function" ? R(ce) : [], Ce;
    if (h) {
      Ce = {};
      for (var de = 0; de < Se.length; de++)
        Ce["$" + Se[de]] = Se[de];
    }
    for (var _e in ce)
      De(ce, _e) && (Te && String(Number(_e)) === _e && _e < ce.length || h && Ce["$" + _e] instanceof Symbol || (G.call(/[^\w$]/, _e) ? Ne.push(Y(_e, ce) + ": " + Y(ce[_e], ce)) : Ne.push(_e + ": " + Y(ce[_e], ce))));
    if (typeof R == "function")
      for (var Me = 0; Me < Se.length; Me++)
        B.call(ce, Se[Me]) && Ne.push("[" + Y(Se[Me]) + "]: " + Y(ce[Se[Me]], ce));
    return Ne;
  }
  return objectInspect;
}
var sideChannelList, hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var e = /* @__PURE__ */ requireObjectInspect(), t = /* @__PURE__ */ requireType(), r = function(c, f, l) {
    for (var s = c, p; (p = s.next) != null; s = p)
      if (p.key === f)
        return s.next = p.next, l || (p.next = /** @type {NonNullable<typeof list.next>} */
        c.next, c.next = p), p;
  }, a = function(c, f) {
    if (c) {
      var l = r(c, f);
      return l && l.value;
    }
  }, u = function(c, f, l) {
    var s = r(c, f);
    s ? s.value = l : c.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: f,
      next: c.next,
      value: l
    };
  }, n = function(c, f) {
    return c ? !!r(c, f) : !1;
  }, o = function(c, f) {
    if (c)
      return r(c, f, !0);
  };
  return sideChannelList = function() {
    var f, l = {
      assert: function(s) {
        if (!l.has(s))
          throw new t("Side channel does not contain " + e(s));
      },
      delete: function(s) {
        var p = f && f.next, m = o(f, s);
        return m && p && p === m && (f = void 0), !!m;
      },
      get: function(s) {
        return a(f, s);
      },
      has: function(s) {
        return n(f, s);
      },
      set: function(s, p) {
        f || (f = {
          next: void 0
        }), u(
          /** @type {NonNullable<typeof $o>} */
          f,
          s,
          p
        );
      }
    };
    return l;
  }, sideChannelList;
}
var sideChannelMap, hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var e = /* @__PURE__ */ requireGetIntrinsic(), t = /* @__PURE__ */ requireCallBound$1(), r = /* @__PURE__ */ requireObjectInspect(), a = /* @__PURE__ */ requireType(), u = e("%Map%", !0), n = t("Map.prototype.get", !0), o = t("Map.prototype.set", !0), c = t("Map.prototype.has", !0), f = t("Map.prototype.delete", !0), l = t("Map.prototype.size", !0);
  return sideChannelMap = !!u && /** @type {Exclude<import('.'), false>} */
  function() {
    var p, m = {
      assert: function(g) {
        if (!m.has(g))
          throw new a("Side channel does not contain " + r(g));
      },
      delete: function(g) {
        if (p) {
          var y = f(p, g);
          return l(p) === 0 && (p = void 0), y;
        }
        return !1;
      },
      get: function(g) {
        if (p)
          return n(p, g);
      },
      has: function(g) {
        return p ? c(p, g) : !1;
      },
      set: function(g, y) {
        p || (p = new u()), o(p, g, y);
      }
    };
    return m;
  }, sideChannelMap;
}
var sideChannelWeakmap, hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var e = /* @__PURE__ */ requireGetIntrinsic(), t = /* @__PURE__ */ requireCallBound$1(), r = /* @__PURE__ */ requireObjectInspect(), a = requireSideChannelMap(), u = /* @__PURE__ */ requireType(), n = e("%WeakMap%", !0), o = t("WeakMap.prototype.get", !0), c = t("WeakMap.prototype.set", !0), f = t("WeakMap.prototype.has", !0), l = t("WeakMap.prototype.delete", !0);
  return sideChannelWeakmap = n ? (
    /** @type {Exclude<import('.'), false>} */
    function() {
      var p, m, g = {
        assert: function(y) {
          if (!g.has(y))
            throw new u("Side channel does not contain " + r(y));
        },
        delete: function(y) {
          if (n && y && (typeof y == "object" || typeof y == "function")) {
            if (p)
              return l(p, y);
          } else if (a && m)
            return m.delete(y);
          return !1;
        },
        get: function(y) {
          return n && y && (typeof y == "object" || typeof y == "function") && p ? o(p, y) : m && m.get(y);
        },
        has: function(y) {
          return n && y && (typeof y == "object" || typeof y == "function") && p ? f(p, y) : !!m && m.has(y);
        },
        set: function(y, v) {
          n && y && (typeof y == "object" || typeof y == "function") ? (p || (p = new n()), c(p, y, v)) : a && (m || (m = a()), m.set(y, v));
        }
      };
      return g;
    }
  ) : a, sideChannelWeakmap;
}
var sideChannel, hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var e = /* @__PURE__ */ requireType(), t = /* @__PURE__ */ requireObjectInspect(), r = requireSideChannelList(), a = requireSideChannelMap(), u = requireSideChannelWeakmap(), n = u || a || r;
  return sideChannel = function() {
    var c, f = {
      assert: function(l) {
        if (!f.has(l))
          throw new e("Side channel does not contain " + t(l));
      },
      delete: function(l) {
        return !!c && c.delete(l);
      },
      get: function(l) {
        return c && c.get(l);
      },
      has: function(l) {
        return !!c && c.has(l);
      },
      set: function(l, s) {
        c || (c = n()), c.set(l, s);
      }
    };
    return f;
  }, sideChannel;
}
var formats, hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var e = String.prototype.replace, t = /%20/g, r = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return formats = {
    default: r.RFC3986,
    formatters: {
      RFC1738: function(a) {
        return e.call(a, t, "+");
      },
      RFC3986: function(a) {
        return String(a);
      }
    },
    RFC1738: r.RFC1738,
    RFC3986: r.RFC3986
  }, formats;
}
var utils, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var e = /* @__PURE__ */ requireFormats(), t = Object.prototype.hasOwnProperty, r = Array.isArray, a = (function() {
    for (var E = [], b = 0; b < 256; ++b)
      E.push("%" + ((b < 16 ? "0" : "") + b.toString(16)).toUpperCase());
    return E;
  })(), u = function(b) {
    for (; b.length > 1; ) {
      var q = b.pop(), O = q.obj[q.prop];
      if (r(O)) {
        for (var j = [], D = 0; D < O.length; ++D)
          typeof O[D] < "u" && j.push(O[D]);
        q.obj[q.prop] = j;
      }
    }
  }, n = function(b, q) {
    for (var O = q && q.plainObjects ? { __proto__: null } : {}, j = 0; j < b.length; ++j)
      typeof b[j] < "u" && (O[j] = b[j]);
    return O;
  }, o = function E(b, q, O) {
    if (!q)
      return b;
    if (typeof q != "object" && typeof q != "function") {
      if (r(b))
        b.push(q);
      else if (b && typeof b == "object")
        (O && (O.plainObjects || O.allowPrototypes) || !t.call(Object.prototype, q)) && (b[q] = !0);
      else
        return [b, q];
      return b;
    }
    if (!b || typeof b != "object")
      return [b].concat(q);
    var j = b;
    return r(b) && !r(q) && (j = n(b, O)), r(b) && r(q) ? (q.forEach(function(D, G) {
      if (t.call(b, G)) {
        var V = b[G];
        V && typeof V == "object" && D && typeof D == "object" ? b[G] = E(V, D, O) : b.push(D);
      } else
        b[G] = D;
    }), b) : Object.keys(q).reduce(function(D, G) {
      var V = q[G];
      return t.call(D, G) ? D[G] = E(D[G], V, O) : D[G] = V, D;
    }, j);
  }, c = function(b, q) {
    return Object.keys(q).reduce(function(O, j) {
      return O[j] = q[j], O;
    }, b);
  }, f = function(E, b, q) {
    var O = E.replace(/\+/g, " ");
    if (q === "iso-8859-1")
      return O.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(O);
    } catch {
      return O;
    }
  }, l = 1024, s = function(b, q, O, j, D) {
    if (b.length === 0)
      return b;
    var G = b;
    if (typeof b == "symbol" ? G = Symbol.prototype.toString.call(b) : typeof b != "string" && (G = String(b)), O === "iso-8859-1")
      return escape(G).replace(/%u[0-9a-f]{4}/gi, function(M) {
        return "%26%23" + parseInt(M.slice(2), 16) + "%3B";
      });
    for (var V = "", Q = 0; Q < G.length; Q += l) {
      for (var re = G.length >= l ? G.slice(Q, Q + l) : G, ve = [], te = 0; te < re.length; ++te) {
        var R = re.charCodeAt(te);
        if (R === 45 || R === 46 || R === 95 || R === 126 || R >= 48 && R <= 57 || R >= 65 && R <= 90 || R >= 97 && R <= 122 || D === e.RFC1738 && (R === 40 || R === 41)) {
          ve[ve.length] = re.charAt(te);
          continue;
        }
        if (R < 128) {
          ve[ve.length] = a[R];
          continue;
        }
        if (R < 2048) {
          ve[ve.length] = a[192 | R >> 6] + a[128 | R & 63];
          continue;
        }
        if (R < 55296 || R >= 57344) {
          ve[ve.length] = a[224 | R >> 12] + a[128 | R >> 6 & 63] + a[128 | R & 63];
          continue;
        }
        te += 1, R = 65536 + ((R & 1023) << 10 | re.charCodeAt(te) & 1023), ve[ve.length] = a[240 | R >> 18] + a[128 | R >> 12 & 63] + a[128 | R >> 6 & 63] + a[128 | R & 63];
      }
      V += ve.join("");
    }
    return V;
  }, p = function(b) {
    for (var q = [{ obj: { o: b }, prop: "o" }], O = [], j = 0; j < q.length; ++j)
      for (var D = q[j], G = D.obj[D.prop], V = Object.keys(G), Q = 0; Q < V.length; ++Q) {
        var re = V[Q], ve = G[re];
        typeof ve == "object" && ve !== null && O.indexOf(ve) === -1 && (q.push({ obj: G, prop: re }), O.push(ve));
      }
    return u(q), b;
  }, m = function(b) {
    return Object.prototype.toString.call(b) === "[object RegExp]";
  }, g = function(b) {
    return !b || typeof b != "object" ? !1 : !!(b.constructor && b.constructor.isBuffer && b.constructor.isBuffer(b));
  }, y = function(b, q) {
    return [].concat(b, q);
  }, v = function(b, q) {
    if (r(b)) {
      for (var O = [], j = 0; j < b.length; j += 1)
        O.push(q(b[j]));
      return O;
    }
    return q(b);
  };
  return utils = {
    arrayToObject: n,
    assign: c,
    combine: y,
    compact: p,
    decode: f,
    encode: s,
    isBuffer: g,
    isRegExp: m,
    maybeMap: v,
    merge: o
  }, utils;
}
var stringify_1, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var e = requireSideChannel(), t = /* @__PURE__ */ requireUtils(), r = /* @__PURE__ */ requireFormats(), a = Object.prototype.hasOwnProperty, u = {
    brackets: function(E) {
      return E + "[]";
    },
    comma: "comma",
    indices: function(E, b) {
      return E + "[" + b + "]";
    },
    repeat: function(E) {
      return E;
    }
  }, n = Array.isArray, o = Array.prototype.push, c = function(v, E) {
    o.apply(v, n(E) ? E : [E]);
  }, f = Date.prototype.toISOString, l = r.default, s = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: t.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: l,
    formatter: r.formatters[l],
    // deprecated
    indices: !1,
    serializeDate: function(E) {
      return f.call(E);
    },
    skipNulls: !1,
    strictNullHandling: !1
  }, p = function(E) {
    return typeof E == "string" || typeof E == "number" || typeof E == "boolean" || typeof E == "symbol" || typeof E == "bigint";
  }, m = {}, g = function v(E, b, q, O, j, D, G, V, Q, re, ve, te, R, M, h, S, B, T) {
    for (var k = E, I = T, C = 0, $ = !1; (I = I.get(m)) !== void 0 && !$; ) {
      var w = I.get(E);
      if (C += 1, typeof w < "u") {
        if (w === C)
          throw new RangeError("Cyclic object value");
        $ = !0;
      }
      typeof I.get(m) > "u" && (C = 0);
    }
    if (typeof re == "function" ? k = re(b, k) : k instanceof Date ? k = R(k) : q === "comma" && n(k) && (k = t.maybeMap(k, function(Pe) {
      return Pe instanceof Date ? R(Pe) : Pe;
    })), k === null) {
      if (D)
        return Q && !S ? Q(b, s.encoder, B, "key", M) : b;
      k = "";
    }
    if (p(k) || t.isBuffer(k)) {
      if (Q) {
        var U = S ? b : Q(b, s.encoder, B, "key", M);
        return [h(U) + "=" + h(Q(k, s.encoder, B, "value", M))];
      }
      return [h(b) + "=" + h(String(k))];
    }
    var ie = [];
    if (typeof k > "u")
      return ie;
    var le;
    if (q === "comma" && n(k))
      S && Q && (k = t.maybeMap(k, Q)), le = [{ value: k.length > 0 ? k.join(",") || null : void 0 }];
    else if (n(re))
      le = re;
    else {
      var ee = Object.keys(k);
      le = ve ? ee.sort(ve) : ee;
    }
    var F = V ? String(b).replace(/\./g, "%2E") : String(b), z = O && n(k) && k.length === 1 ? F + "[]" : F;
    if (j && n(k) && k.length === 0)
      return z + "[]";
    for (var se = 0; se < le.length; ++se) {
      var he = le[se], ae = typeof he == "object" && he && typeof he.value < "u" ? he.value : k[he];
      if (!(G && ae === null)) {
        var X = te && V ? String(he).replace(/\./g, "%2E") : String(he), be = n(k) ? typeof q == "function" ? q(z, X) : z : z + (te ? "." + X : "[" + X + "]");
        T.set(E, C);
        var Re = e();
        Re.set(m, T), c(ie, v(
          ae,
          be,
          q,
          O,
          j,
          D,
          G,
          V,
          q === "comma" && S && n(k) ? null : Q,
          re,
          ve,
          te,
          R,
          M,
          h,
          S,
          B,
          Re
        ));
      }
    }
    return ie;
  }, y = function(E) {
    if (!E)
      return s;
    if (typeof E.allowEmptyArrays < "u" && typeof E.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof E.encodeDotInKeys < "u" && typeof E.encodeDotInKeys != "boolean")
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (E.encoder !== null && typeof E.encoder < "u" && typeof E.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var b = E.charset || s.charset;
    if (typeof E.charset < "u" && E.charset !== "utf-8" && E.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var q = r.default;
    if (typeof E.format < "u") {
      if (!a.call(r.formatters, E.format))
        throw new TypeError("Unknown format option provided.");
      q = E.format;
    }
    var O = r.formatters[q], j = s.filter;
    (typeof E.filter == "function" || n(E.filter)) && (j = E.filter);
    var D;
    if (E.arrayFormat in u ? D = E.arrayFormat : "indices" in E ? D = E.indices ? "indices" : "repeat" : D = s.arrayFormat, "commaRoundTrip" in E && typeof E.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var G = typeof E.allowDots > "u" ? E.encodeDotInKeys === !0 ? !0 : s.allowDots : !!E.allowDots;
    return {
      addQueryPrefix: typeof E.addQueryPrefix == "boolean" ? E.addQueryPrefix : s.addQueryPrefix,
      allowDots: G,
      allowEmptyArrays: typeof E.allowEmptyArrays == "boolean" ? !!E.allowEmptyArrays : s.allowEmptyArrays,
      arrayFormat: D,
      charset: b,
      charsetSentinel: typeof E.charsetSentinel == "boolean" ? E.charsetSentinel : s.charsetSentinel,
      commaRoundTrip: !!E.commaRoundTrip,
      delimiter: typeof E.delimiter > "u" ? s.delimiter : E.delimiter,
      encode: typeof E.encode == "boolean" ? E.encode : s.encode,
      encodeDotInKeys: typeof E.encodeDotInKeys == "boolean" ? E.encodeDotInKeys : s.encodeDotInKeys,
      encoder: typeof E.encoder == "function" ? E.encoder : s.encoder,
      encodeValuesOnly: typeof E.encodeValuesOnly == "boolean" ? E.encodeValuesOnly : s.encodeValuesOnly,
      filter: j,
      format: q,
      formatter: O,
      serializeDate: typeof E.serializeDate == "function" ? E.serializeDate : s.serializeDate,
      skipNulls: typeof E.skipNulls == "boolean" ? E.skipNulls : s.skipNulls,
      sort: typeof E.sort == "function" ? E.sort : null,
      strictNullHandling: typeof E.strictNullHandling == "boolean" ? E.strictNullHandling : s.strictNullHandling
    };
  };
  return stringify_1 = function(v, E) {
    var b = v, q = y(E), O, j;
    typeof q.filter == "function" ? (j = q.filter, b = j("", b)) : n(q.filter) && (j = q.filter, O = j);
    var D = [];
    if (typeof b != "object" || b === null)
      return "";
    var G = u[q.arrayFormat], V = G === "comma" && q.commaRoundTrip;
    O || (O = Object.keys(b)), q.sort && O.sort(q.sort);
    for (var Q = e(), re = 0; re < O.length; ++re) {
      var ve = O[re], te = b[ve];
      q.skipNulls && te === null || c(D, g(
        te,
        ve,
        G,
        V,
        q.allowEmptyArrays,
        q.strictNullHandling,
        q.skipNulls,
        q.encodeDotInKeys,
        q.encode ? q.encoder : null,
        q.filter,
        q.sort,
        q.allowDots,
        q.serializeDate,
        q.format,
        q.formatter,
        q.encodeValuesOnly,
        q.charset,
        Q
      ));
    }
    var R = D.join(q.delimiter), M = q.addQueryPrefix === !0 ? "?" : "";
    return q.charsetSentinel && (q.charset === "iso-8859-1" ? M += "utf8=%26%2310003%3B&" : M += "utf8=%E2%9C%93&"), R.length > 0 ? M + R : "";
  }, stringify_1;
}
var parse$1, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$1;
  hasRequiredParse = 1;
  var e = /* @__PURE__ */ requireUtils(), t = Object.prototype.hasOwnProperty, r = Array.isArray, a = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: e.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1,
    throwOnLimitExceeded: !1
  }, u = function(m) {
    return m.replace(/&#(\d+);/g, function(g, y) {
      return String.fromCharCode(parseInt(y, 10));
    });
  }, n = function(m, g, y) {
    if (m && typeof m == "string" && g.comma && m.indexOf(",") > -1)
      return m.split(",");
    if (g.throwOnLimitExceeded && y >= g.arrayLimit)
      throw new RangeError("Array limit exceeded. Only " + g.arrayLimit + " element" + (g.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return m;
  }, o = "utf8=%26%2310003%3B", c = "utf8=%E2%9C%93", f = function(g, y) {
    var v = { __proto__: null }, E = y.ignoreQueryPrefix ? g.replace(/^\?/, "") : g;
    E = E.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var b = y.parameterLimit === 1 / 0 ? void 0 : y.parameterLimit, q = E.split(
      y.delimiter,
      y.throwOnLimitExceeded ? b + 1 : b
    );
    if (y.throwOnLimitExceeded && q.length > b)
      throw new RangeError("Parameter limit exceeded. Only " + b + " parameter" + (b === 1 ? "" : "s") + " allowed.");
    var O = -1, j, D = y.charset;
    if (y.charsetSentinel)
      for (j = 0; j < q.length; ++j)
        q[j].indexOf("utf8=") === 0 && (q[j] === c ? D = "utf-8" : q[j] === o && (D = "iso-8859-1"), O = j, j = q.length);
    for (j = 0; j < q.length; ++j)
      if (j !== O) {
        var G = q[j], V = G.indexOf("]="), Q = V === -1 ? G.indexOf("=") : V + 1, re, ve;
        Q === -1 ? (re = y.decoder(G, a.decoder, D, "key"), ve = y.strictNullHandling ? null : "") : (re = y.decoder(G.slice(0, Q), a.decoder, D, "key"), ve = e.maybeMap(
          n(
            G.slice(Q + 1),
            y,
            r(v[re]) ? v[re].length : 0
          ),
          function(R) {
            return y.decoder(R, a.decoder, D, "value");
          }
        )), ve && y.interpretNumericEntities && D === "iso-8859-1" && (ve = u(String(ve))), G.indexOf("[]=") > -1 && (ve = r(ve) ? [ve] : ve);
        var te = t.call(v, re);
        te && y.duplicates === "combine" ? v[re] = e.combine(v[re], ve) : (!te || y.duplicates === "last") && (v[re] = ve);
      }
    return v;
  }, l = function(m, g, y, v) {
    var E = 0;
    if (m.length > 0 && m[m.length - 1] === "[]") {
      var b = m.slice(0, -1).join("");
      E = Array.isArray(g) && g[b] ? g[b].length : 0;
    }
    for (var q = v ? g : n(g, y, E), O = m.length - 1; O >= 0; --O) {
      var j, D = m[O];
      if (D === "[]" && y.parseArrays)
        j = y.allowEmptyArrays && (q === "" || y.strictNullHandling && q === null) ? [] : e.combine([], q);
      else {
        j = y.plainObjects ? { __proto__: null } : {};
        var G = D.charAt(0) === "[" && D.charAt(D.length - 1) === "]" ? D.slice(1, -1) : D, V = y.decodeDotInKeys ? G.replace(/%2E/g, ".") : G, Q = parseInt(V, 10);
        !y.parseArrays && V === "" ? j = { 0: q } : !isNaN(Q) && D !== V && String(Q) === V && Q >= 0 && y.parseArrays && Q <= y.arrayLimit ? (j = [], j[Q] = q) : V !== "__proto__" && (j[V] = q);
      }
      q = j;
    }
    return q;
  }, s = function(g, y, v, E) {
    if (g) {
      var b = v.allowDots ? g.replace(/\.([^.[]+)/g, "[$1]") : g, q = /(\[[^[\]]*])/, O = /(\[[^[\]]*])/g, j = v.depth > 0 && q.exec(b), D = j ? b.slice(0, j.index) : b, G = [];
      if (D) {
        if (!v.plainObjects && t.call(Object.prototype, D) && !v.allowPrototypes)
          return;
        G.push(D);
      }
      for (var V = 0; v.depth > 0 && (j = O.exec(b)) !== null && V < v.depth; ) {
        if (V += 1, !v.plainObjects && t.call(Object.prototype, j[1].slice(1, -1)) && !v.allowPrototypes)
          return;
        G.push(j[1]);
      }
      if (j) {
        if (v.strictDepth === !0)
          throw new RangeError("Input depth exceeded depth option of " + v.depth + " and strictDepth is true");
        G.push("[" + b.slice(j.index) + "]");
      }
      return l(G, y, v, E);
    }
  }, p = function(g) {
    if (!g)
      return a;
    if (typeof g.allowEmptyArrays < "u" && typeof g.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof g.decodeDotInKeys < "u" && typeof g.decodeDotInKeys != "boolean")
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (g.decoder !== null && typeof g.decoder < "u" && typeof g.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof g.charset < "u" && g.charset !== "utf-8" && g.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof g.throwOnLimitExceeded < "u" && typeof g.throwOnLimitExceeded != "boolean")
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var y = typeof g.charset > "u" ? a.charset : g.charset, v = typeof g.duplicates > "u" ? a.duplicates : g.duplicates;
    if (v !== "combine" && v !== "first" && v !== "last")
      throw new TypeError("The duplicates option must be either combine, first, or last");
    var E = typeof g.allowDots > "u" ? g.decodeDotInKeys === !0 ? !0 : a.allowDots : !!g.allowDots;
    return {
      allowDots: E,
      allowEmptyArrays: typeof g.allowEmptyArrays == "boolean" ? !!g.allowEmptyArrays : a.allowEmptyArrays,
      allowPrototypes: typeof g.allowPrototypes == "boolean" ? g.allowPrototypes : a.allowPrototypes,
      allowSparse: typeof g.allowSparse == "boolean" ? g.allowSparse : a.allowSparse,
      arrayLimit: typeof g.arrayLimit == "number" ? g.arrayLimit : a.arrayLimit,
      charset: y,
      charsetSentinel: typeof g.charsetSentinel == "boolean" ? g.charsetSentinel : a.charsetSentinel,
      comma: typeof g.comma == "boolean" ? g.comma : a.comma,
      decodeDotInKeys: typeof g.decodeDotInKeys == "boolean" ? g.decodeDotInKeys : a.decodeDotInKeys,
      decoder: typeof g.decoder == "function" ? g.decoder : a.decoder,
      delimiter: typeof g.delimiter == "string" || e.isRegExp(g.delimiter) ? g.delimiter : a.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof g.depth == "number" || g.depth === !1 ? +g.depth : a.depth,
      duplicates: v,
      ignoreQueryPrefix: g.ignoreQueryPrefix === !0,
      interpretNumericEntities: typeof g.interpretNumericEntities == "boolean" ? g.interpretNumericEntities : a.interpretNumericEntities,
      parameterLimit: typeof g.parameterLimit == "number" ? g.parameterLimit : a.parameterLimit,
      parseArrays: g.parseArrays !== !1,
      plainObjects: typeof g.plainObjects == "boolean" ? g.plainObjects : a.plainObjects,
      strictDepth: typeof g.strictDepth == "boolean" ? !!g.strictDepth : a.strictDepth,
      strictNullHandling: typeof g.strictNullHandling == "boolean" ? g.strictNullHandling : a.strictNullHandling,
      throwOnLimitExceeded: typeof g.throwOnLimitExceeded == "boolean" ? g.throwOnLimitExceeded : !1
    };
  };
  return parse$1 = function(m, g) {
    var y = p(g);
    if (m === "" || m === null || typeof m > "u")
      return y.plainObjects ? { __proto__: null } : {};
    for (var v = typeof m == "string" ? f(m, y) : m, E = y.plainObjects ? { __proto__: null } : {}, b = Object.keys(v), q = 0; q < b.length; ++q) {
      var O = b[q], j = s(O, v[O], y, typeof m == "string");
      E = e.merge(E, j, y);
    }
    return y.allowSparse === !0 ? E : e.compact(E);
  }, parse$1;
}
var lib$2, hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var e = /* @__PURE__ */ requireStringify(), t = /* @__PURE__ */ requireParse(), r = /* @__PURE__ */ requireFormats();
  return lib$2 = {
    formats: r,
    parse: t,
    stringify: e
  }, lib$2;
}
var libExports = /* @__PURE__ */ requireLib$2();
const require$$1$1 = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
var punycode = require$$0$6;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  `
`,
  "	"
], unwise = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(autoEscape), hostEndingChars = [
  "/",
  "?",
  "#"
], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = require$$1$1;
function urlParse(e, t, r) {
  if (e && typeof e == "object" && e instanceof Url)
    return e;
  var a = new Url();
  return a.parse(e, t, r), a;
}
Url.prototype.parse = function(e, t, r) {
  if (typeof e != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
  var a = e.indexOf("?"), u = a !== -1 && a < e.indexOf("#") ? "?" : "#", n = e.split(u), o = /\\/g;
  n[0] = n[0].replace(o, "/"), e = n.join(u);
  var c = e;
  if (c = c.trim(), !r && e.split("#").length === 1) {
    var f = simplePathPattern.exec(c);
    if (f)
      return this.path = c, this.href = c, this.pathname = f[1], f[2] ? (this.search = f[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var l = protocolPattern.exec(c);
  if (l) {
    l = l[0];
    var s = l.toLowerCase();
    this.protocol = s, c = c.substr(l.length);
  }
  if (r || l || c.match(/^\/\/[^@/]+@[^@/]+/)) {
    var p = c.substr(0, 2) === "//";
    p && !(l && hostlessProtocol[l]) && (c = c.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[l] && (p || l && !slashedProtocol[l])) {
    for (var m = -1, g = 0; g < hostEndingChars.length; g++) {
      var y = c.indexOf(hostEndingChars[g]);
      y !== -1 && (m === -1 || y < m) && (m = y);
    }
    var v, E;
    m === -1 ? E = c.lastIndexOf("@") : E = c.lastIndexOf("@", m), E !== -1 && (v = c.slice(0, E), c = c.slice(E + 1), this.auth = decodeURIComponent(v)), m = -1;
    for (var g = 0; g < nonHostChars.length; g++) {
      var y = c.indexOf(nonHostChars[g]);
      y !== -1 && (m === -1 || y < m) && (m = y);
    }
    m === -1 && (m = c.length), this.host = c.slice(0, m), c = c.slice(m), this.parseHost(), this.hostname = this.hostname || "";
    var b = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!b)
      for (var q = this.hostname.split(/\./), g = 0, O = q.length; g < O; g++) {
        var j = q[g];
        if (j && !j.match(hostnamePartPattern)) {
          for (var D = "", G = 0, V = j.length; G < V; G++)
            j.charCodeAt(G) > 127 ? D += "x" : D += j[G];
          if (!D.match(hostnamePartPattern)) {
            var Q = q.slice(0, g), re = q.slice(g + 1), ve = j.match(hostnamePartStart);
            ve && (Q.push(ve[1]), re.unshift(ve[2])), re.length && (c = "/" + re.join(".") + c), this.hostname = Q.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), b || (this.hostname = punycode.toASCII(this.hostname));
    var te = this.port ? ":" + this.port : "", R = this.hostname || "";
    this.host = R + te, this.href += this.host, b && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), c[0] !== "/" && (c = "/" + c));
  }
  if (!unsafeProtocol[s])
    for (var g = 0, O = autoEscape.length; g < O; g++) {
      var M = autoEscape[g];
      if (c.indexOf(M) !== -1) {
        var h = encodeURIComponent(M);
        h === M && (h = escape(M)), c = c.split(M).join(h);
      }
    }
  var S = c.indexOf("#");
  S !== -1 && (this.hash = c.substr(S), c = c.slice(0, S));
  var B = c.indexOf("?");
  if (B !== -1 ? (this.search = c.substr(B), this.query = c.substr(B + 1), t && (this.query = querystring.parse(this.query)), c = c.slice(0, B)) : t && (this.search = "", this.query = {}), c && (this.pathname = c), slashedProtocol[s] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var te = this.pathname || "", T = this.search || "";
    this.path = te + T;
  }
  return this.href = this.format(), this;
};
function urlFormat(e) {
  return typeof e == "string" && (e = urlParse(e)), e instanceof Url ? e.format() : Url.prototype.format.call(e);
}
Url.prototype.format = function() {
  var e = this.auth || "";
  e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
  var t = this.protocol || "", r = this.pathname || "", a = this.hash || "", u = !1, n = "";
  this.host ? u = e + this.host : this.hostname && (u = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (u += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (n = querystring.stringify(this.query, {
    arrayFormat: "repeat",
    addQueryPrefix: !1
  }));
  var o = this.search || n && "?" + n || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && u !== !1 ? (u = "//" + (u || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : u || (u = ""), a && a.charAt(0) !== "#" && (a = "#" + a), o && o.charAt(0) !== "?" && (o = "?" + o), r = r.replace(/[?#]/g, function(c) {
    return encodeURIComponent(c);
  }), o = o.replace("#", "%23"), t + u + r + o + a;
};
function urlResolve(e, t) {
  return urlParse(e, !1, !0).resolve(t);
}
Url.prototype.resolve = function(e) {
  return this.resolveObject(urlParse(e, !1, !0)).format();
};
function urlResolveObject(e, t) {
  return e ? urlParse(e, !1, !0).resolveObject(t) : t;
}
Url.prototype.resolveObject = function(e) {
  if (typeof e == "string") {
    var t = new Url();
    t.parse(e, !1, !0), e = t;
  }
  for (var r = new Url(), a = Object.keys(this), u = 0; u < a.length; u++) {
    var n = a[u];
    r[n] = this[n];
  }
  if (r.hash = e.hash, e.href === "")
    return r.href = r.format(), r;
  if (e.slashes && !e.protocol) {
    for (var o = Object.keys(e), c = 0; c < o.length; c++) {
      var f = o[c];
      f !== "protocol" && (r[f] = e[f]);
    }
    return slashedProtocol[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
  }
  if (e.protocol && e.protocol !== r.protocol) {
    if (!slashedProtocol[e.protocol]) {
      for (var l = Object.keys(e), s = 0; s < l.length; s++) {
        var p = l[s];
        r[p] = e[p];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = e.protocol, !e.host && !hostlessProtocol[e.protocol]) {
      for (var O = (e.pathname || "").split("/"); O.length && !(e.host = O.shift()); )
        ;
      e.host || (e.host = ""), e.hostname || (e.hostname = ""), O[0] !== "" && O.unshift(""), O.length < 2 && O.unshift(""), r.pathname = O.join("/");
    } else
      r.pathname = e.pathname;
    if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
      var m = r.pathname || "", g = r.search || "";
      r.path = m + g;
    }
    return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
  }
  var y = r.pathname && r.pathname.charAt(0) === "/", v = e.host || e.pathname && e.pathname.charAt(0) === "/", E = v || y || r.host && e.pathname, b = E, q = r.pathname && r.pathname.split("/") || [], O = e.pathname && e.pathname.split("/") || [], j = r.protocol && !slashedProtocol[r.protocol];
  if (j && (r.hostname = "", r.port = null, r.host && (q[0] === "" ? q[0] = r.host : q.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (O[0] === "" ? O[0] = e.host : O.unshift(e.host)), e.host = null), E = E && (O[0] === "" || q[0] === "")), v)
    r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, q = O;
  else if (O.length)
    q || (q = []), q.pop(), q = q.concat(O), r.search = e.search, r.query = e.query;
  else if (e.search != null) {
    if (j) {
      r.host = q.shift(), r.hostname = r.host;
      var D = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      D && (r.auth = D.shift(), r.hostname = D.shift(), r.host = r.hostname);
    }
    return r.search = e.search, r.query = e.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!q.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var G = q.slice(-1)[0], V = (r.host || e.host || q.length > 1) && (G === "." || G === "..") || G === "", Q = 0, re = q.length; re >= 0; re--)
    G = q[re], G === "." ? q.splice(re, 1) : G === ".." ? (q.splice(re, 1), Q++) : Q && (q.splice(re, 1), Q--);
  if (!E && !b)
    for (; Q--; Q)
      q.unshift("..");
  E && q[0] !== "" && (!q[0] || q[0].charAt(0) !== "/") && q.unshift(""), V && q.join("/").substr(-1) !== "/" && q.push("");
  var ve = q[0] === "" || q[0] && q[0].charAt(0) === "/";
  if (j) {
    r.hostname = ve ? "" : q.length ? q.shift() : "", r.host = r.hostname;
    var D = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    D && (r.auth = D.shift(), r.hostname = D.shift(), r.host = r.hostname);
  }
  return E = E || r.host && q.length, E && !ve && q.unshift(""), q.length > 0 ? r.pathname = q.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
};
Url.prototype.parseHost = function() {
  var e = this.host, t = portPattern.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
var parse = urlParse, resolve$1 = urlResolve, resolveObject = urlResolveObject, format$1 = urlFormat, Url_1 = Url;
function normalizeArray(e, t) {
  for (var r = 0, a = e.length - 1; a >= 0; a--) {
    var u = e[a];
    u === "." ? e.splice(a, 1) : u === ".." ? (e.splice(a, 1), r++) : r && (e.splice(a, 1), r--);
  }
  if (t)
    for (; r--; r)
      e.unshift("..");
  return e;
}
function resolve() {
  for (var e = "", t = !1, r = arguments.length - 1; r >= -1 && !t; r--) {
    var a = r >= 0 ? arguments[r] : "/";
    if (typeof a != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!a)
      continue;
    e = a + "/" + e, t = a.charAt(0) === "/";
  }
  return e = normalizeArray(filter$1(e.split("/"), function(u) {
    return !!u;
  }), !t).join("/"), (t ? "/" : "") + e || ".";
}
function filter$1(e, t) {
  if (e.filter) return e.filter(t);
  for (var r = [], a = 0; a < e.length; a++)
    t(e[a], a, e) && r.push(e[a]);
  return r;
}
var _globalThis = (function(e) {
  function t() {
    var a = this || globalThis;
    return delete e.prototype.__magic__, a;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var r = __magic__;
  return r;
})(Object), formatImport = (
  /** @type {formatImport}*/
  format$1
), parseImport = (
  /** @type {parseImport}*/
  parse
), resolveImport = (
  /** @type {resolveImport}*/
  resolve$1
), UrlImport = (
  /** @type {UrlImport}*/
  Url_1
), URL$1 = _globalThis.URL, URLSearchParams = _globalThis.URLSearchParams, percentRegEx = /%/g, backslashRegEx = /\\/g, newlineRegEx = /\n/g, carriageReturnRegEx = /\r/g, tabRegEx = /\t/g, CHAR_FORWARD_SLASH = 47;
function isURLInstance(e) {
  var t = (
    /** @type {URL|null} */
    e ?? null
  );
  return !!(t !== null && t?.href && t?.origin);
}
function getPathFromURLPosix(e) {
  if (e.hostname !== "")
    throw new TypeError('File URL host must be "localhost" or empty on browser');
  for (var t = e.pathname, r = 0; r < t.length; r++)
    if (t[r] === "%") {
      var a = t.codePointAt(r + 2) | 32;
      if (t[r + 1] === "2" && a === 102)
        throw new TypeError("File URL path must not include encoded / characters");
    }
  return decodeURIComponent(t);
}
function encodePathChars(e) {
  return e.includes("%") && (e = e.replace(percentRegEx, "%25")), e.includes("\\") && (e = e.replace(backslashRegEx, "%5C")), e.includes(`
`) && (e = e.replace(newlineRegEx, "%0A")), e.includes("\r") && (e = e.replace(carriageReturnRegEx, "%0D")), e.includes("	") && (e = e.replace(tabRegEx, "%09")), e;
}
var domainToASCII = (
  /**
   * @type {domainToASCII}
   */
  (function e(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new URL$1("http://" + t).hostname;
  })
), domainToUnicode = (
  /**
   * @type {domainToUnicode}
   */
  (function e(t) {
    if (typeof t > "u")
      throw new TypeError('The "domain" argument must be specified');
    return new URL$1("http://" + t).hostname;
  })
), pathToFileURL = (
  /**
   * @type {(url: string) => URL}
   */
  (function e(t) {
    var r = new URL$1("file://"), a = resolve(t), u = t.charCodeAt(t.length - 1);
    return u === CHAR_FORWARD_SLASH && a[a.length - 1] !== "/" && (a += "/"), r.pathname = encodePathChars(a), r;
  })
), fileURLToPath = (
  /**
   * @type {fileURLToPath & ((path: string | URL) => string)}
   */
  (function e(t) {
    if (!isURLInstance(t) && typeof t != "string")
      throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof t + " (" + t + ")");
    var r = new URL$1(t);
    if (r.protocol !== "file:")
      throw new TypeError("The URL must be of scheme file");
    return getPathFromURLPosix(r);
  })
), formatImportWithOverloads = (
  /**
   * @type {(
   *   ((urlObject: URL, options?: URLFormatOptions) => string) &
   *   ((urlObject: UrlObject | string, options?: never) => string)
   * )}
   */
  (function e(t, r) {
    var a, u, n, o;
    if (r === void 0 && (r = {}), !(t instanceof URL$1))
      return formatImport(t);
    if (typeof r != "object" || r === null)
      throw new TypeError('The "options" argument must be of type object.');
    var c = (a = r.auth) != null ? a : !0, f = (u = r.fragment) != null ? u : !0, l = (n = r.search) != null ? n : !0;
    (o = r.unicode) != null;
    var s = new URL$1(t.toString());
    return c || (s.username = "", s.password = ""), f || (s.hash = ""), l || (s.search = ""), s.toString();
  })
), api = {
  format: formatImportWithOverloads,
  parse: parseImport,
  resolve: resolveImport,
  resolveObject,
  Url: UrlImport,
  URL: URL$1,
  URLSearchParams,
  domainToASCII,
  domainToUnicode,
  pathToFileURL,
  fileURLToPath
};
const url = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  URL: URL$1,
  URLSearchParams,
  Url: UrlImport,
  default: api,
  domainToASCII,
  domainToUnicode,
  fileURLToPath,
  format: formatImportWithOverloads,
  parse: parseImport,
  pathToFileURL,
  resolve: resolveImport,
  resolveObject
}, Symbol.toStringTag, { value: "Module" })), require$$0$5 = /* @__PURE__ */ getAugmentedNamespace(url);
var layouts, hasRequiredLayouts;
function requireLayouts() {
  if (hasRequiredLayouts) return layouts;
  hasRequiredLayouts = 1;
  const e = requireLib$3(), t = requireBrowser$4(), r = requireUtil(), a = requirePathBrowserify(), u = require$$0$5, n = requireBrowser$5()("log4js:layouts"), o = {
    // styles
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    // grayscale
    white: [37, 39],
    grey: [90, 39],
    black: [90, 39],
    // colors
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [91, 39],
    yellow: [33, 39]
  };
  function c(b) {
    return b ? `\x1B[${o[b][0]}m` : "";
  }
  function f(b) {
    return b ? `\x1B[${o[b][1]}m` : "";
  }
  function l(b, q) {
    return c(q) + b + f(q);
  }
  function s(b, q) {
    return l(
      r.format(
        "[%s] [%s] %s - ",
        e.asString(b.startTime),
        b.level.toString(),
        b.categoryName
      ),
      q
    );
  }
  function p(b) {
    return s(b) + r.format(...b.data);
  }
  function m(b) {
    return s(b, b.level.colour) + r.format(...b.data);
  }
  function g(b) {
    return r.format(...b.data);
  }
  function y(b) {
    return b.data[0];
  }
  function v(b, q) {
    const O = "%r %p %c - %m%n", j = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflosCMAF%])(\{([^}]+)\})?|([^%]+)/;
    b = b || O;
    function D(X, be) {
      let Re = X.categoryName;
      if (be) {
        const Pe = parseInt(be, 10), Fe = Re.split(".");
        Pe < Fe.length && (Re = Fe.slice(Fe.length - Pe).join("."));
      }
      return Re;
    }
    function G(X, be) {
      let Re = e.ISO8601_FORMAT;
      if (be)
        switch (Re = be, Re) {
          case "ISO8601":
          case "ISO8601_FORMAT":
            Re = e.ISO8601_FORMAT;
            break;
          case "ISO8601_WITH_TZ_OFFSET":
          case "ISO8601_WITH_TZ_OFFSET_FORMAT":
            Re = e.ISO8601_WITH_TZ_OFFSET_FORMAT;
            break;
          case "ABSOLUTE":
            process$1.emitWarning(
              "Pattern %d{ABSOLUTE} is deprecated in favor of %d{ABSOLUTETIME}. Please use %d{ABSOLUTETIME} instead.",
              "DeprecationWarning",
              "log4js-node-DEP0003"
            ), n(
              "[log4js-node-DEP0003]",
              "DEPRECATION: Pattern %d{ABSOLUTE} is deprecated and replaced by %d{ABSOLUTETIME}."
            );
          // falls through
          case "ABSOLUTETIME":
          case "ABSOLUTETIME_FORMAT":
            Re = e.ABSOLUTETIME_FORMAT;
            break;
          case "DATE":
            process$1.emitWarning(
              "Pattern %d{DATE} is deprecated due to the confusion it causes when used. Please use %d{DATETIME} instead.",
              "DeprecationWarning",
              "log4js-node-DEP0004"
            ), n(
              "[log4js-node-DEP0004]",
              "DEPRECATION: Pattern %d{DATE} is deprecated and replaced by %d{DATETIME}."
            );
          // falls through
          case "DATETIME":
          case "DATETIME_FORMAT":
            Re = e.DATETIME_FORMAT;
            break;
        }
      return e.asString(Re, X.startTime);
    }
    function V() {
      return t.hostname().toString();
    }
    function Q(X, be) {
      let Re = X.data;
      if (be) {
        const [Pe, Fe] = be.split(",");
        Re = Re.slice(Pe, Fe);
      }
      return r.format(...Re);
    }
    function re() {
      return t.EOL;
    }
    function ve(X) {
      return X.level.toString();
    }
    function te(X) {
      return e.asString("hh:mm:ss", X.startTime);
    }
    function R(X) {
      return c(X.level.colour);
    }
    function M(X) {
      return f(X.level.colour);
    }
    function h() {
      return "%";
    }
    function S(X) {
      return X && X.pid ? X.pid.toString() : process$1.pid.toString();
    }
    function B() {
      return S();
    }
    function T(X, be) {
      return typeof q[be] < "u" ? typeof q[be] == "function" ? q[be](X) : q[be] : null;
    }
    function k(X, be) {
      const Re = X.context[be];
      return typeof Re < "u" ? typeof Re == "function" ? Re(X) : Re : null;
    }
    function I(X, be) {
      let Re = X.fileName || "";
      if (Re = function(Fe) {
        const De = "file://";
        return Fe.startsWith(De) && (typeof u.fileURLToPath == "function" ? Fe = u.fileURLToPath(Fe) : (Fe = a.normalize(
          Fe.replace(new RegExp(`^${De}`), "")
        ), process$1.platform === "win32" && (Fe.startsWith("\\") ? Fe = Fe.slice(1) : Fe = a.sep + a.sep + Fe))), Fe;
      }(Re), be) {
        const Fe = parseInt(be, 10), De = Re.split(a.sep);
        De.length > Fe && (Re = De.slice(-Fe).join(a.sep));
      }
      return Re;
    }
    function C(X) {
      return X.lineNumber ? `${X.lineNumber}` : "";
    }
    function $(X) {
      return X.columnNumber ? `${X.columnNumber}` : "";
    }
    function w(X) {
      return X.callStack || "";
    }
    function U(X) {
      return X.className || "";
    }
    function ie(X) {
      return X.functionName || "";
    }
    function le(X) {
      return X.functionAlias || "";
    }
    function ee(X) {
      return X.callerName || "";
    }
    const F = {
      c: D,
      d: G,
      h: V,
      m: Q,
      n: re,
      p: ve,
      r: te,
      "[": R,
      "]": M,
      y: B,
      z: S,
      "%": h,
      x: T,
      X: k,
      f: I,
      l: C,
      o: $,
      s: w,
      C: U,
      M: ie,
      A: le,
      F: ee
    };
    function z(X, be, Re) {
      return F[X](be, Re);
    }
    function se(X, be) {
      let Re;
      return X ? (Re = parseInt(X.slice(1), 10), Re > 0 ? be.slice(0, Re) : be.slice(Re)) : be;
    }
    function he(X, be) {
      let Re;
      if (X)
        if (X.charAt(0) === "-")
          for (Re = parseInt(X.slice(1), 10); be.length < Re; )
            be += " ";
        else
          for (Re = parseInt(X, 10); be.length < Re; )
            be = ` ${be}`;
      return be;
    }
    function ae(X, be, Re) {
      let Pe = X;
      return Pe = se(be, Pe), Pe = he(Re, Pe), Pe;
    }
    return function(X) {
      let be = "", Re, Pe = b;
      for (; (Re = j.exec(Pe)) !== null; ) {
        const Fe = Re[1], De = Re[2], je = Re[3], Oe = Re[5], rt = Re[6];
        if (rt)
          be += rt.toString();
        else {
          const He = z(
            je,
            X,
            Oe
          );
          be += ae(He, De, Fe);
        }
        Pe = Pe.slice(Re.index + Re[0].length);
      }
      return be;
    };
  }
  const E = {
    messagePassThrough() {
      return g;
    },
    basic() {
      return p;
    },
    colored() {
      return m;
    },
    coloured() {
      return m;
    },
    pattern(b) {
      return v(b && b.pattern, b && b.tokens);
    },
    dummy() {
      return y;
    }
  };
  return layouts = {
    basicLayout: p,
    messagePassThroughLayout: g,
    patternLayout: v,
    colouredLayout: m,
    coloredLayout: m,
    dummyLayout: y,
    addLayout(b, q) {
      E[b] = q;
    },
    layout(b, q) {
      return E[b] && E[b](q);
    }
  }, layouts;
}
var levels, hasRequiredLevels;
function requireLevels() {
  if (hasRequiredLevels) return levels;
  hasRequiredLevels = 1;
  const e = requireConfiguration(), t = [
    "white",
    "grey",
    "black",
    "blue",
    "cyan",
    "green",
    "magenta",
    "red",
    "yellow"
  ];
  class r {
    constructor(u, n, o) {
      this.level = u, this.levelStr = n, this.colour = o;
    }
    toString() {
      return this.levelStr;
    }
    /**
     * converts given String to corresponding Level
     * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
     * @param {Level} [defaultLevel] -- default Level, if no String representation
     * @return {Level}
     */
    static getLevel(u, n) {
      return u ? u instanceof r ? u : (u instanceof Object && u.levelStr && (u = u.levelStr), r[u.toString().toUpperCase()] || n) : n;
    }
    static addLevels(u) {
      u && (Object.keys(u).forEach((o) => {
        const c = o.toUpperCase();
        r[c] = new r(
          u[o].value,
          c,
          u[o].colour
        );
        const f = r.levels.findIndex(
          (l) => l.levelStr === c
        );
        f > -1 ? r.levels[f] = r[c] : r.levels.push(r[c]);
      }), r.levels.sort((o, c) => o.level - c.level));
    }
    isLessThanOrEqualTo(u) {
      return typeof u == "string" && (u = r.getLevel(u)), this.level <= u.level;
    }
    isGreaterThanOrEqualTo(u) {
      return typeof u == "string" && (u = r.getLevel(u)), this.level >= u.level;
    }
    isEqualTo(u) {
      return typeof u == "string" && (u = r.getLevel(u)), this.level === u.level;
    }
  }
  return r.levels = [], r.addLevels({
    ALL: { value: Number.MIN_VALUE, colour: "grey" },
    TRACE: { value: 5e3, colour: "blue" },
    DEBUG: { value: 1e4, colour: "cyan" },
    INFO: { value: 2e4, colour: "green" },
    WARN: { value: 3e4, colour: "yellow" },
    ERROR: { value: 4e4, colour: "red" },
    FATAL: { value: 5e4, colour: "magenta" },
    MARK: { value: 9007199254740992, colour: "grey" },
    // 2^53
    OFF: { value: Number.MAX_VALUE, colour: "grey" }
  }), e.addListener((a) => {
    const u = a.levels;
    u && (e.throwExceptionIf(
      a,
      e.not(e.anObject(u)),
      "levels must be an object"
    ), Object.keys(u).forEach((o) => {
      e.throwExceptionIf(
        a,
        e.not(e.validIdentifier(o)),
        `level name "${o}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`
      ), e.throwExceptionIf(
        a,
        e.not(e.anObject(u[o])),
        `level "${o}" must be an object`
      ), e.throwExceptionIf(
        a,
        e.not(u[o].value),
        `level "${o}" must have a 'value' property`
      ), e.throwExceptionIf(
        a,
        e.not(e.anInteger(u[o].value)),
        `level "${o}".value must have an integer value`
      ), e.throwExceptionIf(
        a,
        e.not(u[o].colour),
        `level "${o}" must have a 'colour' property`
      ), e.throwExceptionIf(
        a,
        e.not(t.indexOf(u[o].colour) > -1),
        `level "${o}".colour must be one of ${t.join(", ")}`
      );
    }));
  }), e.addListener((a) => {
    r.addLevels(a.levels);
  }), levels = r, levels;
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var appenders = { exports: {} }, clusteringBrowser, hasRequiredClusteringBrowser;
function requireClusteringBrowser() {
  if (hasRequiredClusteringBrowser) return clusteringBrowser;
  hasRequiredClusteringBrowser = 1;
  const e = () => !0, t = [];
  return clusteringBrowser = {
    onlyOnMaster: (a, u) => a(),
    isMaster: e,
    send: (a) => {
      t.forEach((u) => u(a));
    },
    onMessage: (a) => {
      t.push(a);
    }
  }, clusteringBrowser;
}
var adapters = {}, hasRequiredAdapters;
function requireAdapters() {
  if (hasRequiredAdapters) return adapters;
  hasRequiredAdapters = 1;
  function e(u) {
    if (typeof u == "number" && Number.isInteger(u))
      return u;
    const n = {
      K: 1024,
      M: 1024 * 1024,
      G: 1024 * 1024 * 1024
    }, o = Object.keys(n), c = u.slice(-1).toLocaleUpperCase(), f = u.slice(0, -1).trim();
    if (o.indexOf(c) < 0 || !Number.isInteger(Number(f)))
      throw Error(`maxLogSize: "${u}" is invalid`);
    return f * n[c];
  }
  function t(u, n) {
    const o = Object.assign({}, n);
    return Object.keys(u).forEach((c) => {
      o[c] && (o[c] = u[c](n[c]));
    }), o;
  }
  function r(u) {
    return t({
      maxLogSize: e
    }, u);
  }
  const a = {
    dateFile: r,
    file: r,
    fileSync: r
  };
  return adapters.modifyConfig = (u) => a[u.type] ? a[u.type](u) : u, adapters;
}
var console$1 = {}, hasRequiredConsole;
function requireConsole() {
  if (hasRequiredConsole) return console$1;
  hasRequiredConsole = 1;
  const e = console.log.bind(console);
  function t(a, u) {
    return (n) => {
      e(a(n, u));
    };
  }
  function r(a, u) {
    let n = u.colouredLayout;
    return a.layout && (n = u.layout(a.layout.type, a.layout)), t(n, a.timezoneOffset);
  }
  return console$1.configure = r, console$1;
}
var stdout = {}, hasRequiredStdout;
function requireStdout() {
  if (hasRequiredStdout) return stdout;
  hasRequiredStdout = 1;
  function e(r, a) {
    return (u) => {
      process$1.stdout.write(`${r(u, a)}
`);
    };
  }
  function t(r, a) {
    let u = a.colouredLayout;
    return r.layout && (u = a.layout(r.layout.type, r.layout)), e(u, r.timezoneOffset);
  }
  return stdout.configure = t, stdout;
}
var stderr = {}, hasRequiredStderr;
function requireStderr() {
  if (hasRequiredStderr) return stderr;
  hasRequiredStderr = 1;
  function e(r, a) {
    return (u) => {
      process$1.stderr.write(`${r(u, a)}
`);
    };
  }
  function t(r, a) {
    let u = a.colouredLayout;
    return r.layout && (u = a.layout(r.layout.type, r.layout)), e(u, r.timezoneOffset);
  }
  return stderr.configure = t, stderr;
}
var logLevelFilter = {}, hasRequiredLogLevelFilter;
function requireLogLevelFilter() {
  if (hasRequiredLogLevelFilter) return logLevelFilter;
  hasRequiredLogLevelFilter = 1;
  function e(r, a, u, n) {
    const o = n.getLevel(r), c = n.getLevel(a, n.FATAL);
    return (f) => {
      const l = f.level;
      o.isLessThanOrEqualTo(l) && c.isGreaterThanOrEqualTo(l) && u(f);
    };
  }
  function t(r, a, u, n) {
    const o = u(r.appender);
    return e(r.level, r.maxLevel, o, n);
  }
  return logLevelFilter.configure = t, logLevelFilter;
}
var categoryFilter = {}, hasRequiredCategoryFilter;
function requireCategoryFilter() {
  if (hasRequiredCategoryFilter) return categoryFilter;
  hasRequiredCategoryFilter = 1;
  const e = requireBrowser$5()("log4js:categoryFilter");
  function t(a, u) {
    return typeof a == "string" && (a = [a]), (n) => {
      e(`Checking ${n.categoryName} against ${a}`), a.indexOf(n.categoryName) === -1 && (e("Not excluded, sending to appender"), u(n));
    };
  }
  function r(a, u, n) {
    const o = n(a.appender);
    return t(a.exclude, o);
  }
  return categoryFilter.configure = r, categoryFilter;
}
var noLogFilter = {}, hasRequiredNoLogFilter;
function requireNoLogFilter() {
  if (hasRequiredNoLogFilter) return noLogFilter;
  hasRequiredNoLogFilter = 1;
  const e = requireBrowser$5()("log4js:noLogFilter");
  function t(u) {
    return u.filter((o) => o != null && o !== "");
  }
  function r(u, n) {
    return (o) => {
      e(`Checking data: ${o.data} against filters: ${u}`), typeof u == "string" && (u = [u]), u = t(u);
      const c = new RegExp(u.join("|"), "i");
      (u.length === 0 || o.data.findIndex((f) => c.test(f)) < 0) && (e("Not excluded, sending to appender"), n(o));
    };
  }
  function a(u, n, o) {
    const c = o(u.appender);
    return r(u.exclude, c);
  }
  return noLogFilter.configure = a, noLogFilter;
}
var ignoreBrowser = {}, hasRequiredIgnoreBrowser;
function requireIgnoreBrowser() {
  return hasRequiredIgnoreBrowser || (hasRequiredIgnoreBrowser = 1), ignoreBrowser;
}
var tcp = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(empty$1);
var hasRequiredTcp;
function requireTcp() {
  if (hasRequiredTcp) return tcp;
  hasRequiredTcp = 1;
  const e = requireBrowser$5()("log4js:tcp"), t = require$$1;
  function r(u, n) {
    let o = !1;
    const c = [];
    let f, l = 3, s = "__LOG4JS__";
    function p(v) {
      e("Writing log event to socket"), o = f.write(`${n(v)}${s}`, "utf8");
    }
    function m() {
      let v;
      for (e("emptying buffer"); v = c.shift(); )
        p(v);
    }
    function g() {
      e(
        `appender creating socket to ${u.host || "localhost"}:${u.port || 5e3}`
      ), s = `${u.endMsg || "__LOG4JS__"}`, f = t.createConnection(
        u.port || 5e3,
        u.host || "localhost"
      ), f.on("connect", () => {
        e("socket connected"), m(), o = !0;
      }), f.on("drain", () => {
        e("drain event received, emptying buffer"), o = !0, m();
      }), f.on("timeout", f.end.bind(f)), f.on("error", (v) => {
        e("connection error", v), o = !1, m();
      }), f.on("close", g);
    }
    g();
    function y(v) {
      o ? p(v) : (e("buffering log event because it cannot write at the moment"), c.push(v));
    }
    return y.shutdown = function(v) {
      e("shutdown called"), c.length && l ? (e("buffer has items, waiting 100ms to empty"), l -= 1, setTimeout(() => {
        y.shutdown(v);
      }, 100)) : (f.removeAllListeners("close"), f.end(v));
    }, y;
  }
  function a(u, n) {
    e(`configure with config = ${u}`);
    let o = function(c) {
      return c.serialise();
    };
    return u.layout && (o = n.layout(u.layout.type, u.layout)), r(u, o);
  }
  return tcp.configure = a, tcp;
}
var hasRequiredAppenders;
function requireAppenders() {
  if (hasRequiredAppenders) return appenders.exports;
  hasRequiredAppenders = 1;
  const e = requirePathBrowserify(), t = requireBrowser$5()("log4js:appenders"), r = requireConfiguration(), a = requireClusteringBrowser(), u = requireLevels(), n = requireLayouts(), o = requireAdapters(), c = /* @__PURE__ */ new Map();
  c.set("console", requireConsole()), c.set("stdout", requireStdout()), c.set("stderr", requireStderr()), c.set("logLevelFilter", requireLogLevelFilter()), c.set("categoryFilter", requireCategoryFilter()), c.set("noLogFilter", requireNoLogFilter()), c.set("file", requireIgnoreBrowser()), c.set("dateFile", requireIgnoreBrowser()), c.set("fileSync", requireIgnoreBrowser()), c.set("tcp", requireTcp());
  const f = /* @__PURE__ */ new Map(), l = (E, b) => {
    let q;
    try {
      const O = `${E}.cjs`;
      q = require.resolve(O), t("Loading module from ", O);
    } catch {
      q = E, t("Loading module from ", E);
    }
    try {
      return commonjsRequire(q);
    } catch (O) {
      r.throwExceptionIf(
        b,
        O.code !== "MODULE_NOT_FOUND",
        `appender "${E}" could not be loaded (error was: ${O})`
      );
      return;
    }
  }, s = (E, b) => c.get(E) || l(`./${E}`, b) || l(E, b) || require.main && require.main.filename && l(e.join(e.dirname(require.main.filename), E), b) || l(e.join(process$1.cwd(), E), b), p = /* @__PURE__ */ new Set(), m = (E, b) => {
    if (f.has(E)) return f.get(E);
    if (!b.appenders[E]) return !1;
    if (p.has(E))
      throw new Error(`Dependency loop detected for appender ${E}.`);
    p.add(E), t(`Creating appender ${E}`);
    const q = g(E, b);
    return p.delete(E), f.set(E, q), q;
  }, g = (E, b) => {
    const q = b.appenders[E], O = q.type.configure ? q.type : s(q.type, b);
    return r.throwExceptionIf(
      b,
      r.not(O),
      `appender "${E}" is not valid (type "${q.type}" could not be found)`
    ), O.appender && (process$1.emitWarning(
      `Appender ${q.type} exports an appender function.`,
      "DeprecationWarning",
      "log4js-node-DEP0001"
    ), t(
      "[log4js-node-DEP0001]",
      `DEPRECATION: Appender ${q.type} exports an appender function.`
    )), O.shutdown && (process$1.emitWarning(
      `Appender ${q.type} exports a shutdown function.`,
      "DeprecationWarning",
      "log4js-node-DEP0002"
    ), t(
      "[log4js-node-DEP0002]",
      `DEPRECATION: Appender ${q.type} exports a shutdown function.`
    )), t(`${E}: clustering.isMaster ? ${a.isMaster()}`), t(
      // eslint-disable-next-line global-require
      `${E}: appenderModule is ${requireUtil().inspect(O)}`
    ), a.onlyOnMaster(
      () => (t(
        `calling appenderModule.configure for ${E} / ${q.type}`
      ), O.configure(
        o.modifyConfig(q),
        n,
        (j) => m(j, b),
        u
      )),
      /* istanbul ignore next: fn never gets called by non-master yet needed to pass config validation */
      () => {
      }
    );
  }, y = (E) => {
    if (f.clear(), p.clear(), !E)
      return;
    const b = [];
    Object.values(E.categories).forEach((q) => {
      b.push(...q.appenders);
    }), Object.keys(E.appenders).forEach((q) => {
      (b.includes(q) || E.appenders[q].type === "tcp-server" || E.appenders[q].type === "multiprocess") && m(q, E);
    });
  }, v = () => {
    y();
  };
  return v(), r.addListener((E) => {
    r.throwExceptionIf(
      E,
      r.not(r.anObject(E.appenders)),
      'must have a property "appenders" of type object.'
    );
    const b = Object.keys(E.appenders);
    r.throwExceptionIf(
      E,
      r.not(b.length),
      "must define at least one appender."
    ), b.forEach((q) => {
      r.throwExceptionIf(
        E,
        r.not(E.appenders[q].type),
        `appender "${q}" is not valid (must be an object with property "type")`
      );
    });
  }), r.addListener(y), appenders.exports = f, appenders.exports.init = v, appenders.exports;
}
var categories = { exports: {} }, hasRequiredCategories;
function requireCategories() {
  return hasRequiredCategories || (hasRequiredCategories = 1, (function(e) {
    const t = requireBrowser$5()("log4js:categories"), r = requireConfiguration(), a = requireLevels(), u = requireAppenders(), n = /* @__PURE__ */ new Map();
    function o(E, b, q) {
      if (b.inherit === !1) return;
      const O = q.lastIndexOf(".");
      if (O < 0) return;
      const j = q.slice(0, O);
      let D = E.categories[j];
      D || (D = { inherit: !0, appenders: [] }), o(E, D, j), !E.categories[j] && D.appenders && D.appenders.length && D.level && (E.categories[j] = D), b.appenders = b.appenders || [], b.level = b.level || D.level, D.appenders.forEach((G) => {
        b.appenders.includes(G) || b.appenders.push(G);
      }), b.parent = D;
    }
    function c(E) {
      if (!E.categories) return;
      Object.keys(E.categories).forEach((q) => {
        const O = E.categories[q];
        o(E, O, q);
      });
    }
    r.addPreProcessingListener(
      (E) => c(E)
    ), r.addListener((E) => {
      r.throwExceptionIf(
        E,
        r.not(r.anObject(E.categories)),
        'must have a property "categories" of type object.'
      );
      const b = Object.keys(E.categories);
      r.throwExceptionIf(
        E,
        r.not(b.length),
        "must define at least one category."
      ), b.forEach((q) => {
        const O = E.categories[q];
        r.throwExceptionIf(
          E,
          [
            r.not(O.appenders),
            r.not(O.level)
          ],
          `category "${q}" is not valid (must be an object with properties "appenders" and "level")`
        ), r.throwExceptionIf(
          E,
          r.not(Array.isArray(O.appenders)),
          `category "${q}" is not valid (appenders must be an array of appender names)`
        ), r.throwExceptionIf(
          E,
          r.not(O.appenders.length),
          `category "${q}" is not valid (appenders must contain at least one appender name)`
        ), Object.prototype.hasOwnProperty.call(O, "enableCallStack") && r.throwExceptionIf(
          E,
          typeof O.enableCallStack != "boolean",
          `category "${q}" is not valid (enableCallStack must be boolean type)`
        ), O.appenders.forEach((j) => {
          r.throwExceptionIf(
            E,
            r.not(u.get(j)),
            `category "${q}" is not valid (appender "${j}" is not defined)`
          );
        }), r.throwExceptionIf(
          E,
          r.not(a.getLevel(O.level)),
          `category "${q}" is not valid (level "${O.level}" not recognised; valid levels are ${a.levels.join(", ")})`
        );
      }), r.throwExceptionIf(
        E,
        r.not(E.categories.default),
        'must define a "default" category.'
      );
    });
    const f = (E) => {
      if (n.clear(), !E)
        return;
      Object.keys(E.categories).forEach((q) => {
        const O = E.categories[q], j = [];
        O.appenders.forEach((D) => {
          j.push(u.get(D)), t(`Creating category ${q}`), n.set(q, {
            appenders: j,
            level: a.getLevel(O.level),
            enableCallStack: O.enableCallStack || !1
          });
        });
      });
    }, l = () => {
      f();
    };
    l(), r.addListener(f);
    const s = (E) => {
      if (t(`configForCategory: searching for config for ${E}`), n.has(E))
        return t(`configForCategory: ${E} exists in config, returning it`), n.get(E);
      let b;
      return E.indexOf(".") > 0 ? (t(`configForCategory: ${E} has hierarchy, cloning from parents`), b = {
        ...s(E.slice(0, E.lastIndexOf(".")))
      }) : (n.has("default") || f({ categories: { default: { appenders: ["out"], level: "OFF" } } }), t("configForCategory: cloning default category"), b = { ...n.get("default") }), n.set(E, b), b;
    }, p = (E) => s(E).appenders, m = (E) => s(E).level, g = (E, b) => {
      s(E).level = b;
    }, y = (E) => s(E).enableCallStack === !0, v = (E, b) => {
      s(E).enableCallStack = b;
    };
    e.exports = n, e.exports = Object.assign(e.exports, {
      appendersForCategory: p,
      getLevelForCategory: m,
      setLevelForCategory: g,
      getEnableCallStackForCategory: y,
      setEnableCallStackForCategory: v,
      init: l
    });
  })(categories)), categories.exports;
}
var cjs = {}, hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  const { parse: e, stringify: t } = JSON, { keys: r } = Object, a = String, u = "string", n = {}, o = "object", c = (E, b) => b, f = (E) => E instanceof a ? a(E) : E, l = (E, b) => typeof b === u ? new a(b) : b, s = (E, b, q, O) => {
    const j = [];
    for (let D = r(q), { length: G } = D, V = 0; V < G; V++) {
      const Q = D[V], re = q[Q];
      if (re instanceof a) {
        const ve = E[re];
        typeof ve === o && !b.has(ve) ? (b.add(ve), q[Q] = n, j.push({ k: Q, a: [E, b, ve, O] })) : q[Q] = O.call(q, Q, ve);
      } else q[Q] !== n && (q[Q] = O.call(q, Q, re));
    }
    for (let { length: D } = j, G = 0; G < D; G++) {
      const { k: V, a: Q } = j[G];
      q[V] = O.call(q, V, s.apply(null, Q));
    }
    return q;
  }, p = (E, b, q) => {
    const O = a(b.push(q) - 1);
    return E.set(q, O), O;
  }, m = (E, b) => {
    const q = e(E, l).map(f), O = q[0], j = b || c, D = typeof O === o && O ? s(q, /* @__PURE__ */ new Set(), O, j) : O;
    return j.call({ "": D }, "", D);
  };
  cjs.parse = m;
  const g = (E, b, q) => {
    const O = b && typeof b === o ? (ve, te) => ve === "" || -1 < b.indexOf(ve) ? te : void 0 : b || c, j = /* @__PURE__ */ new Map(), D = [], G = [];
    let V = +p(j, D, O.call({ "": E }, "", E)), Q = !V;
    for (; V < D.length; )
      Q = !0, G[V] = t(D[V++], re, q);
    return "[" + G.join(",") + "]";
    function re(ve, te) {
      if (Q)
        return Q = !Q, te;
      const R = O.call(this, ve, te);
      switch (typeof R) {
        case o:
          if (R === null) return R;
        case u:
          return j.get(R) || p(j, D, R);
      }
      return R;
    }
  };
  cjs.stringify = g;
  const y = (E) => e(g(E));
  cjs.toJSON = y;
  const v = (E) => m(t(E));
  return cjs.fromJSON = v, cjs;
}
var LoggingEvent_1, hasRequiredLoggingEvent;
function requireLoggingEvent() {
  if (hasRequiredLoggingEvent) return LoggingEvent_1;
  hasRequiredLoggingEvent = 1;
  const e = requireCjs(), t = requireLevels();
  class r {
    constructor() {
      const o = {
        __LOG4JS_undefined__: void 0,
        __LOG4JS_NaN__: +"abc",
        __LOG4JS_Infinity__: 1 / 0,
        "__LOG4JS_-Infinity__": -1 / 0
      };
      this.deMap = o, this.serMap = {}, Object.keys(this.deMap).forEach((c) => {
        const f = this.deMap[c];
        this.serMap[f] = c;
      });
    }
    canSerialise(o) {
      return typeof o == "string" ? !1 : o in this.serMap;
    }
    serialise(o) {
      return this.canSerialise(o) ? this.serMap[o] : o;
    }
    canDeserialise(o) {
      return o in this.deMap;
    }
    deserialise(o) {
      return this.canDeserialise(o) ? this.deMap[o] : o;
    }
  }
  const a = new r();
  class u {
    /**
     * Models a logging event.
     * @constructor
     * @param {string} categoryName name of category
     * @param {Log4js.Level} level level of message
     * @param {Array} data objects to log
     * @param {Error} [error]
     * @author Seth Chisamore
     */
    constructor(o, c, f, l, s, p) {
      if (this.startTime = /* @__PURE__ */ new Date(), this.categoryName = o, this.data = f, this.level = c, this.context = Object.assign({}, l), this.pid = process$1.pid, this.error = p, typeof s < "u") {
        if (!s || typeof s != "object" || Array.isArray(s))
          throw new TypeError(
            "Invalid location type passed to LoggingEvent constructor"
          );
        this.constructor._getLocationKeys().forEach((m) => {
          typeof s[m] < "u" && (this[m] = s[m]);
        });
      }
    }
    /** @private */
    static _getLocationKeys() {
      return [
        "fileName",
        "lineNumber",
        "columnNumber",
        "callStack",
        "className",
        "functionName",
        "functionAlias",
        "callerName"
      ];
    }
    serialise() {
      return e.stringify(this, (o, c) => (c instanceof Error && (c = Object.assign(
        { message: c.message, stack: c.stack },
        c
      )), a.serialise(c)));
    }
    static deserialise(o) {
      let c;
      try {
        const f = e.parse(o, (l, s) => {
          if (s && s.message && s.stack) {
            const p = new Error(s);
            Object.keys(s).forEach((m) => {
              p[m] = s[m];
            }), s = p;
          }
          return a.deserialise(s);
        });
        this._getLocationKeys().forEach((l) => {
          typeof f[l] < "u" && (f.location || (f.location = {}), f.location[l] = f[l]);
        }), c = new u(
          f.categoryName,
          t.getLevel(f.level.levelStr),
          f.data,
          f.context,
          f.location,
          f.error
        ), c.startTime = new Date(f.startTime), c.pid = f.pid, f.cluster && (c.cluster = f.cluster);
      } catch (f) {
        c = new u("log4js", t.ERROR, [
          "Unable to parse log:",
          o,
          "because: ",
          f
        ]);
      }
      return c;
    }
  }
  return LoggingEvent_1 = u, LoggingEvent_1;
}
var logger$2, hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return logger$2;
  hasRequiredLogger = 1;
  const e = requireBrowser$5()("log4js:logger"), t = requireLoggingEvent(), r = requireLevels(), a = requireClusteringBrowser(), u = requireCategories(), n = requireConfiguration(), o = /^(?:\s*)at (?:(.+) \()?(?:([^(]+?):(\d+):(\d+))\)?$/, c = 1, f = 3;
  function l(m, g = f + c) {
    try {
      const y = m.stack.split(`
`).slice(g);
      if (!y.length)
        return null;
      const v = o.exec(y[0]);
      if (v && v.length === 5) {
        let E = "", b = "", q = "";
        return v[1] && v[1] !== "" && ([b, q] = v[1].replace(/[[\]]/g, "").split(" as "), q = q || "", b.includes(".") && ([E, b] = b.split("."))), {
          fileName: v[2],
          lineNumber: parseInt(v[3], 10),
          columnNumber: parseInt(v[4], 10),
          callStack: y.join(`
`),
          className: E,
          functionName: b,
          functionAlias: q,
          callerName: v[1] || ""
        };
      } else
        console.error("log4js.logger - defaultParseCallStack error");
    } catch (y) {
      console.error("log4js.logger - defaultParseCallStack error", y);
    }
    return null;
  }
  class s {
    constructor(g) {
      if (!g)
        throw new Error("No category provided.");
      this.category = g, this.context = {}, this.callStackSkipIndex = 0, this.parseCallStack = l, e(`Logger created (${this.category}, ${this.level})`);
    }
    get level() {
      return r.getLevel(
        u.getLevelForCategory(this.category),
        r.OFF
      );
    }
    set level(g) {
      u.setLevelForCategory(
        this.category,
        r.getLevel(g, this.level)
      );
    }
    get useCallStack() {
      return u.getEnableCallStackForCategory(this.category);
    }
    set useCallStack(g) {
      u.setEnableCallStackForCategory(this.category, g === !0);
    }
    get callStackLinesToSkip() {
      return this.callStackSkipIndex;
    }
    set callStackLinesToSkip(g) {
      if (typeof g != "number")
        throw new TypeError("Must be a number");
      if (g < 0)
        throw new RangeError("Must be >= 0");
      this.callStackSkipIndex = g;
    }
    log(g, ...y) {
      const v = r.getLevel(g);
      v ? this.isLevelEnabled(v) && this._log(v, y) : n.validIdentifier(g) && y.length > 0 ? (this.log(
        r.WARN,
        "log4js:logger.log: valid log-level not found as first parameter given:",
        g
      ), this.log(r.INFO, `[${g}]`, ...y)) : this.log(r.INFO, g, ...y);
    }
    isLevelEnabled(g) {
      return this.level.isLessThanOrEqualTo(g);
    }
    _log(g, y) {
      e(`sending log data (${g}) to appenders`);
      const v = y.find((q) => q instanceof Error);
      let E;
      if (this.useCallStack) {
        try {
          v && (E = this.parseCallStack(
            v,
            this.callStackSkipIndex + c
          ));
        } catch {
        }
        E = E || this.parseCallStack(
          new Error(),
          this.callStackSkipIndex + f + c
        );
      }
      const b = new t(
        this.category,
        g,
        y,
        this.context,
        E,
        v
      );
      a.send(b);
    }
    addContext(g, y) {
      this.context[g] = y;
    }
    removeContext(g) {
      delete this.context[g];
    }
    clearContext() {
      this.context = {};
    }
    setParseCallStackFunction(g) {
      if (typeof g == "function")
        this.parseCallStack = g;
      else if (typeof g > "u")
        this.parseCallStack = l;
      else
        throw new TypeError("Invalid type passed to setParseCallStackFunction");
    }
  }
  function p(m) {
    const g = r.getLevel(m), v = g.toString().toLowerCase().replace(
      /_([a-z])/g,
      (b) => b[1].toUpperCase()
    ), E = v[0].toUpperCase() + v.slice(1);
    s.prototype[`is${E}Enabled`] = function() {
      return this.isLevelEnabled(g);
    }, s.prototype[v] = function(...b) {
      this.log(g, ...b);
    };
  }
  return r.levels.forEach(p), n.addListener(() => {
    r.levels.forEach(p);
  }), logger$2 = s, logger$2;
}
var connectLogger, hasRequiredConnectLogger;
function requireConnectLogger() {
  if (hasRequiredConnectLogger) return connectLogger;
  hasRequiredConnectLogger = 1;
  const e = requireLevels(), t = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
  function r(c) {
    return c.originalUrl || c.url;
  }
  function a(c, f, l) {
    const s = (m) => {
      const g = m.concat();
      for (let y = 0; y < g.length; ++y)
        for (let v = y + 1; v < g.length; ++v)
          g[y].token == g[v].token && g.splice(v--, 1);
      return g;
    }, p = [];
    return p.push({ token: ":url", replacement: r(c) }), p.push({ token: ":protocol", replacement: c.protocol }), p.push({ token: ":hostname", replacement: c.hostname }), p.push({ token: ":method", replacement: c.method }), p.push({
      token: ":status",
      replacement: f.__statusCode || f.statusCode
    }), p.push({
      token: ":response-time",
      replacement: f.responseTime
    }), p.push({ token: ":date", replacement: (/* @__PURE__ */ new Date()).toUTCString() }), p.push({
      token: ":referrer",
      replacement: c.headers.referer || c.headers.referrer || ""
    }), p.push({
      token: ":http-version",
      replacement: `${c.httpVersionMajor}.${c.httpVersionMinor}`
    }), p.push({
      token: ":remote-addr",
      replacement: c.headers["x-forwarded-for"] || c.ip || c._remoteAddress || c.socket && (c.socket.remoteAddress || c.socket.socket && c.socket.socket.remoteAddress)
    }), p.push({
      token: ":user-agent",
      replacement: c.headers["user-agent"]
    }), p.push({
      token: ":content-length",
      replacement: f.getHeader("content-length") || f.__headers && f.__headers["Content-Length"] || "-"
    }), p.push({
      token: /:req\[([^\]]+)]/g,
      replacement(m, g) {
        return c.headers[g.toLowerCase()];
      }
    }), p.push({
      token: /:res\[([^\]]+)]/g,
      replacement(m, g) {
        return f.getHeader(g.toLowerCase()) || f.__headers && f.__headers[g];
      }
    }), s(l.concat(p));
  }
  function u(c, f) {
    for (let l = 0; l < f.length; l++)
      c = c.replace(f[l].token, f[l].replacement);
    return c;
  }
  function n(c) {
    let f = null;
    if (c instanceof RegExp && (f = c), typeof c == "string" && (f = new RegExp(c)), Array.isArray(c)) {
      const l = c.map(
        (s) => s.source ? s.source : s
      );
      f = new RegExp(l.join("|"));
    }
    return f;
  }
  function o(c, f, l) {
    let s = f;
    if (l) {
      const p = l.find((m) => {
        let g = !1;
        return m.from && m.to ? g = c >= m.from && c <= m.to : g = m.codes.indexOf(c) !== -1, g;
      });
      p && (s = e.getLevel(p.level, s));
    }
    return s;
  }
  return connectLogger = function(f, l) {
    typeof l == "string" || typeof l == "function" ? l = { format: l } : l = l || {};
    const s = f;
    let p = e.getLevel(l.level, e.INFO);
    const m = l.format || t;
    return (g, y, v) => {
      if (typeof g._logging < "u") return v();
      if (typeof l.nolog != "function") {
        const E = n(l.nolog);
        if (E && E.test(g.originalUrl)) return v();
      }
      if (s.isLevelEnabled(p) || l.level === "auto") {
        const E = /* @__PURE__ */ new Date(), { writeHead: b } = y;
        g._logging = !0, y.writeHead = (j, D) => {
          y.writeHead = b, y.writeHead(j, D), y.__statusCode = j, y.__headers = D || {};
        };
        let q = !1;
        const O = () => {
          if (q)
            return;
          if (q = !0, typeof l.nolog == "function" && l.nolog(g, y) === !0) {
            g._logging = !1;
            return;
          }
          y.responseTime = /* @__PURE__ */ new Date() - E, y.statusCode && l.level === "auto" && (p = e.INFO, y.statusCode >= 300 && (p = e.WARN), y.statusCode >= 400 && (p = e.ERROR)), p = o(y.statusCode, p, l.statusRules);
          const j = a(g, y, l.tokens || []);
          if (l.context && s.addContext("res", y), typeof m == "function") {
            const D = m(g, y, (G) => u(G, j));
            D && s.log(p, D);
          } else
            s.log(p, u(m, j));
          l.context && s.removeContext("res");
        };
        y.on("end", O), y.on("finish", O), y.on("error", O), y.on("close", O);
      }
      return v();
    };
  }, connectLogger;
}
var recording, hasRequiredRecording;
function requireRecording() {
  if (hasRequiredRecording) return recording;
  hasRequiredRecording = 1;
  const e = requireBrowser$5()("log4js:recording"), t = [];
  function r() {
    return function(n) {
      e(
        `received logEvent, number of events now ${t.length + 1}`
      ), e("log event was ", n), t.push(n);
    };
  }
  function a() {
    return t.slice();
  }
  function u() {
    t.length = 0;
  }
  return recording = {
    configure: r,
    replay: a,
    playback: a,
    reset: u,
    erase: u
  }, recording;
}
var log4js_1, hasRequiredLog4js;
function requireLog4js() {
  if (hasRequiredLog4js) return log4js_1;
  hasRequiredLog4js = 1;
  const e = requireBrowser$5()("log4js:main"), t = require$$1$2, r = requireRfdc()({ proto: !0 }), a = requireConfiguration(), u = requireLayouts(), n = requireLevels(), o = requireAppenders(), c = requireCategories(), f = requireLogger(), l = requireClusteringBrowser(), s = requireConnectLogger(), p = requireRecording();
  let m = !1;
  function g(D) {
    if (!m) return;
    e("Received log event ", D), c.appendersForCategory(
      D.categoryName
    ).forEach((V) => {
      V(D);
    });
  }
  function y(D) {
    e(`Loading configuration from ${D}`);
    try {
      return JSON.parse(t.readFileSync(D, "utf8"));
    } catch (G) {
      throw new Error(
        `Problem reading config from file "${D}". Error was ${G.message}`,
        G
      );
    }
  }
  function v(D) {
    m && q();
    let G = D;
    return typeof G == "string" && (G = y(D)), e(`Configuration is ${G}`), a.configure(r(G)), l.onMessage(g), m = !0, j;
  }
  function E() {
    return m;
  }
  function b() {
    return p;
  }
  function q(D = () => {
  }) {
    if (typeof D != "function")
      throw new TypeError("Invalid callback passed to shutdown");
    e("Shutdown called. Disabling all log writing."), m = !1;
    const G = Array.from(o.values());
    o.init(), c.init();
    const V = G.reduce(
      (te, R) => R.shutdown ? te + 1 : te,
      0
    );
    V === 0 && (e("No appenders with shutdown functions found."), D());
    let Q = 0, re;
    e(`Found ${V} appenders with shutdown functions.`);
    function ve(te) {
      re = re || te, Q += 1, e(`Appender shutdowns complete: ${Q} / ${V}`), Q >= V && (e("All shutdown functions completed."), D(re));
    }
    G.filter((te) => te.shutdown).forEach((te) => te.shutdown(ve));
  }
  function O(D) {
    return m || v(
      process$1.env.LOG4JS_CONFIG || {
        appenders: { out: { type: "stdout" } },
        categories: { default: { appenders: ["out"], level: "OFF" } }
      }
    ), new f(D || "default");
  }
  const j = {
    getLogger: O,
    configure: v,
    isConfigured: E,
    shutdown: q,
    connectLogger: s,
    levels: n,
    addLayout: u.addLayout,
    recording: b
  };
  return log4js_1 = j, log4js_1;
}
requireLog4js();
const createLogger = () => ({
  // 开发调试
  trace: console.trace.bind(console),
  debug: console.debug.bind(console),
  // 日常
  info: console.info.bind(console),
  mark: console.info.bind(console),
  // 警告
  warn: console.warn.bind(console),
  // 错误
  error: console.error.bind(console),
  // 严重
  fatal: console.error.bind(console)
});
class Logger {
  #e = null;
  /**
   * 创建一个 logger，如果未存在全局变量则赋值
   * @returns
   */
  constructor() {
    this.#e = createLogger(), globalThis.logger || (globalThis.logger = this.#e);
  }
  get value() {
    return this.#e;
  }
}
class Core {
  constructor() {
    globalThis.alemonjsCore || (globalThis.alemonjsCore = {
      storeState: {},
      storeStateSubscribe: {},
      storeSubscribeList: {
        create: /* @__PURE__ */ new Map(),
        mount: /* @__PURE__ */ new Map(),
        unmount: /* @__PURE__ */ new Map()
      },
      storeChildrenApp: {}
    });
  }
  get value() {
    return globalThis.alemonjsCore;
  }
}
let Response$1 = class {
  get value() {
    return Object.keys(alemonjsCore.storeChildrenApp).map((r) => alemonjsCore.storeChildrenApp[r].response).flat();
  }
};
class ResponseMiddleware {
  find(t, r) {
    if (typeof t != "string" || typeof r != "string")
      return [];
    if (!alemonjsCore.storeChildrenApp[t])
      return [];
    const a = alemonjsCore.storeChildrenApp[t];
    if (!a.middlewareResponse)
      return [];
    const u = r.split(":"), n = [];
    for (; u.length > 1; ) {
      const o = u.join(":");
      a.middlewareResponse[o] && n.push(a.middlewareResponse[o]), u.pop();
    }
    return n;
  }
}
class ResponseRouter {
  get value() {
    return Object.keys(alemonjsCore.storeChildrenApp).map((r) => alemonjsCore.storeChildrenApp[r].register ? alemonjsCore.storeChildrenApp[r].register?.response?.current ?? [] : []).flat();
  }
}
class MiddlewareRouter {
  get value() {
    return Object.keys(alemonjsCore.storeChildrenApp).map((r) => alemonjsCore.storeChildrenApp[r].register ? alemonjsCore.storeChildrenApp[r].register?.middleware?.current ?? [] : []).flat();
  }
}
class Middleware {
  get value() {
    return Object.keys(alemonjsCore.storeChildrenApp).map((r) => alemonjsCore.storeChildrenApp[r].middleware).flat();
  }
}
class SubscribeList {
  #e;
  #t;
  constructor(t, r) {
    this.#e = r, this.#t = t, alemonjsCore.storeSubscribeList[this.#t].has(this.#e) || alemonjsCore.storeSubscribeList[this.#t].set(this.#e, new SinglyLinkedList());
  }
  get value() {
    return alemonjsCore.storeSubscribeList[this.#t].get(this.#e);
  }
}
class StateSubscribe {
  #e = null;
  constructor(t) {
    this.#e = t, alemonjsCore.storeStateSubscribe[t] || (alemonjsCore.storeStateSubscribe[t] = []);
  }
  on(t) {
    alemonjsCore.storeStateSubscribe[this.#e].push(t);
  }
  un(t) {
    alemonjsCore.storeStateSubscribe[this.#e] = alemonjsCore.storeStateSubscribe[this.#e].filter((r) => r !== t);
  }
  get value() {
    return alemonjsCore.storeStateSubscribe[this.#e];
  }
}
class StateProxy {
  create(t = {}) {
    return new Proxy(t, {
      get(r, a) {
        return a in r ? r[a] : !1;
      },
      set(r, a, u) {
        if (r[a] = u, alemonjsCore.storeStateSubscribe[a])
          for (const n of alemonjsCore.storeStateSubscribe[a])
            n(u);
        return !0;
      }
    });
  }
}
class State {
  #e = null;
  /**
   *
   * @param name
   * @param defaultValue 默认，允许匹配
   */
  constructor(t, r = !0) {
    this.#e = t, alemonjsCore.storeState || (alemonjsCore.storeState = new StateProxy().create()), t in alemonjsCore.storeState || (alemonjsCore.storeState[t] = r);
  }
  get value() {
    return alemonjsCore.storeState[this.#e];
  }
  set value(t) {
    alemonjsCore.storeState[this.#e] = t;
  }
}
class ChildrenApp {
  // 名字
  #e = null;
  // 中间件
  #t = [];
  // 响应体
  #r = [];
  // 响应体下的中间件
  #i = {};
  // 周期
  #n = null;
  // create
  constructor(t = "main") {
    this.#e = t;
  }
  #a = {};
  register(t) {
    this.#a = t;
  }
  /**
   * 推送响应体
   * @param data
   */
  pushResponse(t) {
    this.#r = this.#r.concat(t);
  }
  /**
   * 推送响应下的中间件
   */
  pushResponseMiddleware(t) {
    this.#i = {
      ...this.#i,
      ...t
    };
  }
  /**
   * 推送中间件
   * @param data
   */
  pushMiddleware(t) {
    this.#t = this.#t.concat(t);
  }
  /**
   * 推送周期
   * @param data
   */
  pushSycle(t) {
    this.#n = t;
  }
  /**
   * 挂载
   */
  on() {
    alemonjsCore.storeChildrenApp[this.#e] = {
      name: this.#e,
      middleware: this.#t,
      middlewareResponse: this.#i,
      response: this.#r,
      cycle: this.#n,
      register: this.#a
    };
  }
  /**
   * 卸载
   */
  un() {
    delete alemonjsCore.storeChildrenApp[this.#e];
  }
  /**
   * 获取
   */
  get value() {
    return alemonjsCore.storeChildrenApp[this.#e] || this.on(), alemonjsCore.storeChildrenApp[this.#e];
  }
}
const ProcessorEventAutoClearMap = /* @__PURE__ */ new Map(), ProcessorEventUserAudoClearMap = /* @__PURE__ */ new Map(), logger$1 = new Logger().value, core = new Core().value;
["SIGINT", "SIGTERM", "SIGQUIT", "disconnect"].forEach((e) => {
  process$1?.on?.(e, () => {
    setImmediate(() => process$1.exit(0));
  });
});
process$1?.on?.("exit", (e) => {
  logger$1.info?.(`[alemonjs][exit] 进程退出，code=${e}`);
});
const initRequire$2 = () => {
};
initRequire$2.resolve = () => "";
const require$3 = initRequire$2, loadChildren = async (e, t) => {
  if (!e || typeof e != "string") {
    logger.error({
      code: ResultCode.FailParams,
      message: "The module path is not correct",
      data: null
    });
    return;
  }
  const r = pathBrowserifyExports.dirname(e), a = new ChildrenApp(t);
  try {
    const u = await import(`file://${e}`);
    if (!u?.default)
      throw new Error("The Children is not default");
    if (!u?.default?._name)
      throw new Error("The Children name is not correct");
    if (u.default._name !== "app")
      throw new Error("The Children name is not correct");
    if (!u?.default?.callback)
      throw new Error("The Children callback is not correct");
    let n = null;
    typeof u?.default?.callback != "function" ? n = u?.default.callback : n = await u.default.callback(), a.pushSycle(n);
    const o = async (l) => {
      showErrorModule(l), a.un();
      try {
        n?.unMounted && await n.unMounted(l);
      } catch (s) {
        showErrorModule(s);
      }
    };
    try {
      n?.onCreated && await n?.onCreated();
    } catch (l) {
      o(l);
      return;
    }
    const c = async () => {
      const l = await n?.register();
      l && l?.response && a.register(l), a.on();
      try {
        n?.onMounted && await n.onMounted({ response: [], responseMiddleware: {}, middleware: [] });
      } catch (s) {
        o(s);
      }
    }, f = async () => {
      const l = pathBrowserifyExports.join(r, "apps"), s = getRecursiveDirFiles(l), p = pathBrowserifyExports.join(r, "response"), m = getRecursiveDirFiles(p), g = [...s, ...m], y = [];
      for (const j of g) {
        const D = j.path.replace(r, ""), G = createEventName(D, t), V = {
          input: r,
          dir: pathBrowserifyExports.dirname(j.path),
          path: j.path,
          name: j.name,
          stateKey: G,
          appName: t
        };
        y.push(V);
      }
      a.pushResponse(y);
      const v = getRecursiveDirFiles(p, (j) => fileSuffixMiddleware.test(j.name)), E = {};
      for (const j of v) {
        const D = j.path.replace(r, ""), G = createEventName(D, t), V = {
          input: r,
          dir: pathBrowserifyExports.dirname(j.path),
          path: j.path,
          name: j.name,
          stateKey: G,
          appName: t
        };
        E[G] = V;
      }
      a.pushResponseMiddleware(E);
      const b = pathBrowserifyExports.join(r, "middleware"), q = getRecursiveDirFiles(b, (j) => fileSuffixMiddleware.test(j.name)), O = [];
      for (const j of q) {
        const D = j.path.replace(r, ""), G = createEventName(D, t), V = {
          input: r,
          dir: pathBrowserifyExports.dirname(j.path),
          path: j.path,
          name: j.name,
          stateKey: G,
          appName: t
        };
        O.push(V);
      }
      a.pushMiddleware(O), a.on();
      try {
        n?.onMounted && await n.onMounted({ response: y, responseMiddleware: E, middleware: O });
      } catch (j) {
        o(j);
      }
    };
    try {
      n?.register ? await c() : await f();
    } catch (l) {
      o(l);
    }
  } catch (u) {
    showErrorModule(u), a.un();
  }
}, loadChildrenFile = (e) => {
  if (typeof e != "string") {
    logger.error({
      code: ResultCode.FailParams,
      message: "The module name is not correct",
      data: null
    });
    return;
  }
  try {
    const t = require$3.resolve(e);
    if (!existsSync(t)) {
      logger.error({
        code: ResultCode.FailParams,
        message: "The main file does not exist," + t,
        data: null
      });
      return;
    }
    loadChildren(t, e);
  } catch (t) {
    showErrorModule(t);
  }
}, loadApps = () => {
  const e = getConfig(), t = Array.isArray(e.value?.apps) ? e.value.apps : Object.keys(e.value?.apps ?? {}).filter(Boolean), r = Array.from(new Set(t));
  Promise.all(r.map((a) => loadChildrenFile(a)));
}, run = (e) => {
  if (e && (pathBrowserifyExports.join(process$1.cwd(), e), !existsSync(e))) {
    logger.warn({
      code: ResultCode.Warn,
      message: "未找到主要入口文件",
      data: null
    });
    return;
  }
};
function loadModels() {
  const e = process$1.env.input ?? "";
  run(e), loadApps();
}
const defineChildren = (e) => {
  if (typeof e == "function" || typeof e == "object")
    return {
      _name: "app",
      callback: e
    };
  throw logger.error({
    code: ResultCode.FailParams,
    message: "Invalid callback: callback must be a object or function",
    data: null
  }), new Error("Invalid callback: callback must be a object or function");
};
globalThis.defineChildren = defineChildren;
const lazy = (e) => async () => (await e()).default, defineResponse = (e) => ({
  current: e
});
globalThis.defineResponse = defineResponse;
const defineMiddleware = (e) => ({
  current: e
});
globalThis.defineMiddleware = defineMiddleware;
const onGroup = (...e) => {
  if (e.length === 0)
    throw new Error("onGroup: 至少需要一个响应或中间件");
  const r = e[0].select, a = e.reduce((u, n) => (Array.isArray(n.current), u.concat(n.current)), []);
  return {
    select: r,
    current: a
  };
};
globalThis.onGroup = onGroup;
const onMiddleware = (e, t) => {
  if (typeof t != "function")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid callback: callback must be a function",
      data: null
    }), new Error("Invalid callback: callback must be a function");
  if (typeof e == "string" || typeof e == "object")
    return { current: t, select: e };
  throw logger.error({
    code: ResultCode.FailParams,
    message: "Invalid select: select must be a string or object",
    data: null
  }), new Error("Invalid select: select must be a string or object");
};
globalThis.onMiddleware = onMiddleware;
const OnMiddleware = (e, t) => onMiddleware(t, e);
globalThis.OnMiddleware = OnMiddleware;
const isAsyncFunction = (e) => Object.prototype.toString.call(e) === "[object AsyncFunction]", byteToHex = [];
for (let e = 0; e < 256; ++e)
  byteToHex.push((e + 256).toString(16).slice(1));
function unsafeStringify(e, t = 0) {
  return (byteToHex[e[t + 0]] + byteToHex[e[t + 1]] + byteToHex[e[t + 2]] + byteToHex[e[t + 3]] + "-" + byteToHex[e[t + 4]] + byteToHex[e[t + 5]] + "-" + byteToHex[e[t + 6]] + byteToHex[e[t + 7]] + "-" + byteToHex[e[t + 8]] + byteToHex[e[t + 9]] + "-" + byteToHex[e[t + 10]] + byteToHex[e[t + 11]] + byteToHex[e[t + 12]] + byteToHex[e[t + 13]] + byteToHex[e[t + 14]] + byteToHex[e[t + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = { randomUUID };
function v4(e, t, r) {
  if (native.randomUUID && !e)
    return native.randomUUID();
  e = e || {};
  const a = e.random ?? e.rng?.() ?? rng();
  if (a.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return a[6] = a[6] & 15 | 64, a[8] = a[8] & 63 | 128, unsafeStringify(a);
}
const childrenClient = /* @__PURE__ */ new Map(), platformClient = /* @__PURE__ */ new Map(), fullClient = /* @__PURE__ */ new Map(), deviceId = v4(), USER_AGENT_HEADER = "user-agent", USER_AGENT_HEADER_VALUE_MAP = {
  platform: "platform",
  client: "client",
  testone: "testone"
}, DEVICE_ID_HEADER = "x-device-id", FULL_RECEIVE_HEADER = "x-full-receive", actionResolves = /* @__PURE__ */ new Map(), apiResolves = /* @__PURE__ */ new Map(), actionTimeouts = /* @__PURE__ */ new Map(), apiTimeouts = /* @__PURE__ */ new Map(), childrenBind = /* @__PURE__ */ new Map(), generateUniqueId = () => Date.now().toString(36) + Math.random().toString(36).substring(2), timeoutTime = 1e3 * 60 * 3, reconnectInterval = 1e3 * 6, HEARTBEAT_INTERVAL = 1e3 * 18, sendAction = (e) => {
  const t = generateUniqueId();
  return new Promise((r) => {
    e.actionId = t, e.DeviceId = deviceId, globalThis.chatbotClient.send(stringify(e)), actionResolves.set(t, r);
    const a = setTimeout(() => {
      !actionResolves.has(t) || !actionTimeouts.has(t) || (actionResolves.delete(t), actionTimeouts.delete(t), r([createResult(ResultCode.Fail, "行为超时", null)]));
    }, timeoutTime);
    actionTimeouts.set(t, a);
  });
}, sendAPI = (e) => {
  const t = generateUniqueId();
  return new Promise((r) => {
    e.apiId = t, e.DeviceId = deviceId, globalThis.chatbotClient.send(stringify(e)), apiResolves.set(t, r);
    const a = setTimeout(() => {
      !apiResolves.has(t) || !apiTimeouts.has(t) || (apiResolves.delete(t), apiTimeouts.delete(t), r([createResult(ResultCode.Fail, "接口超时", null)]));
    }, timeoutTime);
    apiTimeouts.set(t, a);
  });
}, useMention = (e) => {
  if (!e || typeof e != "object")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid event: event must be an object",
      data: null
    }), new Error("Invalid event: event must be an object");
  let t = null;
  return [{
    find: async (a = {}) => {
      try {
        if (!t) {
          const o = (await sendAction({
            action: "mention.get",
            payload: {
              event: e
            }
          })).find((c) => c.code === ResultCode.Ok);
          o && (t = o.data);
        }
      } catch (n) {
        return createResult(ResultCode.Fail, n?.message || "Failed to get mention data", null);
      }
      if (!Array.isArray(t))
        return createResult(ResultCode.Warn, "No mention data found", null);
      const u = t.filter((n) => !(a.UserId !== void 0 && n.UserId !== a.UserId || a.UserKey !== void 0 && n.UserKey !== a.UserKey || a.UserName !== void 0 && n.UserName !== a.UserName || a.IsMaster !== void 0 && n.IsMaster !== a.IsMaster || a.IsBot !== void 0 && n.IsBot !== a.IsBot));
      return createResult(ResultCode.Ok, "Successfully retrieved mention data", u);
    },
    findOne: async (a = {}) => {
      try {
        if (!t) {
          const o = (await sendAction({
            action: "mention.get",
            payload: {
              event: e
            }
          })).find((c) => c.code === ResultCode.Ok);
          o && (t = o.data);
        }
      } catch (n) {
        return createResult(ResultCode.Fail, n?.message || "Failed to get mention data", null);
      }
      if (!Array.isArray(t))
        return createResult(ResultCode.Warn, "No mention data found", null);
      const u = t.find((n) => !(a.UserId !== void 0 && n.UserId !== a.UserId || a.UserKey !== void 0 && n.UserKey !== a.UserKey || a.UserName !== void 0 && n.UserName !== a.UserName || a.IsMaster !== void 0 && n.IsMaster !== a.IsMaster || a.IsBot !== void 0 && n.IsBot !== a.IsBot || n.IsBot));
      return u ? createResult(ResultCode.Ok, "Successfully retrieved mention data", u) : createResult(ResultCode.Warn, "No mention data found", null);
    }
  }];
}, useMessage = (e) => {
  if (!e || typeof e != "object")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid event: event must be an object",
      data: null
    }), new Error("Invalid event: event must be an object");
  return [{
    send: async (a) => {
      if (!a || a.length === 0)
        return [createResult(ResultCode.FailParams, "Invalid val: val must be a non-empty array", null)];
      const u = await sendAction({
        action: "message.send",
        payload: {
          event: e,
          params: {
            format: a
          }
        }
      });
      return Array.isArray(u) ? u : [u];
    }
    // withdraw,
    // forward,
    // reply,
    // update,
    // pinning,
    // horn,
    // reaction
  }];
}, useMenber = (e) => {
  if (!e || typeof e != "object")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid event: event must be an object",
      data: null
    }), new Error("Invalid event: event must be an object");
  return [{
    // information,
    // mute,
    // unmute,
    // remove
  }];
}, useChannel = (e) => {
  if (!e || typeof e != "object")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid event: event must be an object",
      data: null
    }), new Error("Invalid event: event must be an object");
  return [{
    // exit,
    // join
  }];
}, useSend = (e) => {
  const [t] = useMessage(e);
  return (...a) => t.send(a);
}, useSends = (e) => {
  const [t] = useMessage(e);
  return [t.send];
}, unChildren = (e = "main") => {
  if (!e || typeof e != "string")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid name: name must be a string",
      data: null
    }), new Error("Invalid name: name must be a string");
  new ChildrenApp(e).un();
}, onSelects = (e) => e;
globalThis.onSelects = onSelects;
const createSelects = onSelects, useClient = (e, t) => [new Proxy({}, {
  get(a, u) {
    return (...n) => sendAPI({
      action: "client.api",
      payload: {
        event: e,
        key: String(u),
        params: n
      }
    });
  }
})], createCallHandler = (e) => {
  const [t] = useMessage(e);
  return (a, u) => {
    let n = 0, o = !1, c = !1;
    const f = (s) => {
      if (!s) {
        o = !0;
        return;
      }
      Array.isArray(s) ? (s.length > 0 && t.send(s), o = !0) : typeof s == "object" && (Array.isArray(s.data) && t.send(s.data), s.allowGrouping || (o = !0));
    }, l = async () => {
      if (!(n >= a.length) && !c && !o) {
        try {
          if (isAsyncFunction(a[n])) {
            const s = await a[n](e, (...p) => {
              c = !0, u(...p);
            });
            f(s);
          } else {
            const s = a[n](e, (...p) => {
              c = !0, u(...p);
            });
            f(s);
          }
        } catch (s) {
          showErrorModule(s);
          return;
        }
        ++n, l();
      }
    };
    l();
  };
}, useState = (e, t = !0) => {
  if (typeof e != "string")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid name: name must be a string",
      data: null
    }), new Error("Invalid name: name must be a string");
  if (typeof t != "boolean")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid defaultValue: defaultValue must be a boolean",
      data: null
    }), new Error("Invalid defaultValue: defaultValue must be a boolean");
  const r = new State(e, t), a = (u) => {
    if (r.value === u)
      return;
    r.value = u;
    const n = getConfig();
    n.value.core ??= {}, n.value.core.state ??= [], n.value.core.state.find((f) => f === e) !== u && (u ? n.value.core.state = n.value.core.state.filter((f) => f !== e) : n.value.core.state.push(e)), n.saveValue(n.value);
  };
  return [r.value, a];
}, onState = (e, t) => {
  if (typeof t != "function")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Callback must be a function",
      data: null
    }), new Error("Callback must be a function");
  new StateSubscribe(e).on(t);
}, unState = (e, t) => {
  if (typeof t != "function")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Callback must be a function",
      data: null
    }), new Error("Callback must be a function");
  new StateSubscribe(e).un(t);
}, callHandlerFile = async (e, t, r, a, u) => {
  try {
    const n = await import(`file://${r.path}`);
    if (!n?.default?.current || !n?.default?.select) {
      a();
      return;
    }
    if (r?.stateKey) {
      const [c] = useState(r?.stateKey);
      if (c === !1) {
        a();
        return;
      }
    }
    if (EventMessageText.includes(t) && n?.regular && !new RegExp(n.regular).test(e.MessageText)) {
      a();
      return;
    }
    if (!(Array.isArray(n.default.select) ? n.default.select : [n.default.select]).includes(t)) {
      a();
      return;
    }
    u(n);
  } catch (n) {
    showErrorModule(n);
  }
}, createNextStep = (e, t, r, a, u) => {
  let n = 0;
  const o = /* @__PURE__ */ new Set(), c = (l, ...s) => {
    if (l) {
      r(...s);
      return;
    }
    if (n >= a.length) {
      r();
      return;
    }
    f();
  }, f = async () => {
    if (n >= a.length) {
      c();
      return;
    }
    n++;
    const l = a[n - 1];
    if (!l?.path) {
      c();
      return;
    }
    const p = new ResponseMiddleware().find(l.appName, l.stateKey), m = [];
    for (const g of [...p, l]) {
      let y = !1;
      if (o.has(g.stateKey))
        return;
      if (await callHandlerFile(e, t, g, () => {
        y = !0, o.add(g.stateKey);
      }, (E) => {
        const b = Array.isArray(E.default.current) ? E.default.current : [E.default.current];
        m.push(...b);
      }), y) {
        c();
        return;
      }
    }
    u(m, c);
  };
  return c;
}, createRouteProcessChildren = (e, t, r, a) => {
  const u = (n, o, c) => {
    if (!n || n.length === 0) {
      c();
      return;
    }
    let f = 0;
    const l = async () => {
      if (f++, f > n.length) {
        c();
        return;
      }
      const s = n[f - 1];
      if (s?.selects && !(Array.isArray(s.selects) ? s.selects : [s.selects]).includes(t)) {
        l();
        return;
      }
      if (EventMessageText.includes(t) && s.regular && !new RegExp(s.regular).test(e.MessageText)) {
        l();
        return;
      }
      if (!s.handler) {
        l();
        return;
      }
      if (s.children && s.children.length > 0) {
        u(s.children, [...o, s.handler], l);
        return;
      }
      const p = [...o, s.handler];
      try {
        const m = [];
        for (const g of p) {
          const y = isAsyncFunction(g) ? await g() : g();
          if (!(Array.isArray(y.select) ? y.select : [y.select]).includes(t)) {
            l();
            return;
          }
          const E = Array.isArray(y.current) ? y.current : [y.current];
          m.push(...E);
        }
        a(m, (g, ...y) => {
          if (g) {
            r(!0, ...y);
            return;
          }
          l();
        });
      } catch (m) {
        showErrorModule(m);
      }
    };
    l();
  };
  return u;
}, expendEvent = (e, t, r) => {
  const u = new Response$1().value, n = createCallHandler(e), o = createNextStep(e, t, r, u, n), f = new ResponseRouter().value, l = createCallHandler(e);
  createRouteProcessChildren(e, t, o, l)(f, [], o);
}, expendMiddleware = (e, t, r) => {
  const u = new Middleware().value, n = createCallHandler(e), o = createNextStep(e, t, r, u, n), f = new MiddlewareRouter().value, l = createCallHandler(e);
  createRouteProcessChildren(e, t, o, l)(f, [], o);
}, expendSubscribe = (e, t, r, a) => {
  const u = new SubscribeList(a, t), n = (o, ...c) => {
    if (o) {
      r(...c);
      return;
    }
    const f = u.value.popNext();
    if (!f) {
      n(!0);
      return;
    }
    for (const m in f.data.keys)
      if (f.data.keys[m] !== e[m]) {
        n();
        return;
      }
    const l = () => {
      const m = f.data.selects, g = f.data.id;
      for (const y of m) {
        const v = new SubscribeList(a, y), E = () => {
          const b = v.value.popNext();
          if (!b || b.data.id !== g) {
            E();
            return;
          }
          v.value.removeCurrent();
        };
        E();
      }
    }, s = () => {
      const m = f.data.selects;
      for (const g of m)
        new SubscribeList(a, g).value.append(f.data);
    };
    l();
    const p = (m, ...g) => {
      if (s(), m) {
        n(...g);
        return;
      }
      typeof m == "boolean" && (l(), n(...g));
    };
    f.data.current(e, p);
  };
  n();
}, expendSubscribeCreate = (e, t, r) => {
  expendSubscribe(e, t, r, "create");
}, expendSubscribeMount = (e, t, r) => {
  expendSubscribe(e, t, r, "mount");
}, expendSubscribeUnmount = (e, t, r) => {
  expendSubscribe(e, t, r, "unmount");
}, showLog = (e, t) => {
  if (process$1.env.NODE_ENV === "development") {
    const r = {
      Name: t
    };
    for (const a in e)
      if (Object.prototype.hasOwnProperty.call(e, a)) {
        const u = e[a];
        (typeof u == "string" || typeof u == "number" || typeof u == "boolean") && (r[a] = u);
      }
    logger.debug({
      code: ResultCode.Ok,
      message: "new event",
      data: r
    });
  } else {
    let r = `[Name: ${t}]`;
    typeof e.GuildId == "string" && e.GuildId !== "" && (r += `[GuildId:${e.GuildId}]`), typeof e.ChannelId == "string" && e.ChannelId !== "" && (r += `[ChannelId:${e.ChannelId}]`), typeof e.UserKey == "string" && e.UserKey !== "" && (r += `[UserKey:${e.UserKey}]`), typeof e.UserId == "string" && e.UserId !== "" && (r += `[UserId:${e.UserId}]`), typeof e.MessageId == "string" && e.MessageId !== "" && (r += `[MessageId:${e.MessageId}]`), typeof e.MessageText == "string" && e.MessageText !== "" && (r += `[MessageText:${e.MessageText}]`), logger.info(r);
  }
}, expendCycle = (e, t) => {
  const r = () => {
  }, a = (f, ...l) => {
    if (f) {
      r(...l);
      return;
    }
    expendSubscribeUnmount(e, t, r);
  }, u = (f, ...l) => {
    if (f) {
      a(...l);
      return;
    }
    expendEvent(e, t, a);
  }, n = (f, ...l) => {
    if (f) {
      u(...l);
      return;
    }
    expendSubscribeMount(e, t, u);
  }, o = (f, ...l) => {
    if (f) {
      n(...l);
      return;
    }
    expendMiddleware(e, t, n);
  }, c = getConfigValue() ?? {};
  if (Array.isArray(c?.logs?.channel_id)) {
    const f = c?.logs?.channel_id;
    f && f.length > 0 && f.includes(e.ChannelId) && showLog(e, t);
  } else
    showLog(e, t);
  expendSubscribeCreate(e, t, o);
}, filter = ({ Now: e, store: t, INTERVAL: r }, a) => {
  if (t.has(a)) {
    const u = t.get(a);
    if (e - u < r)
      return t.set(a, Date.now()), !0;
  }
  t.set(a, Date.now());
}, cleanupStore = ({ Now: e, store: t, INTERVAL: r }) => {
  for (const [a, u] of t.entries())
    e - u > r && t.delete(a);
}, cleanupStoreAll = () => {
  const e = Date.now(), t = getConfigValue(), r = t?.processor?.repeated_event_time ?? processorRepeatedEventTime, a = t?.processor?.repeated_user_time ?? processorRepeatedUserTime;
  cleanupStore({ Now: e, INTERVAL: r, store: ProcessorEventAutoClearMap }), cleanupStore({ Now: e, INTERVAL: a, store: ProcessorEventUserAudoClearMap });
}, callback = () => {
  cleanupStoreAll();
  const t = ProcessorEventAutoClearMap.size + ProcessorEventUserAudoClearMap.size > processorPepeatedClearSize ? processorRepeatedClearTimeMin : processorRepeatedClearTimeMax;
  setTimeout(callback, t);
};
setTimeout(callback, processorRepeatedClearTimeMin);
const onProcessor = (e, t, r) => {
  const a = getConfigValue(), u = a?.disabled_text_regular;
  if (u && t.MessageText && new RegExp(u).test(t.MessageText) || (a?.disabled_selects ?? {})[e])
    return;
  const o = a?.disabled_user_id ?? {};
  if (t.UserId && o[t.UserId])
    return;
  const c = a?.disabled_user_key ?? {};
  if (t.UserKey && c[t.UserKey])
    return;
  const f = a?.redirect_regular ?? a?.redirect_text_regular, l = a?.redirect_target ?? a?.redirect_text_target;
  if (f && l && t.MessageText) {
    const q = new RegExp(f);
    q.test(t.MessageText) && (t.MessageText = t.MessageText.replace(q, l));
  }
  const s = a?.mapping_text ?? [];
  for (const q of s) {
    const { regular: O, target: j } = q ?? {};
    if (!O)
      continue;
    const D = new RegExp(O);
    D.test(t.MessageText) && (t.MessageText = t.MessageText.replace(D, j));
  }
  const p = a?.master_id ?? {}, m = a?.master_key ?? {};
  (t.UserId && p[t.UserId] || t.UserKey && m[t.UserKey]) && (t.isMaster = !0);
  const g = a?.bot_id ?? {}, y = a?.bot_key ?? {};
  (t.UserId && g[t.UserId] || t.UserKey && y[t.UserKey]) && (t.isBot = !0);
  const v = Date.now(), E = a?.processor?.repeated_event_time ?? processorRepeatedEventTime;
  if (t.MessageId) {
    const q = createHash(t.MessageId);
    if (filter({ Now: v, INTERVAL: E, store: ProcessorEventAutoClearMap }, q))
      return;
  }
  const b = a?.processor?.repeated_user_time ?? processorRepeatedUserTime;
  if (t.UserId) {
    const q = createHash(t.UserId);
    if (filter({ Now: v, INTERVAL: b, store: ProcessorEventUserAudoClearMap }, q))
      return;
  }
  r && Object.defineProperty(t, "value", {
    get() {
      return r;
    }
  }), t.name = e, expendCycle(t, e);
}, OnProcessor = (e, t) => {
  onProcessor(t, e);
}, onResponse = (e, t) => ({ current: t, select: e });
globalThis.onResponse = onResponse;
const OnResponse = (e, t) => onResponse(t, e);
globalThis.OnResponse = OnResponse;
const useSubscribe = (e, t) => {
  if (typeof e != "object")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "event is not object",
      data: null
    }), new Error("event is not object");
  if (typeof t != "string" && !Array.isArray(t))
    throw logger.error({
      code: ResultCode.FailParams,
      message: "select is not string or array",
      data: null
    }), new Error("select is not string or array");
  const r = (f, l, s) => {
    const p = Array.isArray(t) ? t : [t], m = Date.now().toString(36) + Math.random().toString(36).substring(2, 15);
    for (const g of p) {
      const y = new SubscribeList(s, g);
      if (l.length === 0)
        return;
      const v = {};
      for (const E of l)
        typeof E == "string" && (typeof e[E] == "string" || typeof e[E] == "number" || typeof e[E] == "boolean") ? v[E] = e[E] : logger.warn({
          code: ResultCode.FailParams,
          message: `Invalid key: ${E?.toString()} must be a string, number or boolean`,
          data: null
        });
      y.value.append({
        choose: s,
        selects: p,
        keys: v,
        current: f,
        id: m
      });
    }
    return {
      selects: p,
      choose: s,
      id: m
    };
  };
  return [{
    create: (f, l) => r(f, l, "create"),
    mount: (f, l) => r(f, l, "mount"),
    unmount: (f, l) => r(f, l, "unmount"),
    cancel: (f) => {
      const l = f.selects, s = f.id;
      for (const p of l) {
        const m = new SubscribeList(f.choose, p), g = () => {
          const y = m.value.popNext();
          if (!y || y.data.id !== s) {
            g();
            return;
          }
          m.value.removeCurrent();
        };
        g();
      }
    }
  }];
}, useObserver = (e, t) => {
  const [r] = useSubscribe(e, t);
  return [r.mount, r.cancel];
}, createEventValue = (e) => e.value, format = (...e) => {
  if (!e || e.length === 0)
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid data: data cannot be empty",
      data: null
    }), new Error("Invalid data: data cannot be empty");
  return e;
};
globalThis.format = format;
const createDataFormat = format, sendToChannel = async (e, t) => {
  if (!e || typeof e != "string")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid SpaceId: SpaceId must be a string",
      data: null
    }), new Error("Invalid SpaceId: SpaceId must be a string");
  return await sendAction({
    action: "message.send.channel",
    payload: {
      ChannelId: e,
      params: {
        format: t
      }
    }
  });
}, sendToUser = async (e, t) => {
  if (!e || typeof e != "string")
    throw logger.error({
      code: ResultCode.FailParams,
      message: "Invalid OpenID: OpenID must be a string",
      data: null
    }), new Error("Invalid OpenID: OpenID must be a string");
  return await sendAction({
    action: "message.send.user",
    payload: {
      UserId: e,
      params: {
        format: t
      }
    }
  });
}, Text = (e, t) => ({
  type: "Text",
  value: e,
  options: t
}), Link = (e, t) => ({
  type: "Text",
  value: e,
  options: t
}), ImageURL = (e) => ({
  type: "ImageURL",
  value: e
}), ImageFile = (e) => ({
  type: "ImageFile",
  value: e
}), Image = (e) => ({
  type: "Image",
  value: e.toString("base64")
});
Image.url = ImageURL;
Image.file = ImageFile;
const Mention = (e, t) => ({
  type: "Mention",
  value: e,
  options: t ?? {
    belong: "user"
  }
}), BT = (e, t, r) => ({
  type: "Button",
  value: e,
  options: {
    data: t,
    ...r
  }
});
BT.group = function e(...t) {
  return {
    type: "BT.group",
    value: t
  };
};
BT.template = function e(t) {
  return {
    type: "ButtonTemplate",
    value: t
  };
};
BT.row = function e(...t) {
  return {
    type: "BT.row",
    value: t
  };
};
const Ark = {
  /**
   *
   * @param values 要显示的文本
   * @returns
   */
  list: (...e) => ({
    type: "Ark.list",
    value: e
  }),
  /**
   *
   * @param options 提示信息
   * @returns
   */
  listTip: (e) => ({
    type: "Ark.listTip",
    value: e
  }),
  /**
   *
   * @param values 实际内容
   * @returns
   */
  listContent: (...e) => ({
    type: "Ark.listContent",
    value: e
  }),
  /**
   *
   * @param value 列表项内容
   * @returns
   */
  listItem: (e) => ({
    type: "Ark.listItem",
    value: e
  }),
  /**
   * @param value 卡片内容
   * @returns
   */
  Card: (e) => ({
    type: "Ark.Card",
    value: e
  }),
  /**
   * @param value 大卡片内容
   * @returns
   */
  BigCard: (e) => ({
    type: "Ark.BigCard",
    value: e
  })
}, MD = (...e) => ({
  type: "Markdown",
  value: e
});
MD.template = (e, t) => ({
  type: "MarkdownTemplate",
  value: e,
  options: {
    params: t
  }
});
MD.text = (e) => ({
  type: "MD.text",
  value: e
});
MD.title = (e) => ({
  type: "MD.title",
  value: e
});
MD.subtitle = (e) => ({
  type: "MD.subtitle",
  value: e
});
MD.bold = (e) => ({
  type: "MD.bold",
  value: e
});
MD.italic = (e) => ({
  type: "MD.italic",
  value: e
});
MD.italicStar = (e) => ({
  type: "MD.italicStar",
  value: e
});
MD.strikethrough = (e) => ({
  type: "MD.strikethrough",
  value: e
});
MD.link = (e, t) => ({
  type: "MD.link",
  value: { text: e, url: t }
});
MD.image = (e, t) => ({
  type: "MD.image",
  value: e,
  options: t
});
MD.list = (...e) => ({
  type: "MD.list",
  value: e
});
MD.listItem = (e, t) => ({
  type: "MD.listItem",
  value: typeof e == "number" ? { index: e, text: t } : e
});
MD.blockquote = (e) => ({
  type: "MD.blockquote",
  value: e
});
MD.divider = () => ({
  type: "MD.divider"
});
MD.newline = (e = !1) => ({
  type: "MD.newline",
  value: e
});
MD.code = (e, t) => ({
  type: "MD.code",
  value: e,
  options: t
});
const useHeartbeat = ({ ping: e, isConnected: t, terminate: r }) => {
  let a = null, u = Date.now();
  const n = () => {
    a && (clearInterval(a), a = null);
  }, o = () => {
    if (t()) {
      const l = Date.now() - u, s = HEARTBEAT_INTERVAL * 2;
      if (l > s) {
        logger.debug({
          code: ResultCode.Fail,
          message: "心跳超时，断开重连",
          data: null
        }), r();
        return;
      }
      e(), logger.debug({
        code: ResultCode.Ok,
        message: "发送 ping",
        data: null
      }), a = setTimeout(o, HEARTBEAT_INTERVAL);
    } else
      n(), r();
  };
  return [{
    start: () => {
      u = Date.now(), n(), o();
    },
    stop: n,
    pong: () => {
      u = Date.now(), logger.debug({
        code: ResultCode.Ok,
        message: "收到 pong",
        data: null
      });
    }
  }];
}, cbpClient = (e, t = {}) => {
  globalThis.chatbotClient && delete globalThis.chatbotClient;
  const { open: r = () => {
  }, isFullReceive: a = !0 } = t, [u] = useHeartbeat({
    ping: () => {
      globalThis?.chatbotClient?.ping?.();
    },
    isConnected: () => globalThis?.chatbotClient && globalThis?.chatbotClient?.readyState === browserExports.WebSocket.OPEN,
    terminate: () => {
      try {
        globalThis?.chatbotClient?.terminate?.();
      } catch (o) {
        logger.debug({
          code: ResultCode.Fail,
          message: "强制断开连接失败",
          data: o
        });
      }
    }
  }), n = () => {
    globalThis.chatbotClient = new browserExports.WebSocket(e, {
      headers: {
        [USER_AGENT_HEADER]: "client",
        [DEVICE_ID_HEADER]: deviceId,
        [FULL_RECEIVE_HEADER]: a ? "1" : "0"
      }
    }), globalThis.chatbotClient.on("open", () => {
      r(), u.start();
    }), globalThis.chatbotClient.on("pong", () => {
      u.pong();
    }), globalThis.chatbotClient.on("message", (o) => {
      try {
        const c = parse$2(o.toString());
        if (logger.debug({
          code: ResultCode.Ok,
          message: "客户端接收到消息",
          data: c
        }), c?.activeId) {
          if (c.active === "sync") {
            const l = c.payload.env || {};
            for (const s in l)
              process$1.env[s] = l[s];
          }
        } else if (c?.apiId) {
          const f = apiResolves.get(c.apiId);
          if (f) {
            apiResolves.delete(c.apiId);
            const l = apiTimeouts.get(c.apiId);
            l && (apiTimeouts.delete(c.apiId), clearTimeout(l)), Array.isArray(c.payload) ? f(c.payload) : f([createResult(ResultCode.Fail, "接口处理错误", null)]);
          }
        } else if (c?.actionId) {
          const f = actionResolves.get(c.actionId);
          if (f) {
            actionResolves.delete(c.actionId);
            const l = actionTimeouts.get(c.actionId);
            l && (actionTimeouts.delete(c.actionId), clearTimeout(l)), Array.isArray(c.payload) ? f(c.payload) : f([createResult(ResultCode.Fail, "消费处理错误", null)]);
          }
        } else c.name && onProcessor(c.name, c, c.value);
      } catch (c) {
        logger.error({
          code: ResultCode.Fail,
          message: "客户端解析消息失败",
          data: c
        });
      }
    }), globalThis.chatbotClient.on("close", () => {
      u.stop(), logger.warn({
        code: ResultCode.Fail,
        message: "连接关闭，尝试重新连接...",
        data: null
      }), delete globalThis.chatbotClient, setTimeout(() => {
        n();
      }, reconnectInterval);
    }), globalThis.chatbotClient.on("error", (o) => {
      logger.error({
        code: ResultCode.Fail,
        message: "客户端错误",
        data: o
      });
    });
  };
  n();
}, cbpPlatform = (e, t = {
  open: () => {
  }
}) => {
  globalThis.chatbotPlatform && delete globalThis.chatbotPlatform;
  const { open: r = () => {
  } } = t, [a] = useHeartbeat({
    ping: () => {
      globalThis?.chatbotPlatform?.ping?.();
    },
    isConnected: () => globalThis?.chatbotPlatform && globalThis?.chatbotPlatform?.readyState === browserExports.WebSocket.OPEN,
    terminate: () => {
      try {
        globalThis?.chatbotPlatform?.terminate?.();
      } catch (g) {
        logger.debug({
          code: ResultCode.Fail,
          message: "强制断开连接失败",
          data: g
        });
      }
    }
  }), u = (g) => {
    globalThis.chatbotPlatform && globalThis.chatbotPlatform.readyState === browserExports.WebSocket.OPEN && (g.DeviceId = deviceId, globalThis.chatbotPlatform.send(stringify(g)));
  }, n = [], o = [], c = (g, y) => {
    globalThis.chatbotPlatform && globalThis.chatbotPlatform.readyState === browserExports.WebSocket.OPEN && globalThis.chatbotPlatform.send(
      stringify({
        action: g.action,
        payload: y,
        actionId: g.actionId,
        DeviceId: g.DeviceId
      })
    );
  }, f = (g, y) => {
    globalThis.chatbotPlatform && globalThis.chatbotPlatform.readyState === browserExports.WebSocket.OPEN && globalThis.chatbotPlatform.send(
      stringify({
        action: g.action,
        apiId: g.apiId,
        DeviceId: g.DeviceId,
        payload: y
      })
    );
  }, l = (g) => {
    n.push(g);
  }, s = (g) => {
    o.push(g);
  }, p = () => {
    globalThis.chatbotPlatform = new browserExports.WebSocket(e, {
      headers: {
        [USER_AGENT_HEADER]: "platform",
        [DEVICE_ID_HEADER]: deviceId
      }
    }), globalThis.chatbotPlatform.on("open", () => {
      r(), a.start();
    }), globalThis.chatbotPlatform.on("pong", () => {
      a.pong();
    }), globalThis.chatbotPlatform.on("message", (g) => {
      try {
        const y = parse$2(g.toString());
        if (logger.debug({
          code: ResultCode.Ok,
          message: "平台端接收消息",
          data: y
        }), y.apiId)
          for (const v of o)
            v(
              y,
              // 传入一个消费函数
              (E) => f(y, E)
            );
        else if (y.actionId)
          for (const v of n)
            v(
              y,
              // 传入一个消费函数
              (E) => c(y, E)
            );
      } catch (y) {
        logger.error({
          code: ResultCode.Fail,
          message: "解析消息失败",
          data: y
        });
      }
    }), globalThis.chatbotPlatform.on("close", (g) => {
      a.stop(), logger.warn({
        code: ResultCode.Fail,
        message: "平台端连接关闭，尝试重新连接...",
        data: g
      }), delete globalThis.chatbotPlatform, setTimeout(() => {
        p();
      }, reconnectInterval);
    }), globalThis.chatbotPlatform.on("error", (g) => {
      logger.error({
        code: ResultCode.Fail,
        message: "平台端错误",
        data: g
      });
    });
  };
  return p(), {
    send: u,
    onactions: l,
    onapis: s
  };
};
var application = { exports: {} }, streamHttp = {}, request$1 = { exports: {} }, capability = {}, hasRequiredCapability;
function requireCapability() {
  return hasRequiredCapability || (hasRequiredCapability = 1, (function(e) {
    e.fetch = u(globalThis.fetch) && u(globalThis.ReadableStream), e.writableStream = u(globalThis.WritableStream), e.abortController = u(globalThis.AbortController);
    var t;
    function r() {
      if (t !== void 0) return t;
      if (globalThis.XMLHttpRequest) {
        t = new globalThis.XMLHttpRequest();
        try {
          t.open("GET", globalThis.XDomainRequest ? "/" : "https://example.com");
        } catch {
          t = null;
        }
      } else
        t = null;
      return t;
    }
    function a(n) {
      var o = r();
      if (!o) return !1;
      try {
        return o.responseType = n, o.responseType === n;
      } catch {
      }
      return !1;
    }
    e.arraybuffer = e.fetch || a("arraybuffer"), e.msstream = !e.fetch && a("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && a("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (r() ? u(r().overrideMimeType) : !1);
    function u(n) {
      return typeof n == "function";
    }
    t = null;
  })(capability)), capability;
}
var response$1 = {}, readableBrowser = { exports: {} }, hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, (function(e, t) {
    t = e.exports = require_stream_readable$1(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable$1(), t.Duplex = require_stream_duplex$1(), t.Transform = require_stream_transform$1(), t.PassThrough = require_stream_passthrough$1(), t.finished = requireEndOfStream(), t.pipeline = requirePipeline();
  })(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var hasRequiredResponse$1;
function requireResponse$1() {
  if (hasRequiredResponse$1) return response$1;
  hasRequiredResponse$1 = 1;
  var e = requireCapability(), t = requireInherits_browser(), r = requireReadableBrowser(), a = response$1.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, u = response$1.IncomingMessage = function(n, o, c, f) {
    var l = this;
    if (r.Readable.call(l), l._mode = c, l.headers = {}, l.rawHeaders = [], l.trailers = {}, l.rawTrailers = [], l.on("end", function() {
      process$1.nextTick(function() {
        l.emit("close");
      });
    }), c === "fetch") {
      let v = function() {
        p.read().then(function(E) {
          if (!l._destroyed) {
            if (f(E.done), E.done) {
              l.push(null);
              return;
            }
            l.push(Buffer.from(E.value)), v();
          }
        }).catch(function(E) {
          f(!0), l._destroyed || l.emit("error", E);
        });
      };
      if (l._fetchResponse = o, l.url = o.url, l.statusCode = o.status, l.statusMessage = o.statusText, o.headers.forEach(function(E, b) {
        l.headers[b.toLowerCase()] = E, l.rawHeaders.push(b, E);
      }), e.writableStream) {
        var s = new WritableStream({
          write: function(E) {
            return f(!1), new Promise(function(b, q) {
              l._destroyed ? q() : l.push(Buffer.from(E)) ? b() : l._resumeFetch = b;
            });
          },
          close: function() {
            f(!0), l._destroyed || l.push(null);
          },
          abort: function(E) {
            f(!0), l._destroyed || l.emit("error", E);
          }
        });
        try {
          o.body.pipeTo(s).catch(function(E) {
            f(!0), l._destroyed || l.emit("error", E);
          });
          return;
        } catch {
        }
      }
      var p = o.body.getReader();
      v();
    } else {
      l._xhr = n, l._pos = 0, l.url = n.responseURL, l.statusCode = n.status, l.statusMessage = n.statusText;
      var m = n.getAllResponseHeaders().split(/\r?\n/);
      if (m.forEach(function(v) {
        var E = v.match(/^([^:]+):\s*(.*)/);
        if (E) {
          var b = E[1].toLowerCase();
          b === "set-cookie" ? (l.headers[b] === void 0 && (l.headers[b] = []), l.headers[b].push(E[2])) : l.headers[b] !== void 0 ? l.headers[b] += ", " + E[2] : l.headers[b] = E[2], l.rawHeaders.push(E[1], E[2]);
        }
      }), l._charset = "x-user-defined", !e.overrideMimeType) {
        var g = l.rawHeaders["mime-type"];
        if (g) {
          var y = g.match(/;\s*charset=([^;])(;|$)/);
          y && (l._charset = y[1].toLowerCase());
        }
        l._charset || (l._charset = "utf-8");
      }
    }
  };
  return t(u, r.Readable), u.prototype._read = function() {
    var n = this, o = n._resumeFetch;
    o && (n._resumeFetch = null, o());
  }, u.prototype._onXHRProgress = function(n) {
    var o = this, c = o._xhr, f = null;
    switch (o._mode) {
      case "text":
        if (f = c.responseText, f.length > o._pos) {
          var l = f.substr(o._pos);
          if (o._charset === "x-user-defined") {
            for (var s = Buffer.alloc(l.length), p = 0; p < l.length; p++)
              s[p] = l.charCodeAt(p) & 255;
            o.push(s);
          } else
            o.push(l, o._charset);
          o._pos = f.length;
        }
        break;
      case "arraybuffer":
        if (c.readyState !== a.DONE || !c.response)
          break;
        f = c.response, o.push(Buffer.from(new Uint8Array(f)));
        break;
      case "moz-chunked-arraybuffer":
        if (f = c.response, c.readyState !== a.LOADING || !f)
          break;
        o.push(Buffer.from(new Uint8Array(f)));
        break;
      case "ms-stream":
        if (f = c.response, c.readyState !== a.LOADING)
          break;
        var m = new globalThis.MSStreamReader();
        m.onprogress = function() {
          m.result.byteLength > o._pos && (o.push(Buffer.from(new Uint8Array(m.result.slice(o._pos)))), o._pos = m.result.byteLength);
        }, m.onload = function() {
          n(!0), o.push(null);
        }, m.readAsArrayBuffer(f);
        break;
    }
    o._xhr.readyState === a.DONE && o._mode !== "ms-stream" && (n(!0), o.push(null));
  }, response$1;
}
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request$1.exports;
  hasRequiredRequest$1 = 1;
  var e = requireCapability(), t = requireInherits_browser(), r = requireResponse$1(), a = requireReadableBrowser(), u = r.IncomingMessage, n = r.readyStates;
  function o(s, p) {
    return e.fetch && p ? "fetch" : e.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : e.msstream ? "ms-stream" : e.arraybuffer && s ? "arraybuffer" : "text";
  }
  var c = request$1.exports = function(s) {
    var p = this;
    a.Writable.call(p), p._opts = s, p._body = [], p._headers = {}, s.auth && p.setHeader("Authorization", "Basic " + Buffer.from(s.auth).toString("base64")), Object.keys(s.headers).forEach(function(y) {
      p.setHeader(y, s.headers[y]);
    });
    var m, g = !0;
    if (s.mode === "disable-fetch" || "requestTimeout" in s && !e.abortController)
      g = !1, m = !0;
    else if (s.mode === "prefer-streaming")
      m = !1;
    else if (s.mode === "allow-wrong-content-type")
      m = !e.overrideMimeType;
    else if (!s.mode || s.mode === "default" || s.mode === "prefer-fast")
      m = !0;
    else
      throw new Error("Invalid value for opts.mode");
    p._mode = o(m, g), p._fetchTimer = null, p._socketTimeout = null, p._socketTimer = null, p.on("finish", function() {
      p._onFinish();
    });
  };
  t(c, a.Writable), c.prototype.setHeader = function(s, p) {
    var m = this, g = s.toLowerCase();
    l.indexOf(g) === -1 && (m._headers[g] = {
      name: s,
      value: p
    });
  }, c.prototype.getHeader = function(s) {
    var p = this._headers[s.toLowerCase()];
    return p ? p.value : null;
  }, c.prototype.removeHeader = function(s) {
    var p = this;
    delete p._headers[s.toLowerCase()];
  }, c.prototype._onFinish = function() {
    var s = this;
    if (!s._destroyed) {
      var p = s._opts;
      "timeout" in p && p.timeout !== 0 && s.setTimeout(p.timeout);
      var m = s._headers, g = null;
      p.method !== "GET" && p.method !== "HEAD" && (g = new Blob(s._body, {
        type: (m["content-type"] || {}).value || ""
      }));
      var y = [];
      if (Object.keys(m).forEach(function(q) {
        var O = m[q].name, j = m[q].value;
        Array.isArray(j) ? j.forEach(function(D) {
          y.push([O, D]);
        }) : y.push([O, j]);
      }), s._mode === "fetch") {
        var v = null;
        if (e.abortController) {
          var E = new AbortController();
          v = E.signal, s._fetchAbortController = E, "requestTimeout" in p && p.requestTimeout !== 0 && (s._fetchTimer = globalThis.setTimeout(function() {
            s.emit("requestTimeout"), s._fetchAbortController && s._fetchAbortController.abort();
          }, p.requestTimeout));
        }
        globalThis.fetch(s._opts.url, {
          method: s._opts.method,
          headers: y,
          body: g || void 0,
          mode: "cors",
          credentials: p.withCredentials ? "include" : "same-origin",
          signal: v
        }).then(function(q) {
          s._fetchResponse = q, s._resetTimers(!1), s._connect();
        }, function(q) {
          s._resetTimers(!0), s._destroyed || s.emit("error", q);
        });
      } else {
        var b = s._xhr = new globalThis.XMLHttpRequest();
        try {
          b.open(s._opts.method, s._opts.url, !0);
        } catch (q) {
          process$1.nextTick(function() {
            s.emit("error", q);
          });
          return;
        }
        "responseType" in b && (b.responseType = s._mode), "withCredentials" in b && (b.withCredentials = !!p.withCredentials), s._mode === "text" && "overrideMimeType" in b && b.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in p && (b.timeout = p.requestTimeout, b.ontimeout = function() {
          s.emit("requestTimeout");
        }), y.forEach(function(q) {
          b.setRequestHeader(q[0], q[1]);
        }), s._response = null, b.onreadystatechange = function() {
          switch (b.readyState) {
            case n.LOADING:
            case n.DONE:
              s._onXHRProgress();
              break;
          }
        }, s._mode === "moz-chunked-arraybuffer" && (b.onprogress = function() {
          s._onXHRProgress();
        }), b.onerror = function() {
          s._destroyed || (s._resetTimers(!0), s.emit("error", new Error("XHR error")));
        };
        try {
          b.send(g);
        } catch (q) {
          process$1.nextTick(function() {
            s.emit("error", q);
          });
          return;
        }
      }
    }
  };
  function f(s) {
    try {
      var p = s.status;
      return p !== null && p !== 0;
    } catch {
      return !1;
    }
  }
  c.prototype._onXHRProgress = function() {
    var s = this;
    s._resetTimers(!1), !(!f(s._xhr) || s._destroyed) && (s._response || s._connect(), s._response._onXHRProgress(s._resetTimers.bind(s)));
  }, c.prototype._connect = function() {
    var s = this;
    s._destroyed || (s._response = new u(s._xhr, s._fetchResponse, s._mode, s._resetTimers.bind(s)), s._response.on("error", function(p) {
      s.emit("error", p);
    }), s.emit("response", s._response));
  }, c.prototype._write = function(s, p, m) {
    var g = this;
    g._body.push(s), m();
  }, c.prototype._resetTimers = function(s) {
    var p = this;
    globalThis.clearTimeout(p._socketTimer), p._socketTimer = null, s ? (globalThis.clearTimeout(p._fetchTimer), p._fetchTimer = null) : p._socketTimeout && (p._socketTimer = globalThis.setTimeout(function() {
      p.emit("timeout");
    }, p._socketTimeout));
  }, c.prototype.abort = c.prototype.destroy = function(s) {
    var p = this;
    p._destroyed = !0, p._resetTimers(!0), p._response && (p._response._destroyed = !0), p._xhr ? p._xhr.abort() : p._fetchAbortController && p._fetchAbortController.abort(), s && p.emit("error", s);
  }, c.prototype.end = function(s, p, m) {
    var g = this;
    typeof s == "function" && (m = s, s = void 0), a.Writable.prototype.end.call(g, s, p, m);
  }, c.prototype.setTimeout = function(s, p) {
    var m = this;
    p && m.once("timeout", p), m._socketTimeout = s, m._resetTimers(!1);
  }, c.prototype.flushHeaders = function() {
  }, c.prototype.setNoDelay = function() {
  }, c.prototype.setSocketKeepAlive = function() {
  };
  var l = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return request$1.exports;
}
var immutable, hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable;
  hasRequiredImmutable = 1, immutable = t;
  var e = Object.prototype.hasOwnProperty;
  function t() {
    for (var r = {}, a = 0; a < arguments.length; a++) {
      var u = arguments[a];
      for (var n in u)
        e.call(u, n) && (r[n] = u[n]);
    }
    return r;
  }
  return immutable;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  return hasRequiredBrowser$3 || (hasRequiredBrowser$3 = 1, browser$3 = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), browser$3;
}
var hasRequiredStreamHttp;
function requireStreamHttp() {
  return hasRequiredStreamHttp || (hasRequiredStreamHttp = 1, (function(e) {
    var t = requireRequest$1(), r = requireResponse$1(), a = requireImmutable(), u = requireBrowser$3(), n = require$$0$5, o = e;
    o.request = function(c, f) {
      typeof c == "string" ? c = n.parse(c) : c = a(c);
      var l = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", s = c.protocol || l, p = c.hostname || c.host, m = c.port, g = c.path || "/";
      p && p.indexOf(":") !== -1 && (p = "[" + p + "]"), c.url = (p ? s + "//" + p : "") + (m ? ":" + m : "") + g, c.method = (c.method || "GET").toUpperCase(), c.headers = c.headers || {};
      var y = new t(c);
      return f && y.on("response", f), y;
    }, o.get = function(f, l) {
      var s = o.request(f, l);
      return s.end(), s;
    }, o.ClientRequest = t, o.IncomingMessage = r.IncomingMessage, o.Agent = function() {
    }, o.Agent.defaultMaxSockets = 4, o.globalAgent = new o.Agent(), o.STATUS_CODES = u, o.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  })(streamHttp)), streamHttp;
}
var onFinished = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst, hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst) return eeFirst;
  hasRequiredEeFirst = 1, eeFirst = e;
  function e(r, a) {
    if (!Array.isArray(r))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    for (var u = [], n = 0; n < r.length; n++) {
      var o = r[n];
      if (!Array.isArray(o) || o.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      for (var c = o[0], f = 1; f < o.length; f++) {
        var l = o[f], s = t(l, p);
        c.on(l, s), u.push({
          ee: c,
          event: l,
          fn: s
        });
      }
    }
    function p() {
      m(), a.apply(null, arguments);
    }
    function m() {
      for (var y, v = 0; v < u.length; v++)
        y = u[v], y.ee.removeListener(y.event, y.fn);
    }
    function g(y) {
      a = y;
    }
    return g.cancel = m, g;
  }
  function t(r, a) {
    return function(n) {
      for (var o = new Array(arguments.length), c = this, f = r === "error" ? n : null, l = 0; l < o.length; l++)
        o[l] = arguments[l];
      a(f, c, r, o);
    };
  }
  return eeFirst;
}
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished) return onFinished.exports;
  hasRequiredOnFinished = 1, onFinished.exports = a, onFinished.exports.isFinished = u;
  var e = l(), t = requireEeFirst(), r = typeof setImmediate == "function" ? setImmediate : function(p) {
    process$1.nextTick(p.bind.apply(p, arguments));
  };
  function a(p, m) {
    return u(p) !== !1 ? (r(m, null, p), p) : (o(p, s(m)), p);
  }
  function u(p) {
    var m = p.socket;
    if (typeof p.finished == "boolean")
      return !!(p.finished || m && !m.writable);
    if (typeof p.complete == "boolean")
      return !!(p.upgrade || !m || !m.readable || p.complete && !p.readable);
  }
  function n(p, m) {
    var g, y, v = !1;
    function E(q) {
      g.cancel(), y.cancel(), v = !0, m(q);
    }
    g = y = t([[p, "end", "finish"]], E);
    function b(q) {
      p.removeListener("socket", b), !v && g === y && (y = t([[q, "error", "close"]], E));
    }
    if (p.socket) {
      b(p.socket);
      return;
    }
    p.on("socket", b), p.socket === void 0 && f(p, b);
  }
  function o(p, m) {
    var g = p.__onFinished;
    (!g || !g.queue) && (g = p.__onFinished = c(p), n(p, g)), g.queue.push(m);
  }
  function c(p) {
    function m(g) {
      if (p.__onFinished === m && (p.__onFinished = null), !!m.queue) {
        var y = m.queue;
        m.queue = null;
        for (var v = 0; v < y.length; v++)
          y[v](g, p);
      }
    }
    return m.queue = [], m;
  }
  function f(p, m) {
    var g = p.assignSocket;
    typeof g == "function" && (p.assignSocket = function(v) {
      g.call(this, v), m(v);
    });
  }
  function l() {
    try {
      return require$$4;
    } catch {
      return {};
    }
  }
  function s(p) {
    var m;
    return e.AsyncResource && (m = new e.AsyncResource(p.name || "bound-anonymous-fn")), !m || !m.runInAsyncScope ? p : m.runInAsyncScope.bind(m, p, null);
  }
  return onFinished.exports;
}
var koaCompose, hasRequiredKoaCompose;
function requireKoaCompose() {
  if (hasRequiredKoaCompose) return koaCompose;
  hasRequiredKoaCompose = 1, koaCompose = e;
  function e(t) {
    if (!Array.isArray(t)) throw new TypeError("Middleware stack must be an array!");
    for (const r of t)
      if (typeof r != "function") throw new TypeError("Middleware must be composed of functions!");
    return function(r, a) {
      let u = -1;
      return n(0);
      function n(o) {
        if (o <= u) return Promise.reject(new Error("next() called multiple times"));
        u = o;
        let c = t[o];
        if (o === t.length && (c = a), !c) return Promise.resolve();
        try {
          return Promise.resolve(c(r, n.bind(null, o + 1)));
        } catch (f) {
          return Promise.reject(f);
        }
      }
    };
  }
  return koaCompose;
}
const require$$0$4 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$2, hasRequiredStatuses$2;
function requireStatuses$2() {
  if (hasRequiredStatuses$2) return statuses$2;
  hasRequiredStatuses$2 = 1;
  var e = require$$0$4;
  statuses$2 = n, n.message = e, n.code = t(e), n.codes = r(e), n.redirect = {
    300: !0,
    301: !0,
    302: !0,
    303: !0,
    305: !0,
    307: !0,
    308: !0
  }, n.empty = {
    204: !0,
    205: !0,
    304: !0
  }, n.retry = {
    502: !0,
    503: !0,
    504: !0
  };
  function t(o) {
    var c = {};
    return Object.keys(o).forEach(function(l) {
      var s = o[l], p = Number(l);
      c[s.toLowerCase()] = p;
    }), c;
  }
  function r(o) {
    return Object.keys(o).map(function(f) {
      return Number(f);
    });
  }
  function a(o) {
    var c = o.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(n.code, c))
      throw new Error('invalid status message: "' + o + '"');
    return n.code[c];
  }
  function u(o) {
    if (!Object.prototype.hasOwnProperty.call(n.message, o))
      throw new Error("invalid status code: " + o);
    return n.message[o];
  }
  function n(o) {
    if (typeof o == "number")
      return u(o);
    if (typeof o != "string")
      throw new TypeError("code must be a number or string");
    var c = parseInt(o, 10);
    return isNaN(c) ? a(o) : u(c);
  }
  return statuses$2;
}
var httpErrors$1 = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1, browser$2 = e;
  function e(a) {
    if (!a)
      throw new TypeError("argument namespace is required");
    function u(n) {
    }
    return u._file = void 0, u._ignored = !0, u._namespace = a, u._traced = !1, u._warned = /* @__PURE__ */ Object.create(null), u.function = t, u.property = r, u;
  }
  function t(a, u) {
    if (typeof a != "function")
      throw new TypeError("argument fn must be a function");
    return a;
  }
  function r(a, u, n) {
    if (!a || typeof a != "object" && typeof a != "function")
      throw new TypeError("argument obj must be object");
    var o = Object.getOwnPropertyDescriptor(a, u);
    if (!o)
      throw new TypeError("must call property on owner object");
    if (!o.configurable)
      throw new TypeError("property must be configurable");
  }
  return browser$2;
}
var setprototypeof, hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof) return setprototypeof;
  hasRequiredSetprototypeof = 1, setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? e : t);
  function e(r, a) {
    return r.__proto__ = a, r;
  }
  function t(r, a) {
    for (var u in a)
      Object.prototype.hasOwnProperty.call(r, u) || (r[u] = a[u]);
    return r;
  }
  return setprototypeof;
}
const require$$0$3 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses$1, hasRequiredStatuses$1;
function requireStatuses$1() {
  if (hasRequiredStatuses$1) return statuses$1;
  hasRequiredStatuses$1 = 1;
  var e = require$$0$3;
  statuses$1 = n, n.message = e, n.code = t(e), n.codes = r(e), n.redirect = {
    300: !0,
    301: !0,
    302: !0,
    303: !0,
    305: !0,
    307: !0,
    308: !0
  }, n.empty = {
    204: !0,
    205: !0,
    304: !0
  }, n.retry = {
    502: !0,
    503: !0,
    504: !0
  };
  function t(o) {
    var c = {};
    return Object.keys(o).forEach(function(l) {
      var s = o[l], p = Number(l);
      c[s.toLowerCase()] = p;
    }), c;
  }
  function r(o) {
    return Object.keys(o).map(function(f) {
      return Number(f);
    });
  }
  function a(o) {
    var c = o.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(n.code, c))
      throw new Error('invalid status message: "' + o + '"');
    return n.code[c];
  }
  function u(o) {
    if (!Object.prototype.hasOwnProperty.call(n.message, o))
      throw new Error("invalid status code: " + o);
    return n.message[o];
  }
  function n(o) {
    if (typeof o == "number")
      return u(o);
    if (typeof o != "string")
      throw new TypeError("code must be a number or string");
    var c = parseInt(o, 10);
    return isNaN(c) ? a(o) : u(c);
  }
  return statuses$1;
}
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier, hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier) return toidentifier;
  hasRequiredToidentifier = 1, toidentifier = e;
  function e(t) {
    return t.split(" ").map(function(r) {
      return r.slice(0, 1).toUpperCase() + r.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return toidentifier;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors$1;
function requireHttpErrors$1() {
  return hasRequiredHttpErrors$1 || (hasRequiredHttpErrors$1 = 1, (function(e) {
    var t = requireBrowser$2()("http-errors"), r = requireSetprototypeof(), a = requireStatuses$1(), u = requireInherits_browser(), n = requireToidentifier();
    e.exports = c, e.exports.HttpError = f(), e.exports.isHttpError = s(e.exports.HttpError), g(e.exports, a.codes, e.exports.HttpError);
    function o(v) {
      return +(String(v).charAt(0) + "00");
    }
    function c() {
      for (var v, E, b = 500, q = {}, O = 0; O < arguments.length; O++) {
        var j = arguments[O], D = typeof j;
        if (D === "object" && j instanceof Error)
          v = j, b = v.status || v.statusCode || b;
        else if (D === "number" && O === 0)
          b = j;
        else if (D === "string")
          E = j;
        else if (D === "object")
          q = j;
        else
          throw new TypeError("argument #" + (O + 1) + " unsupported type " + D);
      }
      typeof b == "number" && (b < 400 || b >= 600) && t("non-error status code; use only 4xx or 5xx status codes"), (typeof b != "number" || !a.message[b] && (b < 400 || b >= 600)) && (b = 500);
      var G = c[b] || c[o(b)];
      v || (v = G ? new G(E) : new Error(E || a.message[b]), Error.captureStackTrace(v, c)), (!G || !(v instanceof G) || v.status !== b) && (v.expose = b < 500, v.status = v.statusCode = b);
      for (var V in q)
        V !== "status" && V !== "statusCode" && (v[V] = q[V]);
      return v;
    }
    function f() {
      function v() {
        throw new TypeError("cannot construct abstract class");
      }
      return u(v, Error), v;
    }
    function l(v, E, b) {
      var q = y(E);
      function O(j) {
        var D = j ?? a.message[b], G = new Error(D);
        return Error.captureStackTrace(G, O), r(G, O.prototype), Object.defineProperty(G, "message", {
          enumerable: !0,
          configurable: !0,
          value: D,
          writable: !0
        }), Object.defineProperty(G, "name", {
          enumerable: !1,
          configurable: !0,
          value: q,
          writable: !0
        }), G;
      }
      return u(O, v), m(O, q), O.prototype.status = b, O.prototype.statusCode = b, O.prototype.expose = !0, O;
    }
    function s(v) {
      return function(b) {
        return !b || typeof b != "object" ? !1 : b instanceof v ? !0 : b instanceof Error && typeof b.expose == "boolean" && typeof b.statusCode == "number" && b.status === b.statusCode;
      };
    }
    function p(v, E, b) {
      var q = y(E);
      function O(j) {
        var D = j ?? a.message[b], G = new Error(D);
        return Error.captureStackTrace(G, O), r(G, O.prototype), Object.defineProperty(G, "message", {
          enumerable: !0,
          configurable: !0,
          value: D,
          writable: !0
        }), Object.defineProperty(G, "name", {
          enumerable: !1,
          configurable: !0,
          value: q,
          writable: !0
        }), G;
      }
      return u(O, v), m(O, q), O.prototype.status = b, O.prototype.statusCode = b, O.prototype.expose = !1, O;
    }
    function m(v, E) {
      var b = Object.getOwnPropertyDescriptor(v, "name");
      b && b.configurable && (b.value = E, Object.defineProperty(v, "name", b));
    }
    function g(v, E, b) {
      E.forEach(function(O) {
        var j, D = n(a.message[O]);
        switch (o(O)) {
          case 400:
            j = l(b, D, O);
            break;
          case 500:
            j = p(b, D, O);
            break;
        }
        j && (v[O] = j, v[D] = j);
      });
    }
    function y(v) {
      return v.substr(-5) !== "Error" ? v + "Error" : v;
    }
  })(httpErrors$1)), httpErrors$1.exports;
}
var request = { exports: {} }, negotiator = { exports: {} }, charset = { exports: {} }, hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset) return charset.exports;
  hasRequiredCharset = 1, charset.exports = n, charset.exports.preferredCharsets = n;
  var e = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function t(l) {
    for (var s = l.split(","), p = 0, m = 0; p < s.length; p++) {
      var g = r(s[p].trim(), p);
      g && (s[m++] = g);
    }
    return s.length = m, s;
  }
  function r(l, s) {
    var p = e.exec(l);
    if (!p) return null;
    var m = p[1], g = 1;
    if (p[2])
      for (var y = p[2].split(";"), v = 0; v < y.length; v++) {
        var E = y[v].trim().split("=");
        if (E[0] === "q") {
          g = parseFloat(E[1]);
          break;
        }
      }
    return {
      charset: m,
      q: g,
      i: s
    };
  }
  function a(l, s, p) {
    for (var m = { o: -1, q: 0, s: 0 }, g = 0; g < s.length; g++) {
      var y = u(l, s[g], p);
      y && (m.s - y.s || m.q - y.q || m.o - y.o) < 0 && (m = y);
    }
    return m;
  }
  function u(l, s, p) {
    var m = 0;
    if (s.charset.toLowerCase() === l.toLowerCase())
      m |= 1;
    else if (s.charset !== "*")
      return null;
    return {
      i: p,
      o: s.i,
      q: s.q,
      s: m
    };
  }
  function n(l, s) {
    var p = t(l === void 0 ? "*" : l || "");
    if (!s)
      return p.filter(f).sort(o).map(c);
    var m = s.map(function(y, v) {
      return a(y, p, v);
    });
    return m.filter(f).sort(o).map(function(y) {
      return s[m.indexOf(y)];
    });
  }
  function o(l, s) {
    return s.q - l.q || s.s - l.s || l.o - s.o || l.i - s.i || 0;
  }
  function c(l) {
    return l.charset;
  }
  function f(l) {
    return l.q > 0;
  }
  return charset.exports;
}
var encoding = { exports: {} }, hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding.exports;
  hasRequiredEncoding = 1, encoding.exports = n, encoding.exports.preferredEncodings = n;
  var e = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function t(l) {
    for (var s = l.split(","), p = !1, m = 1, g = 0, y = 0; g < s.length; g++) {
      var v = r(s[g].trim(), g);
      v && (s[y++] = v, p = p || u("identity", v), m = Math.min(m, v.q || 1));
    }
    return p || (s[y++] = {
      encoding: "identity",
      q: m,
      i: g
    }), s.length = y, s;
  }
  function r(l, s) {
    var p = e.exec(l);
    if (!p) return null;
    var m = p[1], g = 1;
    if (p[2])
      for (var y = p[2].split(";"), v = 0; v < y.length; v++) {
        var E = y[v].trim().split("=");
        if (E[0] === "q") {
          g = parseFloat(E[1]);
          break;
        }
      }
    return {
      encoding: m,
      q: g,
      i: s
    };
  }
  function a(l, s, p) {
    for (var m = { o: -1, q: 0, s: 0 }, g = 0; g < s.length; g++) {
      var y = u(l, s[g], p);
      y && (m.s - y.s || m.q - y.q || m.o - y.o) < 0 && (m = y);
    }
    return m;
  }
  function u(l, s, p) {
    var m = 0;
    if (s.encoding.toLowerCase() === l.toLowerCase())
      m |= 1;
    else if (s.encoding !== "*")
      return null;
    return {
      i: p,
      o: s.i,
      q: s.q,
      s: m
    };
  }
  function n(l, s) {
    var p = t(l || "");
    if (!s)
      return p.filter(f).sort(o).map(c);
    var m = s.map(function(y, v) {
      return a(y, p, v);
    });
    return m.filter(f).sort(o).map(function(y) {
      return s[m.indexOf(y)];
    });
  }
  function o(l, s) {
    return s.q - l.q || s.s - l.s || l.o - s.o || l.i - s.i || 0;
  }
  function c(l) {
    return l.encoding;
  }
  function f(l) {
    return l.q > 0;
  }
  return encoding.exports;
}
var language = { exports: {} }, hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage) return language.exports;
  hasRequiredLanguage = 1, language.exports = n, language.exports.preferredLanguages = n;
  var e = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function t(l) {
    for (var s = l.split(","), p = 0, m = 0; p < s.length; p++) {
      var g = r(s[p].trim(), p);
      g && (s[m++] = g);
    }
    return s.length = m, s;
  }
  function r(l, s) {
    var p = e.exec(l);
    if (!p) return null;
    var m = p[1], g = p[2], y = m;
    g && (y += "-" + g);
    var v = 1;
    if (p[3])
      for (var E = p[3].split(";"), b = 0; b < E.length; b++) {
        var q = E[b].split("=");
        q[0] === "q" && (v = parseFloat(q[1]));
      }
    return {
      prefix: m,
      suffix: g,
      q: v,
      i: s,
      full: y
    };
  }
  function a(l, s, p) {
    for (var m = { o: -1, q: 0, s: 0 }, g = 0; g < s.length; g++) {
      var y = u(l, s[g], p);
      y && (m.s - y.s || m.q - y.q || m.o - y.o) < 0 && (m = y);
    }
    return m;
  }
  function u(l, s, p) {
    var m = r(l);
    if (!m) return null;
    var g = 0;
    if (s.full.toLowerCase() === m.full.toLowerCase())
      g |= 4;
    else if (s.prefix.toLowerCase() === m.full.toLowerCase())
      g |= 2;
    else if (s.full.toLowerCase() === m.prefix.toLowerCase())
      g |= 1;
    else if (s.full !== "*")
      return null;
    return {
      i: p,
      o: s.i,
      q: s.q,
      s: g
    };
  }
  function n(l, s) {
    var p = t(l === void 0 ? "*" : l || "");
    if (!s)
      return p.filter(f).sort(o).map(c);
    var m = s.map(function(y, v) {
      return a(y, p, v);
    });
    return m.filter(f).sort(o).map(function(y) {
      return s[m.indexOf(y)];
    });
  }
  function o(l, s) {
    return s.q - l.q || s.s - l.s || l.o - s.o || l.i - s.i || 0;
  }
  function c(l) {
    return l.full;
  }
  function f(l) {
    return l.q > 0;
  }
  return language.exports;
}
var mediaType = { exports: {} }, hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType) return mediaType.exports;
  hasRequiredMediaType = 1, mediaType.exports = n, mediaType.exports.preferredMediaTypes = n;
  var e = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function t(g) {
    for (var y = p(g), v = 0, E = 0; v < y.length; v++) {
      var b = r(y[v].trim(), v);
      b && (y[E++] = b);
    }
    return y.length = E, y;
  }
  function r(g, y) {
    var v = e.exec(g);
    if (!v) return null;
    var E = /* @__PURE__ */ Object.create(null), b = 1, q = v[2], O = v[1];
    if (v[3])
      for (var j = m(v[3]).map(s), D = 0; D < j.length; D++) {
        var G = j[D], V = G[0].toLowerCase(), Q = G[1], re = Q && Q[0] === '"' && Q[Q.length - 1] === '"' ? Q.substr(1, Q.length - 2) : Q;
        if (V === "q") {
          b = parseFloat(re);
          break;
        }
        E[V] = re;
      }
    return {
      type: O,
      subtype: q,
      params: E,
      q: b,
      i: y
    };
  }
  function a(g, y, v) {
    for (var E = { o: -1, q: 0, s: 0 }, b = 0; b < y.length; b++) {
      var q = u(g, y[b], v);
      q && (E.s - q.s || E.q - q.q || E.o - q.o) < 0 && (E = q);
    }
    return E;
  }
  function u(g, y, v) {
    var E = r(g), b = 0;
    if (!E)
      return null;
    if (y.type.toLowerCase() == E.type.toLowerCase())
      b |= 4;
    else if (y.type != "*")
      return null;
    if (y.subtype.toLowerCase() == E.subtype.toLowerCase())
      b |= 2;
    else if (y.subtype != "*")
      return null;
    var q = Object.keys(y.params);
    if (q.length > 0)
      if (q.every(function(O) {
        return y.params[O] == "*" || (y.params[O] || "").toLowerCase() == (E.params[O] || "").toLowerCase();
      }))
        b |= 1;
      else
        return null;
    return {
      i: v,
      o: y.i,
      q: y.q,
      s: b
    };
  }
  function n(g, y) {
    var v = t(g === void 0 ? "*/*" : g || "");
    if (!y)
      return v.filter(f).sort(o).map(c);
    var E = y.map(function(q, O) {
      return a(q, v, O);
    });
    return E.filter(f).sort(o).map(function(q) {
      return y[E.indexOf(q)];
    });
  }
  function o(g, y) {
    return y.q - g.q || y.s - g.s || g.o - y.o || g.i - y.i || 0;
  }
  function c(g) {
    return g.type + "/" + g.subtype;
  }
  function f(g) {
    return g.q > 0;
  }
  function l(g) {
    for (var y = 0, v = 0; (v = g.indexOf('"', v)) !== -1; )
      y++, v++;
    return y;
  }
  function s(g) {
    var y = g.indexOf("="), v, E;
    return y === -1 ? v = g : (v = g.substr(0, y), E = g.substr(y + 1)), [v, E];
  }
  function p(g) {
    for (var y = g.split(","), v = 1, E = 0; v < y.length; v++)
      l(y[E]) % 2 == 0 ? y[++E] = y[v] : y[E] += "," + y[v];
    return y.length = E + 1, y;
  }
  function m(g) {
    for (var y = g.split(";"), v = 1, E = 0; v < y.length; v++)
      l(y[E]) % 2 == 0 ? y[++E] = y[v] : y[E] += ";" + y[v];
    y.length = E + 1;
    for (var v = 0; v < y.length; v++)
      y[v] = y[v].trim();
    return y;
  }
  return mediaType.exports;
}
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator) return negotiator.exports;
  hasRequiredNegotiator = 1;
  var e = requireCharset(), t = requireEncoding(), r = requireLanguage(), a = requireMediaType();
  negotiator.exports = u, negotiator.exports.Negotiator = u;
  function u(n) {
    if (!(this instanceof u))
      return new u(n);
    this.request = n;
  }
  return u.prototype.charset = function(o) {
    var c = this.charsets(o);
    return c && c[0];
  }, u.prototype.charsets = function(o) {
    return e(this.request.headers["accept-charset"], o);
  }, u.prototype.encoding = function(o) {
    var c = this.encodings(o);
    return c && c[0];
  }, u.prototype.encodings = function(o) {
    return t(this.request.headers["accept-encoding"], o);
  }, u.prototype.language = function(o) {
    var c = this.languages(o);
    return c && c[0];
  }, u.prototype.languages = function(o) {
    return r(this.request.headers["accept-language"], o);
  }, u.prototype.mediaType = function(o) {
    var c = this.mediaTypes(o);
    return c && c[0];
  }, u.prototype.mediaTypes = function(o) {
    return a(this.request.headers.accept, o);
  }, u.prototype.preferredCharset = u.prototype.charset, u.prototype.preferredCharsets = u.prototype.charsets, u.prototype.preferredEncoding = u.prototype.encoding, u.prototype.preferredEncodings = u.prototype.encodings, u.prototype.preferredLanguage = u.prototype.language, u.prototype.preferredLanguages = u.prototype.languages, u.prototype.preferredMediaType = u.prototype.mediaType, u.prototype.preferredMediaTypes = u.prototype.mediaTypes, negotiator.exports;
}
var mimeTypes$1 = {};
const require$$0$2 = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": { source: "iana", compressible: !0 },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": { source: "iana", compressible: !0 },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamcontrol+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamparams+json": { source: "iana", compressible: !0 },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": { source: "iana", compressible: !0, extensions: ["atom"] },
  "application/atomcat+xml": { source: "iana", compressible: !0, extensions: ["atomcat"] },
  "application/atomdeleted+xml": { source: "iana", compressible: !0, extensions: ["atomdeleted"] },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": { source: "iana", compressible: !0, extensions: ["atomsvc"] },
  "application/atsc-dwd+xml": { source: "iana", compressible: !0, extensions: ["dwd"] },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": { source: "iana", compressible: !0, extensions: ["held"] },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": { source: "iana", compressible: !0, extensions: ["rsat"] },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": { source: "iana", compressible: !0, extensions: ["xcs"] },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": { source: "iana", compressible: !0, extensions: ["ccxml"] },
  "application/cdfx+xml": { source: "iana", compressible: !0, extensions: ["cdfx"] },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": { source: "iana", compressible: !0, extensions: ["cpl"] },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": { source: "iana", compressible: !0, extensions: ["mpd"] },
  "application/dash-patch+xml": { source: "iana", compressible: !0, extensions: ["mpp"] },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": { source: "iana", compressible: !0, extensions: ["davmount"] },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": { source: "apache", compressible: !0, extensions: ["dbk"] },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": { source: "iana", compressible: !0, extensions: ["xdssc"] },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": { source: "iana", compressible: !0, extensions: ["es", "ecma"] },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/emergencycalldata.comment+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.control+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.deviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.serviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.subscriberinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.veds+xml": { source: "iana", compressible: !0 },
  "application/emma+xml": { source: "iana", compressible: !0, extensions: ["emma"] },
  "application/emotionml+xml": { source: "iana", compressible: !0, extensions: ["emotionml"] },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": { source: "iana", compressible: !1, extensions: ["epub"] },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": { source: "iana", compressible: !0, extensions: ["fdt"] },
  "application/fhir+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fhir+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": { source: "iana", compressible: !0, extensions: ["geojson"] },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": { source: "iana", compressible: !0, extensions: ["gml"] },
  "application/gpx+xml": { source: "apache", compressible: !0, extensions: ["gpx"] },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": { source: "iana", compressible: !0, extensions: ["ink", "inkml"] },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": { source: "iana", compressible: !0, extensions: ["its"] },
  "application/java-archive": { source: "apache", compressible: !1, extensions: ["jar", "war", "ear"] },
  "application/java-serialized-object": { source: "apache", compressible: !1, extensions: ["ser"] },
  "application/java-vm": { source: "apache", compressible: !1, extensions: ["class"] },
  "application/javascript": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["js", "mjs"] },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["json", "map"] },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": { source: "apache", compressible: !0, extensions: ["jsonml"] },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": { source: "iana", compressible: !0, extensions: ["jsonld"] },
  "application/lgr+xml": { source: "iana", compressible: !0, extensions: ["lgr"] },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": { source: "iana", compressible: !0, extensions: ["lostxml"] },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": { source: "iana", compressible: !0, extensions: ["mads"] },
  "application/manifest+json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["webmanifest"] },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": { source: "iana", compressible: !0, extensions: ["mrcx"] },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": { source: "iana", compressible: !0, extensions: ["mathml"] },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": { source: "iana", compressible: !0 },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": { source: "iana", compressible: !0, extensions: ["mpf"] },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": { source: "iana", compressible: !0, extensions: ["mscml"] },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": { source: "apache", compressible: !0, extensions: ["metalink"] },
  "application/metalink4+xml": { source: "iana", compressible: !0, extensions: ["meta4"] },
  "application/mets+xml": { source: "iana", compressible: !0, extensions: ["mets"] },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": { source: "iana", compressible: !0, extensions: ["maei"] },
  "application/mmt-usd+xml": { source: "iana", compressible: !0, extensions: ["musd"] },
  "application/mods+xml": { source: "iana", compressible: !0, extensions: ["mods"] },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msc-mixer+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msword": { source: "iana", compressible: !1, extensions: ["doc", "dot"] },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": { source: "iana", compressible: !1, extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": { source: "iana", compressible: !0, extensions: ["opf"] },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": { source: "apache", compressible: !0, extensions: ["omdoc"] },
  "application/onenote": { source: "apache", extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": { source: "iana", compressible: !0, extensions: ["relo"] },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": { source: "iana", compressible: !0, extensions: ["xer"] },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": { source: "iana", compressible: !1, extensions: ["pgp"] },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pidf-diff+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": { source: "iana", compressible: !0, extensions: ["pls"] },
  "application/poc-settings+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/postscript": { source: "iana", compressible: !0, extensions: ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": { source: "iana", compressible: !0, extensions: ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": { source: "iana", compressible: !0, extensions: ["pskcxml"] },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": { source: "iana", compressible: !0, extensions: ["rdf", "owl"] },
  "application/reginfo+xml": { source: "iana", compressible: !0, extensions: ["rif"] },
  "application/relax-ng-compact-syntax": { source: "iana", extensions: ["rnc"] },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": { source: "iana", compressible: !0, extensions: ["rl"] },
  "application/resource-lists-diff+xml": { source: "iana", compressible: !0, extensions: ["rld"] },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": { source: "iana", compressible: !0, extensions: ["rs"] },
  "application/route-apd+xml": { source: "iana", compressible: !0, extensions: ["rapd"] },
  "application/route-s-tsid+xml": { source: "iana", compressible: !0, extensions: ["sls"] },
  "application/route-usd+xml": { source: "iana", compressible: !0, extensions: ["rusd"] },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": { source: "apache", compressible: !0, extensions: ["rsd"] },
  "application/rss+xml": { source: "apache", compressible: !0, extensions: ["rss"] },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": { source: "iana", compressible: !0 },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": { source: "iana", compressible: !0, extensions: ["sbml"] },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": { source: "iana", compressible: !0, extensions: ["senmlx"] },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": { source: "iana", compressible: !0, extensions: ["sensmlx"] },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": { source: "iana", extensions: ["setpay"] },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": { source: "iana", extensions: ["setreg"] },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": { source: "iana", compressible: !0, extensions: ["shf"] },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": { source: "iana", compressible: !0, extensions: ["smi", "smil"] },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": { source: "iana", compressible: !0, extensions: ["srx"] },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": { source: "iana", compressible: !0, extensions: ["grxml"] },
  "application/sru+xml": { source: "iana", compressible: !0, extensions: ["sru"] },
  "application/ssdl+xml": { source: "apache", compressible: !0, extensions: ["ssdl"] },
  "application/ssml+xml": { source: "iana", compressible: !0, extensions: ["ssml"] },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": { source: "iana", compressible: !0, extensions: ["swidtag"] },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": { source: "iana", compressible: !0, extensions: ["tei", "teicorpus"] },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": { source: "iana", compressible: !0, extensions: ["tfi"] },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": { source: "iana", compressible: !0, extensions: ["ttml"] },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": { source: "iana", compressible: !0, extensions: ["rsheet"] },
  "application/urc-targetdesc+xml": { source: "iana", compressible: !0, extensions: ["td"] },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": { source: "iana", compressible: !0, extensions: ["1km"] },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-floor-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { source: "apache", compressible: !1, extensions: ["air"] },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": { source: "iana", extensions: ["fcdt"] },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": { source: "iana", compressible: !0, extensions: ["xdp"] },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { source: "iana", extensions: ["azf"] },
  "application/vnd.airzip.filesecure.azs": { source: "iana", extensions: ["azs"] },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": { source: "iana", extensions: ["acc"] },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": { source: "apache", compressible: !1, extensions: ["apk"] },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { source: "iana", extensions: ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { source: "apache", extensions: ["fti"] },
  "application/vnd.antix.game-component": { source: "iana", extensions: ["atx"] },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": { source: "iana", compressible: !0 },
  "application/vnd.apple.installer+xml": { source: "iana", compressible: !0, extensions: ["mpkg"] },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": { source: "iana", extensions: ["iota"] },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": { source: "iana", compressible: !0, extensions: ["bmml"] },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": { source: "iana", compressible: !0, extensions: ["cdxml"] },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { source: "iana", extensions: ["mmd"] },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": { source: "iana", compressible: !0, extensions: ["csl"] },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": { source: "iana", extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { source: "iana", extensions: ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { source: "iana", extensions: ["c11amz"] },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { source: "iana" },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { source: "iana", extensions: ["clkk"] },
  "application/vnd.crick.clicker.palette": { source: "iana", extensions: ["clkp"] },
  "application/vnd.crick.clicker.template": { source: "iana", extensions: ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { source: "iana", extensions: ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { source: "iana", compressible: !0, extensions: ["wbs"] },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": { source: "iana", compressible: !1 },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": { source: "iana", compressible: !0, extensions: ["dart"] },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": { source: "iana", extensions: ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { source: "iana", compressible: !0, extensions: ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { source: "iana", extensions: ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { source: "iana", extensions: ["fe_launch"] },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-container+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-response+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": { source: "iana", compressible: !0 },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": { source: "iana", compressible: !0, extensions: ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": { source: "iana", compressible: !1 },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": { source: "iana", extensions: ["seed", "dataless"] },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": { source: "iana", extensions: ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": { source: "iana", extensions: ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { source: "iana", extensions: ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": { source: "iana", extensions: ["gex", "gre"] },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { source: "iana" },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": { compressible: !1, extensions: ["gdoc"] },
  "application/vnd.google-apps.presentation": { compressible: !1, extensions: ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { compressible: !1, extensions: ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { source: "iana", compressible: !0, extensions: ["kml"] },
  "application/vnd.google-earth.kmz": { source: "iana", compressible: !1, extensions: ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": { source: "iana", compressible: !0 },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": { source: "iana", extensions: ["gim"] },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": { source: "iana", extensions: ["gtm"] },
  "application/vnd.groove-tool-template": { source: "iana", extensions: ["tpl"] },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": { source: "iana", compressible: !0, extensions: ["hal"] },
  "application/vnd.handheld-entertainment+xml": { source: "iana", compressible: !0, extensions: ["zmm"] },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.hl7v2+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": { source: "iana", extensions: ["sfd-hdstx"] },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": { source: "iana", extensions: ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { source: "iana", extensions: ["irm"] },
  "application/vnd.ibm.secure-container": { source: "iana", extensions: ["sc"] },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { source: "iana", compressible: !0 },
  "application/vnd.informedcontrol.rms+xml": { source: "iana", compressible: !0 },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": { source: "iana", extensions: ["xpw", "xpx"] },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.conceptitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.knowledgeitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.packageitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.planningitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.ipunplugged.rcprofile": { source: "iana", extensions: ["rcprofile"] },
  "application/vnd.irepository.package+xml": { source: "iana", compressible: !0, extensions: ["irp"] },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": { source: "iana", extensions: ["rms"] },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": { source: "iana", extensions: ["joda"] },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": { source: "iana", extensions: ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": { source: "iana", extensions: ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": { source: "iana", compressible: !0, extensions: ["lasxml"] },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": { source: "iana", extensions: ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { source: "iana", compressible: !0, extensions: ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": { source: "iana", extensions: ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.conftoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.license+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": { source: "iana", extensions: ["cdkey"] },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": { source: "iana", compressible: !0, extensions: ["xul"] },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": { source: "iana", compressible: !1, extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { source: "iana", extensions: ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { source: "iana", extensions: ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { source: "iana", extensions: ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { source: "iana", extensions: ["xltm"] },
  "application/vnd.ms-fontobject": { source: "iana", compressible: !0, extensions: ["eot"] },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-powerpoint": { source: "iana", compressible: !1, extensions: ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { source: "iana", extensions: ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { source: "iana", extensions: ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { source: "iana", extensions: ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { source: "iana", extensions: ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { source: "iana", extensions: ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-printing.printticket+xml": { source: "apache", compressible: !0 },
  "application/vnd.ms-printschematicket+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { source: "iana", extensions: ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { source: "iana", extensions: ["dotm"] },
  "application/vnd.ms-works": { source: "iana", extensions: ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": { source: "iana", compressible: !1, extensions: ["xps"] },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.n-gage.ac+xml": { source: "iana", compressible: !0, extensions: ["ac"] },
  "application/vnd.nokia.n-gage.data": { source: "iana", extensions: ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { source: "iana", extensions: ["n-gage"] },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": { source: "iana", extensions: ["rpst"] },
  "application/vnd.nokia.radio-presets": { source: "iana", extensions: ["rpss"] },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": { source: "iana", extensions: ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { source: "iana", extensions: ["otc"] },
  "application/vnd.oasis.opendocument.database": { source: "iana", extensions: ["odb"] },
  "application/vnd.oasis.opendocument.formula": { source: "iana", extensions: ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { source: "iana", extensions: ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { source: "iana", compressible: !1, extensions: ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { source: "iana", extensions: ["otg"] },
  "application/vnd.oasis.opendocument.image": { source: "iana", extensions: ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { source: "iana", extensions: ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { source: "iana", compressible: !1, extensions: ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { source: "iana", extensions: ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { source: "iana", compressible: !1, extensions: ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { source: "iana", extensions: ["ots"] },
  "application/vnd.oasis.opendocument.text": { source: "iana", compressible: !1, extensions: ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { source: "iana", extensions: ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { source: "iana", extensions: ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { source: "iana", extensions: ["oth"] },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": { source: "iana", compressible: !0 },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessstreaming+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.drm-trigger+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-feature-handler+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-user-prefs+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": { source: "iana", compressible: !0, extensions: ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.final-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.optimized-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.xcap-directory+xml": { source: "iana", compressible: !0 },
  "application/vnd.omads-email+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-file+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-folder+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": { source: "iana", compressible: !0, extensions: ["obgx"] },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": { source: "apache", extensions: ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { source: "iana", compressible: !0, extensions: ["osm"] },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { source: "iana", compressible: !1, extensions: ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { source: "iana", extensions: ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { source: "iana", extensions: ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { source: "iana", extensions: ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { source: "iana", compressible: !1, extensions: ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { source: "iana", extensions: ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.theme+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { source: "iana", compressible: !1, extensions: ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { source: "iana", extensions: ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.relationships+xml": { source: "iana", compressible: !0 },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": { source: "iana", extensions: ["mgp"] },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": { source: "iana", extensions: ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { source: "iana", compressible: !0 },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": { source: "iana", extensions: ["qps"] },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": { source: "iana", extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conn+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-stream+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-base+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-group+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-speech+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-transform+xml": { source: "iana", compressible: !0 },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { source: "iana", compressible: !0, extensions: ["musicxml"] },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": { source: "iana", extensions: ["cryptonote"] },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": { source: "apache", extensions: ["rmvb"] },
  "application/vnd.route66.link66+xml": { source: "iana", compressible: !0, extensions: ["link66"] },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": { source: "iana", extensions: ["st"] },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": { source: "iana", extensions: ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { source: "iana", extensions: ["itp"] },
  "application/vnd.shana.informed.interchange": { source: "iana", extensions: ["iif"] },
  "application/vnd.shana.informed.package": { source: "iana", extensions: ["ipk"] },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": { source: "iana", extensions: ["twd", "twds"] },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": { source: "iana", compressible: !0, extensions: ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": { source: "iana", compressible: !0, extensions: ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": { source: "apache", extensions: ["sdc"] },
  "application/vnd.stardivision.draw": { source: "apache", extensions: ["sda"] },
  "application/vnd.stardivision.impress": { source: "apache", extensions: ["sdd"] },
  "application/vnd.stardivision.math": { source: "apache", extensions: ["smf"] },
  "application/vnd.stardivision.writer": { source: "apache", extensions: ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { source: "apache", extensions: ["sgl"] },
  "application/vnd.stepmania.package": { source: "iana", extensions: ["smzip"] },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": { source: "iana", compressible: !0, extensions: ["wadl"] },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": { source: "apache", extensions: ["stc"] },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": { source: "apache", extensions: ["std"] },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": { source: "apache", extensions: ["sti"] },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": { source: "apache", extensions: ["sxg"] },
  "application/vnd.sun.xml.writer.template": { source: "apache", extensions: ["stw"] },
  "application/vnd.sus-calendar": { source: "iana", extensions: ["sus", "susp"] },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": { source: "apache", extensions: ["sis", "sisx"] },
  "application/vnd.syncml+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { source: "iana", charset: "UTF-8", extensions: ["bdm"] },
  "application/vnd.syncml.dm+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xdm"] },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": { source: "iana", extensions: ["tao"] },
  "application/vnd.tcpdump.pcap": { source: "iana", extensions: ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": { source: "iana", compressible: !0, extensions: ["uoml"] },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": { source: "iana", extensions: ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": { source: "iana", charset: "UTF-8", extensions: ["wbxml"] },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { source: "iana", extensions: ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { source: "iana", compressible: !0, extensions: ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": { source: "iana", extensions: ["cmp"] },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { source: "iana", compressible: !0, extensions: ["zaz"] },
  "application/voicexml+xml": { source: "iana", compressible: !0, extensions: ["vxml"] },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": { source: "iana", compressible: !0, extensions: ["wasm"] },
  "application/watcherinfo+xml": { source: "iana", compressible: !0, extensions: ["wif"] },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": { source: "iana", compressible: !0, extensions: ["wsdl"] },
  "application/wspolicy+xml": { source: "iana", compressible: !0, extensions: ["wspolicy"] },
  "application/x-7z-compressed": { source: "apache", compressible: !1, extensions: ["7z"] },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": { source: "apache", extensions: ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": { source: "apache", compressible: !1, extensions: ["bz"] },
  "application/x-bzip2": { source: "apache", compressible: !1, extensions: ["bz2", "boz"] },
  "application/x-cbr": { source: "apache", extensions: ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": { source: "apache", extensions: ["deb", "udeb"] },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": { source: "apache", extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": { source: "apache", compressible: !0, extensions: ["ncx"] },
  "application/x-dtbook+xml": { source: "apache", compressible: !0, extensions: ["dtb"] },
  "application/x-dtbresource+xml": { source: "apache", compressible: !0, extensions: ["res"] },
  "application/x-dvi": { source: "apache", compressible: !1, extensions: ["dvi"] },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": { source: "apache", extensions: ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": { source: "apache", extensions: ["install"] },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": { source: "nginx", extensions: ["jardiff"] },
  "application/x-java-jnlp-file": { source: "apache", compressible: !1, extensions: ["jnlp"] },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": { source: "apache", compressible: !1, extensions: ["latex"] },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": { source: "apache", extensions: ["lzh", "lha"] },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": { source: "apache", extensions: ["prc", "mobi"] },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": { source: "apache", extensions: ["application"] },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": { source: "apache", extensions: ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { source: "apache", extensions: ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { source: "apache", extensions: ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { compressible: !0, extensions: ["pac"] },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": { source: "apache", compressible: !1, extensions: ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { source: "apache", extensions: ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": { source: "apache", compressible: !1, extensions: ["rar"] },
  "application/x-redhat-package-manager": { source: "nginx", extensions: ["rpm"] },
  "application/x-research-info-systems": { source: "apache", extensions: ["ris"] },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": { source: "apache", compressible: !0, extensions: ["sh"] },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": { source: "apache", compressible: !1, extensions: ["swf"] },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": { source: "apache", compressible: !1, extensions: ["sit"] },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": { source: "apache", compressible: !0, extensions: ["tar"] },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": { source: "apache", extensions: ["texinfo", "texi"] },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { compressible: !1, extensions: ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": { compressible: !0, extensions: ["webapp"] },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": { source: "iana", extensions: ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": { source: "apache", compressible: !0, extensions: ["xlf"] },
  "application/x-xpinstall": { source: "apache", compressible: !1, extensions: ["xpi"] },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": { source: "apache", extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": { source: "apache", compressible: !0, extensions: ["xaml"] },
  "application/xcap-att+xml": { source: "iana", compressible: !0, extensions: ["xav"] },
  "application/xcap-caps+xml": { source: "iana", compressible: !0, extensions: ["xca"] },
  "application/xcap-diff+xml": { source: "iana", compressible: !0, extensions: ["xdf"] },
  "application/xcap-el+xml": { source: "iana", compressible: !0, extensions: ["xel"] },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": { source: "iana", compressible: !0, extensions: ["xns"] },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": { source: "iana", compressible: !0 },
  "application/xenc+xml": { source: "iana", compressible: !0, extensions: ["xenc"] },
  "application/xhtml+xml": { source: "iana", compressible: !0, extensions: ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": { source: "iana", compressible: !0, extensions: ["xlf"] },
  "application/xml": { source: "iana", compressible: !0, extensions: ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { source: "iana", compressible: !0, extensions: ["dtd"] },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": { source: "iana", compressible: !0, extensions: ["xop"] },
  "application/xproc+xml": { source: "apache", compressible: !0, extensions: ["xpl"] },
  "application/xslt+xml": { source: "iana", compressible: !0, extensions: ["xsl", "xslt"] },
  "application/xspf+xml": { source: "apache", compressible: !0, extensions: ["xspf"] },
  "application/xv+xml": { source: "iana", compressible: !0, extensions: ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": { source: "iana", compressible: !0, extensions: ["yin"] },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": { source: "iana", compressible: !1, extensions: ["au", "snd"] },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": { source: "iana", compressible: !1, extensions: ["m4a", "mp4a"] },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": { source: "iana", compressible: !1, extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": { source: "iana", compressible: !1, extensions: ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": { source: "iana", compressible: !1, extensions: ["jp2", "jpg2"] },
  "image/jpeg": { source: "iana", compressible: !1, extensions: ["jpeg", "jpg", "jpe"] },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": { source: "iana", compressible: !0, extensions: ["svg", "svgz"] },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": { source: "iana", compressible: !1, extensions: ["tif", "tiff"] },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": { source: "iana", compressible: !0, extensions: ["psd"] },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": { source: "iana", extensions: ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": { source: "iana", compressible: !0, extensions: ["ico"] },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": { source: "apache", extensions: ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": { source: "iana", extensions: ["disposition-notification"] },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": { source: "iana", extensions: ["u8mdn"] },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": { source: "iana", compressible: !0, extensions: ["eml", "mime"] },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": { source: "iana", compressible: !0, extensions: ["glb"] },
  "model/iges": { source: "iana", compressible: !1, extensions: ["igs", "iges"] },
  "model/mesh": { source: "iana", compressible: !1, extensions: ["msh", "mesh", "silo"] },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": { source: "iana", compressible: !1, extensions: ["stpxz"] },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": { source: "iana", compressible: !0, extensions: ["dae"] },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { source: "iana", extensions: ["x_b"] },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": { source: "iana", compressible: !1, extensions: ["usdz"] },
  "model/vnd.valve.source.compiled-map": { source: "iana", extensions: ["bsp"] },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": { source: "iana", compressible: !1, extensions: ["wrl", "vrml"] },
  "model/x3d+binary": { source: "apache", compressible: !1, extensions: ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": { source: "apache", compressible: !1, extensions: ["x3dv", "x3dvz"] },
  "model/x3d+xml": { source: "iana", compressible: !0, extensions: ["x3d", "x3dz"] },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": { source: "iana", compressible: !0, extensions: ["appcache", "manifest"] },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["css"] },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": { source: "iana", compressible: !0, extensions: ["html", "htm", "shtml"] },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": { source: "iana", compressible: !0, extensions: ["markdown", "md"] },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["n3"] },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": { source: "iana", compressible: !0, extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": { source: "iana", compressible: !0, extensions: ["tsv"] },
  "text/troff": { source: "iana", extensions: ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": { source: "iana", compressible: !0, extensions: ["uri", "uris", "urls"] },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": { source: "iana", charset: "UTF-8", extensions: ["jad"] },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["vtt"] },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": { source: "apache", extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": { source: "apache", extensions: ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": { source: "iana", compressible: !1, extensions: ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": { source: "iana", compressible: !1, extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": { source: "iana", compressible: !1, extensions: ["qt", "mov"] },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": { source: "apache", compressible: !1, extensions: ["mkv", "mk3d", "mks"] },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb$1, hasRequiredMimeDb$1;
function requireMimeDb$1() {
  return hasRequiredMimeDb$1 || (hasRequiredMimeDb$1 = 1, mimeDb$1 = require$$0$2), mimeDb$1;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes$1;
function requireMimeTypes$1() {
  return hasRequiredMimeTypes$1 || (hasRequiredMimeTypes$1 = 1, (function(e) {
    var t = requireMimeDb$1(), r = requirePathBrowserify().extname, a = /^\s*([^;\s]*)(?:;|\s|$)/, u = /^text\//i;
    e.charset = n, e.charsets = { lookup: n }, e.contentType = o, e.extension = c, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = f, e.types = /* @__PURE__ */ Object.create(null), l(e.extensions, e.types);
    function n(s) {
      if (!s || typeof s != "string")
        return !1;
      var p = a.exec(s), m = p && t[p[1].toLowerCase()];
      return m && m.charset ? m.charset : p && u.test(p[1]) ? "UTF-8" : !1;
    }
    function o(s) {
      if (!s || typeof s != "string")
        return !1;
      var p = s.indexOf("/") === -1 ? e.lookup(s) : s;
      if (!p)
        return !1;
      if (p.indexOf("charset") === -1) {
        var m = e.charset(p);
        m && (p += "; charset=" + m.toLowerCase());
      }
      return p;
    }
    function c(s) {
      if (!s || typeof s != "string")
        return !1;
      var p = a.exec(s), m = p && e.extensions[p[1].toLowerCase()];
      return !m || !m.length ? !1 : m[0];
    }
    function f(s) {
      if (!s || typeof s != "string")
        return !1;
      var p = r("x." + s).toLowerCase().substr(1);
      return p && e.types[p] || !1;
    }
    function l(s, p) {
      var m = ["nginx", "apache", void 0, "iana"];
      Object.keys(t).forEach(function(y) {
        var v = t[y], E = v.extensions;
        if (!(!E || !E.length)) {
          s[y] = E;
          for (var b = 0; b < E.length; b++) {
            var q = E[b];
            if (p[q]) {
              var O = m.indexOf(t[p[q]].source), j = m.indexOf(v.source);
              if (p[q] !== "application/octet-stream" && (O > j || O === j && p[q].substr(0, 12) === "application/"))
                continue;
            }
            p[q] = y;
          }
        }
      });
    }
  })(mimeTypes$1)), mimeTypes$1;
}
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts, hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts) return accepts;
  hasRequiredAccepts = 1;
  var e = requireNegotiator(), t = requireMimeTypes$1();
  accepts = r;
  function r(n) {
    if (!(this instanceof r))
      return new r(n);
    this.headers = n.headers, this.negotiator = new e(n);
  }
  r.prototype.type = r.prototype.types = function(n) {
    var o = n;
    if (o && !Array.isArray(o)) {
      o = new Array(arguments.length);
      for (var c = 0; c < o.length; c++)
        o[c] = arguments[c];
    }
    if (!o || o.length === 0)
      return this.negotiator.mediaTypes();
    if (!this.headers.accept)
      return o[0];
    var f = o.map(a), l = this.negotiator.mediaTypes(f.filter(u)), s = l[0];
    return s ? o[f.indexOf(s)] : !1;
  }, r.prototype.encoding = r.prototype.encodings = function(n) {
    var o = n;
    if (o && !Array.isArray(o)) {
      o = new Array(arguments.length);
      for (var c = 0; c < o.length; c++)
        o[c] = arguments[c];
    }
    return !o || o.length === 0 ? this.negotiator.encodings() : this.negotiator.encodings(o)[0] || !1;
  }, r.prototype.charset = r.prototype.charsets = function(n) {
    var o = n;
    if (o && !Array.isArray(o)) {
      o = new Array(arguments.length);
      for (var c = 0; c < o.length; c++)
        o[c] = arguments[c];
    }
    return !o || o.length === 0 ? this.negotiator.charsets() : this.negotiator.charsets(o)[0] || !1;
  }, r.prototype.lang = r.prototype.langs = r.prototype.language = r.prototype.languages = function(n) {
    var o = n;
    if (o && !Array.isArray(o)) {
      o = new Array(arguments.length);
      for (var c = 0; c < o.length; c++)
        o[c] = arguments[c];
    }
    return !o || o.length === 0 ? this.negotiator.languages() : this.negotiator.languages(o)[0] || !1;
  };
  function a(n) {
    return n.indexOf("/") === -1 ? t.lookup(n) : n;
  }
  function u(n) {
    return typeof n == "string";
  }
  return accepts;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, r = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, a = /\\([\u000b\u0020-\u00ff])/g, u = /([\\"])/g, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  contentType.format = o, contentType.parse = c;
  function o(p) {
    if (!p || typeof p != "object")
      throw new TypeError("argument obj is required");
    var m = p.parameters, g = p.type;
    if (!g || !n.test(g))
      throw new TypeError("invalid type");
    var y = g;
    if (m && typeof m == "object")
      for (var v, E = Object.keys(m).sort(), b = 0; b < E.length; b++) {
        if (v = E[b], !r.test(v))
          throw new TypeError("invalid parameter name");
        y += "; " + v + "=" + l(m[v]);
      }
    return y;
  }
  function c(p) {
    if (!p)
      throw new TypeError("argument string is required");
    var m = typeof p == "object" ? f(p) : p;
    if (typeof m != "string")
      throw new TypeError("argument string is required to be a string");
    var g = m.indexOf(";"), y = g !== -1 ? m.slice(0, g).trim() : m.trim();
    if (!n.test(y))
      throw new TypeError("invalid media type");
    var v = new s(y.toLowerCase());
    if (g !== -1) {
      var E, b, q;
      for (e.lastIndex = g; b = e.exec(m); ) {
        if (b.index !== g)
          throw new TypeError("invalid parameter format");
        g += b[0].length, E = b[1].toLowerCase(), q = b[2], q.charCodeAt(0) === 34 && (q = q.slice(1, -1), q.indexOf("\\") !== -1 && (q = q.replace(a, "$1"))), v.parameters[E] = q;
      }
      if (g !== m.length)
        throw new TypeError("invalid parameter format");
    }
    return v;
  }
  function f(p) {
    var m;
    if (typeof p.getHeader == "function" ? m = p.getHeader("content-type") : typeof p.headers == "object" && (m = p.headers && p.headers["content-type"]), typeof m != "string")
      throw new TypeError("content-type header is missing from object");
    return m;
  }
  function l(p) {
    var m = String(p);
    if (r.test(m))
      return m;
    if (m.length > 0 && !t.test(m))
      throw new TypeError("invalid parameter value");
    return '"' + m.replace(u, "\\$1") + '"';
  }
  function s(p) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
  }
  return contentType;
}
var parseurl = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl) return parseurl.exports;
  hasRequiredParseurl = 1;
  var e = require$$0$5, t = e.parse, r = e.Url;
  parseurl.exports = a, parseurl.exports.original = u;
  function a(c) {
    var f = c.url;
    if (f !== void 0) {
      var l = c._parsedUrl;
      return o(f, l) ? l : (l = n(f), l._raw = f, c._parsedUrl = l);
    }
  }
  function u(c) {
    var f = c.originalUrl;
    if (typeof f != "string")
      return a(c);
    var l = c._parsedOriginalUrl;
    return o(f, l) ? l : (l = n(f), l._raw = f, c._parsedOriginalUrl = l);
  }
  function n(c) {
    if (typeof c != "string" || c.charCodeAt(0) !== 47)
      return t(c);
    for (var f = c, l = null, s = null, p = 1; p < c.length; p++)
      switch (c.charCodeAt(p)) {
        case 63:
          s === null && (f = c.substring(0, p), l = c.substring(p + 1), s = c.substring(p));
          break;
        case 9:
        /* \t */
        case 10:
        /* \n */
        case 12:
        /* \f */
        case 13:
        /* \r */
        case 32:
        /*    */
        case 35:
        /* #  */
        case 160:
        case 65279:
          return t(c);
      }
    var m = r !== void 0 ? new r() : {};
    return m.path = c, m.href = c, m.pathname = f, s !== null && (m.query = l, m.search = s), m;
  }
  function o(c, f) {
    return typeof f == "object" && f !== null && (r === void 0 || f instanceof r) && f._raw === c;
  }
  return parseurl.exports;
}
var searchParams, hasRequiredSearchParams;
function requireSearchParams() {
  if (hasRequiredSearchParams) return searchParams;
  hasRequiredSearchParams = 1;
  const e = require$$0$5.URLSearchParams;
  return searchParams = {
    stringify: (t) => {
      const r = new e(), a = (u, n, o) => {
        const c = typeof n == "string" || typeof n == "number" ? n : "";
        o.append(u, c);
      };
      for (const [u, n] of Object.entries(t))
        if (Array.isArray(n)) {
          const o = n.length;
          for (let c = 0; c < o; c++)
            a(u, n[c], r);
        } else
          a(u, n, r);
      return r.toString();
    },
    parse: (t) => {
      const r = new e(t), a = {};
      for (const u of r.keys()) {
        const n = r.getAll(u);
        a[u] = n.length <= 1 ? n[0] : n;
      }
      return a;
    }
  }, searchParams;
}
var typeIs = { exports: {} }, mimeTypes = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/ace+json": { source: "iana", compressible: !0 },
  "application/ace-groupcomm+cbor": { source: "iana" },
  "application/ace-trl+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/aif+cbor": { source: "iana" },
  "application/aif+json": { source: "iana", compressible: !0 },
  "application/alto-cdni+json": { source: "iana", compressible: !0 },
  "application/alto-cdnifilter+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": { source: "iana", compressible: !0 },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": { source: "iana", compressible: !0 },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-propmap+json": { source: "iana", compressible: !0 },
  "application/alto-propmapparams+json": { source: "iana", compressible: !0 },
  "application/alto-tips+json": { source: "iana", compressible: !0 },
  "application/alto-tipsparams+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamcontrol+json": { source: "iana", compressible: !0 },
  "application/alto-updatestreamparams+json": { source: "iana", compressible: !0 },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/appinstaller": { compressible: !1, extensions: ["appinstaller"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/appx": { compressible: !1, extensions: ["appx"] },
  "application/appxbundle": { compressible: !1, extensions: ["appxbundle"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": { source: "iana", compressible: !0, extensions: ["atom"] },
  "application/atomcat+xml": { source: "iana", compressible: !0, extensions: ["atomcat"] },
  "application/atomdeleted+xml": { source: "iana", compressible: !0, extensions: ["atomdeleted"] },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": { source: "iana", compressible: !0, extensions: ["atomsvc"] },
  "application/atsc-dwd+xml": { source: "iana", compressible: !0, extensions: ["dwd"] },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": { source: "iana", compressible: !0, extensions: ["held"] },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": { source: "iana", compressible: !0, extensions: ["rsat"] },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/automationml-aml+xml": { source: "iana", compressible: !0, extensions: ["aml"] },
  "application/automationml-amlx+zip": { source: "iana", compressible: !1, extensions: ["amlx"] },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/bufr": { source: "iana" },
  "application/c2pa": { source: "iana" },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": { source: "iana", compressible: !0, extensions: ["xcs"] },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": { source: "iana", compressible: !0, extensions: ["ccxml"] },
  "application/cda+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/cdfx+xml": { source: "iana", compressible: !0, extensions: ["cdfx"] },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/ce+cbor": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/cid-edhoc+cbor-seq": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/city+json-seq": { source: "iana" },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-eap": { source: "iana" },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/concise-problem-details+cbor": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cose-x509": { source: "iana" },
  "application/cpl+xml": { source: "iana", compressible: !0, extensions: ["cpl"] },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwl": { source: "iana", extensions: ["cwl"] },
  "application/cwl+json": { source: "iana", compressible: !0 },
  "application/cwl+yaml": { source: "iana" },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": { source: "iana", compressible: !0, extensions: ["mpd"] },
  "application/dash-patch+xml": { source: "iana", compressible: !0, extensions: ["mpp"] },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": { source: "iana", compressible: !0, extensions: ["davmount"] },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana", extensions: ["dcm"] },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": { source: "apache", compressible: !0, extensions: ["dbk"] },
  "application/dots+cbor": { source: "iana" },
  "application/dpop+jwt": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": { source: "iana", compressible: !0, extensions: ["xdssc"] },
  "application/dvcs": { source: "iana" },
  "application/eat+cwt": { source: "iana" },
  "application/eat+jwt": { source: "iana" },
  "application/eat-bun+cbor": { source: "iana" },
  "application/eat-bun+json": { source: "iana", compressible: !0 },
  "application/eat-ucs+cbor": { source: "iana" },
  "application/eat-ucs+json": { source: "iana", compressible: !0 },
  "application/ecmascript": { source: "apache", compressible: !0, extensions: ["ecma"] },
  "application/edhoc+cbor-seq": { source: "iana" },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/emergencycalldata.comment+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.control+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.deviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.legacyesn+json": { source: "iana", compressible: !0 },
  "application/emergencycalldata.providerinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.serviceinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.subscriberinfo+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.veds+xml": { source: "iana", compressible: !0 },
  "application/emma+xml": { source: "iana", compressible: !0, extensions: ["emma"] },
  "application/emotionml+xml": { source: "iana", compressible: !0, extensions: ["emotionml"] },
  "application/encaprtp": { source: "iana" },
  "application/entity-statement+jwt": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": { source: "iana", compressible: !1, extensions: ["epub"] },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdf": { source: "iana", extensions: ["fdf"] },
  "application/fdt+xml": { source: "iana", compressible: !0, extensions: ["fdt"] },
  "application/fhir+json": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fhir+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": { source: "iana", compressible: !0, extensions: ["geojson"] },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geopose+json": { source: "iana", compressible: !0 },
  "application/geoxacml+json": { source: "iana", compressible: !0 },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": { source: "iana", compressible: !0, extensions: ["gml"] },
  "application/gnap-binding-jws": { source: "iana" },
  "application/gnap-binding-jwsd": { source: "iana" },
  "application/gnap-binding-rotation-jws": { source: "iana" },
  "application/gnap-binding-rotation-jwsd": { source: "iana" },
  "application/gpx+xml": { source: "apache", compressible: !0, extensions: ["gpx"] },
  "application/grib": { source: "iana" },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/hl7v2+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": { source: "iana", compressible: !0, extensions: ["ink", "inkml"] },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": { source: "iana", compressible: !0, extensions: ["its"] },
  "application/java-archive": { source: "iana", compressible: !1, extensions: ["jar", "war", "ear"] },
  "application/java-serialized-object": { source: "apache", compressible: !1, extensions: ["ser"] },
  "application/java-vm": { source: "apache", compressible: !1, extensions: ["class"] },
  "application/javascript": { source: "apache", charset: "UTF-8", compressible: !0, extensions: ["js"] },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/jscontact+json": { source: "iana", compressible: !0 },
  "application/json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["json", "map"] },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": { source: "apache", compressible: !0, extensions: ["jsonml"] },
  "application/jsonpath": { source: "iana" },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwk-set+jwt": { source: "iana" },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": { source: "iana", compressible: !0, extensions: ["jsonld"] },
  "application/lgr+xml": { source: "iana", compressible: !0, extensions: ["lgr"] },
  "application/link-format": { source: "iana" },
  "application/linkset": { source: "iana" },
  "application/linkset+json": { source: "iana", compressible: !0 },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/logout+jwt": { source: "iana" },
  "application/lost+xml": { source: "iana", compressible: !0, extensions: ["lostxml"] },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": { source: "iana", compressible: !0, extensions: ["mads"] },
  "application/manifest+json": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["webmanifest"] },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": { source: "iana", compressible: !0, extensions: ["mrcx"] },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": { source: "iana", compressible: !0, extensions: ["mathml"] },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": { source: "iana", compressible: !0 },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": { source: "iana", compressible: !0 },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": { source: "iana", compressible: !0, extensions: ["mpf"] },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": { source: "iana", compressible: !0, extensions: ["mscml"] },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": { source: "apache", compressible: !0, extensions: ["metalink"] },
  "application/metalink4+xml": { source: "iana", compressible: !0, extensions: ["meta4"] },
  "application/mets+xml": { source: "iana", compressible: !0, extensions: ["mets"] },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": { source: "iana", compressible: !0, extensions: ["maei"] },
  "application/mmt-usd+xml": { source: "iana", compressible: !0, extensions: ["musd"] },
  "application/mods+xml": { source: "iana", compressible: !0, extensions: ["mods"] },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msc-mixer+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/msix": { compressible: !1, extensions: ["msix"] },
  "application/msixbundle": { compressible: !1, extensions: ["msixbundle"] },
  "application/msword": { source: "iana", compressible: !1, extensions: ["doc", "dot"] },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": { source: "iana", compressible: !0, extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": { source: "iana", compressible: !0, extensions: ["opf"] },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/ohttp-keys": { source: "iana" },
  "application/omdoc+xml": { source: "apache", compressible: !0, extensions: ["omdoc"] },
  "application/onenote": { source: "apache", extensions: ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": { source: "iana", compressible: !0, extensions: ["relo"] },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": { source: "iana", compressible: !0, extensions: ["xer"] },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": { source: "iana", compressible: !1, extensions: ["pgp"] },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["sig", "asc"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pidf-diff+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": { source: "iana", compressible: !0, extensions: ["pls"] },
  "application/poc-settings+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/postscript": { source: "iana", compressible: !0, extensions: ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/private-token-issuer-directory": { source: "iana" },
  "application/private-token-request": { source: "iana" },
  "application/private-token-response": { source: "iana" },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": { source: "iana", compressible: !0, extensions: ["provx"] },
  "application/provided-claims+jwt": { source: "iana" },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.implied-document+xml": { source: "iana", compressible: !0 },
  "application/prs.implied-executable": { source: "iana" },
  "application/prs.implied-object+json": { source: "iana", compressible: !0 },
  "application/prs.implied-object+json-seq": { source: "iana" },
  "application/prs.implied-object+yaml": { source: "iana" },
  "application/prs.implied-structure": { source: "iana" },
  "application/prs.mayfile": { source: "iana" },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.vcfbzip2": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0, extensions: ["xsf"] },
  "application/pskc+xml": { source: "iana", compressible: !0, extensions: ["pskcxml"] },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": { source: "iana", compressible: !0, extensions: ["rdf", "owl"] },
  "application/reginfo+xml": { source: "iana", compressible: !0, extensions: ["rif"] },
  "application/relax-ng-compact-syntax": { source: "iana", extensions: ["rnc"] },
  "application/remote-printing": { source: "apache" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resolve-response+jwt": { source: "iana" },
  "application/resource-lists+xml": { source: "iana", compressible: !0, extensions: ["rl"] },
  "application/resource-lists-diff+xml": { source: "iana", compressible: !0, extensions: ["rld"] },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": { source: "iana", compressible: !0, extensions: ["rs"] },
  "application/route-apd+xml": { source: "iana", compressible: !0, extensions: ["rapd"] },
  "application/route-s-tsid+xml": { source: "iana", compressible: !0, extensions: ["sls"] },
  "application/route-usd+xml": { source: "iana", compressible: !0, extensions: ["rusd"] },
  "application/rpki-checklist": { source: "iana" },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-signed-tal": { source: "iana" },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": { source: "apache", compressible: !0, extensions: ["rsd"] },
  "application/rss+xml": { source: "apache", compressible: !0, extensions: ["rss"] },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": { source: "iana", compressible: !0 },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": { source: "iana", compressible: !0, extensions: ["sbml"] },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": { source: "iana", compressible: !0, extensions: ["senmlx"] },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": { source: "iana", compressible: !0, extensions: ["sensmlx"] },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": { source: "iana", extensions: ["setpay"] },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": { source: "iana", extensions: ["setreg"] },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": { source: "iana", compressible: !0, extensions: ["shf"] },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "apache" },
  "application/smil+xml": { source: "iana", compressible: !0, extensions: ["smi", "smil"] },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": { source: "iana", compressible: !0, extensions: ["srx"] },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana", extensions: ["sql"] },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": { source: "iana", compressible: !0, extensions: ["grxml"] },
  "application/sru+xml": { source: "iana", compressible: !0, extensions: ["sru"] },
  "application/ssdl+xml": { source: "apache", compressible: !0, extensions: ["ssdl"] },
  "application/sslkeylogfile": { source: "iana" },
  "application/ssml+xml": { source: "iana", compressible: !0, extensions: ["ssml"] },
  "application/st2110-41": { source: "iana" },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/stratum": { source: "iana" },
  "application/swid+cbor": { source: "iana" },
  "application/swid+xml": { source: "iana", compressible: !0, extensions: ["swidtag"] },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": { source: "iana", compressible: !0, extensions: ["tei", "teicorpus"] },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": { source: "iana", compressible: !0, extensions: ["tfi"] },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tm+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/toc+cbor": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { source: "iana", compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/trust-chain+json": { source: "iana", compressible: !0 },
  "application/trust-mark+jwt": { source: "iana" },
  "application/trust-mark-delegation+jwt": { source: "iana" },
  "application/ttml+xml": { source: "iana", compressible: !0, extensions: ["ttml"] },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/uccs+cbor": { source: "iana" },
  "application/ujcs+json": { source: "iana", compressible: !0 },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": { source: "iana", compressible: !0, extensions: ["rsheet"] },
  "application/urc-targetdesc+xml": { source: "iana", compressible: !0, extensions: ["td"] },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vc": { source: "iana" },
  "application/vc+cose": { source: "iana" },
  "application/vc+jwt": { source: "iana" },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": { source: "iana", compressible: !0, extensions: ["1km"] },
  "application/vnd.1ob": { source: "iana" },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3a+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ach+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc8+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.5gsa2x": { source: "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gsv2x": { source: "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.crs+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.current-location-discovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-floor-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-regroup+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-regroup+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-service-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-location-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-ue-config-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-unicast-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.seal-user-profile-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.v2x": { source: "iana" },
  "application/vnd.3gpp.vae-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acm.addressxfer+json": { source: "iana", compressible: !0 },
  "application/vnd.acm.chatbot+json": { source: "iana", compressible: !0 },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { source: "apache", compressible: !1, extensions: ["air"] },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": { source: "iana", extensions: ["fcdt"] },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": { source: "iana", compressible: !0, extensions: ["xdp"] },
  "application/vnd.adobe.xfdf": { source: "apache", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "apache" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { source: "iana", extensions: ["azf"] },
  "application/vnd.airzip.filesecure.azs": { source: "iana", extensions: ["azs"] },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": { source: "iana", extensions: ["acc"] },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": { source: "apache", compressible: !1, extensions: ["apk"] },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { source: "iana", extensions: ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { source: "apache", extensions: ["fti"] },
  "application/vnd.antix.game-component": { source: "iana", extensions: ["atx"] },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.parquet": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.apexlang": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": { source: "iana", compressible: !0 },
  "application/vnd.apple.installer+xml": { source: "iana", compressible: !0, extensions: ["mpkg"] },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "apache" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": { source: "iana", extensions: ["iota"] },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autodesk.fbx": { extensions: ["fbx"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": { source: "iana", compressible: !0, extensions: ["bmml"] },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.belightsoft.lhzd+zip": { source: "iana", compressible: !1 },
  "application/vnd.belightsoft.lhzl+zip": { source: "iana", compressible: !1 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.bzip3": { source: "iana" },
  "application/vnd.c3voc.schedule+xml": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": { source: "iana", compressible: !0, extensions: ["cdxml"] },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { source: "iana", extensions: ["mmd"] },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": { source: "iana", compressible: !0, extensions: ["csl"] },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": { source: "iana", extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { source: "iana", extensions: ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { source: "iana", extensions: ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { source: "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { source: "iana" },
  "application/vnd.cncf.helm.config.v1+json": { source: "iana", compressible: !0 },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { source: "iana" },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { source: "iana", extensions: ["clkk"] },
  "application/vnd.crick.clicker.palette": { source: "iana", extensions: ["clkp"] },
  "application/vnd.crick.clicker.template": { source: "iana", extensions: ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { source: "iana", extensions: ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { source: "iana", compressible: !0, extensions: ["wbs"] },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": { source: "iana", compressible: !1 },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": { source: "iana", compressible: !0, extensions: ["dart"] },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datalog": { source: "iana" },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.dcmp+xml": { source: "iana", compressible: !0, extensions: ["dcmp"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": { source: "iana", extensions: ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { source: "iana", compressible: !0, extensions: ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { source: "iana", extensions: ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { source: "iana", extensions: ["fe_launch"] },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-container+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-registration-response+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.eln+zip": { source: "iana", compressible: !1 },
  "application/vnd.emclient.accessrequest+xml": { source: "iana", compressible: !0 },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.erofs": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": { source: "iana", compressible: !0, extensions: ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": { source: "iana", compressible: !1 },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "apache", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": { source: "iana", extensions: ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { source: "iana", charset: "XML-BASED", compressible: !0 },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": { source: "iana", extensions: ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { source: "iana" },
  "application/vnd.frogans.fnc": { source: "apache", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "apache", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": { source: "iana", extensions: ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { source: "iana", extensions: ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { source: "iana" },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.genozip": { source: "iana" },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.gentoo.catmetadata+xml": { source: "iana", compressible: !0 },
  "application/vnd.gentoo.ebuild": { source: "iana" },
  "application/vnd.gentoo.eclass": { source: "iana" },
  "application/vnd.gentoo.gpkg": { source: "iana" },
  "application/vnd.gentoo.manifest": { source: "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { source: "iana", compressible: !0 },
  "application/vnd.gentoo.xpak": { source: "iana" },
  "application/vnd.geo+json": { source: "apache", compressible: !0 },
  "application/vnd.geocube+xml": { source: "apache", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.pinboard": { source: "iana" },
  "application/vnd.geogebra.slides": { source: "iana", extensions: ["ggs"] },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": { source: "iana", extensions: ["gex", "gre"] },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { source: "iana" },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { source: "iana", compressible: !0 },
  "application/vnd.gnu.taler.merchant+json": { source: "iana", compressible: !0 },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { compressible: !1, extensions: ["gdoc"] },
  "application/vnd.google-apps.drawing": { compressible: !1, extensions: ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { compressible: !1 },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { compressible: !1 },
  "application/vnd.google-apps.form": { compressible: !1, extensions: ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { compressible: !1, extensions: ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { compressible: !1, extensions: ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { compressible: !1, extensions: ["gslides"] },
  "application/vnd.google-apps.script": { compressible: !1, extensions: ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { compressible: !1, extensions: ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { compressible: !1, extensions: ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { source: "iana", compressible: !0, extensions: ["kml"] },
  "application/vnd.google-earth.kmz": { source: "iana", compressible: !1, extensions: ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { source: "apache", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": { source: "iana", compressible: !0, extensions: ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { source: "iana", compressible: !0 },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": { source: "iana", extensions: ["gim"] },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": { source: "iana", extensions: ["gtm"] },
  "application/vnd.groove-tool-template": { source: "iana", extensions: ["tpl"] },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": { source: "iana", compressible: !0, extensions: ["hal"] },
  "application/vnd.handheld-entertainment+xml": { source: "iana", compressible: !0, extensions: ["zmm"] },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.hsl": { source: "iana" },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": { source: "iana", extensions: ["sfd-hdstx"] },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "apache" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": { source: "apache", extensions: ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { source: "iana", extensions: ["irm"] },
  "application/vnd.ibm.secure-container": { source: "iana", extensions: ["sc"] },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings+json": { source: "iana", compressible: !0 },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { source: "iana", compressible: !0 },
  "application/vnd.informedcontrol.rms+xml": { source: "iana", compressible: !0 },
  "application/vnd.informix-visionary": { source: "apache" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": { source: "iana", extensions: ["xpw", "xpx"] },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.ipfs.ipns-record": { source: "iana" },
  "application/vnd.ipld.car": { source: "iana" },
  "application/vnd.ipld.dag-cbor": { source: "iana" },
  "application/vnd.ipld.dag-json": { source: "iana" },
  "application/vnd.ipld.raw": { source: "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.conceptitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.knowledgeitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.packageitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.planningitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.ipunplugged.rcprofile": { source: "iana", extensions: ["rcprofile"] },
  "application/vnd.irepository.package+xml": { source: "iana", compressible: !0, extensions: ["irp"] },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": { source: "iana", extensions: ["rms"] },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": { source: "iana", extensions: ["joda"] },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": { source: "iana", extensions: ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kdl": { source: "iana" },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.keyman.kmp+zip": { source: "iana", compressible: !1 },
  "application/vnd.keyman.kmx": { source: "iana" },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": { source: "iana", extensions: ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": { source: "iana", compressible: !0, extensions: ["lasxml"] },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.ldev.productlicensing": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": { source: "iana", extensions: ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { source: "iana", compressible: !0, extensions: ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": { source: "iana", extensions: ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.conftoken+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.license+xml": { source: "iana", compressible: !0 },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.mdl": { source: "iana" },
  "application/vnd.mdl-mbsdf": { source: "iana" },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": { source: "iana", extensions: ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { source: "iana" },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mermaid": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.modl": { source: "iana" },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": { source: "iana", compressible: !0, extensions: ["xul"] },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": { source: "iana", compressible: !1, extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { source: "iana", extensions: ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { source: "iana", extensions: ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { source: "iana", extensions: ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { source: "iana", extensions: ["xltm"] },
  "application/vnd.ms-fontobject": { source: "iana", compressible: !0, extensions: ["eot"] },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-powerpoint": { source: "iana", compressible: !1, extensions: ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { source: "iana", extensions: ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { source: "iana", extensions: ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { source: "iana", extensions: ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { source: "iana", extensions: ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { source: "iana", extensions: ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-printing.printticket+xml": { source: "apache", compressible: !0 },
  "application/vnd.ms-printschematicket+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-visio.viewer": { extensions: ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { source: "iana", extensions: ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { source: "iana", extensions: ["dotm"] },
  "application/vnd.ms-works": { source: "iana", extensions: ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": { source: "iana", compressible: !1, extensions: ["xps"] },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msgpack": { source: "iana" },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.nato.bindingdataobject+cbor": { source: "iana" },
  "application/vnd.nato.bindingdataobject+json": { source: "iana", compressible: !0 },
  "application/vnd.nato.bindingdataobject+xml": { source: "iana", compressible: !0, extensions: ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { source: "iana", compressible: !1 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.n-gage.ac+xml": { source: "iana", compressible: !0, extensions: ["ac"] },
  "application/vnd.nokia.n-gage.data": { source: "iana", extensions: ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { source: "apache", extensions: ["n-gage"] },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": { source: "iana", extensions: ["rpst"] },
  "application/vnd.nokia.radio-presets": { source: "iana", extensions: ["rpss"] },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oai.workflows": { source: "iana" },
  "application/vnd.oai.workflows+json": { source: "iana", compressible: !0 },
  "application/vnd.oai.workflows+yaml": { source: "iana" },
  "application/vnd.oasis.opendocument.base": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": { source: "iana", extensions: ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { source: "iana", extensions: ["otc"] },
  "application/vnd.oasis.opendocument.database": { source: "apache", extensions: ["odb"] },
  "application/vnd.oasis.opendocument.formula": { source: "iana", extensions: ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { source: "iana", extensions: ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { source: "iana", compressible: !1, extensions: ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { source: "iana", extensions: ["otg"] },
  "application/vnd.oasis.opendocument.image": { source: "iana", extensions: ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { source: "iana", extensions: ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { source: "iana", compressible: !1, extensions: ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { source: "iana", extensions: ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { source: "iana", compressible: !1, extensions: ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { source: "iana", extensions: ["ots"] },
  "application/vnd.oasis.opendocument.text": { source: "iana", compressible: !1, extensions: ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { source: "iana", extensions: ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { source: "iana" },
  "application/vnd.oasis.opendocument.text-template": { source: "iana", extensions: ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { source: "iana", extensions: ["oth"] },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": { source: "iana", compressible: !0 },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessstreaming+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.drm-trigger+xml": { source: "apache", compressible: !0 },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { source: "apache", compressible: !0 },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-feature-handler+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-user-prefs+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": { source: "iana", compressible: !0, extensions: ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.final-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.optimized-progress-report+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.xcap-directory+xml": { source: "iana", compressible: !0 },
  "application/vnd.omads-email+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-file+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omads-folder+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.onvif.metadata": { source: "iana" },
  "application/vnd.openblox.game+xml": { source: "iana", compressible: !0, extensions: ["obgx"] },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": { source: "apache", extensions: ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { source: "iana", compressible: !0, extensions: ["osm"] },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openvpi.dspx+json": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { source: "iana", compressible: !1, extensions: ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { source: "iana", extensions: ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { source: "iana", extensions: ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { source: "iana", extensions: ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { source: "iana", compressible: !1, extensions: ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { source: "iana", extensions: ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.theme+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { source: "iana", compressible: !1, extensions: ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { source: "iana", extensions: ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.relationships+xml": { source: "iana", compressible: !0 },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": { source: "iana", extensions: ["mgp"] },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": { source: "iana", extensions: ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { source: "iana", compressible: !0 },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.procrate.brushset": { extensions: ["brushset"] },
  "application/vnd.procreate.brush": { extensions: ["brush"] },
  "application/vnd.procreate.dream": { extensions: ["drm"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.pt.mundusmundi": { source: "iana" },
  "application/vnd.publishare-delta-tree": { source: "iana", extensions: ["qps"] },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0, extensions: ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": { source: "iana", extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-conn+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit-stream+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-base+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-group+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-speech+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog-transform+xml": { source: "iana", compressible: !0 },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { source: "iana", compressible: !0, extensions: ["musicxml"] },
  "application/vnd.relpipe": { source: "iana" },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": { source: "iana", extensions: ["cryptonote"] },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": { source: "apache", extensions: ["rmvb"] },
  "application/vnd.route66.link66+xml": { source: "iana", compressible: !0, extensions: ["link66"] },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": { source: "iana", extensions: ["st"] },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": { source: "iana", extensions: ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { source: "iana", extensions: ["itp"] },
  "application/vnd.shana.informed.interchange": { source: "iana", extensions: ["iif"] },
  "application/vnd.shana.informed.package": { source: "iana", extensions: ["ipk"] },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": { source: "iana", extensions: ["twd", "twds"] },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.sketchometry": { source: "iana" },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.smintio.portals.archive": { source: "iana" },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": { source: "iana", compressible: !0, extensions: ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": { source: "iana", compressible: !0, extensions: ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": { source: "apache", extensions: ["sdc"] },
  "application/vnd.stardivision.draw": { source: "apache", extensions: ["sda"] },
  "application/vnd.stardivision.impress": { source: "apache", extensions: ["sdd"] },
  "application/vnd.stardivision.math": { source: "apache", extensions: ["smf"] },
  "application/vnd.stardivision.writer": { source: "apache", extensions: ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { source: "apache", extensions: ["sgl"] },
  "application/vnd.stepmania.package": { source: "iana", extensions: ["smzip"] },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": { source: "iana", compressible: !0, extensions: ["wadl"] },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": { source: "apache", extensions: ["stc"] },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": { source: "apache", extensions: ["std"] },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": { source: "apache", extensions: ["sti"] },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": { source: "apache", extensions: ["sxg"] },
  "application/vnd.sun.xml.writer.template": { source: "apache", extensions: ["stw"] },
  "application/vnd.sus-calendar": { source: "iana", extensions: ["sus", "susp"] },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sybyl.mol2": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": { source: "apache", extensions: ["sis", "sisx"] },
  "application/vnd.syncml+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { source: "iana", charset: "UTF-8", extensions: ["bdm"] },
  "application/vnd.syncml.dm+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["xdm"] },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": { source: "iana", charset: "UTF-8", compressible: !0 },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": { source: "iana", extensions: ["tao"] },
  "application/vnd.tcpdump.pcap": { source: "iana", extensions: ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { source: "iana", compressible: !0 },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": { source: "iana", compressible: !0, extensions: ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.veraison.tsm-report+cbor": { source: "iana" },
  "application/vnd.veraison.tsm-report+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": { source: "iana", extensions: ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vocalshaper.vsp4": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": { source: "iana", charset: "UTF-8", extensions: ["wbxml"] },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { source: "iana" },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordlift": { source: "iana" },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xarin.cpj": { source: "iana" },
  "application/vnd.xecrets-encrypted": { source: "iana" },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { source: "iana", extensions: ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { source: "iana", compressible: !0, extensions: ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": { source: "iana", extensions: ["cmp"] },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { source: "iana", compressible: !0, extensions: ["zaz"] },
  "application/voicexml+xml": { source: "iana", compressible: !0, extensions: ["vxml"] },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/voucher-jws+json": { source: "iana", compressible: !0 },
  "application/vp": { source: "iana" },
  "application/vp+cose": { source: "iana" },
  "application/vp+jwt": { source: "iana" },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": { source: "iana", compressible: !0, extensions: ["wasm"] },
  "application/watcherinfo+xml": { source: "iana", compressible: !0, extensions: ["wif"] },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": { source: "iana", compressible: !0, extensions: ["wsdl"] },
  "application/wspolicy+xml": { source: "iana", compressible: !0, extensions: ["wspolicy"] },
  "application/x-7z-compressed": { source: "apache", compressible: !1, extensions: ["7z"] },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": { source: "apache", extensions: ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blender": { extensions: ["blend"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": { source: "apache", compressible: !1, extensions: ["bz"] },
  "application/x-bzip2": { source: "apache", compressible: !1, extensions: ["bz2", "boz"] },
  "application/x-cbr": { source: "apache", extensions: ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-compressed": { extensions: ["rar"] },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": { source: "apache", extensions: ["deb", "udeb"] },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": { source: "apache", extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": { source: "apache", compressible: !0, extensions: ["ncx"] },
  "application/x-dtbook+xml": { source: "apache", compressible: !0, extensions: ["dtb"] },
  "application/x-dtbresource+xml": { source: "apache", compressible: !0, extensions: ["res"] },
  "application/x-dvi": { source: "apache", compressible: !1, extensions: ["dvi"] },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": { source: "apache", extensions: ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": { source: "apache", extensions: ["install"] },
  "application/x-ipynb+json": { compressible: !0, extensions: ["ipynb"] },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": { source: "nginx", extensions: ["jardiff"] },
  "application/x-java-jnlp-file": { source: "apache", compressible: !1, extensions: ["jnlp"] },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": { source: "apache", compressible: !1, extensions: ["latex"] },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": { source: "apache", extensions: ["lzh", "lha"] },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": { source: "apache", extensions: ["prc", "mobi"] },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": { source: "apache", extensions: ["application"] },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": { source: "apache", extensions: ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { source: "apache", extensions: ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { source: "apache", extensions: ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { compressible: !0, extensions: ["pac"] },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": { source: "apache", compressible: !1, extensions: ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { source: "apache", extensions: ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": { source: "apache", compressible: !1, extensions: ["rar"] },
  "application/x-redhat-package-manager": { source: "nginx", extensions: ["rpm"] },
  "application/x-research-info-systems": { source: "apache", extensions: ["ris"] },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": { source: "apache", compressible: !0, extensions: ["sh"] },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": { source: "apache", compressible: !1, extensions: ["swf"] },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": { source: "apache", compressible: !1, extensions: ["sit"] },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": { source: "apache", compressible: !0, extensions: ["tar"] },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": { source: "apache", extensions: ["texinfo", "texi"] },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { compressible: !1, extensions: ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": { compressible: !0, extensions: ["webapp"] },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": { source: "iana", extensions: ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": { source: "apache", compressible: !0, extensions: ["xlf"] },
  "application/x-xpinstall": { source: "apache", compressible: !1, extensions: ["xpi"] },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zip-compressed": { extensions: ["zip"] },
  "application/x-zmachine": { source: "apache", extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": { source: "apache", compressible: !0, extensions: ["xaml"] },
  "application/xcap-att+xml": { source: "iana", compressible: !0, extensions: ["xav"] },
  "application/xcap-caps+xml": { source: "iana", compressible: !0, extensions: ["xca"] },
  "application/xcap-diff+xml": { source: "iana", compressible: !0, extensions: ["xdf"] },
  "application/xcap-el+xml": { source: "iana", compressible: !0, extensions: ["xel"] },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": { source: "iana", compressible: !0, extensions: ["xns"] },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": { source: "iana", compressible: !0 },
  "application/xenc+xml": { source: "iana", compressible: !0, extensions: ["xenc"] },
  "application/xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/xhtml+xml": { source: "iana", compressible: !0, extensions: ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": { source: "iana", compressible: !0, extensions: ["xlf"] },
  "application/xml": { source: "iana", compressible: !0, extensions: ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { source: "iana", compressible: !0, extensions: ["dtd"] },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": { source: "iana", compressible: !0, extensions: ["xop"] },
  "application/xproc+xml": { source: "apache", compressible: !0, extensions: ["xpl"] },
  "application/xslt+xml": { source: "iana", compressible: !0, extensions: ["xsl", "xslt"] },
  "application/xspf+xml": { source: "apache", compressible: !0, extensions: ["xspf"] },
  "application/xv+xml": { source: "iana", compressible: !0, extensions: ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { source: "iana" },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+cbor": { source: "iana" },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yang-sid+json": { source: "iana", compressible: !0 },
  "application/yin+xml": { source: "iana", compressible: !0, extensions: ["yin"] },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zip+dotlottie": { extensions: ["lottie"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana", extensions: ["adts", "aac"] },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": { source: "iana", compressible: !1, extensions: ["au", "snd"] },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flac": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/matroska": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { source: "iana" },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": { source: "iana", compressible: !1, extensions: ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": { source: "iana", compressible: !1, extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": { source: "iana", compressible: !1, extensions: ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "apache" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { source: "iana", compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp", "dib"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/dpx": { source: "iana", extensions: ["dpx"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/j2c": { source: "iana" },
  "image/jaii": { source: "iana", extensions: ["jaii"] },
  "image/jais": { source: "iana", extensions: ["jais"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": { source: "iana", compressible: !1, extensions: ["jp2", "jpg2"] },
  "image/jpeg": { source: "iana", compressible: !1, extensions: ["jpg", "jpeg", "jpe"] },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm", "jpgm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxl": { source: "iana", extensions: ["jxl"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1, extensions: ["jfif"] },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif", "btf"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": { source: "iana", compressible: !0, extensions: ["svg", "svgz"] },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": { source: "iana", compressible: !1, extensions: ["tif", "tiff"] },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": { source: "iana", compressible: !0, extensions: ["psd"] },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.clip": { source: "iana" },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": { source: "iana", extensions: ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": { source: "iana", compressible: !0, extensions: ["ico"] },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "iana", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-adobe-dng": { extensions: ["dng"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-emf": { source: "iana" },
  "image/x-freehand": { source: "apache", extensions: ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-wmf": { source: "iana" },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/bhttp": { source: "iana" },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": { source: "iana", extensions: ["disposition-notification"] },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": { source: "iana", extensions: ["u8mdn"] },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/mls": { source: "iana" },
  "message/news": { source: "apache" },
  "message/ohttp-req": { source: "iana" },
  "message/ohttp-res": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": { source: "iana", compressible: !0, extensions: ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { source: "apache" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "apache" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": { source: "iana", compressible: !0, extensions: ["glb"] },
  "model/iges": { source: "iana", compressible: !1, extensions: ["igs", "iges"] },
  "model/jt": { source: "iana", extensions: ["jt"] },
  "model/mesh": { source: "iana", compressible: !1, extensions: ["msh", "mesh", "silo"] },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/prc": { source: "iana", extensions: ["prc"] },
  "model/step": { source: "iana", extensions: ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": { source: "iana", compressible: !1, extensions: ["stpxz"] },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/u3d": { source: "iana", extensions: ["u3d"] },
  "model/vnd.bary": { source: "iana", extensions: ["bary"] },
  "model/vnd.cld": { source: "iana", extensions: ["cld"] },
  "model/vnd.collada+xml": { source: "iana", compressible: !0, extensions: ["dae"] },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { source: "iana", extensions: ["x_b"] },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana", extensions: ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usda": { source: "iana", extensions: ["usda"] },
  "model/vnd.usdz+zip": { source: "iana", compressible: !1, extensions: ["usdz"] },
  "model/vnd.valve.source.compiled-map": { source: "iana", extensions: ["bsp"] },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": { source: "iana", compressible: !1, extensions: ["wrl", "vrml"] },
  "model/x3d+binary": { source: "apache", compressible: !1, extensions: ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": { source: "apache", compressible: !1, extensions: ["x3dv", "x3dvz"] },
  "model/x3d+xml": { source: "iana", compressible: !0, extensions: ["x3d", "x3dz"] },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": { source: "iana", compressible: !0, extensions: ["appcache", "manifest"] },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["css"] },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "apache" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/hl7v2": { source: "iana" },
  "text/html": { source: "iana", compressible: !0, extensions: ["html", "htm", "shtml"] },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["js", "mjs"] },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": { source: "iana", compressible: !0, extensions: ["md", "markdown"] },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["n3"] },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": { source: "iana", compressible: !0, extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/prs.texi": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": { source: "iana", compressible: !0, extensions: ["tsv"] },
  "text/troff": { source: "iana", extensions: ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": { source: "iana", compressible: !0, extensions: ["uri", "uris", "urls"] },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.exchangeable": { source: "iana" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "apache" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": { source: "iana", charset: "UTF-8", extensions: ["jad"] },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.vcf": { source: "iana" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vnd.zoo.kcl": { source: "iana" },
  "text/vtt": { source: "iana", charset: "UTF-8", compressible: !0, extensions: ["vtt"] },
  "text/wgsl": { source: "iana", extensions: ["wgsl"] },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": { source: "apache", extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": { source: "apache", extensions: ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/evc": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/h266": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/lottie+json": { source: "iana", compressible: !0 },
  "video/matroska": { source: "iana" },
  "video/matroska-3d": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { source: "iana", compressible: !1, extensions: ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": { source: "iana", compressible: !1, extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": { source: "iana", compressible: !1, extensions: ["qt", "mov"] },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.planar": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "apache" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": { source: "apache", compressible: !1, extensions: ["mkv", "mk3d", "mks"] },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb, hasRequiredMimeDb;
function requireMimeDb() {
  return hasRequiredMimeDb || (hasRequiredMimeDb = 1, mimeDb = require$$0$1), mimeDb;
}
var mimeScore, hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var e = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  }, t = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  }, r = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
  };
  return mimeScore = function(u, n = "default") {
    if (u === "application/octet-stream")
      return 0;
    const [o, c] = u.split("/"), f = c.replace(/(\.|x-).*/, "$1"), l = e[f] || e.default, s = t[n] || t.default, p = r[o] || r.default, m = 1 - u.length / 100;
    return l + s + p + m;
  }, mimeScore;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  return hasRequiredMimeTypes || (hasRequiredMimeTypes = 1, (function(e) {
    var t = requireMimeDb(), r = requirePathBrowserify().extname, a = requireMimeScore(), u = /^\s*([^;\s]*)(?:;|\s|$)/, n = /^text\//i;
    e.charset = o, e.charsets = { lookup: o }, e.contentType = c, e.extension = f, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = l, e.types = /* @__PURE__ */ Object.create(null), e._extensionConflicts = [], s(e.extensions, e.types);
    function o(g) {
      if (!g || typeof g != "string")
        return !1;
      var y = u.exec(g), v = y && t[y[1].toLowerCase()];
      return v && v.charset ? v.charset : y && n.test(y[1]) ? "UTF-8" : !1;
    }
    function c(g) {
      if (!g || typeof g != "string")
        return !1;
      var y = g.indexOf("/") === -1 ? e.lookup(g) : g;
      if (!y)
        return !1;
      if (y.indexOf("charset") === -1) {
        var v = e.charset(y);
        v && (y += "; charset=" + v.toLowerCase());
      }
      return y;
    }
    function f(g) {
      if (!g || typeof g != "string")
        return !1;
      var y = u.exec(g), v = y && e.extensions[y[1].toLowerCase()];
      return !v || !v.length ? !1 : v[0];
    }
    function l(g) {
      if (!g || typeof g != "string")
        return !1;
      var y = r("x." + g).toLowerCase().slice(1);
      return y && e.types[y] || !1;
    }
    function s(g, y) {
      Object.keys(t).forEach(function(E) {
        var b = t[E], q = b.extensions;
        if (!(!q || !q.length)) {
          g[E] = q;
          for (var O = 0; O < q.length; O++) {
            var j = q[O];
            y[j] = p(j, y[j], E);
            const D = m(
              j,
              y[j],
              E
            );
            D !== y[j] && e._extensionConflicts.push([j, D, y[j]]);
          }
        }
      });
    }
    function p(g, y, v) {
      var E = y ? a(y, t[y].source) : 0, b = v ? a(v, t[v].source) : 0;
      return E > b ? y : v;
    }
    function m(g, y, v) {
      var E = ["nginx", "apache", void 0, "iana"], b = y ? E.indexOf(t[y].source) : 0, q = v ? E.indexOf(t[v].source) : 0;
      return e.types[f] !== "application/octet-stream" && (b > q || b === q && e.types[f]?.slice(0, 12) === "application/") || b > q ? y : v;
    }
  })(mimeTypes)), mimeTypes;
}
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper) return mediaTyper;
  hasRequiredMediaTyper = 1;
  var e = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/, t = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/, r = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper.format = a, mediaTyper.parse = n, mediaTyper.test = u;
  function a(c) {
    if (!c || typeof c != "object")
      throw new TypeError("argument obj is required");
    var f = c.subtype, l = c.suffix, s = c.type;
    if (!s || !t.test(s))
      throw new TypeError("invalid type");
    if (!f || !e.test(f))
      throw new TypeError("invalid subtype");
    var p = s + "/" + f;
    if (l) {
      if (!t.test(l))
        throw new TypeError("invalid suffix");
      p += "+" + l;
    }
    return p;
  }
  function u(c) {
    if (!c)
      throw new TypeError("argument string is required");
    if (typeof c != "string")
      throw new TypeError("argument string is required to be a string");
    return r.test(c.toLowerCase());
  }
  function n(c) {
    if (!c)
      throw new TypeError("argument string is required");
    if (typeof c != "string")
      throw new TypeError("argument string is required to be a string");
    var f = r.exec(c.toLowerCase());
    if (!f)
      throw new TypeError("invalid media type");
    var l = f[1], s = f[2], p, m = s.lastIndexOf("+");
    return m !== -1 && (p = s.substr(m + 1), s = s.substr(0, m)), new o(l, s, p);
  }
  function o(c, f, l) {
    this.type = c, this.subtype = f, this.suffix = l;
  }
  return mediaTyper;
}
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs) return typeIs.exports;
  hasRequiredTypeIs = 1;
  var e = requireContentType(), t = requireMimeTypes(), r = requireMediaTyper();
  typeIs.exports = n, typeIs.exports.is = a, typeIs.exports.hasBody = u, typeIs.exports.normalize = o, typeIs.exports.match = c;
  function a(s, p) {
    var m, g = p, y = l(s);
    if (!y)
      return !1;
    if (g && !Array.isArray(g))
      for (g = new Array(arguments.length - 1), m = 0; m < g.length; m++)
        g[m] = arguments[m + 1];
    if (!g || !g.length)
      return y;
    var v;
    for (m = 0; m < g.length; m++)
      if (c(o(v = g[m]), y))
        return v[0] === "+" || v.indexOf("*") !== -1 ? y : v;
    return !1;
  }
  function u(s) {
    return s.headers["transfer-encoding"] !== void 0 || !isNaN(s.headers["content-length"]);
  }
  function n(s, p) {
    if (!u(s)) return null;
    var m = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : p, g = s.headers["content-type"];
    return a(g, m);
  }
  function o(s) {
    if (typeof s != "string")
      return !1;
    switch (s) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    return s[0] === "+" ? "*/*" + s : s.indexOf("/") === -1 ? t.lookup(s) : s;
  }
  function c(s, p) {
    if (s === !1)
      return !1;
    var m = p.split("/"), g = s.split("/");
    return m.length !== 2 || g.length !== 2 || g[0] !== "*" && g[0] !== m[0] ? !1 : g[1].slice(0, 2) === "*+" ? g[1].length <= m[1].length + 1 && g[1].slice(1) === m[1].slice(1 - g[1].length) : !(g[1] !== "*" && g[1] !== m[1]);
  }
  function f(s) {
    var p = e.parse(s).type;
    return r.test(p) ? p : null;
  }
  function l(s) {
    try {
      return s ? f(s) : null;
    } catch {
      return null;
    }
  }
  return typeIs.exports;
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var fresh_1, hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh) return fresh_1;
  hasRequiredFresh = 1;
  var e = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  fresh_1 = t;
  function t(u, n) {
    var o = u["if-modified-since"], c = u["if-none-match"];
    if (!o && !c)
      return !1;
    var f = u["cache-control"];
    if (f && e.test(f))
      return !1;
    if (c && c !== "*") {
      var l = n.etag;
      if (!l)
        return !1;
      for (var s = !0, p = a(c), m = 0; m < p.length; m++) {
        var g = p[m];
        if (g === l || g === "W/" + l || "W/" + g === l) {
          s = !1;
          break;
        }
      }
      if (s)
        return !1;
    }
    if (o) {
      var y = n["last-modified"], v = !y || !(r(y) <= r(o));
      if (v)
        return !1;
    }
    return !0;
  }
  function r(u) {
    var n = u && Date.parse(u);
    return typeof n == "number" ? n : NaN;
  }
  function a(u) {
    for (var n = 0, o = [], c = 0, f = 0, l = u.length; f < l; f++)
      switch (u.charCodeAt(f)) {
        case 32:
          c === n && (c = n = f + 1);
          break;
        case 44:
          o.push(u.substring(c, n)), c = n = f + 1;
          break;
        default:
          n = f + 1;
          break;
      }
    return o.push(u.substring(c, n)), o;
  }
  return fresh_1;
}
var only, hasRequiredOnly;
function requireOnly() {
  return hasRequiredOnly || (hasRequiredOnly = 1, only = (e, t) => {
    const r = {};
    for (let a = 0; a < t.length; a++) {
      const u = t[a];
      e[u] != null && (r[u] = e[u]);
    }
    return r;
  }), only;
}
var hasRequiredRequest;
function requireRequest() {
  return hasRequiredRequest || (hasRequiredRequest = 1, (function(e) {
    const t = require$$0$5.URL, r = require$$1, a = requireAccepts(), u = requireContentType(), n = require$$0$5.format, o = requireParseurl(), c = requireSearchParams(), f = requireTypeIs(), l = requireFresh(), s = requireOnly(), p = requireUtil(), m = Symbol("context#ip");
    e.exports = {
      /**
       * Return request header.
       *
       * @return {Object}
       * @api public
       */
      get header() {
        return this.req.headers;
      },
      /**
       * Set request header.
       *
       * @api public
       */
      set header(y) {
        this.req.headers = y;
      },
      /**
       * Return request header, alias as request.header
       *
       * @return {Object}
       * @api public
       */
      get headers() {
        return this.req.headers;
      },
      /**
       * Set request header, alias as request.header
       *
       * @api public
       */
      set headers(y) {
        this.req.headers = y;
      },
      /**
       * Get request URL.
       *
       * @return {String}
       * @api public
       */
      get url() {
        return this.req.url;
      },
      /**
       * Set request URL.
       *
       * @api public
       */
      set url(y) {
        this.req.url = y;
      },
      /**
       * Get the origin header.
       *
       * @return {String}
       * @api public
       */
      get origin() {
        return this.req.headers.origin || null;
      },
      /**
       * Get full request URL.
       *
       * @return {String}
       * @api public
       */
      get href() {
        return /^https?:\/\//i.test(this.originalUrl) ? this.originalUrl : this.protocol + "://" + this.host + this.originalUrl;
      },
      /**
       * Get request method.
       *
       * @return {String}
       * @api public
       */
      get method() {
        return this.req.method;
      },
      /**
       * Set request method.
       *
       * @param {String} val
       * @api public
       */
      set method(y) {
        this.req.method = y;
      },
      /**
       * Get request pathname.
       *
       * @return {String}
       * @api public
       */
      get path() {
        return o(this.req).pathname;
      },
      /**
       * Set pathname, retaining the query string when present.
       *
       * @param {String} path
       * @api public
       */
      set path(y) {
        const v = o(this.req);
        v.pathname !== y && (v.pathname = y, v.path = null, this.url = n(v));
      },
      /**
       * Get parsed query string.
       *
       * @return {Object}
       * @api public
       */
      get query() {
        const y = this.querystring, v = this._querycache = this._querycache || {};
        return v[y] || (v[y] = c.parse(y));
      },
      /**
       * Set query string as an object.
       *
       * @param {Object} obj
       * @api public
       */
      set query(y) {
        this.querystring = c.stringify(y);
      },
      /**
       * Get query string.
       *
       * @return {String}
       * @api public
       */
      get querystring() {
        return this.req && o(this.req).query || "";
      },
      /**
       * Set query string.
       *
       * @param {String} str
       * @api public
       */
      set querystring(y) {
        const v = o(this.req);
        v.search !== `?${y}` && (v.search = y, v.path = null, this.url = n(v));
      },
      /**
       * Get the search string. Same as the query string
       * except it includes the leading ?.
       *
       * @return {String}
       * @api public
       */
      get search() {
        return this.querystring ? `?${this.querystring}` : "";
      },
      /**
       * Set the search string. Same as
       * request.querystring= but included for ubiquity.
       *
       * @param {String} str
       * @api public
       */
      set search(y) {
        this.querystring = y;
      },
      /**
       * Parse the "Host" header field host
       * and support X-Forwarded-Host when a
       * proxy is enabled.
       *
       * @return {String} hostname:port
       * @api public
       */
      get host() {
        let v = this.app.proxy && this.get("X-Forwarded-Host");
        return v || (this.req.httpVersionMajor >= 2 && (v = this.get(":authority")), v || (v = this.get("Host"))), v ? g(v, 1)[0] : "";
      },
      /**
       * Parse the "Host" header field hostname
       * and support X-Forwarded-Host when a
       * proxy is enabled.
       *
       * @return {String} hostname
       * @api public
       */
      get hostname() {
        const y = this.host;
        return y ? y[0] === "[" ? this.URL.hostname || "" : y.split(":", 1)[0] : "";
      },
      /**
       * Get WHATWG parsed URL.
       * Lazily memoized.
       *
       * @return {URL|Object}
       * @api public
       */
      get URL() {
        if (!this.memoizedURL) {
          const y = this.originalUrl || "";
          try {
            this.memoizedURL = new t(`${this.protocol}://${this.host}${y}`);
          } catch {
            this.memoizedURL = /* @__PURE__ */ Object.create(null);
          }
        }
        return this.memoizedURL;
      },
      /**
       * Check if the request is fresh, aka
       * Last-Modified and/or the ETag
       * still match.
       *
       * @return {Boolean}
       * @api public
       */
      get fresh() {
        const y = this.method, v = this.ctx.status;
        return y !== "GET" && y !== "HEAD" ? !1 : v >= 200 && v < 300 || v === 304 ? l(this.header, this.response.header) : !1;
      },
      /**
       * Check if the request is stale, aka
       * "Last-Modified" and / or the "ETag" for the
       * resource has changed.
       *
       * @return {Boolean}
       * @api public
       */
      get stale() {
        return !this.fresh;
      },
      /**
       * Check if the request is idempotent.
       *
       * @return {Boolean}
       * @api public
       */
      get idempotent() {
        return !!~["GET", "HEAD", "PUT", "DELETE", "OPTIONS", "TRACE"].indexOf(this.method);
      },
      /**
       * Return the request socket.
       *
       * @return {Connection}
       * @api public
       */
      get socket() {
        return this.req.socket;
      },
      /**
       * Get the charset when present or undefined.
       *
       * @return {String}
       * @api public
       */
      get charset() {
        try {
          const { parameters: y } = u.parse(this.req);
          return y.charset || "";
        } catch {
          return "";
        }
      },
      /**
       * Return parsed Content-Length when present.
       *
       * @return {Number|void}
       * @api public
       */
      get length() {
        const y = this.get("Content-Length");
        if (y !== "")
          return ~~y;
      },
      /**
       * Return the protocol string "http" or "https"
       * when requested with TLS. When the proxy setting
       * is enabled the "X-Forwarded-Proto" header
       * field will be trusted. If you're running behind
       * a reverse proxy that supplies https for you this
       * may be enabled.
       *
       * @return {String}
       * @api public
       */
      get protocol() {
        if (this.socket.encrypted) return "https";
        if (!this.app.proxy) return "http";
        const y = this.get("X-Forwarded-Proto");
        return y ? g(y, 1)[0] : "http";
      },
      /**
       * Shorthand for:
       *
       *    this.protocol == 'https'
       *
       * @return {Boolean}
       * @api public
       */
      get secure() {
        return this.protocol === "https";
      },
      /**
       * When `app.proxy` is `true`, parse
       * the "X-Forwarded-For" ip address list.
       *
       * For example if the value was "client, proxy1, proxy2"
       * you would receive the array `["client", "proxy1", "proxy2"]`
       * where "proxy2" is the furthest down-stream.
       *
       * @return {Array}
       * @api public
       */
      get ips() {
        const y = this.app.proxy, v = this.get(this.app.proxyIpHeader);
        let E = y && v ? g(v) : [];
        return this.app.maxIpsCount > 0 && (E = E.slice(-this.app.maxIpsCount)), E;
      },
      /**
       * Return request's remote address
       * When `app.proxy` is `true`, parse
       * the "X-Forwarded-For" ip address list and return the first one
       *
       * @return {String}
       * @api public
       */
      get ip() {
        return this[m] || (this[m] = this.ips[0] || this.socket.remoteAddress || ""), this[m];
      },
      set ip(y) {
        this[m] = y;
      },
      /**
       * Return subdomains as an array.
       *
       * Subdomains are the dot-separated parts of the host before the main domain
       * of the app. By default, the domain of the app is assumed to be the last two
       * parts of the host. This can be changed by setting `app.subdomainOffset`.
       *
       * For example, if the domain is "tobi.ferrets.example.com":
       * If `app.subdomainOffset` is not set, this.subdomains is
       * `["ferrets", "tobi"]`.
       * If `app.subdomainOffset` is 3, this.subdomains is `["tobi"]`.
       *
       * @return {Array}
       * @api public
       */
      get subdomains() {
        const y = this.app.subdomainOffset, v = this.hostname;
        return r.isIP(v) ? [] : v.split(".").reverse().slice(y);
      },
      /**
       * Get accept object.
       * Lazily memoized.
       *
       * @return {Object}
       * @api private
       */
      get accept() {
        return this._accept || (this._accept = a(this.req));
      },
      /**
       * Set accept object.
       *
       * @param {Object} obj
       * @api private
       */
      set accept(y) {
        this._accept = y;
      },
      /**
       * Check if the given `type(s)` is acceptable, returning
       * the best match when true, otherwise `false`, in which
       * case you should respond with 406 "Not Acceptable".
       *
       * The `type` value may be a single mime type string
       * such as "application/json", the extension name
       * such as "json" or an array `["json", "html", "text/plain"]`. When a list
       * or array is given the _best_ match, if any is returned.
       *
       * Examples:
       *
       *     // Accept: text/html
       *     this.accepts('html');
       *     // => "html"
       *
       *     // Accept: text/*, application/json
       *     this.accepts('html');
       *     // => "html"
       *     this.accepts('text/html');
       *     // => "text/html"
       *     this.accepts('json', 'text');
       *     // => "json"
       *     this.accepts('application/json');
       *     // => "application/json"
       *
       *     // Accept: text/*, application/json
       *     this.accepts('image/png');
       *     this.accepts('png');
       *     // => false
       *
       *     // Accept: text/*;q=.5, application/json
       *     this.accepts(['html', 'json']);
       *     this.accepts('html', 'json');
       *     // => "json"
       *
       * @param {String|Array} type(s)...
       * @return {String|Array|false}
       * @api public
       */
      accepts(...y) {
        return this.accept.types(...y);
      },
      /**
       * Return accepted encodings or best fit based on `encodings`.
       *
       * Given `Accept-Encoding: gzip, deflate`
       * an array sorted by quality is returned:
       *
       *     ['gzip', 'deflate']
       *
       * @param {String|Array} encoding(s)...
       * @return {String|Array}
       * @api public
       */
      acceptsEncodings(...y) {
        return this.accept.encodings(...y);
      },
      /**
       * Return accepted charsets or best fit based on `charsets`.
       *
       * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
       * an array sorted by quality is returned:
       *
       *     ['utf-8', 'utf-7', 'iso-8859-1']
       *
       * @param {String|Array} charset(s)...
       * @return {String|Array}
       * @api public
       */
      acceptsCharsets(...y) {
        return this.accept.charsets(...y);
      },
      /**
       * Return accepted languages or best fit based on `langs`.
       *
       * Given `Accept-Language: en;q=0.8, es, pt`
       * an array sorted by quality is returned:
       *
       *     ['es', 'pt', 'en']
       *
       * @param {String|Array} lang(s)...
       * @return {Array|String}
       * @api public
       */
      acceptsLanguages(...y) {
        return this.accept.languages(...y);
      },
      /**
       * Check if the incoming request contains the "Content-Type"
       * header field and if it contains any of the given mime `type`s.
       * If there is no request body, `null` is returned.
       * If there is no content type, `false` is returned.
       * Otherwise, it returns the first `type` that matches.
       *
       * Examples:
       *
       *     // With Content-Type: text/html; charset=utf-8
       *     this.is('html'); // => 'html'
       *     this.is('text/html'); // => 'text/html'
       *     this.is('text/*', 'application/json'); // => 'text/html'
       *
       *     // When Content-Type is application/json
       *     this.is('json', 'urlencoded'); // => 'json'
       *     this.is('application/json'); // => 'application/json'
       *     this.is('html', 'application/*'); // => 'application/json'
       *
       *     this.is('html'); // => false
       *
       * @param {String|String[]} [type]
       * @param {String[]} [types]
       * @return {String|false|null}
       * @api public
       */
      is(y, ...v) {
        return f(this.req, y, ...v);
      },
      /**
       * Return the request mime type void of
       * parameters such as "charset".
       *
       * @return {String}
       * @api public
       */
      get type() {
        const y = this.get("Content-Type");
        return y ? y.split(";")[0] : "";
      },
      /**
       * Return request header.
       *
       * The `Referrer` header field is special-cased,
       * both `Referrer` and `Referer` are interchangeable.
       *
       * Examples:
       *
       *     this.get('Content-Type');
       *     // => "text/plain"
       *
       *     this.get('content-type');
       *     // => "text/plain"
       *
       *     this.get('Something');
       *     // => ''
       *
       * @param {String} field
       * @return {String}
       * @api public
       */
      get(y) {
        const v = this.req;
        switch (y = y.toLowerCase()) {
          case "referer":
          case "referrer":
            return v.headers.referrer || v.headers.referer || "";
          default:
            return v.headers[y] || "";
        }
      },
      /**
       * Inspect implementation.
       *
       * @return {Object}
       * @api public
       */
      inspect() {
        if (this.req)
          return this.toJSON();
      },
      /**
       * Return JSON representation.
       *
       * @return {Object}
       * @api public
       */
      toJSON() {
        return s(this, [
          "method",
          "url",
          "header"
        ]);
      }
    }, p.inspect.custom && (e.exports[p.inspect.custom] = e.exports.inspect);
    function g(y, v) {
      return y.split(",", v).map((E) => E.trim());
    }
  })(request)), request.exports;
}
var response = { exports: {} }, assert = { exports: {} }, errors = {}, hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  function e(q) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(O) {
      return typeof O;
    } : function(O) {
      return O && typeof Symbol == "function" && O.constructor === Symbol && O !== Symbol.prototype ? "symbol" : typeof O;
    }, e(q);
  }
  function t(q, O, j) {
    return Object.defineProperty(q, "prototype", { writable: !1 }), q;
  }
  function r(q, O) {
    if (!(q instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(q, O) {
    if (typeof O != "function" && O !== null)
      throw new TypeError("Super expression must either be null or a function");
    q.prototype = Object.create(O && O.prototype, { constructor: { value: q, writable: !0, configurable: !0 } }), Object.defineProperty(q, "prototype", { writable: !1 }), O && u(q, O);
  }
  function u(q, O) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(D, G) {
      return D.__proto__ = G, D;
    }, u(q, O);
  }
  function n(q) {
    var O = f();
    return function() {
      var D = l(q), G;
      if (O) {
        var V = l(this).constructor;
        G = Reflect.construct(D, arguments, V);
      } else
        G = D.apply(this, arguments);
      return o(this, G);
    };
  }
  function o(q, O) {
    if (O && (e(O) === "object" || typeof O == "function"))
      return O;
    if (O !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return c(q);
  }
  function c(q) {
    if (q === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return q;
  }
  function f() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function l(q) {
    return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(j) {
      return j.__proto__ || Object.getPrototypeOf(j);
    }, l(q);
  }
  var s = {}, p, m;
  function g(q, O, j) {
    j || (j = Error);
    function D(V, Q, re) {
      return typeof O == "string" ? O : O(V, Q, re);
    }
    var G = /* @__PURE__ */ (function(V) {
      a(re, V);
      var Q = n(re);
      function re(ve, te, R) {
        var M;
        return r(this, re), M = Q.call(this, D(ve, te, R)), M.code = q, M;
      }
      return t(re);
    })(j);
    s[q] = G;
  }
  function y(q, O) {
    if (Array.isArray(q)) {
      var j = q.length;
      return q = q.map(function(D) {
        return String(D);
      }), j > 2 ? "one of ".concat(O, " ").concat(q.slice(0, j - 1).join(", "), ", or ") + q[j - 1] : j === 2 ? "one of ".concat(O, " ").concat(q[0], " or ").concat(q[1]) : "of ".concat(O, " ").concat(q[0]);
    } else
      return "of ".concat(O, " ").concat(String(q));
  }
  function v(q, O, j) {
    return q.substr(0, O.length) === O;
  }
  function E(q, O, j) {
    return (j === void 0 || j > q.length) && (j = q.length), q.substring(j - O.length, j) === O;
  }
  function b(q, O, j) {
    return typeof j != "number" && (j = 0), j + O.length > q.length ? !1 : q.indexOf(O, j) !== -1;
  }
  return g("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), g("ERR_INVALID_ARG_TYPE", function(q, O, j) {
    p === void 0 && (p = requireAssert()), p(typeof q == "string", "'name' must be a string");
    var D;
    typeof O == "string" && v(O, "not ") ? (D = "must not be", O = O.replace(/^not /, "")) : D = "must be";
    var G;
    if (E(q, " argument"))
      G = "The ".concat(q, " ").concat(D, " ").concat(y(O, "type"));
    else {
      var V = b(q, ".") ? "property" : "argument";
      G = 'The "'.concat(q, '" ').concat(V, " ").concat(D, " ").concat(y(O, "type"));
    }
    return G += ". Received type ".concat(e(j)), G;
  }, TypeError), g("ERR_INVALID_ARG_VALUE", function(q, O) {
    var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    m === void 0 && (m = requireUtil());
    var D = m.inspect(O);
    return D.length > 128 && (D = "".concat(D.slice(0, 128), "...")), "The argument '".concat(q, "' ").concat(j, ". Received ").concat(D);
  }, TypeError), g("ERR_INVALID_RETURN_VALUE", function(q, O, j) {
    var D;
    return j && j.constructor && j.constructor.name ? D = "instance of ".concat(j.constructor.name) : D = "type ".concat(e(j)), "Expected ".concat(q, ' to be returned from the "').concat(O, '"') + " function but got ".concat(D, ".");
  }, TypeError), g("ERR_MISSING_ARGS", function() {
    for (var q = arguments.length, O = new Array(q), j = 0; j < q; j++)
      O[j] = arguments[j];
    p === void 0 && (p = requireAssert()), p(O.length > 0, "At least one arg needs to be specified");
    var D = "The ", G = O.length;
    switch (O = O.map(function(V) {
      return '"'.concat(V, '"');
    }), G) {
      case 1:
        D += "".concat(O[0], " argument");
        break;
      case 2:
        D += "".concat(O[0], " and ").concat(O[1], " arguments");
        break;
      default:
        D += O.slice(0, G - 1).join(", "), D += ", and ".concat(O[G - 1], " arguments");
        break;
    }
    return "".concat(D, " must be specified");
  }, TypeError), errors.codes = s, errors;
}
var assertion_error, hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error) return assertion_error;
  hasRequiredAssertion_error = 1;
  function e(I, C) {
    var $ = Object.keys(I);
    if (Object.getOwnPropertySymbols) {
      var w = Object.getOwnPropertySymbols(I);
      C && (w = w.filter(function(U) {
        return Object.getOwnPropertyDescriptor(I, U).enumerable;
      })), $.push.apply($, w);
    }
    return $;
  }
  function t(I) {
    for (var C = 1; C < arguments.length; C++) {
      var $ = arguments[C] != null ? arguments[C] : {};
      C % 2 ? e(Object($), !0).forEach(function(w) {
        r(I, w, $[w]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(I, Object.getOwnPropertyDescriptors($)) : e(Object($)).forEach(function(w) {
        Object.defineProperty(I, w, Object.getOwnPropertyDescriptor($, w));
      });
    }
    return I;
  }
  function r(I, C, $) {
    return C = o(C), C in I ? Object.defineProperty(I, C, { value: $, enumerable: !0, configurable: !0, writable: !0 }) : I[C] = $, I;
  }
  function a(I, C) {
    if (!(I instanceof C))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(I, C) {
    for (var $ = 0; $ < C.length; $++) {
      var w = C[$];
      w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(I, o(w.key), w);
    }
  }
  function n(I, C, $) {
    return C && u(I.prototype, C), Object.defineProperty(I, "prototype", { writable: !1 }), I;
  }
  function o(I) {
    var C = c(I, "string");
    return q(C) === "symbol" ? C : String(C);
  }
  function c(I, C) {
    if (q(I) !== "object" || I === null) return I;
    var $ = I[Symbol.toPrimitive];
    if ($ !== void 0) {
      var w = $.call(I, C);
      if (q(w) !== "object") return w;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(I);
  }
  function f(I, C) {
    if (typeof C != "function" && C !== null)
      throw new TypeError("Super expression must either be null or a function");
    I.prototype = Object.create(C && C.prototype, { constructor: { value: I, writable: !0, configurable: !0 } }), Object.defineProperty(I, "prototype", { writable: !1 }), C && E(I, C);
  }
  function l(I) {
    var C = y();
    return function() {
      var w = b(I), U;
      if (C) {
        var ie = b(this).constructor;
        U = Reflect.construct(w, arguments, ie);
      } else
        U = w.apply(this, arguments);
      return s(this, U);
    };
  }
  function s(I, C) {
    if (C && (q(C) === "object" || typeof C == "function"))
      return C;
    if (C !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return p(I);
  }
  function p(I) {
    if (I === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return I;
  }
  function m(I) {
    var C = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return m = function(w) {
      if (w === null || !v(w)) return w;
      if (typeof w != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof C < "u") {
        if (C.has(w)) return C.get(w);
        C.set(w, U);
      }
      function U() {
        return g(w, arguments, b(this).constructor);
      }
      return U.prototype = Object.create(w.prototype, { constructor: { value: U, enumerable: !1, writable: !0, configurable: !0 } }), E(U, w);
    }, m(I);
  }
  function g(I, C, $) {
    return y() ? g = Reflect.construct.bind() : g = function(U, ie, le) {
      var ee = [null];
      ee.push.apply(ee, ie);
      var F = Function.bind.apply(U, ee), z = new F();
      return le && E(z, le.prototype), z;
    }, g.apply(null, arguments);
  }
  function y() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function v(I) {
    return Function.toString.call(I).indexOf("[native code]") !== -1;
  }
  function E(I, C) {
    return E = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w, U) {
      return w.__proto__ = U, w;
    }, E(I, C);
  }
  function b(I) {
    return b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function($) {
      return $.__proto__ || Object.getPrototypeOf($);
    }, b(I);
  }
  function q(I) {
    "@babel/helpers - typeof";
    return q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
      return typeof C;
    } : function(C) {
      return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
    }, q(I);
  }
  var O = requireUtil(), j = O.inspect, D = requireErrors(), G = D.codes.ERR_INVALID_ARG_TYPE;
  function V(I, C, $) {
    return ($ === void 0 || $ > I.length) && ($ = I.length), I.substring($ - C.length, $) === C;
  }
  function Q(I, C) {
    if (C = Math.floor(C), I.length == 0 || C == 0) return "";
    var $ = I.length * C;
    for (C = Math.floor(Math.log(C) / Math.log(2)); C; )
      I += I, C--;
    return I += I.substring(0, $ - I.length), I;
  }
  var re = "", ve = "", te = "", R = "", M = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, h = 10;
  function S(I) {
    var C = Object.keys(I), $ = Object.create(Object.getPrototypeOf(I));
    return C.forEach(function(w) {
      $[w] = I[w];
    }), Object.defineProperty($, "message", {
      value: I.message
    }), $;
  }
  function B(I) {
    return j(I, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function T(I, C, $) {
    var w = "", U = "", ie = 0, le = "", ee = !1, F = B(I), z = F.split(`
`), se = B(C).split(`
`), he = 0, ae = "";
    if ($ === "strictEqual" && q(I) === "object" && q(C) === "object" && I !== null && C !== null && ($ = "strictEqualObject"), z.length === 1 && se.length === 1 && z[0] !== se[0]) {
      var X = z[0].length + se[0].length;
      if (X <= h) {
        if ((q(I) !== "object" || I === null) && (q(C) !== "object" || C === null) && (I !== 0 || C !== 0))
          return "".concat(M[$], `

`) + "".concat(z[0], " !== ").concat(se[0], `
`);
      } else if ($ !== "strictEqualObject") {
        var be = process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80;
        if (X < be) {
          for (; z[0][he] === se[0][he]; )
            he++;
          he > 2 && (ae = `
  `.concat(Q(" ", he), "^"), he = 0);
        }
      }
    }
    for (var Re = z[z.length - 1], Pe = se[se.length - 1]; Re === Pe && (he++ < 2 ? le = `
  `.concat(Re).concat(le) : w = Re, z.pop(), se.pop(), !(z.length === 0 || se.length === 0)); )
      Re = z[z.length - 1], Pe = se[se.length - 1];
    var Fe = Math.max(z.length, se.length);
    if (Fe === 0) {
      var De = F.split(`
`);
      if (De.length > 30)
        for (De[26] = "".concat(re, "...").concat(R); De.length > 27; )
          De.pop();
      return "".concat(M.notIdentical, `

`).concat(De.join(`
`), `
`);
    }
    he > 3 && (le = `
`.concat(re, "...").concat(R).concat(le), ee = !0), w !== "" && (le = `
  `.concat(w).concat(le), w = "");
    var je = 0, Oe = M[$] + `
`.concat(ve, "+ actual").concat(R, " ").concat(te, "- expected").concat(R), rt = " ".concat(re, "...").concat(R, " Lines skipped");
    for (he = 0; he < Fe; he++) {
      var He = he - ie;
      if (z.length < he + 1)
        He > 1 && he > 2 && (He > 4 ? (U += `
`.concat(re, "...").concat(R), ee = !0) : He > 3 && (U += `
  `.concat(se[he - 2]), je++), U += `
  `.concat(se[he - 1]), je++), ie = he, w += `
`.concat(te, "-").concat(R, " ").concat(se[he]), je++;
      else if (se.length < he + 1)
        He > 1 && he > 2 && (He > 4 ? (U += `
`.concat(re, "...").concat(R), ee = !0) : He > 3 && (U += `
  `.concat(z[he - 2]), je++), U += `
  `.concat(z[he - 1]), je++), ie = he, U += `
`.concat(ve, "+").concat(R, " ").concat(z[he]), je++;
      else {
        var Qe = se[he], Je = z[he], we = Je !== Qe && (!V(Je, ",") || Je.slice(0, -1) !== Qe);
        we && V(Qe, ",") && Qe.slice(0, -1) === Je && (we = !1, Je += ","), we ? (He > 1 && he > 2 && (He > 4 ? (U += `
`.concat(re, "...").concat(R), ee = !0) : He > 3 && (U += `
  `.concat(z[he - 2]), je++), U += `
  `.concat(z[he - 1]), je++), ie = he, U += `
`.concat(ve, "+").concat(R, " ").concat(Je), w += `
`.concat(te, "-").concat(R, " ").concat(Qe), je += 2) : (U += w, w = "", (He === 1 || he === 0) && (U += `
  `.concat(Je), je++));
      }
      if (je > 20 && he < Fe - 2)
        return "".concat(Oe).concat(rt, `
`).concat(U, `
`).concat(re, "...").concat(R).concat(w, `
`) + "".concat(re, "...").concat(R);
    }
    return "".concat(Oe).concat(ee ? rt : "", `
`).concat(U).concat(w).concat(le).concat(ae);
  }
  var k = /* @__PURE__ */ (function(I, C) {
    f(w, I);
    var $ = l(w);
    function w(U) {
      var ie;
      if (a(this, w), q(U) !== "object" || U === null)
        throw new G("options", "Object", U);
      var le = U.message, ee = U.operator, F = U.stackStartFn, z = U.actual, se = U.expected, he = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, le != null)
        ie = $.call(this, String(le));
      else if (process$1.stderr && process$1.stderr.isTTY && (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1 ? (re = "\x1B[34m", ve = "\x1B[32m", R = "\x1B[39m", te = "\x1B[31m") : (re = "", ve = "", R = "", te = "")), q(z) === "object" && z !== null && q(se) === "object" && se !== null && "stack" in z && z instanceof Error && "stack" in se && se instanceof Error && (z = S(z), se = S(se)), ee === "deepStrictEqual" || ee === "strictEqual")
        ie = $.call(this, T(z, se, ee));
      else if (ee === "notDeepStrictEqual" || ee === "notStrictEqual") {
        var ae = M[ee], X = B(z).split(`
`);
        if (ee === "notStrictEqual" && q(z) === "object" && z !== null && (ae = M.notStrictEqualObject), X.length > 30)
          for (X[26] = "".concat(re, "...").concat(R); X.length > 27; )
            X.pop();
        X.length === 1 ? ie = $.call(this, "".concat(ae, " ").concat(X[0])) : ie = $.call(this, "".concat(ae, `

`).concat(X.join(`
`), `
`));
      } else {
        var be = B(z), Re = "", Pe = M[ee];
        ee === "notDeepEqual" || ee === "notEqual" ? (be = "".concat(M[ee], `

`).concat(be), be.length > 1024 && (be = "".concat(be.slice(0, 1021), "..."))) : (Re = "".concat(B(se)), be.length > 512 && (be = "".concat(be.slice(0, 509), "...")), Re.length > 512 && (Re = "".concat(Re.slice(0, 509), "...")), ee === "deepEqual" || ee === "equal" ? be = "".concat(Pe, `

`).concat(be, `

should equal

`) : Re = " ".concat(ee, " ").concat(Re)), ie = $.call(this, "".concat(be).concat(Re));
      }
      return Error.stackTraceLimit = he, ie.generatedMessage = !le, Object.defineProperty(p(ie), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), ie.code = "ERR_ASSERTION", ie.actual = z, ie.expected = se, ie.operator = ee, Error.captureStackTrace && Error.captureStackTrace(p(ie), F), ie.stack, ie.name = "AssertionError", s(ie);
    }
    return n(w, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: C,
      value: function(ie, le) {
        return j(this, t(t({}, le), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), w;
  })(/* @__PURE__ */ m(Error), j.custom);
  return assertion_error = k, assertion_error;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var e = Object.prototype.toString;
  return isArguments = function(r) {
    var a = e.call(r), u = a === "[object Arguments]";
    return u || (u = a !== "[object Array]" && r !== null && typeof r == "object" && typeof r.length == "number" && r.length >= 0 && e.call(r.callee) === "[object Function]"), u;
  }, isArguments;
}
var implementation$3, hasRequiredImplementation$3;
function requireImplementation$3() {
  if (hasRequiredImplementation$3) return implementation$3;
  hasRequiredImplementation$3 = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, r = Object.prototype.toString, a = requireIsArguments(), u = Object.prototype.propertyIsEnumerable, n = !u.call({ toString: null }, "toString"), o = u.call(function() {
    }, "prototype"), c = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], f = function(m) {
      var g = m.constructor;
      return g && g.prototype === m;
    }, l = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, s = (function() {
      if (typeof globalThis > "u")
        return !1;
      for (var m in globalThis)
        try {
          if (!l["$" + m] && t.call(globalThis, m) && globalThis[m] !== null && typeof globalThis[m] == "object")
            try {
              f(globalThis[m]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    })(), p = function(m) {
      if (typeof globalThis > "u" || !s)
        return f(m);
      try {
        return f(m);
      } catch {
        return !1;
      }
    };
    e = function(g) {
      var y = g !== null && typeof g == "object", v = r.call(g) === "[object Function]", E = a(g), b = y && r.call(g) === "[object String]", q = [];
      if (!y && !v && !E)
        throw new TypeError("Object.keys called on a non-object");
      var O = o && v;
      if (b && g.length > 0 && !t.call(g, 0))
        for (var j = 0; j < g.length; ++j)
          q.push(String(j));
      if (E && g.length > 0)
        for (var D = 0; D < g.length; ++D)
          q.push(String(D));
      else
        for (var G in g)
          !(O && G === "prototype") && t.call(g, G) && q.push(String(G));
      if (n)
        for (var V = p(g), Q = 0; Q < c.length; ++Q)
          !(V && c[Q] === "constructor") && t.call(g, c[Q]) && q.push(c[Q]);
      return q;
    };
  }
  return implementation$3 = e, implementation$3;
}
var objectKeys, hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var e = Array.prototype.slice, t = requireIsArguments(), r = Object.keys, a = r ? function(o) {
    return r(o);
  } : requireImplementation$3(), u = Object.keys;
  return a.shim = function() {
    if (Object.keys) {
      var o = (function() {
        var c = Object.keys(arguments);
        return c && c.length === arguments.length;
      })(1, 2);
      o || (Object.keys = function(f) {
        return t(f) ? u(e.call(f)) : u(f);
      });
    } else
      Object.keys = a;
    return Object.keys || a;
  }, objectKeys = a, objectKeys;
}
var implementation$2, hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2) return implementation$2;
  hasRequiredImplementation$2 = 1;
  var e = requireObjectKeys(), t = requireShams$1()(), r = /* @__PURE__ */ requireCallBound$1(), a = /* @__PURE__ */ requireEsObjectAtoms(), u = r("Array.prototype.push"), n = r("Object.prototype.propertyIsEnumerable"), o = t ? a.getOwnPropertySymbols : null;
  return implementation$2 = function(f, l) {
    if (f == null)
      throw new TypeError("target must be an object");
    var s = a(f);
    if (arguments.length === 1)
      return s;
    for (var p = 1; p < arguments.length; ++p) {
      var m = a(arguments[p]), g = e(m), y = t && (a.getOwnPropertySymbols || o);
      if (y)
        for (var v = y(m), E = 0; E < v.length; ++E) {
          var b = v[E];
          n(m, b) && u(g, b);
        }
      for (var q = 0; q < g.length; ++q) {
        var O = g[q];
        if (n(m, O)) {
          var j = m[O];
          s[O] = j;
        }
      }
    }
    return s;
  }, implementation$2;
}
var polyfill$2, hasRequiredPolyfill$2;
function requirePolyfill$2() {
  if (hasRequiredPolyfill$2) return polyfill$2;
  hasRequiredPolyfill$2 = 1;
  var e = requireImplementation$2(), t = function() {
    if (!Object.assign)
      return !1;
    for (var a = "abcdefghijklmnopqrst", u = a.split(""), n = {}, o = 0; o < u.length; ++o)
      n[u[o]] = u[o];
    var c = Object.assign({}, n), f = "";
    for (var l in c)
      f += l;
    return a !== f;
  }, r = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var a = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(a, "xy");
    } catch {
      return a[1] === "y";
    }
    return !1;
  };
  return polyfill$2 = function() {
    return !Object.assign || t() || r() ? e : Object.assign;
  }, polyfill$2;
}
var implementation$1, hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var e = function(t) {
    return t !== t;
  };
  return implementation$1 = function(r, a) {
    return r === 0 && a === 0 ? 1 / r === 1 / a : !!(r === a || e(r) && e(a));
  }, implementation$1;
}
var polyfill$1, hasRequiredPolyfill$1;
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1) return polyfill$1;
  hasRequiredPolyfill$1 = 1;
  var e = requireImplementation$1();
  return polyfill$1 = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, polyfill$1;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var e = /* @__PURE__ */ requireGetIntrinsic(), t = requireCallBind(), r = t(e("String.prototype.indexOf"));
  return callBound = function(u, n) {
    var o = e(u, !!n);
    return typeof o == "function" && r(u, ".prototype.") > -1 ? t(o) : o;
  }, callBound;
}
var defineProperties_1, hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var e = requireObjectKeys(), t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", r = Object.prototype.toString, a = Array.prototype.concat, u = /* @__PURE__ */ requireDefineDataProperty(), n = function(l) {
    return typeof l == "function" && r.call(l) === "[object Function]";
  }, o = /* @__PURE__ */ requireHasPropertyDescriptors()(), c = function(l, s, p, m) {
    if (s in l) {
      if (m === !0) {
        if (l[s] === p)
          return;
      } else if (!n(m) || !m())
        return;
    }
    o ? u(l, s, p, !0) : u(l, s, p);
  }, f = function(l, s) {
    var p = arguments.length > 2 ? arguments[2] : {}, m = e(s);
    t && (m = a.call(m, Object.getOwnPropertySymbols(s)));
    for (var g = 0; g < m.length; g += 1)
      c(l, m[g], s[m[g]], p[m[g]]);
  };
  return f.supportsDescriptors = !!o, defineProperties_1 = f, defineProperties_1;
}
var shim$1, hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1) return shim$1;
  hasRequiredShim$1 = 1;
  var e = requirePolyfill$1(), t = requireDefineProperties();
  return shim$1 = function() {
    var a = e();
    return t(Object, { is: a }, {
      is: function() {
        return Object.is !== a;
      }
    }), a;
  }, shim$1;
}
var objectIs, hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs) return objectIs;
  hasRequiredObjectIs = 1;
  var e = requireDefineProperties(), t = requireCallBind(), r = requireImplementation$1(), a = requirePolyfill$1(), u = requireShim$1(), n = t(a(), Object);
  return e(n, {
    getPolyfill: a,
    implementation: r,
    shim: u
  }), objectIs = n, objectIs;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  return hasRequiredImplementation || (hasRequiredImplementation = 1, implementation = function(t) {
    return t !== t;
  }), implementation;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var e = requireImplementation();
  return polyfill = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, polyfill;
}
var shim, hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim;
  hasRequiredShim = 1;
  var e = requireDefineProperties(), t = requirePolyfill();
  return shim = function() {
    var a = t();
    return e(Number, { isNaN: a }, {
      isNaN: function() {
        return Number.isNaN !== a;
      }
    }), a;
  }, shim;
}
var isNan, hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan) return isNan;
  hasRequiredIsNan = 1;
  var e = requireCallBind(), t = requireDefineProperties(), r = requireImplementation(), a = requirePolyfill(), u = requireShim(), n = e(a(), Number);
  return t(n, {
    getPolyfill: a,
    implementation: r,
    shim: u
  }), isNan = n, isNan;
}
var comparisons, hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons) return comparisons;
  hasRequiredComparisons = 1;
  function e(we, Ae) {
    return n(we) || u(we, Ae) || r(we, Ae) || t();
  }
  function t() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(we, Ae) {
    if (we) {
      if (typeof we == "string") return a(we, Ae);
      var ze = Object.prototype.toString.call(we).slice(8, -1);
      if (ze === "Object" && we.constructor && (ze = we.constructor.name), ze === "Map" || ze === "Set") return Array.from(we);
      if (ze === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ze)) return a(we, Ae);
    }
  }
  function a(we, Ae) {
    (Ae == null || Ae > we.length) && (Ae = we.length);
    for (var ze = 0, Ue = new Array(Ae); ze < Ae; ze++) Ue[ze] = we[ze];
    return Ue;
  }
  function u(we, Ae) {
    var ze = we == null ? null : typeof Symbol < "u" && we[Symbol.iterator] || we["@@iterator"];
    if (ze != null) {
      var Ue, Ge, Xe, oe, L = [], H = !0, ue = !1;
      try {
        if (Xe = (ze = ze.call(we)).next, Ae !== 0) for (; !(H = (Ue = Xe.call(ze)).done) && (L.push(Ue.value), L.length !== Ae); H = !0) ;
      } catch (xe) {
        ue = !0, Ge = xe;
      } finally {
        try {
          if (!H && ze.return != null && (oe = ze.return(), Object(oe) !== oe)) return;
        } finally {
          if (ue) throw Ge;
        }
      }
      return L;
    }
  }
  function n(we) {
    if (Array.isArray(we)) return we;
  }
  function o(we) {
    "@babel/helpers - typeof";
    return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ae) {
      return typeof Ae;
    } : function(Ae) {
      return Ae && typeof Symbol == "function" && Ae.constructor === Symbol && Ae !== Symbol.prototype ? "symbol" : typeof Ae;
    }, o(we);
  }
  var c = /a/g.flags !== void 0, f = function(Ae) {
    var ze = [];
    return Ae.forEach(function(Ue) {
      return ze.push(Ue);
    }), ze;
  }, l = function(Ae) {
    var ze = [];
    return Ae.forEach(function(Ue, Ge) {
      return ze.push([Ge, Ue]);
    }), ze;
  }, s = Object.is ? Object.is : requireObjectIs(), p = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, m = Number.isNaN ? Number.isNaN : requireIsNan();
  function g(we) {
    return we.call.bind(we);
  }
  var y = g(Object.prototype.hasOwnProperty), v = g(Object.prototype.propertyIsEnumerable), E = g(Object.prototype.toString), b = requireUtil().types, q = b.isAnyArrayBuffer, O = b.isArrayBufferView, j = b.isDate, D = b.isMap, G = b.isRegExp, V = b.isSet, Q = b.isNativeError, re = b.isBoxedPrimitive, ve = b.isNumberObject, te = b.isStringObject, R = b.isBooleanObject, M = b.isBigIntObject, h = b.isSymbolObject, S = b.isFloat32Array, B = b.isFloat64Array;
  function T(we) {
    if (we.length === 0 || we.length > 10) return !0;
    for (var Ae = 0; Ae < we.length; Ae++) {
      var ze = we.charCodeAt(Ae);
      if (ze < 48 || ze > 57) return !0;
    }
    return we.length === 10 && we >= Math.pow(2, 32);
  }
  function k(we) {
    return Object.keys(we).filter(T).concat(p(we).filter(Object.prototype.propertyIsEnumerable.bind(we)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function I(we, Ae) {
    if (we === Ae)
      return 0;
    for (var ze = we.length, Ue = Ae.length, Ge = 0, Xe = Math.min(ze, Ue); Ge < Xe; ++Ge)
      if (we[Ge] !== Ae[Ge]) {
        ze = we[Ge], Ue = Ae[Ge];
        break;
      }
    return ze < Ue ? -1 : Ue < ze ? 1 : 0;
  }
  var C = !0, $ = !1, w = 0, U = 1, ie = 2, le = 3;
  function ee(we, Ae) {
    return c ? we.source === Ae.source && we.flags === Ae.flags : RegExp.prototype.toString.call(we) === RegExp.prototype.toString.call(Ae);
  }
  function F(we, Ae) {
    if (we.byteLength !== Ae.byteLength)
      return !1;
    for (var ze = 0; ze < we.byteLength; ze++)
      if (we[ze] !== Ae[ze])
        return !1;
    return !0;
  }
  function z(we, Ae) {
    return we.byteLength !== Ae.byteLength ? !1 : I(new Uint8Array(we.buffer, we.byteOffset, we.byteLength), new Uint8Array(Ae.buffer, Ae.byteOffset, Ae.byteLength)) === 0;
  }
  function se(we, Ae) {
    return we.byteLength === Ae.byteLength && I(new Uint8Array(we), new Uint8Array(Ae)) === 0;
  }
  function he(we, Ae) {
    return ve(we) ? ve(Ae) && s(Number.prototype.valueOf.call(we), Number.prototype.valueOf.call(Ae)) : te(we) ? te(Ae) && String.prototype.valueOf.call(we) === String.prototype.valueOf.call(Ae) : R(we) ? R(Ae) && Boolean.prototype.valueOf.call(we) === Boolean.prototype.valueOf.call(Ae) : M(we) ? M(Ae) && BigInt.prototype.valueOf.call(we) === BigInt.prototype.valueOf.call(Ae) : h(Ae) && Symbol.prototype.valueOf.call(we) === Symbol.prototype.valueOf.call(Ae);
  }
  function ae(we, Ae, ze, Ue) {
    if (we === Ae)
      return we !== 0 ? !0 : ze ? s(we, Ae) : !0;
    if (ze) {
      if (o(we) !== "object")
        return typeof we == "number" && m(we) && m(Ae);
      if (o(Ae) !== "object" || we === null || Ae === null || Object.getPrototypeOf(we) !== Object.getPrototypeOf(Ae))
        return !1;
    } else {
      if (we === null || o(we) !== "object")
        return Ae === null || o(Ae) !== "object" ? we == Ae : !1;
      if (Ae === null || o(Ae) !== "object")
        return !1;
    }
    var Ge = E(we), Xe = E(Ae);
    if (Ge !== Xe)
      return !1;
    if (Array.isArray(we)) {
      if (we.length !== Ae.length)
        return !1;
      var oe = k(we), L = k(Ae);
      return oe.length !== L.length ? !1 : be(we, Ae, ze, Ue, U, oe);
    }
    if (Ge === "[object Object]" && (!D(we) && D(Ae) || !V(we) && V(Ae)))
      return !1;
    if (j(we)) {
      if (!j(Ae) || Date.prototype.getTime.call(we) !== Date.prototype.getTime.call(Ae))
        return !1;
    } else if (G(we)) {
      if (!G(Ae) || !ee(we, Ae))
        return !1;
    } else if (Q(we) || we instanceof Error) {
      if (we.message !== Ae.message || we.name !== Ae.name)
        return !1;
    } else if (O(we)) {
      if (!ze && (S(we) || B(we))) {
        if (!F(we, Ae))
          return !1;
      } else if (!z(we, Ae))
        return !1;
      var H = k(we), ue = k(Ae);
      return H.length !== ue.length ? !1 : be(we, Ae, ze, Ue, w, H);
    } else {
      if (V(we))
        return !V(Ae) || we.size !== Ae.size ? !1 : be(we, Ae, ze, Ue, ie);
      if (D(we))
        return !D(Ae) || we.size !== Ae.size ? !1 : be(we, Ae, ze, Ue, le);
      if (q(we)) {
        if (!se(we, Ae))
          return !1;
      } else if (re(we) && !he(we, Ae))
        return !1;
    }
    return be(we, Ae, ze, Ue, w);
  }
  function X(we, Ae) {
    return Ae.filter(function(ze) {
      return v(we, ze);
    });
  }
  function be(we, Ae, ze, Ue, Ge, Xe) {
    if (arguments.length === 5) {
      Xe = Object.keys(we);
      var oe = Object.keys(Ae);
      if (Xe.length !== oe.length)
        return !1;
    }
    for (var L = 0; L < Xe.length; L++)
      if (!y(Ae, Xe[L]))
        return !1;
    if (ze && arguments.length === 5) {
      var H = p(we);
      if (H.length !== 0) {
        var ue = 0;
        for (L = 0; L < H.length; L++) {
          var xe = H[L];
          if (v(we, xe)) {
            if (!v(Ae, xe))
              return !1;
            Xe.push(xe), ue++;
          } else if (v(Ae, xe))
            return !1;
        }
        var pe = p(Ae);
        if (H.length !== pe.length && X(Ae, pe).length !== ue)
          return !1;
      } else {
        var ce = p(Ae);
        if (ce.length !== 0 && X(Ae, ce).length !== 0)
          return !1;
      }
    }
    if (Xe.length === 0 && (Ge === w || Ge === U && we.length === 0 || we.size === 0))
      return !0;
    if (Ue === void 0)
      Ue = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Y = Ue.val1.get(we);
      if (Y !== void 0) {
        var Te = Ue.val2.get(Ae);
        if (Te !== void 0)
          return Y === Te;
      }
      Ue.position++;
    }
    Ue.val1.set(we, Ue.position), Ue.val2.set(Ae, Ue.position);
    var Ne = He(we, Ae, ze, Xe, Ue, Ge);
    return Ue.val1.delete(we), Ue.val2.delete(Ae), Ne;
  }
  function Re(we, Ae, ze, Ue) {
    for (var Ge = f(we), Xe = 0; Xe < Ge.length; Xe++) {
      var oe = Ge[Xe];
      if (ae(Ae, oe, ze, Ue))
        return we.delete(oe), !0;
    }
    return !1;
  }
  function Pe(we) {
    switch (o(we)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        we = +we;
      // Loose equal entries exist only if the string is possible to convert to
      // a regular number and not NaN.
      // Fall through
      case "number":
        if (m(we))
          return !1;
    }
    return !0;
  }
  function Fe(we, Ae, ze) {
    var Ue = Pe(ze);
    return Ue ?? (Ae.has(Ue) && !we.has(Ue));
  }
  function De(we, Ae, ze, Ue, Ge) {
    var Xe = Pe(ze);
    if (Xe != null)
      return Xe;
    var oe = Ae.get(Xe);
    return oe === void 0 && !Ae.has(Xe) || !ae(Ue, oe, !1, Ge) ? !1 : !we.has(Xe) && ae(Ue, oe, !1, Ge);
  }
  function je(we, Ae, ze, Ue) {
    for (var Ge = null, Xe = f(we), oe = 0; oe < Xe.length; oe++) {
      var L = Xe[oe];
      if (o(L) === "object" && L !== null)
        Ge === null && (Ge = /* @__PURE__ */ new Set()), Ge.add(L);
      else if (!Ae.has(L)) {
        if (ze || !Fe(we, Ae, L))
          return !1;
        Ge === null && (Ge = /* @__PURE__ */ new Set()), Ge.add(L);
      }
    }
    if (Ge !== null) {
      for (var H = f(Ae), ue = 0; ue < H.length; ue++) {
        var xe = H[ue];
        if (o(xe) === "object" && xe !== null) {
          if (!Re(Ge, xe, ze, Ue)) return !1;
        } else if (!ze && !we.has(xe) && !Re(Ge, xe, ze, Ue))
          return !1;
      }
      return Ge.size === 0;
    }
    return !0;
  }
  function Oe(we, Ae, ze, Ue, Ge, Xe) {
    for (var oe = f(we), L = 0; L < oe.length; L++) {
      var H = oe[L];
      if (ae(ze, H, Ge, Xe) && ae(Ue, Ae.get(H), Ge, Xe))
        return we.delete(H), !0;
    }
    return !1;
  }
  function rt(we, Ae, ze, Ue) {
    for (var Ge = null, Xe = l(we), oe = 0; oe < Xe.length; oe++) {
      var L = e(Xe[oe], 2), H = L[0], ue = L[1];
      if (o(H) === "object" && H !== null)
        Ge === null && (Ge = /* @__PURE__ */ new Set()), Ge.add(H);
      else {
        var xe = Ae.get(H);
        if (xe === void 0 && !Ae.has(H) || !ae(ue, xe, ze, Ue)) {
          if (ze || !De(we, Ae, H, ue, Ue)) return !1;
          Ge === null && (Ge = /* @__PURE__ */ new Set()), Ge.add(H);
        }
      }
    }
    if (Ge !== null) {
      for (var pe = l(Ae), ce = 0; ce < pe.length; ce++) {
        var Y = e(pe[ce], 2), Te = Y[0], Ne = Y[1];
        if (o(Te) === "object" && Te !== null) {
          if (!Oe(Ge, we, Te, Ne, ze, Ue)) return !1;
        } else if (!ze && (!we.has(Te) || !ae(we.get(Te), Ne, !1, Ue)) && !Oe(Ge, we, Te, Ne, !1, Ue))
          return !1;
      }
      return Ge.size === 0;
    }
    return !0;
  }
  function He(we, Ae, ze, Ue, Ge, Xe) {
    var oe = 0;
    if (Xe === ie) {
      if (!je(we, Ae, ze, Ge))
        return !1;
    } else if (Xe === le) {
      if (!rt(we, Ae, ze, Ge))
        return !1;
    } else if (Xe === U)
      for (; oe < we.length; oe++)
        if (y(we, oe)) {
          if (!y(Ae, oe) || !ae(we[oe], Ae[oe], ze, Ge))
            return !1;
        } else {
          if (y(Ae, oe))
            return !1;
          for (var L = Object.keys(we); oe < L.length; oe++) {
            var H = L[oe];
            if (!y(Ae, H) || !ae(we[H], Ae[H], ze, Ge))
              return !1;
          }
          return L.length === Object.keys(Ae).length;
        }
    for (oe = 0; oe < Ue.length; oe++) {
      var ue = Ue[oe];
      if (!ae(we[ue], Ae[ue], ze, Ge))
        return !1;
    }
    return !0;
  }
  function Qe(we, Ae) {
    return ae(we, Ae, $);
  }
  function Je(we, Ae) {
    return ae(we, Ae, C);
  }
  return comparisons = {
    isDeepEqual: Qe,
    isDeepStrictEqual: Je
  }, comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert.exports;
  hasRequiredAssert = 1;
  function e(ie) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(le) {
      return typeof le;
    } : function(le) {
      return le && typeof Symbol == "function" && le.constructor === Symbol && le !== Symbol.prototype ? "symbol" : typeof le;
    }, e(ie);
  }
  function t(ie, le, ee) {
    return Object.defineProperty(ie, "prototype", { writable: !1 }), ie;
  }
  function r(ie, le) {
    if (!(ie instanceof le))
      throw new TypeError("Cannot call a class as a function");
  }
  var a = requireErrors(), u = a.codes, n = u.ERR_AMBIGUOUS_ARGUMENT, o = u.ERR_INVALID_ARG_TYPE, c = u.ERR_INVALID_ARG_VALUE, f = u.ERR_INVALID_RETURN_VALUE, l = u.ERR_MISSING_ARGS, s = requireAssertion_error(), p = requireUtil(), m = p.inspect, g = requireUtil().types, y = g.isPromise, v = g.isRegExp, E = requirePolyfill$2()(), b = requirePolyfill$1()(), q = requireCallBound()("RegExp.prototype.test"), O, j;
  function D() {
    var ie = requireComparisons();
    O = ie.isDeepEqual, j = ie.isDeepStrictEqual;
  }
  var G = !1, V = assert.exports = R, Q = {};
  function re(ie) {
    throw ie.message instanceof Error ? ie.message : new s(ie);
  }
  function ve(ie, le, ee, F, z) {
    var se = arguments.length, he;
    if (se === 0)
      he = "Failed";
    else if (se === 1)
      ee = ie, ie = void 0;
    else {
      if (G === !1) {
        G = !0;
        var ae = process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console);
        ae("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      se === 2 && (F = "!=");
    }
    if (ee instanceof Error) throw ee;
    var X = {
      actual: ie,
      expected: le,
      operator: F === void 0 ? "fail" : F,
      stackStartFn: z || ve
    };
    ee !== void 0 && (X.message = ee);
    var be = new s(X);
    throw he && (be.message = he, be.generatedMessage = !0), be;
  }
  V.fail = ve, V.AssertionError = s;
  function te(ie, le, ee, F) {
    if (!ee) {
      var z = !1;
      if (le === 0)
        z = !0, F = "No value argument passed to `assert.ok()`";
      else if (F instanceof Error)
        throw F;
      var se = new s({
        actual: ee,
        expected: !0,
        message: F,
        operator: "==",
        stackStartFn: ie
      });
      throw se.generatedMessage = z, se;
    }
  }
  function R() {
    for (var ie = arguments.length, le = new Array(ie), ee = 0; ee < ie; ee++)
      le[ee] = arguments[ee];
    te.apply(void 0, [R, le.length].concat(le));
  }
  V.ok = R, V.equal = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    le != ee && re({
      actual: le,
      expected: ee,
      message: F,
      operator: "==",
      stackStartFn: ie
    });
  }, V.notEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    le == ee && re({
      actual: le,
      expected: ee,
      message: F,
      operator: "!=",
      stackStartFn: ie
    });
  }, V.deepEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    O === void 0 && D(), O(le, ee) || re({
      actual: le,
      expected: ee,
      message: F,
      operator: "deepEqual",
      stackStartFn: ie
    });
  }, V.notDeepEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    O === void 0 && D(), O(le, ee) && re({
      actual: le,
      expected: ee,
      message: F,
      operator: "notDeepEqual",
      stackStartFn: ie
    });
  }, V.deepStrictEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    O === void 0 && D(), j(le, ee) || re({
      actual: le,
      expected: ee,
      message: F,
      operator: "deepStrictEqual",
      stackStartFn: ie
    });
  }, V.notDeepStrictEqual = M;
  function M(ie, le, ee) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    O === void 0 && D(), j(ie, le) && re({
      actual: ie,
      expected: le,
      message: ee,
      operator: "notDeepStrictEqual",
      stackStartFn: M
    });
  }
  V.strictEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    b(le, ee) || re({
      actual: le,
      expected: ee,
      message: F,
      operator: "strictEqual",
      stackStartFn: ie
    });
  }, V.notStrictEqual = function ie(le, ee, F) {
    if (arguments.length < 2)
      throw new l("actual", "expected");
    b(le, ee) && re({
      actual: le,
      expected: ee,
      message: F,
      operator: "notStrictEqual",
      stackStartFn: ie
    });
  };
  var h = /* @__PURE__ */ t(function ie(le, ee, F) {
    var z = this;
    r(this, ie), ee.forEach(function(se) {
      se in le && (F !== void 0 && typeof F[se] == "string" && v(le[se]) && q(le[se], F[se]) ? z[se] = F[se] : z[se] = le[se]);
    });
  });
  function S(ie, le, ee, F, z, se) {
    if (!(ee in ie) || !j(ie[ee], le[ee])) {
      if (!F) {
        var he = new h(ie, z), ae = new h(le, z, ie), X = new s({
          actual: he,
          expected: ae,
          operator: "deepStrictEqual",
          stackStartFn: se
        });
        throw X.actual = ie, X.expected = le, X.operator = se.name, X;
      }
      re({
        actual: ie,
        expected: le,
        message: F,
        operator: se.name,
        stackStartFn: se
      });
    }
  }
  function B(ie, le, ee, F) {
    if (typeof le != "function") {
      if (v(le)) return q(le, ie);
      if (arguments.length === 2)
        throw new o("expected", ["Function", "RegExp"], le);
      if (e(ie) !== "object" || ie === null) {
        var z = new s({
          actual: ie,
          expected: le,
          message: ee,
          operator: "deepStrictEqual",
          stackStartFn: F
        });
        throw z.operator = F.name, z;
      }
      var se = Object.keys(le);
      if (le instanceof Error)
        se.push("name", "message");
      else if (se.length === 0)
        throw new c("error", le, "may not be an empty object");
      return O === void 0 && D(), se.forEach(function(he) {
        typeof ie[he] == "string" && v(le[he]) && q(le[he], ie[he]) || S(ie, le, he, ee, se, F);
      }), !0;
    }
    return le.prototype !== void 0 && ie instanceof le ? !0 : Error.isPrototypeOf(le) ? !1 : le.call({}, ie) === !0;
  }
  function T(ie) {
    if (typeof ie != "function")
      throw new o("fn", "Function", ie);
    try {
      ie();
    } catch (le) {
      return le;
    }
    return Q;
  }
  function k(ie) {
    return y(ie) || ie !== null && e(ie) === "object" && typeof ie.then == "function" && typeof ie.catch == "function";
  }
  function I(ie) {
    return Promise.resolve().then(function() {
      var le;
      if (typeof ie == "function") {
        if (le = ie(), !k(le))
          throw new f("instance of Promise", "promiseFn", le);
      } else if (k(ie))
        le = ie;
      else
        throw new o("promiseFn", ["Function", "Promise"], ie);
      return Promise.resolve().then(function() {
        return le;
      }).then(function() {
        return Q;
      }).catch(function(ee) {
        return ee;
      });
    });
  }
  function C(ie, le, ee, F) {
    if (typeof ee == "string") {
      if (arguments.length === 4)
        throw new o("error", ["Object", "Error", "Function", "RegExp"], ee);
      if (e(le) === "object" && le !== null) {
        if (le.message === ee)
          throw new n("error/message", 'The error message "'.concat(le.message, '" is identical to the message.'));
      } else if (le === ee)
        throw new n("error/message", 'The error "'.concat(le, '" is identical to the message.'));
      F = ee, ee = void 0;
    } else if (ee != null && e(ee) !== "object" && typeof ee != "function")
      throw new o("error", ["Object", "Error", "Function", "RegExp"], ee);
    if (le === Q) {
      var z = "";
      ee && ee.name && (z += " (".concat(ee.name, ")")), z += F ? ": ".concat(F) : ".";
      var se = ie.name === "rejects" ? "rejection" : "exception";
      re({
        actual: void 0,
        expected: ee,
        operator: ie.name,
        message: "Missing expected ".concat(se).concat(z),
        stackStartFn: ie
      });
    }
    if (ee && !B(le, ee, F, ie))
      throw le;
  }
  function $(ie, le, ee, F) {
    if (le !== Q) {
      if (typeof ee == "string" && (F = ee, ee = void 0), !ee || B(le, ee)) {
        var z = F ? ": ".concat(F) : ".", se = ie.name === "doesNotReject" ? "rejection" : "exception";
        re({
          actual: le,
          expected: ee,
          operator: ie.name,
          message: "Got unwanted ".concat(se).concat(z, `
`) + 'Actual message: "'.concat(le && le.message, '"'),
          stackStartFn: ie
        });
      }
      throw le;
    }
  }
  V.throws = function ie(le) {
    for (var ee = arguments.length, F = new Array(ee > 1 ? ee - 1 : 0), z = 1; z < ee; z++)
      F[z - 1] = arguments[z];
    C.apply(void 0, [ie, T(le)].concat(F));
  }, V.rejects = function ie(le) {
    for (var ee = arguments.length, F = new Array(ee > 1 ? ee - 1 : 0), z = 1; z < ee; z++)
      F[z - 1] = arguments[z];
    return I(le).then(function(se) {
      return C.apply(void 0, [ie, se].concat(F));
    });
  }, V.doesNotThrow = function ie(le) {
    for (var ee = arguments.length, F = new Array(ee > 1 ? ee - 1 : 0), z = 1; z < ee; z++)
      F[z - 1] = arguments[z];
    $.apply(void 0, [ie, T(le)].concat(F));
  }, V.doesNotReject = function ie(le) {
    for (var ee = arguments.length, F = new Array(ee > 1 ? ee - 1 : 0), z = 1; z < ee; z++)
      F[z - 1] = arguments[z];
    return I(le).then(function(se) {
      return $.apply(void 0, [ie, se].concat(F));
    });
  }, V.ifError = function ie(le) {
    if (le != null) {
      var ee = "ifError got unwanted exception: ";
      e(le) === "object" && typeof le.message == "string" ? le.message.length === 0 && le.constructor ? ee += le.constructor.name : ee += le.message : ee += m(le);
      var F = new s({
        actual: le,
        expected: null,
        operator: "ifError",
        message: ee,
        stackStartFn: ie
      }), z = le.stack;
      if (typeof z == "string") {
        var se = z.split(`
`);
        se.shift();
        for (var he = F.stack.split(`
`), ae = 0; ae < se.length; ae++) {
          var X = he.indexOf(se[ae]);
          if (X !== -1) {
            he = he.slice(0, X);
            break;
          }
        }
        F.stack = "".concat(he.join(`
`), `
`).concat(se.join(`
`));
      }
      throw F;
    }
  };
  function w(ie, le, ee, F, z) {
    if (!v(le))
      throw new o("regexp", "RegExp", le);
    var se = z === "match";
    if (typeof ie != "string" || q(le, ie) !== se) {
      if (ee instanceof Error)
        throw ee;
      var he = !ee;
      ee = ee || (typeof ie != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(ie), " (").concat(m(ie), ")") : (se ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(m(le), `. Input:

`).concat(m(ie), `
`));
      var ae = new s({
        actual: ie,
        expected: le,
        message: ee,
        operator: z,
        stackStartFn: F
      });
      throw ae.generatedMessage = he, ae;
    }
  }
  V.match = function ie(le, ee, F) {
    w(le, ee, F, ie, "match");
  }, V.doesNotMatch = function ie(le, ee, F) {
    w(le, ee, F, ie, "doesNotMatch");
  };
  function U() {
    for (var ie = arguments.length, le = new Array(ie), ee = 0; ee < ie; ee++)
      le[ee] = arguments[ee];
    te.apply(void 0, [U, le.length].concat(le));
  }
  return V.strict = E(U, V, {
    equal: V.strictEqual,
    deepEqual: V.deepStrictEqual,
    notEqual: V.notStrictEqual,
    notDeepEqual: V.notDeepStrictEqual
  }), V.strict.strict = V.strict, assert.exports;
}
var contentDisposition = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition) return contentDisposition.exports;
  hasRequiredContentDisposition = 1, contentDisposition.exports = g, contentDisposition.exports.parse = q;
  var e = requirePathBrowserify().basename, t = requireSafeBuffer$4().Buffer, r = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g, a = /%[0-9A-Fa-f]{2}/, u = /%([0-9A-Fa-f]{2})/g, n = /[^\x20-\x7e\xa0-\xff]/g, o = /\\([\u0000-\u007f])/g, c = /([\\"])/g, f = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g, l = /^[\x20-\x7e\x80-\xff]+$/, s = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/, p = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/, m = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function g(Q, re) {
    var ve = re || {}, te = ve.type || "attachment", R = y(Q, ve.fallback);
    return v(new V(te, R));
  }
  function y(Q, re) {
    if (Q !== void 0) {
      var ve = {};
      if (typeof Q != "string")
        throw new TypeError("filename must be a string");
      if (re === void 0 && (re = !0), typeof re != "string" && typeof re != "boolean")
        throw new TypeError("fallback must be a string or boolean");
      if (typeof re == "string" && n.test(re))
        throw new TypeError("fallback must be ISO-8859-1 string");
      var te = e(Q), R = l.test(te), M = typeof re != "string" ? re && b(te) : e(re), h = typeof M == "string" && M !== te;
      return (h || !R || a.test(te)) && (ve["filename*"] = te), (R || h) && (ve.filename = h ? M : te), ve;
    }
  }
  function v(Q) {
    var re = Q.parameters, ve = Q.type;
    if (!ve || typeof ve != "string" || !s.test(ve))
      throw new TypeError("invalid type");
    var te = String(ve).toLowerCase();
    if (re && typeof re == "object")
      for (var R, M = Object.keys(re).sort(), h = 0; h < M.length; h++) {
        R = M[h];
        var S = R.substr(-1) === "*" ? G(re[R]) : D(re[R]);
        te += "; " + R + "=" + S;
      }
    return te;
  }
  function E(Q) {
    var re = p.exec(Q);
    if (!re)
      throw new TypeError("invalid extended field value");
    var ve = re[1].toLowerCase(), te = re[2], R, M = te.replace(u, O);
    switch (ve) {
      case "iso-8859-1":
        R = b(M);
        break;
      case "utf-8":
        R = t.from(M, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return R;
  }
  function b(Q) {
    return String(Q).replace(n, "?");
  }
  function q(Q) {
    if (!Q || typeof Q != "string")
      throw new TypeError("argument string is required");
    var re = m.exec(Q);
    if (!re)
      throw new TypeError("invalid type format");
    var ve = re[0].length, te = re[1].toLowerCase(), R, M = [], h = {}, S;
    for (ve = f.lastIndex = re[0].substr(-1) === ";" ? ve - 1 : ve; re = f.exec(Q); ) {
      if (re.index !== ve)
        throw new TypeError("invalid parameter format");
      if (ve += re[0].length, R = re[1].toLowerCase(), S = re[2], M.indexOf(R) !== -1)
        throw new TypeError("invalid duplicate parameter");
      if (M.push(R), R.indexOf("*") + 1 === R.length) {
        R = R.slice(0, -1), S = E(S), h[R] = S;
        continue;
      }
      typeof h[R] != "string" && (S[0] === '"' && (S = S.substr(1, S.length - 2).replace(o, "$1")), h[R] = S);
    }
    if (ve !== -1 && ve !== Q.length)
      throw new TypeError("invalid parameter format");
    return new V(te, h);
  }
  function O(Q, re) {
    return String.fromCharCode(parseInt(re, 16));
  }
  function j(Q) {
    return "%" + String(Q).charCodeAt(0).toString(16).toUpperCase();
  }
  function D(Q) {
    var re = String(Q);
    return '"' + re.replace(c, "\\$1") + '"';
  }
  function G(Q) {
    var re = String(Q), ve = encodeURIComponent(re).replace(r, j);
    return "UTF-8''" + ve;
  }
  function V(Q, re) {
    this.type = Q, this.parameters = re;
  }
  return contentDisposition.exports;
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var escapeHtml_1, hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var e = /["'&<>]/;
  escapeHtml_1 = t;
  function t(r) {
    var a = "" + r, u = e.exec(a);
    if (!u)
      return a;
    var n, o = "", c = 0, f = 0;
    for (c = u.index; c < a.length; c++) {
      switch (a.charCodeAt(c)) {
        case 34:
          n = "&quot;";
          break;
        case 38:
          n = "&amp;";
          break;
        case 39:
          n = "&#39;";
          break;
        case 60:
          n = "&lt;";
          break;
        case 62:
          n = "&gt;";
          break;
        default:
          continue;
      }
      f !== c && (o += a.substring(f, c)), f = c + 1, o += n;
    }
    return f !== c ? o + a.substring(f, c) : o;
  }
  return escapeHtml_1;
}
var lib$1 = {}, binding = {}, zstream, hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return zstream = e, zstream;
}
var deflate = {}, common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  return hasRequiredCommon$1 || (hasRequiredCommon$1 = 1, (function(e) {
    var t = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function r(n, o) {
      return Object.prototype.hasOwnProperty.call(n, o);
    }
    e.assign = function(n) {
      for (var o = Array.prototype.slice.call(arguments, 1); o.length; ) {
        var c = o.shift();
        if (c) {
          if (typeof c != "object")
            throw new TypeError(c + "must be non-object");
          for (var f in c)
            r(c, f) && (n[f] = c[f]);
        }
      }
      return n;
    }, e.shrinkBuf = function(n, o) {
      return n.length === o ? n : n.subarray ? n.subarray(0, o) : (n.length = o, n);
    };
    var a = {
      arraySet: function(n, o, c, f, l) {
        if (o.subarray && n.subarray) {
          n.set(o.subarray(c, c + f), l);
          return;
        }
        for (var s = 0; s < f; s++)
          n[l + s] = o[c + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        var o, c, f, l, s, p;
        for (f = 0, o = 0, c = n.length; o < c; o++)
          f += n[o].length;
        for (p = new Uint8Array(f), l = 0, o = 0, c = n.length; o < c; o++)
          s = n[o], p.set(s, l), l += s.length;
        return p;
      }
    }, u = {
      arraySet: function(n, o, c, f, l) {
        for (var s = 0; s < f; s++)
          n[l + s] = o[c + s];
      },
      // Join array of chunks to single array.
      flattenChunks: function(n) {
        return [].concat.apply([], n);
      }
    };
    e.setTyped = function(n) {
      n ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, a)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, u));
    }, e.setTyped(t);
  })(common$1)), common$1;
}
var trees = {}, hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var e = requireCommon$1(), t = 4, r = 0, a = 1, u = 2;
  function n(L) {
    for (var H = L.length; --H >= 0; )
      L[H] = 0;
  }
  var o = 0, c = 1, f = 2, l = 3, s = 258, p = 29, m = 256, g = m + 1 + p, y = 30, v = 19, E = 2 * g + 1, b = 15, q = 16, O = 7, j = 256, D = 16, G = 17, V = 18, Q = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), re = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), ve = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), te = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], R = 512, M = new Array((g + 2) * 2);
  n(M);
  var h = new Array(y * 2);
  n(h);
  var S = new Array(R);
  n(S);
  var B = new Array(s - l + 1);
  n(B);
  var T = new Array(p);
  n(T);
  var k = new Array(y);
  n(k);
  function I(L, H, ue, xe, pe) {
    this.static_tree = L, this.extra_bits = H, this.extra_base = ue, this.elems = xe, this.max_length = pe, this.has_stree = L && L.length;
  }
  var C, $, w;
  function U(L, H) {
    this.dyn_tree = L, this.max_code = 0, this.stat_desc = H;
  }
  function ie(L) {
    return L < 256 ? S[L] : S[256 + (L >>> 7)];
  }
  function le(L, H) {
    L.pending_buf[L.pending++] = H & 255, L.pending_buf[L.pending++] = H >>> 8 & 255;
  }
  function ee(L, H, ue) {
    L.bi_valid > q - ue ? (L.bi_buf |= H << L.bi_valid & 65535, le(L, L.bi_buf), L.bi_buf = H >> q - L.bi_valid, L.bi_valid += ue - q) : (L.bi_buf |= H << L.bi_valid & 65535, L.bi_valid += ue);
  }
  function F(L, H, ue) {
    ee(
      L,
      ue[H * 2],
      ue[H * 2 + 1]
      /*.Len*/
    );
  }
  function z(L, H) {
    var ue = 0;
    do
      ue |= L & 1, L >>>= 1, ue <<= 1;
    while (--H > 0);
    return ue >>> 1;
  }
  function se(L) {
    L.bi_valid === 16 ? (le(L, L.bi_buf), L.bi_buf = 0, L.bi_valid = 0) : L.bi_valid >= 8 && (L.pending_buf[L.pending++] = L.bi_buf & 255, L.bi_buf >>= 8, L.bi_valid -= 8);
  }
  function he(L, H) {
    var ue = H.dyn_tree, xe = H.max_code, pe = H.stat_desc.static_tree, ce = H.stat_desc.has_stree, Y = H.stat_desc.extra_bits, Te = H.stat_desc.extra_base, Ne = H.stat_desc.max_length, K, Se, Ce, de, _e, Me, tt = 0;
    for (de = 0; de <= b; de++)
      L.bl_count[de] = 0;
    for (ue[L.heap[L.heap_max] * 2 + 1] = 0, K = L.heap_max + 1; K < E; K++)
      Se = L.heap[K], de = ue[ue[Se * 2 + 1] * 2 + 1] + 1, de > Ne && (de = Ne, tt++), ue[Se * 2 + 1] = de, !(Se > xe) && (L.bl_count[de]++, _e = 0, Se >= Te && (_e = Y[Se - Te]), Me = ue[Se * 2], L.opt_len += Me * (de + _e), ce && (L.static_len += Me * (pe[Se * 2 + 1] + _e)));
    if (tt !== 0) {
      do {
        for (de = Ne - 1; L.bl_count[de] === 0; )
          de--;
        L.bl_count[de]--, L.bl_count[de + 1] += 2, L.bl_count[Ne]--, tt -= 2;
      } while (tt > 0);
      for (de = Ne; de !== 0; de--)
        for (Se = L.bl_count[de]; Se !== 0; )
          Ce = L.heap[--K], !(Ce > xe) && (ue[Ce * 2 + 1] !== de && (L.opt_len += (de - ue[Ce * 2 + 1]) * ue[Ce * 2], ue[Ce * 2 + 1] = de), Se--);
    }
  }
  function ae(L, H, ue) {
    var xe = new Array(b + 1), pe = 0, ce, Y;
    for (ce = 1; ce <= b; ce++)
      xe[ce] = pe = pe + ue[ce - 1] << 1;
    for (Y = 0; Y <= H; Y++) {
      var Te = L[Y * 2 + 1];
      Te !== 0 && (L[Y * 2] = z(xe[Te]++, Te));
    }
  }
  function X() {
    var L, H, ue, xe, pe, ce = new Array(b + 1);
    for (ue = 0, xe = 0; xe < p - 1; xe++)
      for (T[xe] = ue, L = 0; L < 1 << Q[xe]; L++)
        B[ue++] = xe;
    for (B[ue - 1] = xe, pe = 0, xe = 0; xe < 16; xe++)
      for (k[xe] = pe, L = 0; L < 1 << re[xe]; L++)
        S[pe++] = xe;
    for (pe >>= 7; xe < y; xe++)
      for (k[xe] = pe << 7, L = 0; L < 1 << re[xe] - 7; L++)
        S[256 + pe++] = xe;
    for (H = 0; H <= b; H++)
      ce[H] = 0;
    for (L = 0; L <= 143; )
      M[L * 2 + 1] = 8, L++, ce[8]++;
    for (; L <= 255; )
      M[L * 2 + 1] = 9, L++, ce[9]++;
    for (; L <= 279; )
      M[L * 2 + 1] = 7, L++, ce[7]++;
    for (; L <= 287; )
      M[L * 2 + 1] = 8, L++, ce[8]++;
    for (ae(M, g + 1, ce), L = 0; L < y; L++)
      h[L * 2 + 1] = 5, h[L * 2] = z(L, 5);
    C = new I(M, Q, m + 1, g, b), $ = new I(h, re, 0, y, b), w = new I(new Array(0), ve, 0, v, O);
  }
  function be(L) {
    var H;
    for (H = 0; H < g; H++)
      L.dyn_ltree[H * 2] = 0;
    for (H = 0; H < y; H++)
      L.dyn_dtree[H * 2] = 0;
    for (H = 0; H < v; H++)
      L.bl_tree[H * 2] = 0;
    L.dyn_ltree[j * 2] = 1, L.opt_len = L.static_len = 0, L.last_lit = L.matches = 0;
  }
  function Re(L) {
    L.bi_valid > 8 ? le(L, L.bi_buf) : L.bi_valid > 0 && (L.pending_buf[L.pending++] = L.bi_buf), L.bi_buf = 0, L.bi_valid = 0;
  }
  function Pe(L, H, ue, xe) {
    Re(L), le(L, ue), le(L, ~ue), e.arraySet(L.pending_buf, L.window, H, ue, L.pending), L.pending += ue;
  }
  function Fe(L, H, ue, xe) {
    var pe = H * 2, ce = ue * 2;
    return L[pe] < L[ce] || L[pe] === L[ce] && xe[H] <= xe[ue];
  }
  function De(L, H, ue) {
    for (var xe = L.heap[ue], pe = ue << 1; pe <= L.heap_len && (pe < L.heap_len && Fe(H, L.heap[pe + 1], L.heap[pe], L.depth) && pe++, !Fe(H, xe, L.heap[pe], L.depth)); )
      L.heap[ue] = L.heap[pe], ue = pe, pe <<= 1;
    L.heap[ue] = xe;
  }
  function je(L, H, ue) {
    var xe, pe, ce = 0, Y, Te;
    if (L.last_lit !== 0)
      do
        xe = L.pending_buf[L.d_buf + ce * 2] << 8 | L.pending_buf[L.d_buf + ce * 2 + 1], pe = L.pending_buf[L.l_buf + ce], ce++, xe === 0 ? F(L, pe, H) : (Y = B[pe], F(L, Y + m + 1, H), Te = Q[Y], Te !== 0 && (pe -= T[Y], ee(L, pe, Te)), xe--, Y = ie(xe), F(L, Y, ue), Te = re[Y], Te !== 0 && (xe -= k[Y], ee(L, xe, Te)));
      while (ce < L.last_lit);
    F(L, j, H);
  }
  function Oe(L, H) {
    var ue = H.dyn_tree, xe = H.stat_desc.static_tree, pe = H.stat_desc.has_stree, ce = H.stat_desc.elems, Y, Te, Ne = -1, K;
    for (L.heap_len = 0, L.heap_max = E, Y = 0; Y < ce; Y++)
      ue[Y * 2] !== 0 ? (L.heap[++L.heap_len] = Ne = Y, L.depth[Y] = 0) : ue[Y * 2 + 1] = 0;
    for (; L.heap_len < 2; )
      K = L.heap[++L.heap_len] = Ne < 2 ? ++Ne : 0, ue[K * 2] = 1, L.depth[K] = 0, L.opt_len--, pe && (L.static_len -= xe[K * 2 + 1]);
    for (H.max_code = Ne, Y = L.heap_len >> 1; Y >= 1; Y--)
      De(L, ue, Y);
    K = ce;
    do
      Y = L.heap[
        1
        /*SMALLEST*/
      ], L.heap[
        1
        /*SMALLEST*/
      ] = L.heap[L.heap_len--], De(
        L,
        ue,
        1
        /*SMALLEST*/
      ), Te = L.heap[
        1
        /*SMALLEST*/
      ], L.heap[--L.heap_max] = Y, L.heap[--L.heap_max] = Te, ue[K * 2] = ue[Y * 2] + ue[Te * 2], L.depth[K] = (L.depth[Y] >= L.depth[Te] ? L.depth[Y] : L.depth[Te]) + 1, ue[Y * 2 + 1] = ue[Te * 2 + 1] = K, L.heap[
        1
        /*SMALLEST*/
      ] = K++, De(
        L,
        ue,
        1
        /*SMALLEST*/
      );
    while (L.heap_len >= 2);
    L.heap[--L.heap_max] = L.heap[
      1
      /*SMALLEST*/
    ], he(L, H), ae(ue, Ne, L.bl_count);
  }
  function rt(L, H, ue) {
    var xe, pe = -1, ce, Y = H[1], Te = 0, Ne = 7, K = 4;
    for (Y === 0 && (Ne = 138, K = 3), H[(ue + 1) * 2 + 1] = 65535, xe = 0; xe <= ue; xe++)
      ce = Y, Y = H[(xe + 1) * 2 + 1], !(++Te < Ne && ce === Y) && (Te < K ? L.bl_tree[ce * 2] += Te : ce !== 0 ? (ce !== pe && L.bl_tree[ce * 2]++, L.bl_tree[D * 2]++) : Te <= 10 ? L.bl_tree[G * 2]++ : L.bl_tree[V * 2]++, Te = 0, pe = ce, Y === 0 ? (Ne = 138, K = 3) : ce === Y ? (Ne = 6, K = 3) : (Ne = 7, K = 4));
  }
  function He(L, H, ue) {
    var xe, pe = -1, ce, Y = H[1], Te = 0, Ne = 7, K = 4;
    for (Y === 0 && (Ne = 138, K = 3), xe = 0; xe <= ue; xe++)
      if (ce = Y, Y = H[(xe + 1) * 2 + 1], !(++Te < Ne && ce === Y)) {
        if (Te < K)
          do
            F(L, ce, L.bl_tree);
          while (--Te !== 0);
        else ce !== 0 ? (ce !== pe && (F(L, ce, L.bl_tree), Te--), F(L, D, L.bl_tree), ee(L, Te - 3, 2)) : Te <= 10 ? (F(L, G, L.bl_tree), ee(L, Te - 3, 3)) : (F(L, V, L.bl_tree), ee(L, Te - 11, 7));
        Te = 0, pe = ce, Y === 0 ? (Ne = 138, K = 3) : ce === Y ? (Ne = 6, K = 3) : (Ne = 7, K = 4);
      }
  }
  function Qe(L) {
    var H;
    for (rt(L, L.dyn_ltree, L.l_desc.max_code), rt(L, L.dyn_dtree, L.d_desc.max_code), Oe(L, L.bl_desc), H = v - 1; H >= 3 && L.bl_tree[te[H] * 2 + 1] === 0; H--)
      ;
    return L.opt_len += 3 * (H + 1) + 5 + 5 + 4, H;
  }
  function Je(L, H, ue, xe) {
    var pe;
    for (ee(L, H - 257, 5), ee(L, ue - 1, 5), ee(L, xe - 4, 4), pe = 0; pe < xe; pe++)
      ee(L, L.bl_tree[te[pe] * 2 + 1], 3);
    He(L, L.dyn_ltree, H - 1), He(L, L.dyn_dtree, ue - 1);
  }
  function we(L) {
    var H = 4093624447, ue;
    for (ue = 0; ue <= 31; ue++, H >>>= 1)
      if (H & 1 && L.dyn_ltree[ue * 2] !== 0)
        return r;
    if (L.dyn_ltree[18] !== 0 || L.dyn_ltree[20] !== 0 || L.dyn_ltree[26] !== 0)
      return a;
    for (ue = 32; ue < m; ue++)
      if (L.dyn_ltree[ue * 2] !== 0)
        return a;
    return r;
  }
  var Ae = !1;
  function ze(L) {
    Ae || (X(), Ae = !0), L.l_desc = new U(L.dyn_ltree, C), L.d_desc = new U(L.dyn_dtree, $), L.bl_desc = new U(L.bl_tree, w), L.bi_buf = 0, L.bi_valid = 0, be(L);
  }
  function Ue(L, H, ue, xe) {
    ee(L, (o << 1) + (xe ? 1 : 0), 3), Pe(L, H, ue);
  }
  function Ge(L) {
    ee(L, c << 1, 3), F(L, j, M), se(L);
  }
  function Xe(L, H, ue, xe) {
    var pe, ce, Y = 0;
    L.level > 0 ? (L.strm.data_type === u && (L.strm.data_type = we(L)), Oe(L, L.l_desc), Oe(L, L.d_desc), Y = Qe(L), pe = L.opt_len + 3 + 7 >>> 3, ce = L.static_len + 3 + 7 >>> 3, ce <= pe && (pe = ce)) : pe = ce = ue + 5, ue + 4 <= pe && H !== -1 ? Ue(L, H, ue, xe) : L.strategy === t || ce === pe ? (ee(L, (c << 1) + (xe ? 1 : 0), 3), je(L, M, h)) : (ee(L, (f << 1) + (xe ? 1 : 0), 3), Je(L, L.l_desc.max_code + 1, L.d_desc.max_code + 1, Y + 1), je(L, L.dyn_ltree, L.dyn_dtree)), be(L), xe && Re(L);
  }
  function oe(L, H, ue) {
    return L.pending_buf[L.d_buf + L.last_lit * 2] = H >>> 8 & 255, L.pending_buf[L.d_buf + L.last_lit * 2 + 1] = H & 255, L.pending_buf[L.l_buf + L.last_lit] = ue & 255, L.last_lit++, H === 0 ? L.dyn_ltree[ue * 2]++ : (L.matches++, H--, L.dyn_ltree[(B[ue] + m + 1) * 2]++, L.dyn_dtree[ie(H) * 2]++), L.last_lit === L.lit_bufsize - 1;
  }
  return trees._tr_init = ze, trees._tr_stored_block = Ue, trees._tr_flush_block = Xe, trees._tr_tally = oe, trees._tr_align = Ge, trees;
}
var adler32_1, hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function e(t, r, a, u) {
    for (var n = t & 65535 | 0, o = t >>> 16 & 65535 | 0, c = 0; a !== 0; ) {
      c = a > 2e3 ? 2e3 : a, a -= c;
      do
        n = n + r[u++] | 0, o = o + n | 0;
      while (--c);
      n %= 65521, o %= 65521;
    }
    return n | o << 16 | 0;
  }
  return adler32_1 = e, adler32_1;
}
var crc32_1, hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function e() {
    for (var a, u = [], n = 0; n < 256; n++) {
      a = n;
      for (var o = 0; o < 8; o++)
        a = a & 1 ? 3988292384 ^ a >>> 1 : a >>> 1;
      u[n] = a;
    }
    return u;
  }
  var t = e();
  function r(a, u, n, o) {
    var c = t, f = o + n;
    a ^= -1;
    for (var l = o; l < f; l++)
      a = a >>> 8 ^ c[(a ^ u[l]) & 255];
    return a ^ -1;
  }
  return crc32_1 = r, crc32_1;
}
var messages, hasRequiredMessages;
function requireMessages() {
  return hasRequiredMessages || (hasRequiredMessages = 1, messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), messages;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate;
  hasRequiredDeflate = 1;
  var e = requireCommon$1(), t = requireTrees(), r = requireAdler32(), a = requireCrc32(), u = requireMessages(), n = 0, o = 1, c = 3, f = 4, l = 5, s = 0, p = 1, m = -2, g = -3, y = -5, v = -1, E = 1, b = 2, q = 3, O = 4, j = 0, D = 2, G = 8, V = 9, Q = 15, re = 8, ve = 29, te = 256, R = te + 1 + ve, M = 30, h = 19, S = 2 * R + 1, B = 15, T = 3, k = 258, I = k + T + 1, C = 32, $ = 42, w = 69, U = 73, ie = 91, le = 103, ee = 113, F = 666, z = 1, se = 2, he = 3, ae = 4, X = 3;
  function be(K, Se) {
    return K.msg = u[Se], Se;
  }
  function Re(K) {
    return (K << 1) - (K > 4 ? 9 : 0);
  }
  function Pe(K) {
    for (var Se = K.length; --Se >= 0; )
      K[Se] = 0;
  }
  function Fe(K) {
    var Se = K.state, Ce = Se.pending;
    Ce > K.avail_out && (Ce = K.avail_out), Ce !== 0 && (e.arraySet(K.output, Se.pending_buf, Se.pending_out, Ce, K.next_out), K.next_out += Ce, Se.pending_out += Ce, K.total_out += Ce, K.avail_out -= Ce, Se.pending -= Ce, Se.pending === 0 && (Se.pending_out = 0));
  }
  function De(K, Se) {
    t._tr_flush_block(K, K.block_start >= 0 ? K.block_start : -1, K.strstart - K.block_start, Se), K.block_start = K.strstart, Fe(K.strm);
  }
  function je(K, Se) {
    K.pending_buf[K.pending++] = Se;
  }
  function Oe(K, Se) {
    K.pending_buf[K.pending++] = Se >>> 8 & 255, K.pending_buf[K.pending++] = Se & 255;
  }
  function rt(K, Se, Ce, de) {
    var _e = K.avail_in;
    return _e > de && (_e = de), _e === 0 ? 0 : (K.avail_in -= _e, e.arraySet(Se, K.input, K.next_in, _e, Ce), K.state.wrap === 1 ? K.adler = r(K.adler, Se, _e, Ce) : K.state.wrap === 2 && (K.adler = a(K.adler, Se, _e, Ce)), K.next_in += _e, K.total_in += _e, _e);
  }
  function He(K, Se) {
    var Ce = K.max_chain_length, de = K.strstart, _e, Me, tt = K.prev_length, We = K.nice_match, ne = K.strstart > K.w_size - I ? K.strstart - (K.w_size - I) : 0, W = K.window, J = K.w_mask, me = K.prev, Ee = K.strstart + k, ke = W[de + tt - 1], Ie = W[de + tt];
    K.prev_length >= K.good_match && (Ce >>= 2), We > K.lookahead && (We = K.lookahead);
    do
      if (_e = Se, !(W[_e + tt] !== Ie || W[_e + tt - 1] !== ke || W[_e] !== W[de] || W[++_e] !== W[de + 1])) {
        de += 2, _e++;
        do
          ;
        while (W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && W[++de] === W[++_e] && de < Ee);
        if (Me = k - (Ee - de), de = Ee - k, Me > tt) {
          if (K.match_start = Se, tt = Me, Me >= We)
            break;
          ke = W[de + tt - 1], Ie = W[de + tt];
        }
      }
    while ((Se = me[Se & J]) > ne && --Ce !== 0);
    return tt <= K.lookahead ? tt : K.lookahead;
  }
  function Qe(K) {
    var Se = K.w_size, Ce, de, _e, Me, tt;
    do {
      if (Me = K.window_size - K.lookahead - K.strstart, K.strstart >= Se + (Se - I)) {
        e.arraySet(K.window, K.window, Se, Se, 0), K.match_start -= Se, K.strstart -= Se, K.block_start -= Se, de = K.hash_size, Ce = de;
        do
          _e = K.head[--Ce], K.head[Ce] = _e >= Se ? _e - Se : 0;
        while (--de);
        de = Se, Ce = de;
        do
          _e = K.prev[--Ce], K.prev[Ce] = _e >= Se ? _e - Se : 0;
        while (--de);
        Me += Se;
      }
      if (K.strm.avail_in === 0)
        break;
      if (de = rt(K.strm, K.window, K.strstart + K.lookahead, Me), K.lookahead += de, K.lookahead + K.insert >= T)
        for (tt = K.strstart - K.insert, K.ins_h = K.window[tt], K.ins_h = (K.ins_h << K.hash_shift ^ K.window[tt + 1]) & K.hash_mask; K.insert && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[tt + T - 1]) & K.hash_mask, K.prev[tt & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = tt, tt++, K.insert--, !(K.lookahead + K.insert < T)); )
          ;
    } while (K.lookahead < I && K.strm.avail_in !== 0);
  }
  function Je(K, Se) {
    var Ce = 65535;
    for (Ce > K.pending_buf_size - 5 && (Ce = K.pending_buf_size - 5); ; ) {
      if (K.lookahead <= 1) {
        if (Qe(K), K.lookahead === 0 && Se === n)
          return z;
        if (K.lookahead === 0)
          break;
      }
      K.strstart += K.lookahead, K.lookahead = 0;
      var de = K.block_start + Ce;
      if ((K.strstart === 0 || K.strstart >= de) && (K.lookahead = K.strstart - de, K.strstart = de, De(K, !1), K.strm.avail_out === 0) || K.strstart - K.block_start >= K.w_size - I && (De(K, !1), K.strm.avail_out === 0))
        return z;
    }
    return K.insert = 0, Se === f ? (De(K, !0), K.strm.avail_out === 0 ? he : ae) : (K.strstart > K.block_start && (De(K, !1), K.strm.avail_out === 0), z);
  }
  function we(K, Se) {
    for (var Ce, de; ; ) {
      if (K.lookahead < I) {
        if (Qe(K), K.lookahead < I && Se === n)
          return z;
        if (K.lookahead === 0)
          break;
      }
      if (Ce = 0, K.lookahead >= T && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + T - 1]) & K.hash_mask, Ce = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart), Ce !== 0 && K.strstart - Ce <= K.w_size - I && (K.match_length = He(K, Ce)), K.match_length >= T)
        if (de = t._tr_tally(K, K.strstart - K.match_start, K.match_length - T), K.lookahead -= K.match_length, K.match_length <= K.max_lazy_match && K.lookahead >= T) {
          K.match_length--;
          do
            K.strstart++, K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + T - 1]) & K.hash_mask, Ce = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart;
          while (--K.match_length !== 0);
          K.strstart++;
        } else
          K.strstart += K.match_length, K.match_length = 0, K.ins_h = K.window[K.strstart], K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + 1]) & K.hash_mask;
      else
        de = t._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++;
      if (de && (De(K, !1), K.strm.avail_out === 0))
        return z;
    }
    return K.insert = K.strstart < T - 1 ? K.strstart : T - 1, Se === f ? (De(K, !0), K.strm.avail_out === 0 ? he : ae) : K.last_lit && (De(K, !1), K.strm.avail_out === 0) ? z : se;
  }
  function Ae(K, Se) {
    for (var Ce, de, _e; ; ) {
      if (K.lookahead < I) {
        if (Qe(K), K.lookahead < I && Se === n)
          return z;
        if (K.lookahead === 0)
          break;
      }
      if (Ce = 0, K.lookahead >= T && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + T - 1]) & K.hash_mask, Ce = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart), K.prev_length = K.match_length, K.prev_match = K.match_start, K.match_length = T - 1, Ce !== 0 && K.prev_length < K.max_lazy_match && K.strstart - Ce <= K.w_size - I && (K.match_length = He(K, Ce), K.match_length <= 5 && (K.strategy === E || K.match_length === T && K.strstart - K.match_start > 4096) && (K.match_length = T - 1)), K.prev_length >= T && K.match_length <= K.prev_length) {
        _e = K.strstart + K.lookahead - T, de = t._tr_tally(K, K.strstart - 1 - K.prev_match, K.prev_length - T), K.lookahead -= K.prev_length - 1, K.prev_length -= 2;
        do
          ++K.strstart <= _e && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + T - 1]) & K.hash_mask, Ce = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart);
        while (--K.prev_length !== 0);
        if (K.match_available = 0, K.match_length = T - 1, K.strstart++, de && (De(K, !1), K.strm.avail_out === 0))
          return z;
      } else if (K.match_available) {
        if (de = t._tr_tally(K, 0, K.window[K.strstart - 1]), de && De(K, !1), K.strstart++, K.lookahead--, K.strm.avail_out === 0)
          return z;
      } else
        K.match_available = 1, K.strstart++, K.lookahead--;
    }
    return K.match_available && (de = t._tr_tally(K, 0, K.window[K.strstart - 1]), K.match_available = 0), K.insert = K.strstart < T - 1 ? K.strstart : T - 1, Se === f ? (De(K, !0), K.strm.avail_out === 0 ? he : ae) : K.last_lit && (De(K, !1), K.strm.avail_out === 0) ? z : se;
  }
  function ze(K, Se) {
    for (var Ce, de, _e, Me, tt = K.window; ; ) {
      if (K.lookahead <= k) {
        if (Qe(K), K.lookahead <= k && Se === n)
          return z;
        if (K.lookahead === 0)
          break;
      }
      if (K.match_length = 0, K.lookahead >= T && K.strstart > 0 && (_e = K.strstart - 1, de = tt[_e], de === tt[++_e] && de === tt[++_e] && de === tt[++_e])) {
        Me = K.strstart + k;
        do
          ;
        while (de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && de === tt[++_e] && _e < Me);
        K.match_length = k - (Me - _e), K.match_length > K.lookahead && (K.match_length = K.lookahead);
      }
      if (K.match_length >= T ? (Ce = t._tr_tally(K, 1, K.match_length - T), K.lookahead -= K.match_length, K.strstart += K.match_length, K.match_length = 0) : (Ce = t._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++), Ce && (De(K, !1), K.strm.avail_out === 0))
        return z;
    }
    return K.insert = 0, Se === f ? (De(K, !0), K.strm.avail_out === 0 ? he : ae) : K.last_lit && (De(K, !1), K.strm.avail_out === 0) ? z : se;
  }
  function Ue(K, Se) {
    for (var Ce; ; ) {
      if (K.lookahead === 0 && (Qe(K), K.lookahead === 0)) {
        if (Se === n)
          return z;
        break;
      }
      if (K.match_length = 0, Ce = t._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++, Ce && (De(K, !1), K.strm.avail_out === 0))
        return z;
    }
    return K.insert = 0, Se === f ? (De(K, !0), K.strm.avail_out === 0 ? he : ae) : K.last_lit && (De(K, !1), K.strm.avail_out === 0) ? z : se;
  }
  function Ge(K, Se, Ce, de, _e) {
    this.good_length = K, this.max_lazy = Se, this.nice_length = Ce, this.max_chain = de, this.func = _e;
  }
  var Xe;
  Xe = [
    /*      good lazy nice chain */
    new Ge(0, 0, 0, 0, Je),
    /* 0 store only */
    new Ge(4, 4, 8, 4, we),
    /* 1 max speed, no lazy matches */
    new Ge(4, 5, 16, 8, we),
    /* 2 */
    new Ge(4, 6, 32, 32, we),
    /* 3 */
    new Ge(4, 4, 16, 16, Ae),
    /* 4 lazy matches */
    new Ge(8, 16, 32, 32, Ae),
    /* 5 */
    new Ge(8, 16, 128, 128, Ae),
    /* 6 */
    new Ge(8, 32, 128, 256, Ae),
    /* 7 */
    new Ge(32, 128, 258, 1024, Ae),
    /* 8 */
    new Ge(32, 258, 258, 4096, Ae)
    /* 9 max compression */
  ];
  function oe(K) {
    K.window_size = 2 * K.w_size, Pe(K.head), K.max_lazy_match = Xe[K.level].max_lazy, K.good_match = Xe[K.level].good_length, K.nice_match = Xe[K.level].nice_length, K.max_chain_length = Xe[K.level].max_chain, K.strstart = 0, K.block_start = 0, K.lookahead = 0, K.insert = 0, K.match_length = K.prev_length = T - 1, K.match_available = 0, K.ins_h = 0;
  }
  function L() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = G, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(S * 2), this.dyn_dtree = new e.Buf16((2 * M + 1) * 2), this.bl_tree = new e.Buf16((2 * h + 1) * 2), Pe(this.dyn_ltree), Pe(this.dyn_dtree), Pe(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(B + 1), this.heap = new e.Buf16(2 * R + 1), Pe(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * R + 1), Pe(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function H(K) {
    var Se;
    return !K || !K.state ? be(K, m) : (K.total_in = K.total_out = 0, K.data_type = D, Se = K.state, Se.pending = 0, Se.pending_out = 0, Se.wrap < 0 && (Se.wrap = -Se.wrap), Se.status = Se.wrap ? $ : ee, K.adler = Se.wrap === 2 ? 0 : 1, Se.last_flush = n, t._tr_init(Se), s);
  }
  function ue(K) {
    var Se = H(K);
    return Se === s && oe(K.state), Se;
  }
  function xe(K, Se) {
    return !K || !K.state || K.state.wrap !== 2 ? m : (K.state.gzhead = Se, s);
  }
  function pe(K, Se, Ce, de, _e, Me) {
    if (!K)
      return m;
    var tt = 1;
    if (Se === v && (Se = 6), de < 0 ? (tt = 0, de = -de) : de > 15 && (tt = 2, de -= 16), _e < 1 || _e > V || Ce !== G || de < 8 || de > 15 || Se < 0 || Se > 9 || Me < 0 || Me > O)
      return be(K, m);
    de === 8 && (de = 9);
    var We = new L();
    return K.state = We, We.strm = K, We.wrap = tt, We.gzhead = null, We.w_bits = de, We.w_size = 1 << We.w_bits, We.w_mask = We.w_size - 1, We.hash_bits = _e + 7, We.hash_size = 1 << We.hash_bits, We.hash_mask = We.hash_size - 1, We.hash_shift = ~~((We.hash_bits + T - 1) / T), We.window = new e.Buf8(We.w_size * 2), We.head = new e.Buf16(We.hash_size), We.prev = new e.Buf16(We.w_size), We.lit_bufsize = 1 << _e + 6, We.pending_buf_size = We.lit_bufsize * 4, We.pending_buf = new e.Buf8(We.pending_buf_size), We.d_buf = 1 * We.lit_bufsize, We.l_buf = 3 * We.lit_bufsize, We.level = Se, We.strategy = Me, We.method = Ce, ue(K);
  }
  function ce(K, Se) {
    return pe(K, Se, G, Q, re, j);
  }
  function Y(K, Se) {
    var Ce, de, _e, Me;
    if (!K || !K.state || Se > l || Se < 0)
      return K ? be(K, m) : m;
    if (de = K.state, !K.output || !K.input && K.avail_in !== 0 || de.status === F && Se !== f)
      return be(K, K.avail_out === 0 ? y : m);
    if (de.strm = K, Ce = de.last_flush, de.last_flush = Se, de.status === $)
      if (de.wrap === 2)
        K.adler = 0, je(de, 31), je(de, 139), je(de, 8), de.gzhead ? (je(
          de,
          (de.gzhead.text ? 1 : 0) + (de.gzhead.hcrc ? 2 : 0) + (de.gzhead.extra ? 4 : 0) + (de.gzhead.name ? 8 : 0) + (de.gzhead.comment ? 16 : 0)
        ), je(de, de.gzhead.time & 255), je(de, de.gzhead.time >> 8 & 255), je(de, de.gzhead.time >> 16 & 255), je(de, de.gzhead.time >> 24 & 255), je(de, de.level === 9 ? 2 : de.strategy >= b || de.level < 2 ? 4 : 0), je(de, de.gzhead.os & 255), de.gzhead.extra && de.gzhead.extra.length && (je(de, de.gzhead.extra.length & 255), je(de, de.gzhead.extra.length >> 8 & 255)), de.gzhead.hcrc && (K.adler = a(K.adler, de.pending_buf, de.pending, 0)), de.gzindex = 0, de.status = w) : (je(de, 0), je(de, 0), je(de, 0), je(de, 0), je(de, 0), je(de, de.level === 9 ? 2 : de.strategy >= b || de.level < 2 ? 4 : 0), je(de, X), de.status = ee);
      else {
        var tt = G + (de.w_bits - 8 << 4) << 8, We = -1;
        de.strategy >= b || de.level < 2 ? We = 0 : de.level < 6 ? We = 1 : de.level === 6 ? We = 2 : We = 3, tt |= We << 6, de.strstart !== 0 && (tt |= C), tt += 31 - tt % 31, de.status = ee, Oe(de, tt), de.strstart !== 0 && (Oe(de, K.adler >>> 16), Oe(de, K.adler & 65535)), K.adler = 1;
      }
    if (de.status === w)
      if (de.gzhead.extra) {
        for (_e = de.pending; de.gzindex < (de.gzhead.extra.length & 65535) && !(de.pending === de.pending_buf_size && (de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), Fe(K), _e = de.pending, de.pending === de.pending_buf_size)); )
          je(de, de.gzhead.extra[de.gzindex] & 255), de.gzindex++;
        de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), de.gzindex === de.gzhead.extra.length && (de.gzindex = 0, de.status = U);
      } else
        de.status = U;
    if (de.status === U)
      if (de.gzhead.name) {
        _e = de.pending;
        do {
          if (de.pending === de.pending_buf_size && (de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), Fe(K), _e = de.pending, de.pending === de.pending_buf_size)) {
            Me = 1;
            break;
          }
          de.gzindex < de.gzhead.name.length ? Me = de.gzhead.name.charCodeAt(de.gzindex++) & 255 : Me = 0, je(de, Me);
        } while (Me !== 0);
        de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), Me === 0 && (de.gzindex = 0, de.status = ie);
      } else
        de.status = ie;
    if (de.status === ie)
      if (de.gzhead.comment) {
        _e = de.pending;
        do {
          if (de.pending === de.pending_buf_size && (de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), Fe(K), _e = de.pending, de.pending === de.pending_buf_size)) {
            Me = 1;
            break;
          }
          de.gzindex < de.gzhead.comment.length ? Me = de.gzhead.comment.charCodeAt(de.gzindex++) & 255 : Me = 0, je(de, Me);
        } while (Me !== 0);
        de.gzhead.hcrc && de.pending > _e && (K.adler = a(K.adler, de.pending_buf, de.pending - _e, _e)), Me === 0 && (de.status = le);
      } else
        de.status = le;
    if (de.status === le && (de.gzhead.hcrc ? (de.pending + 2 > de.pending_buf_size && Fe(K), de.pending + 2 <= de.pending_buf_size && (je(de, K.adler & 255), je(de, K.adler >> 8 & 255), K.adler = 0, de.status = ee)) : de.status = ee), de.pending !== 0) {
      if (Fe(K), K.avail_out === 0)
        return de.last_flush = -1, s;
    } else if (K.avail_in === 0 && Re(Se) <= Re(Ce) && Se !== f)
      return be(K, y);
    if (de.status === F && K.avail_in !== 0)
      return be(K, y);
    if (K.avail_in !== 0 || de.lookahead !== 0 || Se !== n && de.status !== F) {
      var ne = de.strategy === b ? Ue(de, Se) : de.strategy === q ? ze(de, Se) : Xe[de.level].func(de, Se);
      if ((ne === he || ne === ae) && (de.status = F), ne === z || ne === he)
        return K.avail_out === 0 && (de.last_flush = -1), s;
      if (ne === se && (Se === o ? t._tr_align(de) : Se !== l && (t._tr_stored_block(de, 0, 0, !1), Se === c && (Pe(de.head), de.lookahead === 0 && (de.strstart = 0, de.block_start = 0, de.insert = 0))), Fe(K), K.avail_out === 0))
        return de.last_flush = -1, s;
    }
    return Se !== f ? s : de.wrap <= 0 ? p : (de.wrap === 2 ? (je(de, K.adler & 255), je(de, K.adler >> 8 & 255), je(de, K.adler >> 16 & 255), je(de, K.adler >> 24 & 255), je(de, K.total_in & 255), je(de, K.total_in >> 8 & 255), je(de, K.total_in >> 16 & 255), je(de, K.total_in >> 24 & 255)) : (Oe(de, K.adler >>> 16), Oe(de, K.adler & 65535)), Fe(K), de.wrap > 0 && (de.wrap = -de.wrap), de.pending !== 0 ? s : p);
  }
  function Te(K) {
    var Se;
    return !K || !K.state ? m : (Se = K.state.status, Se !== $ && Se !== w && Se !== U && Se !== ie && Se !== le && Se !== ee && Se !== F ? be(K, m) : (K.state = null, Se === ee ? be(K, g) : s));
  }
  function Ne(K, Se) {
    var Ce = Se.length, de, _e, Me, tt, We, ne, W, J;
    if (!K || !K.state || (de = K.state, tt = de.wrap, tt === 2 || tt === 1 && de.status !== $ || de.lookahead))
      return m;
    for (tt === 1 && (K.adler = r(K.adler, Se, Ce, 0)), de.wrap = 0, Ce >= de.w_size && (tt === 0 && (Pe(de.head), de.strstart = 0, de.block_start = 0, de.insert = 0), J = new e.Buf8(de.w_size), e.arraySet(J, Se, Ce - de.w_size, de.w_size, 0), Se = J, Ce = de.w_size), We = K.avail_in, ne = K.next_in, W = K.input, K.avail_in = Ce, K.next_in = 0, K.input = Se, Qe(de); de.lookahead >= T; ) {
      _e = de.strstart, Me = de.lookahead - (T - 1);
      do
        de.ins_h = (de.ins_h << de.hash_shift ^ de.window[_e + T - 1]) & de.hash_mask, de.prev[_e & de.w_mask] = de.head[de.ins_h], de.head[de.ins_h] = _e, _e++;
      while (--Me);
      de.strstart = _e, de.lookahead = T - 1, Qe(de);
    }
    return de.strstart += de.lookahead, de.block_start = de.strstart, de.insert = de.lookahead, de.lookahead = 0, de.match_length = de.prev_length = T - 1, de.match_available = 0, K.next_in = ne, K.input = W, K.avail_in = We, de.wrap = tt, s;
  }
  return deflate.deflateInit = ce, deflate.deflateInit2 = pe, deflate.deflateReset = ue, deflate.deflateResetKeep = H, deflate.deflateSetHeader = xe, deflate.deflate = Y, deflate.deflateEnd = Te, deflate.deflateSetDictionary = Ne, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
var inflate = {}, inffast, hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var e = 30, t = 12;
  return inffast = function(a, u) {
    var n, o, c, f, l, s, p, m, g, y, v, E, b, q, O, j, D, G, V, Q, re, ve, te, R, M;
    n = a.state, o = a.next_in, R = a.input, c = o + (a.avail_in - 5), f = a.next_out, M = a.output, l = f - (u - a.avail_out), s = f + (a.avail_out - 257), p = n.dmax, m = n.wsize, g = n.whave, y = n.wnext, v = n.window, E = n.hold, b = n.bits, q = n.lencode, O = n.distcode, j = (1 << n.lenbits) - 1, D = (1 << n.distbits) - 1;
    e:
      do {
        b < 15 && (E += R[o++] << b, b += 8, E += R[o++] << b, b += 8), G = q[E & j];
        t:
          for (; ; ) {
            if (V = G >>> 24, E >>>= V, b -= V, V = G >>> 16 & 255, V === 0)
              M[f++] = G & 65535;
            else if (V & 16) {
              Q = G & 65535, V &= 15, V && (b < V && (E += R[o++] << b, b += 8), Q += E & (1 << V) - 1, E >>>= V, b -= V), b < 15 && (E += R[o++] << b, b += 8, E += R[o++] << b, b += 8), G = O[E & D];
              r:
                for (; ; ) {
                  if (V = G >>> 24, E >>>= V, b -= V, V = G >>> 16 & 255, V & 16) {
                    if (re = G & 65535, V &= 15, b < V && (E += R[o++] << b, b += 8, b < V && (E += R[o++] << b, b += 8)), re += E & (1 << V) - 1, re > p) {
                      a.msg = "invalid distance too far back", n.mode = e;
                      break e;
                    }
                    if (E >>>= V, b -= V, V = f - l, re > V) {
                      if (V = re - V, V > g && n.sane) {
                        a.msg = "invalid distance too far back", n.mode = e;
                        break e;
                      }
                      if (ve = 0, te = v, y === 0) {
                        if (ve += m - V, V < Q) {
                          Q -= V;
                          do
                            M[f++] = v[ve++];
                          while (--V);
                          ve = f - re, te = M;
                        }
                      } else if (y < V) {
                        if (ve += m + y - V, V -= y, V < Q) {
                          Q -= V;
                          do
                            M[f++] = v[ve++];
                          while (--V);
                          if (ve = 0, y < Q) {
                            V = y, Q -= V;
                            do
                              M[f++] = v[ve++];
                            while (--V);
                            ve = f - re, te = M;
                          }
                        }
                      } else if (ve += y - V, V < Q) {
                        Q -= V;
                        do
                          M[f++] = v[ve++];
                        while (--V);
                        ve = f - re, te = M;
                      }
                      for (; Q > 2; )
                        M[f++] = te[ve++], M[f++] = te[ve++], M[f++] = te[ve++], Q -= 3;
                      Q && (M[f++] = te[ve++], Q > 1 && (M[f++] = te[ve++]));
                    } else {
                      ve = f - re;
                      do
                        M[f++] = M[ve++], M[f++] = M[ve++], M[f++] = M[ve++], Q -= 3;
                      while (Q > 2);
                      Q && (M[f++] = M[ve++], Q > 1 && (M[f++] = M[ve++]));
                    }
                  } else if ((V & 64) === 0) {
                    G = O[(G & 65535) + (E & (1 << V) - 1)];
                    continue r;
                  } else {
                    a.msg = "invalid distance code", n.mode = e;
                    break e;
                  }
                  break;
                }
            } else if ((V & 64) === 0) {
              G = q[(G & 65535) + (E & (1 << V) - 1)];
              continue t;
            } else if (V & 32) {
              n.mode = t;
              break e;
            } else {
              a.msg = "invalid literal/length code", n.mode = e;
              break e;
            }
            break;
          }
      } while (o < c && f < s);
    Q = b >> 3, o -= Q, b -= Q << 3, E &= (1 << b) - 1, a.next_in = o, a.next_out = f, a.avail_in = o < c ? 5 + (c - o) : 5 - (o - c), a.avail_out = f < s ? 257 + (s - f) : 257 - (f - s), n.hold = E, n.bits = b;
  }, inffast;
}
var inftrees, hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var e = requireCommon$1(), t = 15, r = 852, a = 592, u = 0, n = 1, o = 2, c = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], f = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], l = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], s = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return inftrees = function(m, g, y, v, E, b, q, O) {
    var j = O.bits, D = 0, G = 0, V = 0, Q = 0, re = 0, ve = 0, te = 0, R = 0, M = 0, h = 0, S, B, T, k, I, C = null, $ = 0, w, U = new e.Buf16(t + 1), ie = new e.Buf16(t + 1), le = null, ee = 0, F, z, se;
    for (D = 0; D <= t; D++)
      U[D] = 0;
    for (G = 0; G < v; G++)
      U[g[y + G]]++;
    for (re = j, Q = t; Q >= 1 && U[Q] === 0; Q--)
      ;
    if (re > Q && (re = Q), Q === 0)
      return E[b++] = 1 << 24 | 64 << 16 | 0, E[b++] = 1 << 24 | 64 << 16 | 0, O.bits = 1, 0;
    for (V = 1; V < Q && U[V] === 0; V++)
      ;
    for (re < V && (re = V), R = 1, D = 1; D <= t; D++)
      if (R <<= 1, R -= U[D], R < 0)
        return -1;
    if (R > 0 && (m === u || Q !== 1))
      return -1;
    for (ie[1] = 0, D = 1; D < t; D++)
      ie[D + 1] = ie[D] + U[D];
    for (G = 0; G < v; G++)
      g[y + G] !== 0 && (q[ie[g[y + G]]++] = G);
    if (m === u ? (C = le = q, w = 19) : m === n ? (C = c, $ -= 257, le = f, ee -= 257, w = 256) : (C = l, le = s, w = -1), h = 0, G = 0, D = V, I = b, ve = re, te = 0, T = -1, M = 1 << re, k = M - 1, m === n && M > r || m === o && M > a)
      return 1;
    for (; ; ) {
      F = D - te, q[G] < w ? (z = 0, se = q[G]) : q[G] > w ? (z = le[ee + q[G]], se = C[$ + q[G]]) : (z = 96, se = 0), S = 1 << D - te, B = 1 << ve, V = B;
      do
        B -= S, E[I + (h >> te) + B] = F << 24 | z << 16 | se | 0;
      while (B !== 0);
      for (S = 1 << D - 1; h & S; )
        S >>= 1;
      if (S !== 0 ? (h &= S - 1, h += S) : h = 0, G++, --U[D] === 0) {
        if (D === Q)
          break;
        D = g[y + q[G]];
      }
      if (D > re && (h & k) !== T) {
        for (te === 0 && (te = re), I += V, ve = D - te, R = 1 << ve; ve + te < Q && (R -= U[ve + te], !(R <= 0)); )
          ve++, R <<= 1;
        if (M += 1 << ve, m === n && M > r || m === o && M > a)
          return 1;
        T = h & k, E[T] = re << 24 | ve << 16 | I - b | 0;
      }
    }
    return h !== 0 && (E[I + h] = D - te << 24 | 64 << 16 | 0), O.bits = re, 0;
  }, inftrees;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate;
  hasRequiredInflate = 1;
  var e = requireCommon$1(), t = requireAdler32(), r = requireCrc32(), a = requireInffast(), u = requireInftrees(), n = 0, o = 1, c = 2, f = 4, l = 5, s = 6, p = 0, m = 1, g = 2, y = -2, v = -3, E = -4, b = -5, q = 8, O = 1, j = 2, D = 3, G = 4, V = 5, Q = 6, re = 7, ve = 8, te = 9, R = 10, M = 11, h = 12, S = 13, B = 14, T = 15, k = 16, I = 17, C = 18, $ = 19, w = 20, U = 21, ie = 22, le = 23, ee = 24, F = 25, z = 26, se = 27, he = 28, ae = 29, X = 30, be = 31, Re = 32, Pe = 852, Fe = 592, De = 15, je = De;
  function Oe(pe) {
    return (pe >>> 24 & 255) + (pe >>> 8 & 65280) + ((pe & 65280) << 8) + ((pe & 255) << 24);
  }
  function rt() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function He(pe) {
    var ce;
    return !pe || !pe.state ? y : (ce = pe.state, pe.total_in = pe.total_out = ce.total = 0, pe.msg = "", ce.wrap && (pe.adler = ce.wrap & 1), ce.mode = O, ce.last = 0, ce.havedict = 0, ce.dmax = 32768, ce.head = null, ce.hold = 0, ce.bits = 0, ce.lencode = ce.lendyn = new e.Buf32(Pe), ce.distcode = ce.distdyn = new e.Buf32(Fe), ce.sane = 1, ce.back = -1, p);
  }
  function Qe(pe) {
    var ce;
    return !pe || !pe.state ? y : (ce = pe.state, ce.wsize = 0, ce.whave = 0, ce.wnext = 0, He(pe));
  }
  function Je(pe, ce) {
    var Y, Te;
    return !pe || !pe.state || (Te = pe.state, ce < 0 ? (Y = 0, ce = -ce) : (Y = (ce >> 4) + 1, ce < 48 && (ce &= 15)), ce && (ce < 8 || ce > 15)) ? y : (Te.window !== null && Te.wbits !== ce && (Te.window = null), Te.wrap = Y, Te.wbits = ce, Qe(pe));
  }
  function we(pe, ce) {
    var Y, Te;
    return pe ? (Te = new rt(), pe.state = Te, Te.window = null, Y = Je(pe, ce), Y !== p && (pe.state = null), Y) : y;
  }
  function Ae(pe) {
    return we(pe, je);
  }
  var ze = !0, Ue, Ge;
  function Xe(pe) {
    if (ze) {
      var ce;
      for (Ue = new e.Buf32(512), Ge = new e.Buf32(32), ce = 0; ce < 144; )
        pe.lens[ce++] = 8;
      for (; ce < 256; )
        pe.lens[ce++] = 9;
      for (; ce < 280; )
        pe.lens[ce++] = 7;
      for (; ce < 288; )
        pe.lens[ce++] = 8;
      for (u(o, pe.lens, 0, 288, Ue, 0, pe.work, { bits: 9 }), ce = 0; ce < 32; )
        pe.lens[ce++] = 5;
      u(c, pe.lens, 0, 32, Ge, 0, pe.work, { bits: 5 }), ze = !1;
    }
    pe.lencode = Ue, pe.lenbits = 9, pe.distcode = Ge, pe.distbits = 5;
  }
  function oe(pe, ce, Y, Te) {
    var Ne, K = pe.state;
    return K.window === null && (K.wsize = 1 << K.wbits, K.wnext = 0, K.whave = 0, K.window = new e.Buf8(K.wsize)), Te >= K.wsize ? (e.arraySet(K.window, ce, Y - K.wsize, K.wsize, 0), K.wnext = 0, K.whave = K.wsize) : (Ne = K.wsize - K.wnext, Ne > Te && (Ne = Te), e.arraySet(K.window, ce, Y - Te, Ne, K.wnext), Te -= Ne, Te ? (e.arraySet(K.window, ce, Y - Te, Te, 0), K.wnext = Te, K.whave = K.wsize) : (K.wnext += Ne, K.wnext === K.wsize && (K.wnext = 0), K.whave < K.wsize && (K.whave += Ne))), 0;
  }
  function L(pe, ce) {
    var Y, Te, Ne, K, Se, Ce, de, _e, Me, tt, We, ne, W, J, me = 0, Ee, ke, Ie, at, ot, it, ct, nt, st = new e.Buf8(4), yt, ft, dt = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!pe || !pe.state || !pe.output || !pe.input && pe.avail_in !== 0)
      return y;
    Y = pe.state, Y.mode === h && (Y.mode = S), Se = pe.next_out, Ne = pe.output, de = pe.avail_out, K = pe.next_in, Te = pe.input, Ce = pe.avail_in, _e = Y.hold, Me = Y.bits, tt = Ce, We = de, nt = p;
    e:
      for (; ; )
        switch (Y.mode) {
          case O:
            if (Y.wrap === 0) {
              Y.mode = S;
              break;
            }
            for (; Me < 16; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if (Y.wrap & 2 && _e === 35615) {
              Y.check = 0, st[0] = _e & 255, st[1] = _e >>> 8 & 255, Y.check = r(Y.check, st, 2, 0), _e = 0, Me = 0, Y.mode = j;
              break;
            }
            if (Y.flags = 0, Y.head && (Y.head.done = !1), !(Y.wrap & 1) || /* check if zlib header allowed */
            (((_e & 255) << 8) + (_e >> 8)) % 31) {
              pe.msg = "incorrect header check", Y.mode = X;
              break;
            }
            if ((_e & 15) !== q) {
              pe.msg = "unknown compression method", Y.mode = X;
              break;
            }
            if (_e >>>= 4, Me -= 4, ct = (_e & 15) + 8, Y.wbits === 0)
              Y.wbits = ct;
            else if (ct > Y.wbits) {
              pe.msg = "invalid window size", Y.mode = X;
              break;
            }
            Y.dmax = 1 << ct, pe.adler = Y.check = 1, Y.mode = _e & 512 ? R : h, _e = 0, Me = 0;
            break;
          case j:
            for (; Me < 16; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if (Y.flags = _e, (Y.flags & 255) !== q) {
              pe.msg = "unknown compression method", Y.mode = X;
              break;
            }
            if (Y.flags & 57344) {
              pe.msg = "unknown header flags set", Y.mode = X;
              break;
            }
            Y.head && (Y.head.text = _e >> 8 & 1), Y.flags & 512 && (st[0] = _e & 255, st[1] = _e >>> 8 & 255, Y.check = r(Y.check, st, 2, 0)), _e = 0, Me = 0, Y.mode = D;
          /* falls through */
          case D:
            for (; Me < 32; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            Y.head && (Y.head.time = _e), Y.flags & 512 && (st[0] = _e & 255, st[1] = _e >>> 8 & 255, st[2] = _e >>> 16 & 255, st[3] = _e >>> 24 & 255, Y.check = r(Y.check, st, 4, 0)), _e = 0, Me = 0, Y.mode = G;
          /* falls through */
          case G:
            for (; Me < 16; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            Y.head && (Y.head.xflags = _e & 255, Y.head.os = _e >> 8), Y.flags & 512 && (st[0] = _e & 255, st[1] = _e >>> 8 & 255, Y.check = r(Y.check, st, 2, 0)), _e = 0, Me = 0, Y.mode = V;
          /* falls through */
          case V:
            if (Y.flags & 1024) {
              for (; Me < 16; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              Y.length = _e, Y.head && (Y.head.extra_len = _e), Y.flags & 512 && (st[0] = _e & 255, st[1] = _e >>> 8 & 255, Y.check = r(Y.check, st, 2, 0)), _e = 0, Me = 0;
            } else Y.head && (Y.head.extra = null);
            Y.mode = Q;
          /* falls through */
          case Q:
            if (Y.flags & 1024 && (ne = Y.length, ne > Ce && (ne = Ce), ne && (Y.head && (ct = Y.head.extra_len - Y.length, Y.head.extra || (Y.head.extra = new Array(Y.head.extra_len)), e.arraySet(
              Y.head.extra,
              Te,
              K,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              ne,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              ct
            )), Y.flags & 512 && (Y.check = r(Y.check, Te, ne, K)), Ce -= ne, K += ne, Y.length -= ne), Y.length))
              break e;
            Y.length = 0, Y.mode = re;
          /* falls through */
          case re:
            if (Y.flags & 2048) {
              if (Ce === 0)
                break e;
              ne = 0;
              do
                ct = Te[K + ne++], Y.head && ct && Y.length < 65536 && (Y.head.name += String.fromCharCode(ct));
              while (ct && ne < Ce);
              if (Y.flags & 512 && (Y.check = r(Y.check, Te, ne, K)), Ce -= ne, K += ne, ct)
                break e;
            } else Y.head && (Y.head.name = null);
            Y.length = 0, Y.mode = ve;
          /* falls through */
          case ve:
            if (Y.flags & 4096) {
              if (Ce === 0)
                break e;
              ne = 0;
              do
                ct = Te[K + ne++], Y.head && ct && Y.length < 65536 && (Y.head.comment += String.fromCharCode(ct));
              while (ct && ne < Ce);
              if (Y.flags & 512 && (Y.check = r(Y.check, Te, ne, K)), Ce -= ne, K += ne, ct)
                break e;
            } else Y.head && (Y.head.comment = null);
            Y.mode = te;
          /* falls through */
          case te:
            if (Y.flags & 512) {
              for (; Me < 16; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              if (_e !== (Y.check & 65535)) {
                pe.msg = "header crc mismatch", Y.mode = X;
                break;
              }
              _e = 0, Me = 0;
            }
            Y.head && (Y.head.hcrc = Y.flags >> 9 & 1, Y.head.done = !0), pe.adler = Y.check = 0, Y.mode = h;
            break;
          case R:
            for (; Me < 32; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            pe.adler = Y.check = Oe(_e), _e = 0, Me = 0, Y.mode = M;
          /* falls through */
          case M:
            if (Y.havedict === 0)
              return pe.next_out = Se, pe.avail_out = de, pe.next_in = K, pe.avail_in = Ce, Y.hold = _e, Y.bits = Me, g;
            pe.adler = Y.check = 1, Y.mode = h;
          /* falls through */
          case h:
            if (ce === l || ce === s)
              break e;
          /* falls through */
          case S:
            if (Y.last) {
              _e >>>= Me & 7, Me -= Me & 7, Y.mode = se;
              break;
            }
            for (; Me < 3; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            switch (Y.last = _e & 1, _e >>>= 1, Me -= 1, _e & 3) {
              case 0:
                Y.mode = B;
                break;
              case 1:
                if (Xe(Y), Y.mode = w, ce === s) {
                  _e >>>= 2, Me -= 2;
                  break e;
                }
                break;
              case 2:
                Y.mode = I;
                break;
              case 3:
                pe.msg = "invalid block type", Y.mode = X;
            }
            _e >>>= 2, Me -= 2;
            break;
          case B:
            for (_e >>>= Me & 7, Me -= Me & 7; Me < 32; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if ((_e & 65535) !== (_e >>> 16 ^ 65535)) {
              pe.msg = "invalid stored block lengths", Y.mode = X;
              break;
            }
            if (Y.length = _e & 65535, _e = 0, Me = 0, Y.mode = T, ce === s)
              break e;
          /* falls through */
          case T:
            Y.mode = k;
          /* falls through */
          case k:
            if (ne = Y.length, ne) {
              if (ne > Ce && (ne = Ce), ne > de && (ne = de), ne === 0)
                break e;
              e.arraySet(Ne, Te, K, ne, Se), Ce -= ne, K += ne, de -= ne, Se += ne, Y.length -= ne;
              break;
            }
            Y.mode = h;
            break;
          case I:
            for (; Me < 14; ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if (Y.nlen = (_e & 31) + 257, _e >>>= 5, Me -= 5, Y.ndist = (_e & 31) + 1, _e >>>= 5, Me -= 5, Y.ncode = (_e & 15) + 4, _e >>>= 4, Me -= 4, Y.nlen > 286 || Y.ndist > 30) {
              pe.msg = "too many length or distance symbols", Y.mode = X;
              break;
            }
            Y.have = 0, Y.mode = C;
          /* falls through */
          case C:
            for (; Y.have < Y.ncode; ) {
              for (; Me < 3; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              Y.lens[dt[Y.have++]] = _e & 7, _e >>>= 3, Me -= 3;
            }
            for (; Y.have < 19; )
              Y.lens[dt[Y.have++]] = 0;
            if (Y.lencode = Y.lendyn, Y.lenbits = 7, yt = { bits: Y.lenbits }, nt = u(n, Y.lens, 0, 19, Y.lencode, 0, Y.work, yt), Y.lenbits = yt.bits, nt) {
              pe.msg = "invalid code lengths set", Y.mode = X;
              break;
            }
            Y.have = 0, Y.mode = $;
          /* falls through */
          case $:
            for (; Y.have < Y.nlen + Y.ndist; ) {
              for (; me = Y.lencode[_e & (1 << Y.lenbits) - 1], Ee = me >>> 24, ke = me >>> 16 & 255, Ie = me & 65535, !(Ee <= Me); ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              if (Ie < 16)
                _e >>>= Ee, Me -= Ee, Y.lens[Y.have++] = Ie;
              else {
                if (Ie === 16) {
                  for (ft = Ee + 2; Me < ft; ) {
                    if (Ce === 0)
                      break e;
                    Ce--, _e += Te[K++] << Me, Me += 8;
                  }
                  if (_e >>>= Ee, Me -= Ee, Y.have === 0) {
                    pe.msg = "invalid bit length repeat", Y.mode = X;
                    break;
                  }
                  ct = Y.lens[Y.have - 1], ne = 3 + (_e & 3), _e >>>= 2, Me -= 2;
                } else if (Ie === 17) {
                  for (ft = Ee + 3; Me < ft; ) {
                    if (Ce === 0)
                      break e;
                    Ce--, _e += Te[K++] << Me, Me += 8;
                  }
                  _e >>>= Ee, Me -= Ee, ct = 0, ne = 3 + (_e & 7), _e >>>= 3, Me -= 3;
                } else {
                  for (ft = Ee + 7; Me < ft; ) {
                    if (Ce === 0)
                      break e;
                    Ce--, _e += Te[K++] << Me, Me += 8;
                  }
                  _e >>>= Ee, Me -= Ee, ct = 0, ne = 11 + (_e & 127), _e >>>= 7, Me -= 7;
                }
                if (Y.have + ne > Y.nlen + Y.ndist) {
                  pe.msg = "invalid bit length repeat", Y.mode = X;
                  break;
                }
                for (; ne--; )
                  Y.lens[Y.have++] = ct;
              }
            }
            if (Y.mode === X)
              break;
            if (Y.lens[256] === 0) {
              pe.msg = "invalid code -- missing end-of-block", Y.mode = X;
              break;
            }
            if (Y.lenbits = 9, yt = { bits: Y.lenbits }, nt = u(o, Y.lens, 0, Y.nlen, Y.lencode, 0, Y.work, yt), Y.lenbits = yt.bits, nt) {
              pe.msg = "invalid literal/lengths set", Y.mode = X;
              break;
            }
            if (Y.distbits = 6, Y.distcode = Y.distdyn, yt = { bits: Y.distbits }, nt = u(c, Y.lens, Y.nlen, Y.ndist, Y.distcode, 0, Y.work, yt), Y.distbits = yt.bits, nt) {
              pe.msg = "invalid distances set", Y.mode = X;
              break;
            }
            if (Y.mode = w, ce === s)
              break e;
          /* falls through */
          case w:
            Y.mode = U;
          /* falls through */
          case U:
            if (Ce >= 6 && de >= 258) {
              pe.next_out = Se, pe.avail_out = de, pe.next_in = K, pe.avail_in = Ce, Y.hold = _e, Y.bits = Me, a(pe, We), Se = pe.next_out, Ne = pe.output, de = pe.avail_out, K = pe.next_in, Te = pe.input, Ce = pe.avail_in, _e = Y.hold, Me = Y.bits, Y.mode === h && (Y.back = -1);
              break;
            }
            for (Y.back = 0; me = Y.lencode[_e & (1 << Y.lenbits) - 1], Ee = me >>> 24, ke = me >>> 16 & 255, Ie = me & 65535, !(Ee <= Me); ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if (ke && (ke & 240) === 0) {
              for (at = Ee, ot = ke, it = Ie; me = Y.lencode[it + ((_e & (1 << at + ot) - 1) >> at)], Ee = me >>> 24, ke = me >>> 16 & 255, Ie = me & 65535, !(at + Ee <= Me); ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              _e >>>= at, Me -= at, Y.back += at;
            }
            if (_e >>>= Ee, Me -= Ee, Y.back += Ee, Y.length = Ie, ke === 0) {
              Y.mode = z;
              break;
            }
            if (ke & 32) {
              Y.back = -1, Y.mode = h;
              break;
            }
            if (ke & 64) {
              pe.msg = "invalid literal/length code", Y.mode = X;
              break;
            }
            Y.extra = ke & 15, Y.mode = ie;
          /* falls through */
          case ie:
            if (Y.extra) {
              for (ft = Y.extra; Me < ft; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              Y.length += _e & (1 << Y.extra) - 1, _e >>>= Y.extra, Me -= Y.extra, Y.back += Y.extra;
            }
            Y.was = Y.length, Y.mode = le;
          /* falls through */
          case le:
            for (; me = Y.distcode[_e & (1 << Y.distbits) - 1], Ee = me >>> 24, ke = me >>> 16 & 255, Ie = me & 65535, !(Ee <= Me); ) {
              if (Ce === 0)
                break e;
              Ce--, _e += Te[K++] << Me, Me += 8;
            }
            if ((ke & 240) === 0) {
              for (at = Ee, ot = ke, it = Ie; me = Y.distcode[it + ((_e & (1 << at + ot) - 1) >> at)], Ee = me >>> 24, ke = me >>> 16 & 255, Ie = me & 65535, !(at + Ee <= Me); ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              _e >>>= at, Me -= at, Y.back += at;
            }
            if (_e >>>= Ee, Me -= Ee, Y.back += Ee, ke & 64) {
              pe.msg = "invalid distance code", Y.mode = X;
              break;
            }
            Y.offset = Ie, Y.extra = ke & 15, Y.mode = ee;
          /* falls through */
          case ee:
            if (Y.extra) {
              for (ft = Y.extra; Me < ft; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              Y.offset += _e & (1 << Y.extra) - 1, _e >>>= Y.extra, Me -= Y.extra, Y.back += Y.extra;
            }
            if (Y.offset > Y.dmax) {
              pe.msg = "invalid distance too far back", Y.mode = X;
              break;
            }
            Y.mode = F;
          /* falls through */
          case F:
            if (de === 0)
              break e;
            if (ne = We - de, Y.offset > ne) {
              if (ne = Y.offset - ne, ne > Y.whave && Y.sane) {
                pe.msg = "invalid distance too far back", Y.mode = X;
                break;
              }
              ne > Y.wnext ? (ne -= Y.wnext, W = Y.wsize - ne) : W = Y.wnext - ne, ne > Y.length && (ne = Y.length), J = Y.window;
            } else
              J = Ne, W = Se - Y.offset, ne = Y.length;
            ne > de && (ne = de), de -= ne, Y.length -= ne;
            do
              Ne[Se++] = J[W++];
            while (--ne);
            Y.length === 0 && (Y.mode = U);
            break;
          case z:
            if (de === 0)
              break e;
            Ne[Se++] = Y.length, de--, Y.mode = U;
            break;
          case se:
            if (Y.wrap) {
              for (; Me < 32; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e |= Te[K++] << Me, Me += 8;
              }
              if (We -= de, pe.total_out += We, Y.total += We, We && (pe.adler = Y.check = /*UPDATE(state.check, put - _out, _out);*/
              Y.flags ? r(Y.check, Ne, We, Se - We) : t(Y.check, Ne, We, Se - We)), We = de, (Y.flags ? _e : Oe(_e)) !== Y.check) {
                pe.msg = "incorrect data check", Y.mode = X;
                break;
              }
              _e = 0, Me = 0;
            }
            Y.mode = he;
          /* falls through */
          case he:
            if (Y.wrap && Y.flags) {
              for (; Me < 32; ) {
                if (Ce === 0)
                  break e;
                Ce--, _e += Te[K++] << Me, Me += 8;
              }
              if (_e !== (Y.total & 4294967295)) {
                pe.msg = "incorrect length check", Y.mode = X;
                break;
              }
              _e = 0, Me = 0;
            }
            Y.mode = ae;
          /* falls through */
          case ae:
            nt = m;
            break e;
          case X:
            nt = v;
            break e;
          case be:
            return E;
          case Re:
          /* falls through */
          default:
            return y;
        }
    return pe.next_out = Se, pe.avail_out = de, pe.next_in = K, pe.avail_in = Ce, Y.hold = _e, Y.bits = Me, (Y.wsize || We !== pe.avail_out && Y.mode < X && (Y.mode < se || ce !== f)) && oe(pe, pe.output, pe.next_out, We - pe.avail_out), tt -= pe.avail_in, We -= pe.avail_out, pe.total_in += tt, pe.total_out += We, Y.total += We, Y.wrap && We && (pe.adler = Y.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    Y.flags ? r(Y.check, Ne, We, pe.next_out - We) : t(Y.check, Ne, We, pe.next_out - We)), pe.data_type = Y.bits + (Y.last ? 64 : 0) + (Y.mode === h ? 128 : 0) + (Y.mode === w || Y.mode === T ? 256 : 0), (tt === 0 && We === 0 || ce === f) && nt === p && (nt = b), nt;
  }
  function H(pe) {
    if (!pe || !pe.state)
      return y;
    var ce = pe.state;
    return ce.window && (ce.window = null), pe.state = null, p;
  }
  function ue(pe, ce) {
    var Y;
    return !pe || !pe.state || (Y = pe.state, (Y.wrap & 2) === 0) ? y : (Y.head = ce, ce.done = !1, p);
  }
  function xe(pe, ce) {
    var Y = ce.length, Te, Ne, K;
    return !pe || !pe.state || (Te = pe.state, Te.wrap !== 0 && Te.mode !== M) ? y : Te.mode === M && (Ne = 1, Ne = t(Ne, ce, Y, 0), Ne !== Te.check) ? v : (K = oe(pe, ce, Y, Y), K ? (Te.mode = be, E) : (Te.havedict = 1, p));
  }
  return inflate.inflateReset = Qe, inflate.inflateReset2 = Je, inflate.inflateResetKeep = He, inflate.inflateInit = Ae, inflate.inflateInit2 = we, inflate.inflate = L, inflate.inflateEnd = H, inflate.inflateGetHeader = ue, inflate.inflateSetDictionary = xe, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
var constants, hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, constants = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), constants;
}
var hasRequiredBinding;
function requireBinding() {
  return hasRequiredBinding || (hasRequiredBinding = 1, (function(e) {
    var t = requireAssert(), r = requireZstream(), a = requireDeflate(), u = requireInflate(), n = requireConstants();
    for (var o in n)
      e[o] = n[o];
    e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7;
    var c = 31, f = 139;
    function l(s) {
      if (typeof s != "number" || s < e.DEFLATE || s > e.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = s, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
    }
    l.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = !0;
        return;
      }
      this.pending_close = !1, t(this.init_done, "close before init"), t(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? a.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && u.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null;
    }, l.prototype.write = function(s, p, m, g, y, v, E) {
      return this._write(!0, s, p, m, g, y, v, E);
    }, l.prototype.writeSync = function(s, p, m, g, y, v, E) {
      return this._write(!1, s, p, m, g, y, v, E);
    }, l.prototype._write = function(s, p, m, g, y, v, E, b) {
      if (t.equal(arguments.length, 8), t(this.init_done, "write before init"), t(this.mode !== e.NONE, "already finalized"), t.equal(!1, this.write_in_progress, "write already in progress"), t.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, t.equal(!1, p === void 0, "must provide flush value"), this.write_in_progress = !0, p !== e.Z_NO_FLUSH && p !== e.Z_PARTIAL_FLUSH && p !== e.Z_SYNC_FLUSH && p !== e.Z_FULL_FLUSH && p !== e.Z_FINISH && p !== e.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (m == null && (m = Buffer.alloc(0), y = 0, g = 0), this.strm.avail_in = y, this.strm.input = m, this.strm.next_in = g, this.strm.avail_out = b, this.strm.output = v, this.strm.next_out = E, this.flush = p, !s)
        return this._process(), this._checkError() ? this._afterSync() : void 0;
      var q = this;
      return process$1.nextTick(function() {
        q._process(), q._after();
      }), this;
    }, l.prototype._afterSync = function() {
      var s = this.strm.avail_out, p = this.strm.avail_in;
      return this.write_in_progress = !1, [p, s];
    }, l.prototype._process = function() {
      var s = null;
      switch (this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = a.deflate(this.strm, this.flush);
          break;
        case e.UNZIP:
          switch (this.strm.avail_in > 0 && (s = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (s === null)
                break;
              if (this.strm.input[s] === c) {
                if (this.gzip_id_bytes_read = 1, s++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = e.INFLATE;
                break;
              }
            // fallthrough
            case 1:
              if (s === null)
                break;
              this.strm.input[s] === f ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        // fallthrough
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
          for (this.err = u.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          ), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = u.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = u.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = u.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    }, l.prototype._checkError = function() {
      switch (this.err) {
        case e.Z_OK:
        case e.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === e.Z_FINISH)
            return this._error("unexpected end of file"), !1;
          break;
        case e.Z_STREAM_END:
          break;
        case e.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
          return this._error("Zlib error"), !1;
      }
      return !0;
    }, l.prototype._after = function() {
      if (this._checkError()) {
        var s = this.strm.avail_out, p = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(p, s), this.pending_close && this.close();
      }
    }, l.prototype._error = function(s) {
      this.strm.msg && (s = this.strm.msg), this.onerror(
        s,
        this.err
        // no hope of rescue.
      ), this.write_in_progress = !1, this.pending_close && this.close();
    }, l.prototype.init = function(s, p, m, g, y) {
      t(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), t(s >= 8 && s <= 15, "invalid windowBits"), t(p >= -1 && p <= 9, "invalid compression level"), t(m >= 1 && m <= 9, "invalid memlevel"), t(g === e.Z_FILTERED || g === e.Z_HUFFMAN_ONLY || g === e.Z_RLE || g === e.Z_FIXED || g === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(p, s, m, g, y), this._setDictionary();
    }, l.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    }, l.prototype.reset = function() {
      this._reset(), this._setDictionary();
    }, l.prototype._init = function(s, p, m, g, y) {
      switch (this.level = s, this.windowBits = p, this.memLevel = m, this.strategy = g, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new r(), this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = a.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
        case e.UNZIP:
          this.err = u.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== e.Z_OK && this._error("Init error"), this.dictionary = y, this.write_in_progress = !1, this.init_done = !0;
    }, l.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = e.Z_OK, this.mode) {
          case e.DEFLATE:
          case e.DEFLATERAW:
            this.err = a.deflateSetDictionary(this.strm, this.dictionary);
            break;
        }
        this.err !== e.Z_OK && this._error("Failed to set dictionary");
      }
    }, l.prototype._reset = function() {
      switch (this.err = e.Z_OK, this.mode) {
        case e.DEFLATE:
        case e.DEFLATERAW:
        case e.GZIP:
          this.err = a.deflateReset(this.strm);
          break;
        case e.INFLATE:
        case e.INFLATERAW:
        case e.GUNZIP:
          this.err = u.inflateReset(this.strm);
          break;
      }
      this.err !== e.Z_OK && this._error("Failed to reset stream");
    }, e.Zlib = l;
  })(binding)), binding;
}
var hasRequiredLib$1;
function requireLib$1() {
  return hasRequiredLib$1 || (hasRequiredLib$1 = 1, (function(e) {
    var t = requireDist$1().Buffer, r = requireStreamBrowserify().Transform, a = requireBinding(), u = requireUtil(), n = requireAssert().ok, o = requireDist$1().kMaxLength, c = "Cannot create final Buffer. It would be larger than 0x" + o.toString(16) + " bytes";
    a.Z_MIN_WINDOWBITS = 8, a.Z_MAX_WINDOWBITS = 15, a.Z_DEFAULT_WINDOWBITS = 15, a.Z_MIN_CHUNK = 64, a.Z_MAX_CHUNK = 1 / 0, a.Z_DEFAULT_CHUNK = 16 * 1024, a.Z_MIN_MEMLEVEL = 1, a.Z_MAX_MEMLEVEL = 9, a.Z_DEFAULT_MEMLEVEL = 8, a.Z_MIN_LEVEL = -1, a.Z_MAX_LEVEL = 9, a.Z_DEFAULT_LEVEL = a.Z_DEFAULT_COMPRESSION;
    for (var f = Object.keys(a), l = 0; l < f.length; l++) {
      var s = f[l];
      s.match(/^Z/) && Object.defineProperty(e, s, {
        enumerable: !0,
        value: a[s],
        writable: !1
      });
    }
    for (var p = {
      Z_OK: a.Z_OK,
      Z_STREAM_END: a.Z_STREAM_END,
      Z_NEED_DICT: a.Z_NEED_DICT,
      Z_ERRNO: a.Z_ERRNO,
      Z_STREAM_ERROR: a.Z_STREAM_ERROR,
      Z_DATA_ERROR: a.Z_DATA_ERROR,
      Z_MEM_ERROR: a.Z_MEM_ERROR,
      Z_BUF_ERROR: a.Z_BUF_ERROR,
      Z_VERSION_ERROR: a.Z_VERSION_ERROR
    }, m = Object.keys(p), g = 0; g < m.length; g++) {
      var y = m[g];
      p[p[y]] = y;
    }
    Object.defineProperty(e, "codes", {
      enumerable: !0,
      value: Object.freeze(p),
      writable: !1
    }), e.Deflate = b, e.Inflate = q, e.Gzip = O, e.Gunzip = j, e.DeflateRaw = D, e.InflateRaw = G, e.Unzip = V, e.createDeflate = function(R) {
      return new b(R);
    }, e.createInflate = function(R) {
      return new q(R);
    }, e.createDeflateRaw = function(R) {
      return new D(R);
    }, e.createInflateRaw = function(R) {
      return new G(R);
    }, e.createGzip = function(R) {
      return new O(R);
    }, e.createGunzip = function(R) {
      return new j(R);
    }, e.createUnzip = function(R) {
      return new V(R);
    }, e.deflate = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new b(M), R, h);
    }, e.deflateSync = function(R, M) {
      return E(new b(M), R);
    }, e.gzip = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new O(M), R, h);
    }, e.gzipSync = function(R, M) {
      return E(new O(M), R);
    }, e.deflateRaw = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new D(M), R, h);
    }, e.deflateRawSync = function(R, M) {
      return E(new D(M), R);
    }, e.unzip = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new V(M), R, h);
    }, e.unzipSync = function(R, M) {
      return E(new V(M), R);
    }, e.inflate = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new q(M), R, h);
    }, e.inflateSync = function(R, M) {
      return E(new q(M), R);
    }, e.gunzip = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new j(M), R, h);
    }, e.gunzipSync = function(R, M) {
      return E(new j(M), R);
    }, e.inflateRaw = function(R, M, h) {
      return typeof M == "function" && (h = M, M = {}), v(new G(M), R, h);
    }, e.inflateRawSync = function(R, M) {
      return E(new G(M), R);
    };
    function v(R, M, h) {
      var S = [], B = 0;
      R.on("error", k), R.on("end", I), R.end(M), T();
      function T() {
        for (var C; (C = R.read()) !== null; )
          S.push(C), B += C.length;
        R.once("readable", T);
      }
      function k(C) {
        R.removeListener("end", I), R.removeListener("readable", T), h(C);
      }
      function I() {
        var C, $ = null;
        B >= o ? $ = new RangeError(c) : C = t.concat(S, B), S = [], R.close(), h($, C);
      }
    }
    function E(R, M) {
      if (typeof M == "string" && (M = t.from(M)), !t.isBuffer(M)) throw new TypeError("Not a string or buffer");
      var h = R._finishFlushFlag;
      return R._processChunk(M, h);
    }
    function b(R) {
      if (!(this instanceof b)) return new b(R);
      re.call(this, R, a.DEFLATE);
    }
    function q(R) {
      if (!(this instanceof q)) return new q(R);
      re.call(this, R, a.INFLATE);
    }
    function O(R) {
      if (!(this instanceof O)) return new O(R);
      re.call(this, R, a.GZIP);
    }
    function j(R) {
      if (!(this instanceof j)) return new j(R);
      re.call(this, R, a.GUNZIP);
    }
    function D(R) {
      if (!(this instanceof D)) return new D(R);
      re.call(this, R, a.DEFLATERAW);
    }
    function G(R) {
      if (!(this instanceof G)) return new G(R);
      re.call(this, R, a.INFLATERAW);
    }
    function V(R) {
      if (!(this instanceof V)) return new V(R);
      re.call(this, R, a.UNZIP);
    }
    function Q(R) {
      return R === a.Z_NO_FLUSH || R === a.Z_PARTIAL_FLUSH || R === a.Z_SYNC_FLUSH || R === a.Z_FULL_FLUSH || R === a.Z_FINISH || R === a.Z_BLOCK;
    }
    function re(R, M) {
      var h = this;
      if (this._opts = R = R || {}, this._chunkSize = R.chunkSize || e.Z_DEFAULT_CHUNK, r.call(this, R), R.flush && !Q(R.flush))
        throw new Error("Invalid flush flag: " + R.flush);
      if (R.finishFlush && !Q(R.finishFlush))
        throw new Error("Invalid flush flag: " + R.finishFlush);
      if (this._flushFlag = R.flush || a.Z_NO_FLUSH, this._finishFlushFlag = typeof R.finishFlush < "u" ? R.finishFlush : a.Z_FINISH, R.chunkSize && (R.chunkSize < e.Z_MIN_CHUNK || R.chunkSize > e.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + R.chunkSize);
      if (R.windowBits && (R.windowBits < e.Z_MIN_WINDOWBITS || R.windowBits > e.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + R.windowBits);
      if (R.level && (R.level < e.Z_MIN_LEVEL || R.level > e.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + R.level);
      if (R.memLevel && (R.memLevel < e.Z_MIN_MEMLEVEL || R.memLevel > e.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + R.memLevel);
      if (R.strategy && R.strategy != e.Z_FILTERED && R.strategy != e.Z_HUFFMAN_ONLY && R.strategy != e.Z_RLE && R.strategy != e.Z_FIXED && R.strategy != e.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + R.strategy);
      if (R.dictionary && !t.isBuffer(R.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new a.Zlib(M);
      var S = this;
      this._hadError = !1, this._handle.onerror = function(k, I) {
        ve(S), S._hadError = !0;
        var C = new Error(k);
        C.errno = I, C.code = e.codes[I], S.emit("error", C);
      };
      var B = e.Z_DEFAULT_COMPRESSION;
      typeof R.level == "number" && (B = R.level);
      var T = e.Z_DEFAULT_STRATEGY;
      typeof R.strategy == "number" && (T = R.strategy), this._handle.init(R.windowBits || e.Z_DEFAULT_WINDOWBITS, B, R.memLevel || e.Z_DEFAULT_MEMLEVEL, T, R.dictionary), this._buffer = t.allocUnsafe(this._chunkSize), this._offset = 0, this._level = B, this._strategy = T, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function() {
          return !h._handle;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    u.inherits(re, r), re.prototype.params = function(R, M, h) {
      if (R < e.Z_MIN_LEVEL || R > e.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + R);
      if (M != e.Z_FILTERED && M != e.Z_HUFFMAN_ONLY && M != e.Z_RLE && M != e.Z_FIXED && M != e.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + M);
      if (this._level !== R || this._strategy !== M) {
        var S = this;
        this.flush(a.Z_SYNC_FLUSH, function() {
          n(S._handle, "zlib binding closed"), S._handle.params(R, M), S._hadError || (S._level = R, S._strategy = M, h && h());
        });
      } else
        process$1.nextTick(h);
    }, re.prototype.reset = function() {
      return n(this._handle, "zlib binding closed"), this._handle.reset();
    }, re.prototype._flush = function(R) {
      this._transform(t.alloc(0), "", R);
    }, re.prototype.flush = function(R, M) {
      var h = this, S = this._writableState;
      (typeof R == "function" || R === void 0 && !M) && (M = R, R = a.Z_FULL_FLUSH), S.ended ? M && process$1.nextTick(M) : S.ending ? M && this.once("end", M) : S.needDrain ? M && this.once("drain", function() {
        return h.flush(R, M);
      }) : (this._flushFlag = R, this.write(t.alloc(0), "", M));
    }, re.prototype.close = function(R) {
      ve(this, R), process$1.nextTick(te, this);
    };
    function ve(R, M) {
      M && process$1.nextTick(M), R._handle && (R._handle.close(), R._handle = null);
    }
    function te(R) {
      R.emit("close");
    }
    re.prototype._transform = function(R, M, h) {
      var S, B = this._writableState, T = B.ending || B.ended, k = T && (!R || B.length === R.length);
      if (R !== null && !t.isBuffer(R)) return h(new Error("invalid input"));
      if (!this._handle) return h(new Error("zlib binding closed"));
      k ? S = this._finishFlushFlag : (S = this._flushFlag, R.length >= B.length && (this._flushFlag = this._opts.flush || a.Z_NO_FLUSH)), this._processChunk(R, S, h);
    }, re.prototype._processChunk = function(R, M, h) {
      var S = R && R.length, B = this._chunkSize - this._offset, T = 0, k = this, I = typeof h == "function";
      if (!I) {
        var C = [], $ = 0, w;
        this.on("error", function(F) {
          w = F;
        }), n(this._handle, "zlib binding closed");
        do
          var U = this._handle.writeSync(
            M,
            R,
            // in
            T,
            // in_off
            S,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            B
          );
        while (!this._hadError && ee(U[0], U[1]));
        if (this._hadError)
          throw w;
        if ($ >= o)
          throw ve(this), new RangeError(c);
        var ie = t.concat(C, $);
        return ve(this), ie;
      }
      n(this._handle, "zlib binding closed");
      var le = this._handle.write(
        M,
        R,
        // in
        T,
        // in_off
        S,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        B
      );
      le.buffer = R, le.callback = ee;
      function ee(F, z) {
        if (this && (this.buffer = null, this.callback = null), !k._hadError) {
          var se = B - z;
          if (n(se >= 0, "have should not go down"), se > 0) {
            var he = k._buffer.slice(k._offset, k._offset + se);
            k._offset += se, I ? k.push(he) : (C.push(he), $ += he.length);
          }
          if ((z === 0 || k._offset >= k._chunkSize) && (B = k._chunkSize, k._offset = 0, k._buffer = t.allocUnsafe(k._chunkSize)), z === 0) {
            if (T += S - F, S = F, !I) return !0;
            var ae = k._handle.write(M, R, T, S, k._buffer, k._offset, k._chunkSize);
            ae.callback = ee, ae.buffer = R;
            return;
          }
          if (!I) return !1;
          h();
        }
      }
    }, u.inherits(b, re), u.inherits(q, re), u.inherits(O, re), u.inherits(j, re), u.inherits(D, re), u.inherits(G, re), u.inherits(V, re);
  })(lib$1)), lib$1;
}
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var e = requireEvents().EventEmitter, t = require$$1$2.ReadStream, r = requireStreamBrowserify(), a = requireLib$1();
  destroy_1 = u;
  function u(v, E) {
    return s(v) ? n(v) : p(v) ? c(v) : f(v) && v.destroy(), l(v) && E && (v.removeAllListeners("error"), v.addListener("error", m)), v;
  }
  function n(v) {
    v.destroy(), typeof v.close == "function" && v.on("open", y);
  }
  function o(v) {
    if (v._hadError === !0) {
      var E = v._binding === null ? "_binding" : "_handle";
      v[E] = {
        close: function() {
          this[E] = null;
        }
      };
    }
    v.close();
  }
  function c(v) {
    typeof v.destroy == "function" ? v._binding ? (v.destroy(), v._processing ? (v._needDrain = !0, v.once("drain", g)) : v._binding.clear()) : v._destroy && v._destroy !== r.Transform.prototype._destroy ? v.destroy() : v._destroy && typeof v.close == "function" ? (v.destroyed = !0, v.close()) : v.destroy() : typeof v.close == "function" && o(v);
  }
  function f(v) {
    return v instanceof r && typeof v.destroy == "function";
  }
  function l(v) {
    return v instanceof e;
  }
  function s(v) {
    return v instanceof t;
  }
  function p(v) {
    return v instanceof a.Gzip || v instanceof a.Gunzip || v instanceof a.Deflate || v instanceof a.DeflateRaw || v instanceof a.Inflate || v instanceof a.InflateRaw || v instanceof a.Unzip;
  }
  function m() {
  }
  function g() {
    this._binding.clear();
  }
  function y() {
    typeof this.fd == "number" && this.close();
  }
  return destroy_1;
}
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl, hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl) return encodeurl;
  hasRequiredEncodeurl = 1, encodeurl = a;
  var e = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g, t = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g, r = "$1�$2";
  function a(u) {
    return String(u).replace(t, r).replace(e, encodeURI);
  }
  return encodeurl;
}
var vary = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary.exports;
  hasRequiredVary = 1, vary.exports = a, vary.exports.append = t;
  var e = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function t(u, n) {
    if (typeof u != "string")
      throw new TypeError("header argument is required");
    if (!n)
      throw new TypeError("field argument is required");
    for (var o = Array.isArray(n) ? n : r(String(n)), c = 0; c < o.length; c++)
      if (!e.test(o[c]))
        throw new TypeError("field argument contains an invalid header name");
    if (u === "*")
      return u;
    var f = u, l = r(u.toLowerCase());
    if (o.indexOf("*") !== -1 || l.indexOf("*") !== -1)
      return "*";
    for (var s = 0; s < o.length; s++) {
      var p = o[s].toLowerCase();
      l.indexOf(p) === -1 && (l.push(p), f = f ? f + ", " + o[s] : o[s]);
    }
    return f;
  }
  function r(u) {
    for (var n = 0, o = [], c = 0, f = 0, l = u.length; f < l; f++)
      switch (u.charCodeAt(f)) {
        case 32:
          c === n && (c = n = f + 1);
          break;
        case 44:
          o.push(u.substring(c, n)), c = n = f + 1;
          break;
        default:
          n = f + 1;
          break;
      }
    return o.push(u.substring(c, n)), o;
  }
  function a(u, n) {
    if (!u || !u.getHeader || !u.setHeader)
      throw new TypeError("res argument is required");
    var o = u.getHeader("Vary") || "", c = Array.isArray(o) ? o.join(", ") : String(o);
    (o = t(c, n)) && u.setHeader("Vary", o);
  }
  return vary.exports;
}
var isStream, hasRequiredIsStream;
function requireIsStream() {
  if (hasRequiredIsStream) return isStream;
  hasRequiredIsStream = 1;
  const e = requireStreamBrowserify();
  return isStream = (t) => t instanceof e || t !== null && typeof t == "object" && !!t.readable && typeof t.pipe == "function" && typeof t.read == "function" && typeof t.readable == "boolean" && typeof t.readableObjectMode == "boolean" && typeof t.destroy == "function" && typeof t.destroyed == "boolean", isStream;
}
var hasRequiredResponse;
function requireResponse() {
  return hasRequiredResponse || (hasRequiredResponse = 1, (function(e) {
    const t = requireAssert(), r = requirePathBrowserify().extname, a = requireUtil(), u = requireContentDisposition(), n = requireOnFinished(), o = requireEscapeHtml(), c = requireTypeIs().is, f = requireStatuses$2(), l = requireDestroy(), s = requireEncodeurl(), p = requireVary(), m = requireMimeTypes().contentType, g = requireIsStream(), y = requireOnly();
    e.exports = {
      /**
       * Return the request socket.
       *
       * @return {Connection}
       * @api public
       */
      get socket() {
        return this.res.socket;
      },
      /**
       * Return response header.
       *
       * @return {Object}
       * @api public
       */
      get header() {
        const { res: v } = this;
        return typeof v.getHeaders == "function" ? v.getHeaders() : v._headers || {};
      },
      /**
       * Return response header, alias as response.header
       *
       * @return {Object}
       * @api public
       */
      get headers() {
        return this.header;
      },
      /**
       * Get response status code.
       *
       * @return {Number}
       * @api public
       */
      get status() {
        return this.res.statusCode;
      },
      /**
       * Set response status code.
       *
       * @param {Number} code
       * @api public
       */
      set status(v) {
        this.headerSent || (t(Number.isInteger(v), "status code must be a number"), t(v >= 100 && v <= 999, `invalid status code: ${v}`), this._explicitStatus = !0, this.res.statusCode = v, this.req.httpVersionMajor < 2 && (this.res.statusMessage = f.message[v]), this.body && f.empty[v] && (this.body = null));
      },
      /**
       * Get response status message
       *
       * @return {String}
       * @api public
       */
      get message() {
        return this.res.statusMessage || f.message[this.status];
      },
      /**
       * Set response status message
       *
       * @param {String} msg
       * @api public
       */
      set message(v) {
        this.res.statusMessage = v;
      },
      /**
       * Get response body.
       *
       * @return {Mixed}
       * @api public
       */
      get body() {
        return this._body;
      },
      /**
       * Set response body.
       *
       * @param {String|Buffer|Object|Stream|ReadableStream|Blob|Response} val
       * @api public
       */
      set body(v) {
        const E = this._body;
        if (this._body = v, v == null) {
          if (!f.empty[this.status]) {
            if (this.type === "application/json") {
              this._body = "null";
              return;
            }
            this.status = 204;
          }
          v === null && (this._explicitNullBody = !0), this.remove("Content-Type"), this.remove("Content-Length"), this.remove("Transfer-Encoding");
          return;
        }
        this._explicitStatus || (this.status = 200);
        const b = !this.has("Content-Type");
        if (typeof v == "string") {
          b && (this.type = /^\s*</.test(v) ? "html" : "text"), this.length = Buffer.byteLength(v);
          return;
        }
        if (Buffer.isBuffer(v)) {
          b && (this.type = "bin"), this.length = v.length;
          return;
        }
        if (g(v)) {
          n(this.res, l.bind(null, v)), E !== v && (v.once("error", (q) => this.ctx.onerror(q)), E != null && this.remove("Content-Length")), b && (this.type = "bin");
          return;
        }
        if (v instanceof ReadableStream) {
          b && (this.type = "bin");
          return;
        }
        if (v instanceof Blob) {
          b && (this.type = "bin"), this.length = v.size;
          return;
        }
        if (v instanceof Response) {
          this.status = v.status, b && (this.type = "bin");
          const q = v.headers;
          for (const O of q.keys())
            this.set(O, q.get(O));
          return;
        }
        this.remove("Content-Length"), (!this.type || !/\bjson\b/i.test(this.type)) && (this.type = "json");
      },
      /**
       * Set Content-Length field to `n`.
       *
       * @param {Number} n
       * @api public
       */
      set length(v) {
        this.has("Transfer-Encoding") || this.set("Content-Length", v);
      },
      /**
       * Return parsed response Content-Length when present.
       *
       * @return {Number}
       * @api public
       */
      get length() {
        if (this.has("Content-Length"))
          return parseInt(this.get("Content-Length"), 10) || 0;
        const { body: v } = this;
        if (!(!v || g(v)))
          return typeof v == "string" ? Buffer.byteLength(v) : Buffer.isBuffer(v) ? v.length : Buffer.byteLength(JSON.stringify(v));
      },
      /**
       * Check if a header has been written to the socket.
       *
       * @return {Boolean}
       * @api public
       */
      get headerSent() {
        return this.res.headersSent;
      },
      /**
       * Vary on `field`.
       *
       * @param {String|String[]} field
       * @api public
       */
      vary(v) {
        this.headerSent || p(this.res, v);
      },
      /**
       * Perform a 302 redirect to `url`.
       *
       * Examples:
       *
       *    this.redirect('/login');
       *    this.redirect('http://google.com');
       *
       * @param {String} url
       * @api public
       */
      redirect(v) {
        if (/^https?:\/\//i.test(v) && (v = new URL(v).toString()), this.set("Location", s(v)), f.redirect[this.status] || (this.status = 302), this.ctx.accepts("html")) {
          v = o(v), this.type = "text/html; charset=utf-8", this.body = `Redirecting to ${v}.`;
          return;
        }
        this.type = "text/plain; charset=utf-8", this.body = `Redirecting to ${v}.`;
      },
      /**
       * Perform a special-cased "back" to provide Referrer support.
       * When Referrer is not present, `alt` or "/" is used.
       *
       * Examples:
       *
       *    ctx.back()
       *    ctx.back('/index.html')
       *
       * @param {String} [alt]
       * @api public
       */
      back(v) {
        const E = this.ctx.get("Referrer");
        if (E) {
          if (E.startsWith("/")) {
            this.redirect(E);
            return;
          }
          if (new URL(E, this.ctx.href).host === this.ctx.host) {
            this.redirect(E);
            return;
          }
        }
        this.redirect(v || "/");
      },
      /**
       * Set Content-Disposition header to "attachment" with optional `filename`.
       *
       * @param {String} [filename]
       * @param {object} [options]
       * @param {string} [options.type=attachment]
       * @param {string|boolean} [options.fallback=true]
       * @api public
       */
      attachment(v, E) {
        v && (this.type = r(v)), this.set("Content-Disposition", u(v, E));
      },
      /**
       * Set Content-Type response header with `type` through `mime.lookup()`
       * when it does not contain a charset.
       *
       * Examples:
       *
       *     this.type = '.html';
       *     this.type = 'html';
       *     this.type = 'json';
       *     this.type = 'application/json';
       *     this.type = 'png';
       *
       * @param {String} type
       * @api public
       */
      set type(v) {
        v = m(v), v ? this.set("Content-Type", v) : this.remove("Content-Type");
      },
      /**
       * Set the Last-Modified date using a string or a Date.
       *
       *     this.response.lastModified = new Date();
       *     this.response.lastModified = '2013-09-13';
       *
       * @param {String|Date} val
       * @api public
       */
      set lastModified(v) {
        typeof v == "string" && (v = new Date(v)), this.set("Last-Modified", v.toUTCString());
      },
      /**
       * Get the Last-Modified date in Date form, if it exists.
       *
       * @return {Date}
       * @api public
       */
      get lastModified() {
        const v = this.get("last-modified");
        if (v) return new Date(v);
      },
      /**
       * Set the ETag of a response.
       * This will normalize the quotes if necessary.
       *
       *     this.response.etag = 'md5hashsum';
       *     this.response.etag = '"md5hashsum"';
       *     this.response.etag = 'W/"123456789"';
       *
       * @param {String} val
       * @api public
       */
      set etag(v) {
        /^(W\/)?"/.test(v) || (v = `"${v}"`), this.set("ETag", v);
      },
      /**
       * Get the ETag of a response.
       *
       * @return {String}
       * @api public
       */
      get etag() {
        return this.get("ETag");
      },
      /**
       * Return the response mime type void of
       * parameters such as "charset".
       *
       * @return {String}
       * @api public
       */
      get type() {
        const v = this.get("Content-Type");
        return v ? v.split(";", 1)[0] : "";
      },
      /**
       * Check whether the response is one of the listed types.
       * Pretty much the same as `this.request.is()`.
       *
       * @param {String|String[]} [type]
       * @param {String[]} [types]
       * @return {String|false}
       * @api public
       */
      is(v, ...E) {
        return c(this.type, v, ...E);
      },
      /**
       * Return response header.
       *
       * Examples:
       *
       *     this.get('Content-Type');
       *     // => "text/plain"
       *
       *     this.get('content-type');
       *     // => "text/plain"
       *
       * @param {String} field
       * @return {any}
       * @api public
       */
      get(v) {
        return this.res.getHeader(v);
      },
      /**
       * Returns true if the header identified by name is currently set in the outgoing headers.
       * The header name matching is case-insensitive.
       *
       * Examples:
       *
       *     this.has('Content-Type');
       *     // => true
       *
       *     this.get('content-type');
       *     // => true
       *
       * @param {String} field
       * @return {boolean}
       * @api public
       */
      has(v) {
        return typeof this.res.hasHeader == "function" ? this.res.hasHeader(v) : v.toLowerCase() in this.headers;
      },
      /**
       * Set header `field` to `val` or pass
       * an object of header fields.
       *
       * Examples:
       *
       *    this.set('Foo', ['bar', 'baz']);
       *    this.set('Accept', 'application/json');
       *    this.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
       *
       * @param {String|{ [k: string]: any }} field
       * @param {any} [val]
       * @api public
       */
      set(v, E) {
        this.headerSent || !v || (typeof v == "string" ? this.res.setHeader(v, E) : Object.keys(v).forEach((b) => this.res.setHeader(b, v[b])));
      },
      /**
       * Append additional header `field` with value `val`.
       *
       * Examples:
       *
       * ```
       * this.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
       * this.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
       * this.append('Warning', '199 Miscellaneous warning');
       * ```
       *
       * @param {String} field
       * @param {*} val
       * @api public
       */
      append(v, E) {
        const b = this.get(v);
        return b && (E = Array.isArray(b) ? b.concat(E) : [b].concat(E)), this.set(v, E);
      },
      /**
       * Remove header `field`.
       *
       * @param {String} field
       * @api public
       */
      remove(v) {
        this.headerSent || this.res.removeHeader(v);
      },
      /**
       * Checks if the request is writable.
       * Tests for the existence of the socket
       * as node sometimes does not set it.
       *
       * @return {Boolean}
       * @api private
       */
      get writable() {
        if (this.res.writableEnded || this.res.finished) return !1;
        const v = this.res.socket;
        return v ? v.writable : !0;
      },
      /**
       * Inspect implementation.
       *
       * @return {Object}
       * @api public
       */
      inspect() {
        if (!this.res) return;
        const v = this.toJSON();
        return v.body = this.body, v;
      },
      /**
       * Return JSON representation.
       *
       * @return {Object}
       * @api public
       */
      toJSON() {
        return y(this, [
          "status",
          "message",
          "header"
        ]);
      },
      /**
       * Flush any set headers and begin the body
       */
      flushHeaders() {
        this.res.flushHeaders();
      }
    }, a.inspect.custom && (e.exports[a.inspect.custom] = e.exports.inspect);
  })(response)), response.exports;
}
var context = { exports: {} }, httpErrors = { exports: {} };
/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var browser$1, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1, browser$1 = e;
  function e(a) {
    if (!a)
      throw new TypeError("argument namespace is required");
    function u(n) {
    }
    return u._file = void 0, u._ignored = !0, u._namespace = a, u._traced = !1, u._warned = /* @__PURE__ */ Object.create(null), u.function = t, u.property = r, u;
  }
  function t(a, u) {
    if (typeof a != "function")
      throw new TypeError("argument fn must be a function");
    return a;
  }
  function r(a, u, n) {
    if (!a || typeof a != "object" && typeof a != "function")
      throw new TypeError("argument obj must be object");
    var o = Object.getOwnPropertyDescriptor(a, u);
    if (!o)
      throw new TypeError("must call property on owner object");
    if (!o.configurable)
      throw new TypeError("property must be configurable");
  }
  return browser$1;
}
const require$$0 = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "(Unused)",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Unordered Collection",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var statuses, hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses;
  hasRequiredStatuses = 1;
  var e = require$$0;
  statuses = r, r.STATUS_CODES = e, r.codes = t(r, e), r.redirect = {
    300: !0,
    301: !0,
    302: !0,
    303: !0,
    305: !0,
    307: !0,
    308: !0
  }, r.empty = {
    204: !0,
    205: !0,
    304: !0
  }, r.retry = {
    502: !0,
    503: !0,
    504: !0
  };
  function t(a, u) {
    var n = [];
    return Object.keys(u).forEach(function(c) {
      var f = u[c], l = Number(c);
      a[l] = f, a[f] = l, a[f.toLowerCase()] = l, n.push(l);
    }), n;
  }
  function r(a) {
    if (typeof a == "number") {
      if (!r[a]) throw new Error("invalid status code: " + a);
      return a;
    }
    if (typeof a != "string")
      throw new TypeError("code must be a number or string");
    var u = parseInt(a, 10);
    if (!isNaN(u)) {
      if (!r[u]) throw new Error("invalid status code: " + u);
      return u;
    }
    if (u = r[a.toLowerCase()], !u) throw new Error('invalid status message: "' + a + '"');
    return u;
  }
  return statuses;
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredHttpErrors;
function requireHttpErrors() {
  return hasRequiredHttpErrors || (hasRequiredHttpErrors = 1, (function(e) {
    var t = requireBrowser$1()("http-errors"), r = requireSetprototypeof(), a = requireStatuses(), u = requireInherits_browser(), n = requireToidentifier();
    e.exports = c, e.exports.HttpError = f(), e.exports.isHttpError = s(e.exports.HttpError), g(e.exports, a.codes, e.exports.HttpError);
    function o(v) {
      return +(String(v).charAt(0) + "00");
    }
    function c() {
      for (var v, E, b = 500, q = {}, O = 0; O < arguments.length; O++) {
        var j = arguments[O];
        if (j instanceof Error) {
          v = j, b = v.status || v.statusCode || b;
          continue;
        }
        switch (typeof j) {
          case "string":
            E = j;
            break;
          case "number":
            b = j, O !== 0 && t("non-first-argument status code; replace with createError(" + j + ", ...)");
            break;
          case "object":
            q = j;
            break;
        }
      }
      typeof b == "number" && (b < 400 || b >= 600) && t("non-error status code; use only 4xx or 5xx status codes"), (typeof b != "number" || !a[b] && (b < 400 || b >= 600)) && (b = 500);
      var D = c[b] || c[o(b)];
      v || (v = D ? new D(E) : new Error(E || a[b]), Error.captureStackTrace(v, c)), (!D || !(v instanceof D) || v.status !== b) && (v.expose = b < 500, v.status = v.statusCode = b);
      for (var G in q)
        G !== "status" && G !== "statusCode" && (v[G] = q[G]);
      return v;
    }
    function f() {
      function v() {
        throw new TypeError("cannot construct abstract class");
      }
      return u(v, Error), v;
    }
    function l(v, E, b) {
      var q = y(E);
      function O(j) {
        var D = j ?? a[b], G = new Error(D);
        return Error.captureStackTrace(G, O), r(G, O.prototype), Object.defineProperty(G, "message", {
          enumerable: !0,
          configurable: !0,
          value: D,
          writable: !0
        }), Object.defineProperty(G, "name", {
          enumerable: !1,
          configurable: !0,
          value: q,
          writable: !0
        }), G;
      }
      return u(O, v), m(O, q), O.prototype.status = b, O.prototype.statusCode = b, O.prototype.expose = !0, O;
    }
    function s(v) {
      return function(b) {
        return !b || typeof b != "object" ? !1 : b instanceof v ? !0 : b instanceof Error && typeof b.expose == "boolean" && typeof b.statusCode == "number" && b.status === b.statusCode;
      };
    }
    function p(v, E, b) {
      var q = y(E);
      function O(j) {
        var D = j ?? a[b], G = new Error(D);
        return Error.captureStackTrace(G, O), r(G, O.prototype), Object.defineProperty(G, "message", {
          enumerable: !0,
          configurable: !0,
          value: D,
          writable: !0
        }), Object.defineProperty(G, "name", {
          enumerable: !1,
          configurable: !0,
          value: q,
          writable: !0
        }), G;
      }
      return u(O, v), m(O, q), O.prototype.status = b, O.prototype.statusCode = b, O.prototype.expose = !1, O;
    }
    function m(v, E) {
      var b = Object.getOwnPropertyDescriptor(v, "name");
      b && b.configurable && (b.value = E, Object.defineProperty(v, "name", b));
    }
    function g(v, E, b) {
      E.forEach(function(O) {
        var j, D = n(a[O]);
        switch (o(O)) {
          case 400:
            j = l(b, D, O);
            break;
          case 500:
            j = p(b, D, O);
            break;
        }
        j && (v[O] = j, v[D] = j);
      }), v["I'mateapot"] = t.function(
        v.ImATeapot,
        `"I'mateapot"; use "ImATeapot" instead`
      );
    }
    function y(v) {
      return v.substr(-5) !== "Error" ? v + "Error" : v;
    }
  })(httpErrors)), httpErrors.exports;
}
var deepEqual = { exports: {} }, keys = { exports: {} }, hasRequiredKeys;
function requireKeys() {
  return hasRequiredKeys || (hasRequiredKeys = 1, (function(e, t) {
    t = e.exports = typeof Object.keys == "function" ? Object.keys : r, t.shim = r;
    function r(a) {
      var u = [];
      for (var n in a) u.push(n);
      return u;
    }
  })(keys, keys.exports)), keys.exports;
}
var is_arguments = { exports: {} }, hasRequiredIs_arguments;
function requireIs_arguments() {
  return hasRequiredIs_arguments || (hasRequiredIs_arguments = 1, (function(e, t) {
    var r = (function() {
      return Object.prototype.toString.call(arguments);
    })() == "[object Arguments]";
    t = e.exports = r ? a : u, t.supported = a;
    function a(n) {
      return Object.prototype.toString.call(n) == "[object Arguments]";
    }
    t.unsupported = u;
    function u(n) {
      return n && typeof n == "object" && typeof n.length == "number" && Object.prototype.hasOwnProperty.call(n, "callee") && !Object.prototype.propertyIsEnumerable.call(n, "callee") || !1;
    }
  })(is_arguments, is_arguments.exports)), is_arguments.exports;
}
var hasRequiredDeepEqual;
function requireDeepEqual() {
  if (hasRequiredDeepEqual) return deepEqual.exports;
  hasRequiredDeepEqual = 1;
  var e = Array.prototype.slice, t = requireKeys(), r = requireIs_arguments(), a = deepEqual.exports = function(c, f, l) {
    return l || (l = {}), c === f ? !0 : c instanceof Date && f instanceof Date ? c.getTime() === f.getTime() : !c || !f || typeof c != "object" && typeof f != "object" ? l.strict ? c === f : c == f : o(c, f, l);
  };
  function u(c) {
    return c == null;
  }
  function n(c) {
    return !(!c || typeof c != "object" || typeof c.length != "number" || typeof c.copy != "function" || typeof c.slice != "function" || c.length > 0 && typeof c[0] != "number");
  }
  function o(c, f, l) {
    var s, p;
    if (u(c) || u(f) || c.prototype !== f.prototype) return !1;
    if (r(c))
      return r(f) ? (c = e.call(c), f = e.call(f), a(c, f, l)) : !1;
    if (n(c)) {
      if (!n(f) || c.length !== f.length) return !1;
      for (s = 0; s < c.length; s++)
        if (c[s] !== f[s]) return !1;
      return !0;
    }
    try {
      var m = t(c), g = t(f);
    } catch {
      return !1;
    }
    if (m.length != g.length)
      return !1;
    for (m.sort(), g.sort(), s = m.length - 1; s >= 0; s--)
      if (m[s] != g[s])
        return !1;
    for (s = m.length - 1; s >= 0; s--)
      if (p = m[s], !a(c[p], f[p], l)) return !1;
    return typeof c == typeof f;
  }
  return deepEqual.exports;
}
var httpAssert, hasRequiredHttpAssert;
function requireHttpAssert() {
  if (hasRequiredHttpAssert) return httpAssert;
  hasRequiredHttpAssert = 1;
  var e = requireHttpErrors(), t = requireDeepEqual();
  httpAssert = r;
  function r(a, u, n, o) {
    if (!a)
      throw e(u, n, o);
  }
  return r.fail = function(a, u, n) {
    r(!1, a, u, n);
  }, r.equal = function(a, u, n, o, c) {
    r(a == u, n, o, c);
  }, r.notEqual = function(a, u, n, o, c) {
    r(a != u, n, o, c);
  }, r.ok = function(a, u, n, o) {
    r(a, u, n, o);
  }, r.strictEqual = function(a, u, n, o, c) {
    r(a === u, n, o, c);
  }, r.notStrictEqual = function(a, u, n, o, c) {
    r(a !== u, n, o, c);
  }, r.deepEqual = function(a, u, n, o, c) {
    r(t(a, u), n, o, c);
  }, r.notDeepEqual = function(a, u, n, o, c) {
    r(!t(a, u), n, o, c);
  }, httpAssert;
}
var delegates, hasRequiredDelegates;
function requireDelegates() {
  if (hasRequiredDelegates) return delegates;
  hasRequiredDelegates = 1, delegates = e;
  function e(t, r) {
    if (!(this instanceof e)) return new e(t, r);
    this.proto = t, this.target = r, this.methods = [], this.getters = [], this.setters = [], this.fluents = [];
  }
  return e.prototype.method = function(t) {
    var r = this.proto, a = this.target;
    return this.methods.push(t), r[t] = function() {
      return this[a][t].apply(this[a], arguments);
    }, this;
  }, e.prototype.access = function(t) {
    return this.getter(t).setter(t);
  }, e.prototype.getter = function(t) {
    var r = this.proto, a = this.target;
    return this.getters.push(t), r.__defineGetter__(t, function() {
      return this[a][t];
    }), this;
  }, e.prototype.setter = function(t) {
    var r = this.proto, a = this.target;
    return this.setters.push(t), r.__defineSetter__(t, function(u) {
      return this[a][t] = u;
    }), this;
  }, e.prototype.fluent = function(t) {
    var r = this.proto, a = this.target;
    return this.fluents.push(t), r[t] = function(u) {
      return typeof u < "u" ? (this[a][t] = u, this) : this[a][t];
    }, this;
  }, delegates;
}
var lib, hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var e = requireCryptoBrowserify();
  function t(a, u) {
    if (a.length !== u.length)
      return !1;
    if (e.timingSafeEqual)
      return e.timingSafeEqual(a, u);
    for (var n = 0; n < a.length; n++)
      if (a[n] !== u[n])
        return !1;
    return !0;
  }
  function r(a, u) {
    var n = String(a), o = String(u), c = e.pseudoRandomBytes(32), f = e.createHmac("sha256", c).update(n).digest(), l = e.createHmac("sha256", c).update(o).digest();
    return t(f, l) && a === u;
  }
  return lib = r, lib;
}
/*!
 * keygrip
 * Copyright(c) 2011-2014 Jed Schmidt
 * MIT Licensed
 */
var keygrip, hasRequiredKeygrip;
function requireKeygrip() {
  if (hasRequiredKeygrip) return keygrip;
  hasRequiredKeygrip = 1;
  var e = requireLib(), t = requireCryptoBrowserify();
  function r(a, u, n) {
    if (u || (u = "sha1"), n || (n = "base64"), !(this instanceof r)) return new r(a, u, n);
    if (!a || !(0 in a))
      throw new Error("Keys must be provided.");
    function o(c, f) {
      return t.createHmac(u, f).update(c).digest(n).replace(/\/|\+|=/g, function(l) {
        return { "/": "_", "+": "-", "=": "" }[l];
      });
    }
    this.sign = function(c) {
      return o(c, a[0]);
    }, this.verify = function(c, f) {
      return this.index(c, f) > -1;
    }, this.index = function(c, f) {
      for (var l = 0, s = a.length; l < s; l++)
        if (e(f, o(c, a[l])))
          return l;
      return -1;
    };
  }
  return r.sign = r.verify = r.index = function() {
    throw new Error("Usage: require('keygrip')(<array-of-keys>)");
  }, keygrip = r, keygrip;
}
/*!
 * cookies
 * Copyright(c) 2014 Jed Schmidt, http://jed.is/
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  var e = requireBrowser$2()("cookies"), t = requireKeygrip(), r = requireStreamHttp(), a = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, u = /^(?:low|medium|high)$/i, n = /* @__PURE__ */ Object.create(null), o = /[\^$\\.*+?()[\]{}|]/g, c = /[;=]/, f = /[;]/, l = /^(?:lax|none|strict)$/i;
  function s(v, E, b) {
    if (!(this instanceof s)) return new s(v, E, b);
    this.secure = void 0, this.request = v, this.response = E, b && (Array.isArray(b) ? (e('"keys" argument; provide using options {"keys": [...]}'), this.keys = new t(b)) : b.constructor && b.constructor.name === "Keygrip" ? (e('"keys" argument; provide using options {"keys": keygrip}'), this.keys = b) : (this.keys = Array.isArray(b.keys) ? new t(b.keys) : b.keys, this.secure = b.secure));
  }
  s.prototype.get = function(v, E) {
    var b = v + ".sig", q, O, j, D, G, V, Q = E && E.signed !== void 0 ? E.signed : !!this.keys;
    if (q = this.request.headers.cookie, !!q && (O = q.match(m(v)), !!O)) {
      if (j = O[1], j[0] === '"' && (j = j.slice(1, -1)), !E || !Q) return j;
      if (D = this.get(b), !!D) {
        if (G = v + "=" + j, !this.keys) throw new Error(".keys required for signed cookies");
        if (V = this.keys.index(G, D), V < 0)
          this.set(b, null, { path: "/", signed: !1 });
        else
          return V && this.set(b, this.keys.sign(G), { signed: !1 }), j;
      }
    }
  }, s.prototype.set = function(v, E, b) {
    var q = this.response, O = this.request, j = q.getHeader("Set-Cookie") || [], D = new p(v, E, b), G = b && b.signed !== void 0 ? b.signed : !!this.keys, V = this.secure === void 0 ? O.protocol === "https" || g(O) : !!this.secure;
    if (typeof j == "string" && (j = [j]), !V && b && b.secure)
      throw new Error("Cannot send secure cookie over unencrypted connection");
    if (D.secure = b && b.secure !== void 0 ? b.secure : V, b && "secureProxy" in b && (e('"secureProxy" option; use "secure" option, provide "secure" to constructor if needed'), D.secure = b.secureProxy), y(j, D), b && G) {
      if (!this.keys) throw new Error(".keys required for signed cookies");
      D.value = this.keys.sign(D.toString()), D.name += ".sig", y(j, D);
    }
    var Q = q.set ? r.OutgoingMessage.prototype.setHeader : q.setHeader;
    return Q.call(q, "Set-Cookie", j), this;
  };
  function p(v, E, b) {
    if (!a.test(v) || c.test(v))
      throw new TypeError("argument name is invalid");
    if (E && (!a.test(E) || f.test(E)))
      throw new TypeError("argument value is invalid");
    this.name = v, this.value = E || "";
    for (var v in b)
      this[v] = b[v];
    if (this.value || (this.expires = /* @__PURE__ */ new Date(0), this.maxAge = null), this.path && !a.test(this.path))
      throw new TypeError("option path is invalid");
    if (this.domain && !a.test(this.domain))
      throw new TypeError("option domain is invalid");
    if (typeof this.maxAge == "number" ? isNaN(this.maxAge) || !isFinite(this.maxAge) : this.maxAge)
      throw new TypeError("option maxAge is invalid");
    if (this.priority && !u.test(this.priority))
      throw new TypeError("option priority is invalid");
    if (this.sameSite && this.sameSite !== !0 && !l.test(this.sameSite))
      throw new TypeError("option sameSite is invalid");
  }
  p.prototype.path = "/", p.prototype.expires = void 0, p.prototype.domain = void 0, p.prototype.httpOnly = !0, p.prototype.partitioned = !1, p.prototype.priority = void 0, p.prototype.sameSite = !1, p.prototype.secure = !1, p.prototype.overwrite = !1, p.prototype.toString = function() {
    return this.name + "=" + this.value;
  }, p.prototype.toHeader = function() {
    var v = this.toString();
    return this.maxAge && (this.expires = new Date(Date.now() + this.maxAge)), this.path && (v += "; path=" + this.path), this.expires && (v += "; expires=" + this.expires.toUTCString()), this.domain && (v += "; domain=" + this.domain), this.priority && (v += "; priority=" + this.priority.toLowerCase()), this.sameSite && (v += "; samesite=" + (this.sameSite === !0 ? "strict" : this.sameSite.toLowerCase())), this.secure && (v += "; secure"), this.httpOnly && (v += "; httponly"), this.partitioned && (v += "; partitioned"), v;
  }, Object.defineProperty(p.prototype, "maxage", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.maxAge;
    },
    set: function(v) {
      return this.maxAge = v;
    }
  }), e.property(p.prototype, "maxage", '"maxage"; use "maxAge" instead');
  function m(v) {
    return n[v] || (n[v] = new RegExp(
      "(?:^|;) *" + v.replace(o, "\\$&") + "=([^;]*)"
    )), n[v];
  }
  function g(v) {
    return v.socket ? v.socket.encrypted : v.connection.encrypted;
  }
  function y(v, E) {
    if (E.overwrite)
      for (var b = v.length - 1; b >= 0; b--)
        v[b].indexOf(E.name + "=") === 0 && v.splice(b, 1);
    v.push(E.toHeader());
  }
  return s.connect = s.express = function(v) {
    return function(E, b, q) {
      E.cookies = b.cookies = new s(E, b, {
        keys: v
      }), q();
    };
  }, s.Cookie = p, cookies = s, cookies;
}
var hasRequiredContext;
function requireContext() {
  return hasRequiredContext || (hasRequiredContext = 1, (function(e) {
    const t = requireUtil(), r = requireHttpErrors$1(), a = requireHttpAssert(), u = requireDelegates(), n = requireStatuses$2(), o = requireCookies(), c = Symbol("context#cookies"), f = e.exports = {
      /**
       * util.inspect() implementation, which
       * just returns the JSON output.
       *
       * @return {Object}
       * @api public
       */
      inspect() {
        return this === f ? this : this.toJSON();
      },
      /**
       * Return JSON representation.
       *
       * Here we explicitly invoke .toJSON() on each
       * object, as iteration will otherwise fail due
       * to the getters and cause utilities such as
       * clone() to fail.
       *
       * @return {Object}
       * @api public
       */
      toJSON() {
        return {
          request: this.request.toJSON(),
          response: this.response.toJSON(),
          app: this.app.toJSON(),
          originalUrl: this.originalUrl,
          req: "<original node req>",
          res: "<original node res>",
          socket: "<original node socket>"
        };
      },
      /**
       * Similar to .throw(), adds assertion.
       *
       *    this.assert(this.user, 401, 'Please login!');
       *
       * See: https://github.com/jshttp/http-assert
       *
       * @param {Mixed} test
       * @param {Number} status
       * @param {String} message
       * @api public
       */
      assert: a,
      /**
       * Throw an error with `status` (default 500) and
       * `msg`. Note that these are user-level
       * errors, and the message may be exposed to the client.
       *
       *    this.throw(403)
       *    this.throw(400, 'name required')
       *    this.throw('something exploded')
       *    this.throw(new Error('invalid'))
       *    this.throw(400, new Error('invalid'))
       *
       * See: https://github.com/jshttp/http-errors
       *
       * Note: `status` should only be passed as the first parameter.
       *
       * @param {String|Number|Error} err, msg or status
       * @param {String|Number|Error} [err, msg or status]
       * @param {Object} [props]
       * @api public
       */
      throw(...l) {
        throw r(...l);
      },
      /**
       * Default error handling.
       *
       * @param {Error} err
       * @api private
       */
      onerror(l) {
        if (l == null) return;
        Object.prototype.toString.call(l) === "[object Error]" || l instanceof Error || (l = new Error(t.format("non-error thrown: %j", l)));
        let p = !1;
        if ((this.headerSent || !this.writable) && (p = l.headerSent = !0), this.app.emit("error", l, this), p)
          return;
        const { res: m } = this;
        typeof m.getHeaderNames == "function" ? m.getHeaderNames().forEach((E) => m.removeHeader(E)) : m._headers = {}, this.set(l.headers), this.type = "text";
        let g = l.status || l.statusCode;
        (typeof g != "number" || !n.message[g]) && (g = 500);
        const y = n.message[g], v = l.expose ? l.message : y;
        this.status = l.status = g, this.length = Buffer.byteLength(v), m.end(v);
      },
      get cookies() {
        return this[c] || (this[c] = new o(this.req, this.res, {
          keys: this.app.keys,
          secure: this.request.secure
        })), this[c];
      },
      set cookies(l) {
        this[c] = l;
      }
    };
    t.inspect.custom && (e.exports[t.inspect.custom] = e.exports.inspect), u(f, "response").method("attachment").method("redirect").method("remove").method("vary").method("has").method("set").method("append").method("flushHeaders").method("back").access("status").access("message").access("body").access("length").access("type").access("lastModified").access("etag").getter("headerSent").getter("writable"), u(f, "request").method("acceptsLanguages").method("acceptsEncodings").method("acceptsCharsets").method("accepts").method("get").method("is").access("querystring").access("idempotent").access("socket").access("search").access("method").access("query").access("path").access("url").access("accept").getter("origin").getter("href").getter("subdomains").getter("protocol").getter("host").getter("hostname").getter("URL").getter("header").getter("headers").getter("secure").getter("stale").getter("fresh").getter("ips").getter("ip");
  })(context)), context.exports;
}
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return application.exports;
  hasRequiredApplication = 1;
  const e = requireUtil(), t = e.debuglog("koa:application"), r = requireEvents(), a = requireStreamBrowserify(), u = requireStreamHttp(), { AsyncLocalStorage: n } = require$$4, o = requireOnFinished(), c = requireKoaCompose(), f = requireStatuses$2(), { HttpError: l } = requireHttpErrors$1(), s = requireRequest(), p = requireResponse(), m = requireContext(), g = requireIsStream(), y = requireOnly();
  application.exports = class uc extends r {
    /**
     * Initialize a new `Application`.
     *
     * @api public
     */
    /**
     *
     * @param {object} [options] Application options
     * @param {string} [options.env='development'] Environment
     * @param {string[]} [options.keys] Signed cookie keys
     * @param {boolean} [options.proxy] Trust proxy headers
     * @param {number} [options.subdomainOffset] Subdomain offset
     * @param {string} [options.proxyIpHeader] Proxy IP header, defaults to X-Forwarded-For
     * @param {number} [options.maxIpsCount] Max IPs read from proxy IP header, default to 0 (means infinity)
     * @param {function} [options.compose] Function to handle middleware composition
     * @param {boolean} [options.asyncLocalStorage] Enable AsyncLocalStorage, default to false
     *
     */
    constructor(b) {
      super(), b = b || {}, this.proxy = b.proxy || !1, this.subdomainOffset = b.subdomainOffset || 2, this.proxyIpHeader = b.proxyIpHeader || "X-Forwarded-For", this.maxIpsCount = b.maxIpsCount || 0, this.env = b.env || process$1.env.NODE_ENV || "development", this.compose = b.compose || c, b.keys && (this.keys = b.keys), this.middleware = [], this.context = Object.create(m), this.request = Object.create(s), this.response = Object.create(p), e.inspect.custom && (this[e.inspect.custom] = this.inspect), b.asyncLocalStorage && (b.asyncLocalStorage instanceof n ? this.ctxStorage = b.asyncLocalStorage : this.ctxStorage = new n());
    }
    /**
     * Shorthand for:
     *
     *    http.createServer(app.callback()).listen(...)
     *
     * @param {Mixed} ...
     * @return {import('http').Server}
     * @api public
     */
    listen(...b) {
      return t("listen"), u.createServer(this.callback()).listen(...b);
    }
    /**
     * Return JSON representation.
     * We only bother showing settings.
     *
     * @return {Object}
     * @api public
     */
    toJSON() {
      return y(this, ["subdomainOffset", "proxy", "env"]);
    }
    /**
     * Inspect implementation.
     *
     * @return {Object}
     * @api public
     */
    inspect() {
      return this.toJSON();
    }
    /**
     * Use the given middleware `fn`.
     *
     * Old-style middleware will be converted.
     *
     * @param {(context: Context) => Promise<any | void>} fn
     * @return {Application} self
     * @api public
     */
    use(b) {
      if (typeof b != "function")
        throw new TypeError("middleware must be a function!");
      return t("use %s", b._name || b.name || "-"), this.middleware.push(b), this;
    }
    /**
     * Return a request handler callback
     * for node's native http server.
     *
     * @return {Function}
     * @api public
     */
    callback() {
      const b = this.compose(this.middleware);
      return this.listenerCount("error") || this.on("error", this.onerror), (O, j) => {
        const D = this.createContext(O, j);
        return this.ctxStorage ? this.ctxStorage.run(D, async () => await this.handleRequest(D, b)) : this.handleRequest(D, b);
      };
    }
    /**
     * return current context from async local storage
     */
    get currentContext() {
      if (this.ctxStorage) return this.ctxStorage.getStore();
    }
    /**
     * Handle request in callback.
     *
     * @api private
     */
    handleRequest(b, q) {
      const O = b.res;
      O.statusCode = 404;
      const j = (G) => b.onerror(G), D = () => v(b);
      return o(O, j), q(b).then(D).catch(j);
    }
    /**
     * Initialize a new context.
     *
     * @api private
     */
    createContext(b, q) {
      const O = Object.create(this.context), j = O.request = Object.create(this.request), D = O.response = Object.create(this.response);
      return O.app = j.app = D.app = this, O.req = j.req = D.req = b, O.res = j.res = D.res = q, j.ctx = D.ctx = O, j.response = D, D.request = j, O.originalUrl = j.originalUrl = b.url, O.state = {}, O;
    }
    /**
     * Default error handler.
     *
     * @param {Error} err
     * @api private
     */
    onerror(b) {
      if (!(Object.prototype.toString.call(b) === "[object Error]" || b instanceof Error))
        throw new TypeError(e.format("non-error thrown: %j", b));
      if (b.status === 404 || b.expose || this.silent) return;
      const O = b.stack || b.toString();
      console.error(`
${O.replace(/^/gm, "  ")}
`);
    }
    /**
     * Help TS users comply to CommonJS, ESM, bundler mismatch.
     * @see https://github.com/koajs/koa/issues/1513
     */
    static get default() {
      return uc;
    }
  };
  function v(E) {
    if (E.respond === !1) return;
    const b = E.res;
    if (!E.writable) return b.end();
    let q = E.body;
    const O = E.status;
    if (f.empty[O])
      return E.body = null, b.end();
    if (E.method === "HEAD") {
      if (!b.headersSent && !E.response.has("Content-Length")) {
        const { length: j } = E.response;
        Number.isInteger(j) && (E.length = j);
      }
      return b.end();
    }
    if (q == null)
      return E.response._explicitNullBody ? (E.response.remove("Content-Type"), E.response.remove("Transfer-Encoding"), E.length = 0, b.end()) : (E.req.httpVersionMajor >= 2 ? q = String(O) : q = E.message || String(O), b.headersSent || (E.type = "text", E.length = Buffer.byteLength(q)), b.end(q));
    if (Buffer.isBuffer(q) || typeof q == "string") return b.end(q);
    if (q instanceof Blob)
      return a.Readable.from(q.stream()).pipe(b);
    if (q instanceof ReadableStream)
      return a.Readable.from(q).pipe(b);
    if (q instanceof Response)
      return a.Readable.from(q?.body || "").pipe(b);
    if (g(q)) return q.pipe(b);
    q = JSON.stringify(q), b.headersSent || (E.length = Buffer.byteLength(q)), b.end(q);
  }
  return application.exports.HttpError = l, application.exports;
}
var applicationExports = requireApplication();
const mod = /* @__PURE__ */ getDefaultExportFromCjs(applicationExports);
mod.HttpError;
var cors, hasRequiredCors;
function requireCors() {
  if (hasRequiredCors) return cors;
  hasRequiredCors = 1;
  const e = requireVary();
  return cors = function(t) {
    return t = {
      ...{
        allowMethods: "GET,HEAD,PUT,POST,DELETE,PATCH",
        secureContext: !1
      },
      ...t
    }, Array.isArray(t.exposeHeaders) && (t.exposeHeaders = t.exposeHeaders.join(",")), Array.isArray(t.allowMethods) && (t.allowMethods = t.allowMethods.join(",")), Array.isArray(t.allowHeaders) && (t.allowHeaders = t.allowHeaders.join(",")), t.maxAge && (t.maxAge = String(t.maxAge)), t.keepHeadersOnError = t.keepHeadersOnError === void 0 || !!t.keepHeadersOnError, async function(u, n) {
      const o = u.get("Origin");
      u.vary("Origin");
      let c;
      if (typeof t.origin == "function") {
        if (c = await t.origin(u), !c)
          return await n();
      } else
        c = t.origin || "*";
      let f;
      typeof t.credentials == "function" ? f = await t.credentials(u) : f = !!t.credentials, f && c === "*" && (c = o);
      const l = {};
      function s(p, m) {
        u.set(p, m), l[p] = m;
      }
      if (u.method !== "OPTIONS") {
        if (s("Access-Control-Allow-Origin", c), f === !0 && s("Access-Control-Allow-Credentials", "true"), t.exposeHeaders && s("Access-Control-Expose-Headers", t.exposeHeaders), t.secureContext && (s("Cross-Origin-Opener-Policy", "same-origin"), s("Cross-Origin-Embedder-Policy", "require-corp")), !t.keepHeadersOnError)
          return await n();
        try {
          return await n();
        } catch (p) {
          const m = p.headers || {}, g = e.append(m.vary || m.Vary || "", "Origin");
          throw delete m.Vary, p.headers = {
            ...m,
            ...l,
            vary: g
          }, p;
        }
      } else {
        if (!u.get("Access-Control-Request-Method"))
          return await n();
        u.set("Access-Control-Allow-Origin", c), f === !0 && u.set("Access-Control-Allow-Credentials", "true"), t.maxAge && u.set("Access-Control-Max-Age", t.maxAge), t.privateNetworkAccess && u.get("Access-Control-Request-Private-Network") && u.set("Access-Control-Allow-Private-Network", "true"), t.allowMethods && u.set("Access-Control-Allow-Methods", t.allowMethods), t.secureContext && (s("Cross-Origin-Opener-Policy", "same-origin"), s("Cross-Origin-Embedder-Policy", "require-corp"));
        let p = t.allowHeaders;
        p || (p = u.get("Access-Control-Request-Headers")), p && u.set("Access-Control-Allow-Headers", p), u.status = 204;
      }
    };
  }, cors;
}
var corsExports = requireCors();
const koaCors = /* @__PURE__ */ getDefaultExportFromCjs(corsExports);
var browser = { exports: {} }, common, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function e(t) {
    a.debug = a, a.default = a, a.coerce = l, a.disable = c, a.enable = n, a.enabled = f, a.humanize = requireMs(), a.destroy = s, Object.keys(t).forEach((p) => {
      a[p] = t[p];
    }), a.names = [], a.skips = [], a.formatters = {};
    function r(p) {
      let m = 0;
      for (let g = 0; g < p.length; g++)
        m = (m << 5) - m + p.charCodeAt(g), m |= 0;
      return a.colors[Math.abs(m) % a.colors.length];
    }
    a.selectColor = r;
    function a(p) {
      let m, g = null, y, v;
      function E(...b) {
        if (!E.enabled)
          return;
        const q = E, O = Number(/* @__PURE__ */ new Date()), j = O - (m || O);
        q.diff = j, q.prev = m, q.curr = O, m = O, b[0] = a.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
        let D = 0;
        b[0] = b[0].replace(/%([a-zA-Z%])/g, (V, Q) => {
          if (V === "%%")
            return "%";
          D++;
          const re = a.formatters[Q];
          if (typeof re == "function") {
            const ve = b[D];
            V = re.call(q, ve), b.splice(D, 1), D--;
          }
          return V;
        }), a.formatArgs.call(q, b), (q.log || a.log).apply(q, b);
      }
      return E.namespace = p, E.useColors = a.useColors(), E.color = a.selectColor(p), E.extend = u, E.destroy = a.destroy, Object.defineProperty(E, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => g !== null ? g : (y !== a.namespaces && (y = a.namespaces, v = a.enabled(p)), v),
        set: (b) => {
          g = b;
        }
      }), typeof a.init == "function" && a.init(E), E;
    }
    function u(p, m) {
      const g = a(this.namespace + (typeof m > "u" ? ":" : m) + p);
      return g.log = this.log, g;
    }
    function n(p) {
      a.save(p), a.namespaces = p, a.names = [], a.skips = [];
      const m = (typeof p == "string" ? p : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const g of m)
        g[0] === "-" ? a.skips.push(g.slice(1)) : a.names.push(g);
    }
    function o(p, m) {
      let g = 0, y = 0, v = -1, E = 0;
      for (; g < p.length; )
        if (y < m.length && (m[y] === p[g] || m[y] === "*"))
          m[y] === "*" ? (v = y, E = g, y++) : (g++, y++);
        else if (v !== -1)
          y = v + 1, E++, g = E;
        else
          return !1;
      for (; y < m.length && m[y] === "*"; )
        y++;
      return y === m.length;
    }
    function c() {
      const p = [
        ...a.names,
        ...a.skips.map((m) => "-" + m)
      ].join(",");
      return a.enable(""), p;
    }
    function f(p) {
      for (const m of a.skips)
        if (o(p, m))
          return !1;
      for (const m of a.names)
        if (o(p, m))
          return !0;
      return !1;
    }
    function l(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    function s() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return a.enable(a.load()), a;
  }
  return common = e, common;
}
var hasRequiredBrowser;
function requireBrowser() {
  return hasRequiredBrowser || (hasRequiredBrowser = 1, (function(e, t) {
    t.formatArgs = a, t.save = u, t.load = n, t.useColors = r, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
      let f = !1;
      return () => {
        f || (f = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof globalThis < "u" && globalThis.process && (globalThis.process.type === "renderer" || globalThis.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let f;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof globalThis < "u" && globalThis.console && (globalThis.console.firebug || globalThis.console.exception && globalThis.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (f = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(f[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function a(f) {
      if (f[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + f[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const l = "color: " + this.color;
      f.splice(1, 0, l, "color: inherit");
      let s = 0, p = 0;
      f[0].replace(/%[a-zA-Z%]/g, (m) => {
        m !== "%%" && (s++, m === "%c" && (p = s));
      }), f.splice(p, 0, l);
    }
    t.log = console.debug || console.log || (() => {
    });
    function u(f) {
      try {
        f ? t.storage.setItem("debug", f) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function n() {
      let f;
      try {
        f = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !f && typeof process$1 < "u" && "env" in process$1 && (f = process$1.env.DEBUG), f;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = requireCommon()(t);
    const { formatters: c } = e.exports;
    c.j = function(f) {
      try {
        return JSON.stringify(f);
      } catch (l) {
        return "[UnexpectedJSONParseError]: " + l.message;
      }
    };
  })(browser, browser.exports)), browser.exports;
}
var dist = {}, hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1, Object.defineProperty(dist, "__esModule", { value: !0 }), dist.TokenData = void 0, dist.parse = p, dist.compile = m, dist.match = v, dist.pathToRegexp = E, dist.stringify = j;
  const e = "/", t = (V) => V, r = /^[$_\p{ID_Start}]$/u, a = /^[$\u200c\u200d\p{ID_Continue}]$/u, u = "https://git.new/pathToRegexpError", n = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
  };
  function o(V) {
    return V.replace(/[{}()\[\]+?!:*]/g, "\\$&");
  }
  function c(V) {
    return V.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
  }
  function* f(V) {
    const Q = [...V];
    let re = 0;
    function ve() {
      let te = "";
      if (r.test(Q[++re]))
        for (te += Q[re]; a.test(Q[++re]); )
          te += Q[re];
      else if (Q[re] === '"') {
        let R = re;
        for (; re < Q.length; ) {
          if (Q[++re] === '"') {
            re++, R = 0;
            break;
          }
          Q[re] === "\\" ? te += Q[++re] : te += Q[re];
        }
        if (R)
          throw new TypeError(`Unterminated quote at ${R}: ${u}`);
      }
      if (!te)
        throw new TypeError(`Missing parameter name at ${re}: ${u}`);
      return te;
    }
    for (; re < Q.length; ) {
      const te = Q[re], R = n[te];
      if (R)
        yield { type: R, index: re++, value: te };
      else if (te === "\\")
        yield { type: "ESCAPED", index: re++, value: Q[re++] };
      else if (te === ":") {
        const M = ve();
        yield { type: "PARAM", index: re, value: M };
      } else if (te === "*") {
        const M = ve();
        yield { type: "WILDCARD", index: re, value: M };
      } else
        yield { type: "CHAR", index: re, value: Q[re++] };
    }
    return { type: "END", index: re, value: "" };
  }
  class l {
    constructor(Q) {
      this.tokens = Q;
    }
    peek() {
      if (!this._peek) {
        const Q = this.tokens.next();
        this._peek = Q.value;
      }
      return this._peek;
    }
    tryConsume(Q) {
      const re = this.peek();
      if (re.type === Q)
        return this._peek = void 0, re.value;
    }
    consume(Q) {
      const re = this.tryConsume(Q);
      if (re !== void 0)
        return re;
      const { type: ve, index: te } = this.peek();
      throw new TypeError(`Unexpected ${ve} at ${te}, expected ${Q}: ${u}`);
    }
    text() {
      let Q = "", re;
      for (; re = this.tryConsume("CHAR") || this.tryConsume("ESCAPED"); )
        Q += re;
      return Q;
    }
  }
  class s {
    constructor(Q) {
      this.tokens = Q;
    }
  }
  dist.TokenData = s;
  function p(V, Q = {}) {
    const { encodePath: re = t } = Q, ve = new l(f(V));
    function te(M) {
      const h = [];
      for (; ; ) {
        const S = ve.text();
        S && h.push({ type: "text", value: re(S) });
        const B = ve.tryConsume("PARAM");
        if (B) {
          h.push({
            type: "param",
            name: B
          });
          continue;
        }
        const T = ve.tryConsume("WILDCARD");
        if (T) {
          h.push({
            type: "wildcard",
            name: T
          });
          continue;
        }
        if (ve.tryConsume("{")) {
          h.push({
            type: "group",
            tokens: te("}")
          });
          continue;
        }
        return ve.consume(M), h;
      }
    }
    const R = te("END");
    return new s(R);
  }
  function m(V, Q = {}) {
    const { encode: re = encodeURIComponent, delimiter: ve = e } = Q, te = V instanceof s ? V : p(V, Q), R = g(te.tokens, ve, re);
    return function(h = {}) {
      const [S, ...B] = R(h);
      if (B.length)
        throw new TypeError(`Missing parameters: ${B.join(", ")}`);
      return S;
    };
  }
  function g(V, Q, re) {
    const ve = V.map((te) => y(te, Q, re));
    return (te) => {
      const R = [""];
      for (const M of ve) {
        const [h, ...S] = M(te);
        R[0] += h, R.push(...S);
      }
      return R;
    };
  }
  function y(V, Q, re) {
    if (V.type === "text")
      return () => [V.value];
    if (V.type === "group") {
      const te = g(V.tokens, Q, re);
      return (R) => {
        const [M, ...h] = te(R);
        return h.length ? [""] : [M];
      };
    }
    const ve = re || t;
    return V.type === "wildcard" && re !== !1 ? (te) => {
      const R = te[V.name];
      if (R == null)
        return ["", V.name];
      if (!Array.isArray(R) || R.length === 0)
        throw new TypeError(`Expected "${V.name}" to be a non-empty array`);
      return [
        R.map((M, h) => {
          if (typeof M != "string")
            throw new TypeError(`Expected "${V.name}/${h}" to be a string`);
          return ve(M);
        }).join(Q)
      ];
    } : (te) => {
      const R = te[V.name];
      if (R == null)
        return ["", V.name];
      if (typeof R != "string")
        throw new TypeError(`Expected "${V.name}" to be a string`);
      return [ve(R)];
    };
  }
  function v(V, Q = {}) {
    const { decode: re = decodeURIComponent, delimiter: ve = e } = Q, { regexp: te, keys: R } = E(V, Q), M = R.map((h) => re === !1 ? t : h.type === "param" ? re : (S) => S.split(ve).map(re));
    return function(S) {
      const B = te.exec(S);
      if (!B)
        return !1;
      const T = B[0], k = /* @__PURE__ */ Object.create(null);
      for (let I = 1; I < B.length; I++) {
        if (B[I] === void 0)
          continue;
        const C = R[I - 1], $ = M[I - 1];
        k[C.name] = $(B[I]);
      }
      return { path: T, params: k };
    };
  }
  function E(V, Q = {}) {
    const { delimiter: re = e, end: ve = !0, sensitive: te = !1, trailing: R = !0 } = Q, M = [], h = [], S = te ? "" : "i", T = (Array.isArray(V) ? V : [V]).map((C) => C instanceof s ? C : p(C, Q));
    for (const { tokens: C } of T)
      for (const $ of b(C, 0, [])) {
        const w = q($, re, M);
        h.push(w);
      }
    let k = `^(?:${h.join("|")})`;
    return R && (k += `(?:${c(re)}$)?`), k += ve ? "$" : `(?=${c(re)}|$)`, { regexp: new RegExp(k, S), keys: M };
  }
  function* b(V, Q, re) {
    if (Q === V.length)
      return yield re;
    const ve = V[Q];
    if (ve.type === "group") {
      const te = re.slice();
      for (const R of b(ve.tokens, 0, te))
        yield* b(V, Q + 1, R);
    } else
      re.push(ve);
    yield* b(V, Q + 1, re);
  }
  function q(V, Q, re) {
    let ve = "", te = "", R = !0;
    for (let M = 0; M < V.length; M++) {
      const h = V[M];
      if (h.type === "text") {
        ve += c(h.value), te += h.value, R || (R = h.value.includes(Q));
        continue;
      }
      if (h.type === "param" || h.type === "wildcard") {
        if (!R && !te)
          throw new TypeError(`Missing text after "${h.name}": ${u}`);
        h.type === "param" ? ve += `(${O(Q, R ? "" : te)}+)` : ve += "([\\s\\S]+)", re.push(h), te = "", R = !1;
        continue;
      }
    }
    return ve;
  }
  function O(V, Q) {
    return Q.length < 2 ? V.length < 2 ? `[^${c(V + Q)}]` : `(?:(?!${c(V)})[^${c(Q)}])` : V.length < 2 ? `(?:(?!${c(Q)})[^${c(V)}])` : `(?:(?!${c(Q)}|${c(V)})[\\s\\S])`;
  }
  function j(V) {
    return V.tokens.map(function Q(re, ve, te) {
      if (re.type === "text")
        return o(re.value);
      if (re.type === "group")
        return `{${re.tokens.map(Q).join("")}}`;
      const M = D(re.name) && G(te[ve + 1]) ? re.name : JSON.stringify(re.name);
      if (re.type === "param")
        return `:${M}`;
      if (re.type === "wildcard")
        return `*${M}`;
      throw new TypeError(`Unexpected token: ${re}`);
    }).join("");
  }
  function D(V) {
    const [Q, ...re] = V;
    return r.test(Q) ? re.every((ve) => a.test(ve)) : !1;
  }
  function G(V) {
    return V?.type !== "text" ? !0 : !a.test(V.value[0]);
  }
  return dist;
}
var layer, hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer) return layer;
  hasRequiredLayer = 1;
  const { parse: e, format: t } = require$$0$5, { pathToRegexp: r, compile: a, parse: u } = requireDist();
  layer = class {
    /**
     * Initialize a new routing Layer with given `method`, `path`, and `middleware`.
     *
     * @param {String|RegExp} path Path string or regular expression.
     * @param {Array} methods Array of HTTP verbs.
     * @param {Array} middleware Layer callback/middleware or series of.
     * @param {Object=} opts
     * @param {String=} opts.name route name
     * @param {String=} opts.sensitive case sensitive (default: false)
     * @param {String=} opts.strict require the trailing slash (default: false)
     * @param {Boolean=} opts.pathAsRegExp if true, treat `path` as a regular expression
     * @returns {Layer}
     * @private
     */
    constructor(c, f, l, s = {}) {
      this.opts = s, this.name = this.opts.name || null, this.methods = [];
      for (const p of f) {
        const m = this.methods.push(p.toUpperCase());
        this.methods[m - 1] === "GET" && this.methods.unshift("HEAD");
      }
      this.stack = Array.isArray(l) ? l : [l];
      for (let p = 0; p < this.stack.length; p++) {
        const g = typeof this.stack[p];
        if (g !== "function")
          throw new Error(
            `${f.toString()} \`${this.opts.name || c}\`: \`middleware\` must be a function, not \`${g}\``
          );
      }
      if (this.path = c, this.paramNames = [], this.opts.pathAsRegExp === !0)
        this.regexp = new RegExp(c);
      else if (this.path) {
        "strict" in this.opts && (this.opts.trailing = this.opts.strict !== !0);
        const { regexp: p, keys: m } = r(this.path, this.opts);
        this.regexp = p, this.paramNames = m;
      }
    }
    /**
     * Returns whether request `path` matches route.
     *
     * @param {String} path
     * @returns {Boolean}
     * @private
     */
    match(c) {
      return this.regexp.test(c);
    }
    /**
     * Returns map of URL parameters for given `path` and `paramNames`.
     *
     * @param {String} path
     * @param {Array.<String>} captures
     * @param {Object=} params
     * @returns {Object}
     * @private
     */
    params(c, f, l = {}) {
      for (let s = f.length, p = 0; p < s; p++)
        if (this.paramNames[p]) {
          const m = f[p];
          m && m.length > 0 && (l[this.paramNames[p].name] = m && n(m));
        }
      return l;
    }
    /**
     * Returns array of regexp url path captures.
     *
     * @param {String} path
     * @returns {Array.<String>}
     * @private
     */
    captures(c) {
      return this.opts.ignoreCaptures ? [] : c.match(this.regexp).slice(1);
    }
    /**
     * Generate URL for route using given `params`.
     *
     * @example
     *
     * ```javascript
     * const route = new Layer('/users/:id', ['GET'], fn);
     *
     * route.url({ id: 123 }); // => "/users/123"
     * ```
     *
     * @param {Object} params url parameters
     * @returns {String}
     * @private
     */
    url(c, f) {
      let l = c;
      const s = this.path.replace(/\(\.\*\)/g, "");
      typeof c != "object" && (l = Array.prototype.slice.call(arguments), typeof l[l.length - 1] == "object" && (f = l[l.length - 1], l = l.slice(0, -1)));
      const p = a(s, { encode: encodeURIComponent, ...f });
      let m;
      const { tokens: g } = u(s);
      let y = {};
      if (Array.isArray(l))
        for (let v = g.length, E = 0, b = 0; E < v; E++)
          g[E].name && (y[g[E].name] = l[b++]);
      else g.some((v) => v.name) ? y = c : f || (f = c);
      for (const [v, E] of Object.entries(y))
        y[v] = String(E);
      return m = p(y), f && f.query ? (m = e(m), typeof f.query == "string" ? m.search = f.query : (m.search = void 0, m.query = f.query), t(m)) : m;
    }
    /**
     * Run validations on route named parameters.
     *
     * @example
     *
     * ```javascript
     * router
     *   .param('user', function (id, ctx, next) {
     *     ctx.user = users[id];
     *     if (!ctx.user) return ctx.status = 404;
     *     next();
     *   })
     *   .get('/users/:user', function (ctx, next) {
     *     ctx.body = ctx.user;
     *   });
     * ```
     *
     * @param {String} param
     * @param {Function} middleware
     * @returns {Layer}
     * @private
     */
    param(c, f) {
      const { stack: l } = this, s = this.paramNames, p = function(y, v) {
        return f.call(this, y.params[c], y, v);
      };
      p.param = c;
      const m = s.map(function(y) {
        return y.name;
      }), g = m.indexOf(c);
      return g > -1 && l.some((y, v) => {
        if (!y.param || m.indexOf(y.param) > g)
          return l.splice(v, 0, p), !0;
      }), this;
    }
    /**
     * Prefix route path.
     *
     * @param {String} prefix
     * @returns {Layer}
     * @private
     */
    setPrefix(c) {
      if (this.path) {
        if (this.path = this.path !== "/" || this.opts.strict === !0 ? `${c}${this.path}` : c, this.opts.pathAsRegExp === !0 || c instanceof RegExp)
          this.regexp = new RegExp(this.path);
        else if (this.path) {
          const { regexp: f, keys: l } = r(this.path, this.opts);
          this.regexp = f, this.paramNames = l;
        }
      }
      return this;
    }
  };
  function n(o) {
    try {
      return decodeURIComponent(o.replace(/\+/g, " "));
    } catch {
      return o;
    }
  }
  return layer;
}
var router$1, hasRequiredRouter;
function requireRouter() {
  if (hasRequiredRouter) return router$1;
  hasRequiredRouter = 1;
  const e = requireStreamHttp(), t = requireBrowser()("koa-router"), r = requireKoaCompose(), a = requireHttpErrors$1(), { pathToRegexp: u } = requireDist(), n = requireLayer(), o = e.METHODS.map((f) => f.toLowerCase());
  class c {
    /**
     * Create a new router.
     *
     * @example
     *
     * Basic usage:
     *
     * ```javascript
     * const Koa = require('koa');
     * const Router = require('@koa/router');
     *
     * const app = new Koa();
     * const router = new Router();
     *
     * router.get('/', (ctx, next) => {
     *   // ctx.router available
     * });
     *
     * app
     *   .use(router.routes())
     *   .use(router.allowedMethods());
     * ```
     *
     * @alias module:koa-router
     * @param {Object=} opts
     * @param {Boolean=false} opts.exclusive only run last matched route's controller when there are multiple matches
     * @param {String=} opts.prefix prefix router paths
     * @param {String|RegExp=} opts.host host for router match
     * @constructor
     */
    constructor(l = {}) {
      if (!(this instanceof c)) return new c(l);
      this.opts = l, this.methods = this.opts.methods || [
        "HEAD",
        "OPTIONS",
        "GET",
        "PUT",
        "PATCH",
        "POST",
        "DELETE"
      ], this.exclusive = !!this.opts.exclusive, this.params = {}, this.stack = [], this.host = this.opts.host;
    }
    /**
     * Generate URL from url pattern and given `params`.
     *
     * @example
     *
     * ```javascript
     * const url = Router.url('/users/:id', {id: 1});
     * // => "/users/1"
     * ```
     *
     * @param {String} path url pattern
     * @param {Object} params url parameters
     * @returns {String}
     */
    static url(l, ...s) {
      return n.prototype.url.apply({ path: l }, s);
    }
    /**
     * Use given middleware.
     *
     * Middleware run in the order they are defined by `.use()`. They are invoked
     * sequentially, requests start at the first middleware and work their way
     * "down" the middleware stack.
     *
     * @example
     *
     * ```javascript
     * // session middleware will run before authorize
     * router
     *   .use(session())
     *   .use(authorize());
     *
     * // use middleware only with given path
     * router.use('/users', userAuth());
     *
     * // or with an array of paths
     * router.use(['/users', '/admin'], userAuth());
     *
     * app.use(router.routes());
     * ```
     *
     * @param {String=} path
     * @param {Function} middleware
     * @param {Function=} ...
     * @returns {Router}
     */
    use(...l) {
      const s = this;
      let p;
      if (Array.isArray(l[0]) && typeof l[0][0] == "string") {
        const g = l[0];
        for (const y of g)
          s.use.apply(s, [y, ...l.slice(1)]);
        return this;
      }
      const m = typeof l[0] == "string";
      m && (p = l.shift());
      for (const g of l)
        if (g.router) {
          const y = Object.assign(
            Object.create(c.prototype),
            g.router,
            {
              stack: [...g.router.stack]
            }
          );
          for (let v = 0; v < y.stack.length; v++) {
            const E = y.stack[v], b = Object.assign(
              Object.create(n.prototype),
              E
            );
            p && b.setPrefix(p), s.opts.prefix && b.setPrefix(s.opts.prefix), s.stack.push(b), y.stack[v] = b;
          }
          if (s.params) {
            const v = Object.keys(s.params);
            for (const E of v)
              y.param(E, s.params[E]);
          }
        } else {
          const { keys: y } = u(s.opts.prefix || "", s.opts), v = !!(s.opts.prefix && y.length > 0);
          s.register(p || "([^/]*)", [], g, {
            end: !1,
            ignoreCaptures: !m && !v,
            pathAsRegExp: !0
          });
        }
      return this;
    }
    /**
     * Set the path prefix for a Router instance that was already initialized.
     *
     * @example
     *
     * ```javascript
     * router.prefix('/things/:thing_id')
     * ```
     *
     * @param {String} prefix
     * @returns {Router}
     */
    prefix(l) {
      l = l.replace(/\/$/, ""), this.opts.prefix = l;
      for (let s = 0; s < this.stack.length; s++)
        this.stack[s].setPrefix(l);
      return this;
    }
    /**
     * Returns router middleware which dispatches a route matching the request.
     *
     * @returns {Function}
     */
    middleware() {
      const l = this, s = (p, m) => {
        if (t("%s %s", p.method, p.path), !l.matchHost(p.host))
          return m();
        const y = l.opts.routerPath || p.newRouterPath || p.path || p.routerPath, v = l.match(y, p.method);
        if (p.matched ? p.matched.push.apply(p.matched, v.path) : p.matched = v.path, p.router = l, !v.route) return m();
        const E = v.pathAndMethod, b = E[E.length - 1];
        p._matchedRoute = b.path, b.name && (p._matchedRouteName = b.name);
        const q = (l.exclusive ? [b] : E).reduce((O, j) => (O.push((D, G) => (D.captures = j.captures(y, D.captures), D.request.params = j.params(y, D.captures, D.params), D.params = D.request.params, D.routerPath = j.path, D.routerName = j.name, D._matchedRoute = j.path, j.name && (D._matchedRouteName = j.name), G())), [...O, ...j.stack]), []);
        return r(q)(p, m);
      };
      return s.router = this, s;
    }
    routes() {
      return this.middleware();
    }
    /**
     * Returns separate middleware for responding to `OPTIONS` requests with
     * an `Allow` header containing the allowed methods, as well as responding
     * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.
     *
     * @example
     *
     * ```javascript
     * const Koa = require('koa');
     * const Router = require('@koa/router');
     *
     * const app = new Koa();
     * const router = new Router();
     *
     * app.use(router.routes());
     * app.use(router.allowedMethods());
     * ```
     *
     * **Example with [Boom](https://github.com/hapijs/boom)**
     *
     * ```javascript
     * const Koa = require('koa');
     * const Router = require('@koa/router');
     * const Boom = require('boom');
     *
     * const app = new Koa();
     * const router = new Router();
     *
     * app.use(router.routes());
     * app.use(router.allowedMethods({
     *   throw: true,
     *   notImplemented: () => new Boom.notImplemented(),
     *   methodNotAllowed: () => new Boom.methodNotAllowed()
     * }));
     * ```
     *
     * @param {Object=} options
     * @param {Boolean=} options.throw throw error instead of setting status and header
     * @param {Function=} options.notImplemented throw the returned value in place of the default NotImplemented error
     * @param {Function=} options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error
     * @returns {Function}
     */
    allowedMethods(l = {}) {
      const s = this.methods;
      return (p, m) => m().then(() => {
        const g = {};
        if (p.matched && (!p.status || p.status === 404)) {
          for (let v = 0; v < p.matched.length; v++) {
            const E = p.matched[v];
            for (let b = 0; b < E.methods.length; b++) {
              const q = E.methods[b];
              g[q] = q;
            }
          }
          const y = Object.keys(g);
          if (s.includes(p.method)) {
            if (y.length > 0) {
              if (p.method === "OPTIONS")
                p.status = 200, p.body = "", p.set("Allow", y.join(", "));
              else if (!g[p.method]) {
                if (l.throw)
                  throw typeof l.methodNotAllowed == "function" ? l.methodNotAllowed() : new a.MethodNotAllowed();
                p.status = 405, p.set("Allow", y.join(", "));
              }
            }
          } else {
            if (l.throw)
              throw typeof l.notImplemented == "function" ? l.notImplemented() : new a.NotImplemented();
            p.status = 501, p.set("Allow", y.join(", "));
          }
        }
      });
    }
    /**
     * Register route with all methods.
     *
     * @param {String} name Optional.
     * @param {String} path
     * @param {Function=} middleware You may also pass multiple middleware.
     * @param {Function} callback
     * @returns {Router}
     */
    all(l, s, p) {
      if (typeof s == "string" || s instanceof RegExp ? p = Array.prototype.slice.call(arguments, 2) : (p = Array.prototype.slice.call(arguments, 1), s = l, l = null), typeof s != "string" && !(s instanceof RegExp) && (!Array.isArray(s) || s.length === 0))
        throw new Error("You have to provide a path when adding an all handler");
      const m = {
        name: l,
        pathAsRegExp: s instanceof RegExp
      };
      return this.register(s, o, p, { ...this.opts, ...m }), this;
    }
    /**
     * Redirect `source` to `destination` URL with optional 30x status `code`.
     *
     * Both `source` and `destination` can be route names.
     *
     * ```javascript
     * router.redirect('/login', 'sign-in');
     * ```
     *
     * This is equivalent to:
     *
     * ```javascript
     * router.all('/login', ctx => {
     *   ctx.redirect('/sign-in');
     *   ctx.status = 301;
     * });
     * ```
     *
     * @param {String} source URL or route name.
     * @param {String} destination URL or route name.
     * @param {Number=} code HTTP status code (default: 301).
     * @returns {Router}
     */
    redirect(l, s, p) {
      if ((typeof l == "symbol" || l[0] !== "/") && (l = this.url(l), l instanceof Error))
        throw l;
      if ((typeof s == "symbol" || s[0] !== "/" && !s.includes("://")) && (s = this.url(s), s instanceof Error))
        throw s;
      return this.all(l, (m) => {
        m.redirect(s), m.status = p || 301;
      });
    }
    /**
     * Create and register a route.
     *
     * @param {String} path Path string.
     * @param {Array.<String>} methods Array of HTTP verbs.
     * @param {Function} middleware Multiple middleware also accepted.
     * @returns {Layer}
     * @private
     */
    register(l, s, p, m = {}) {
      const g = this, { stack: y } = this, v = { ...this.opts, ...m };
      if (Array.isArray(l)) {
        for (const b of l)
          g.register.call(g, b, s, p, v);
        return this;
      }
      const E = new n(l, s, p, {
        end: v.end === !1 ? v.end : !0,
        name: v.name,
        sensitive: v.sensitive || !1,
        strict: v.strict || !1,
        prefix: v.prefix || "",
        ignoreCaptures: v.ignoreCaptures,
        pathAsRegExp: v.pathAsRegExp
      });
      this.opts.prefix && E.setPrefix(this.opts.prefix);
      for (let b = 0; b < Object.keys(this.params).length; b++) {
        const q = Object.keys(this.params)[b];
        E.param(q, this.params[q]);
      }
      return y.push(E), t("defined route %s %s", E.methods, E.path), E;
    }
    /**
     * Lookup route with given `name`.
     *
     * @param {String} name
     * @returns {Layer|false}
     */
    route(l) {
      const s = this.stack;
      for (let p = s.length, m = 0; m < p; m++)
        if (s[m].name && s[m].name === l) return s[m];
      return !1;
    }
    /**
     * Generate URL for route. Takes a route name and map of named `params`.
     *
     * @example
     *
     * ```javascript
     * router.get('user', '/users/:id', (ctx, next) => {
     *   // ...
     * });
     *
     * router.url('user', 3);
     * // => "/users/3"
     *
     * router.url('user', { id: 3 });
     * // => "/users/3"
     *
     * router.use((ctx, next) => {
     *   // redirect to named route
     *   ctx.redirect(ctx.router.url('sign-in'));
     * })
     *
     * router.url('user', { id: 3 }, { query: { limit: 1 } });
     * // => "/users/3?limit=1"
     *
     * router.url('user', { id: 3 }, { query: "limit=1" });
     * // => "/users/3?limit=1"
     * ```
     *
     * @param {String} name route name
     * @param {Object} params url parameters
     * @param {Object} [options] options parameter
     * @param {Object|String} [options.query] query options
     * @returns {String|Error}
     */
    url(l, ...s) {
      const p = this.route(l);
      return p ? p.url.apply(p, s) : new Error(`No route found for name: ${String(l)}`);
    }
    /**
     * Match given `path` and return corresponding routes.
     *
     * @param {String} path
     * @param {String} method
     * @returns {Object.<path, pathAndMethod>} returns layers that matched path and
     * path and method.
     * @private
     */
    match(l, s) {
      const p = this.stack;
      let m;
      const g = {
        path: [],
        pathAndMethod: [],
        route: !1
      };
      for (let y = p.length, v = 0; v < y; v++)
        m = p[v], t("test %s %s", m.path, m.regexp), m.match(l) && (g.path.push(m), (m.methods.length === 0 || m.methods.includes(s)) && (g.pathAndMethod.push(m), m.methods.length > 0 && (g.route = !0)));
      return g;
    }
    /**
     * Match given `input` to allowed host
     * @param {String} input
     * @returns {boolean}
     */
    matchHost(l) {
      const { host: s } = this;
      if (!s)
        return !0;
      if (!l)
        return !1;
      if (typeof s == "string")
        return l === s;
      if (typeof s == "object" && s instanceof RegExp)
        return s.test(l);
    }
    /**
     * Run middleware for named route parameters. Useful for auto-loading or
     * validation.
     *
     * @example
     *
     * ```javascript
     * router
     *   .param('user', (id, ctx, next) => {
     *     ctx.user = users[id];
     *     if (!ctx.user) return ctx.status = 404;
     *     return next();
     *   })
     *   .get('/users/:user', ctx => {
     *     ctx.body = ctx.user;
     *   })
     *   .get('/users/:user/friends', ctx => {
     *     return ctx.user.getFriends().then(function(friends) {
     *       ctx.body = friends;
     *     });
     *   })
     *   // /users/3 => {"id": 3, "name": "Alex"}
     *   // /users/3/friends => [{"id": 4, "name": "TJ"}]
     * ```
     *
     * @param {String} param
     * @param {Function} middleware
     * @returns {Router}
     */
    param(l, s) {
      this.params[l] = s;
      for (let p = 0; p < this.stack.length; p++)
        this.stack[p].param(l, s);
      return this;
    }
  }
  for (const f of o)
    c.prototype[f] = function(l, s, p) {
      if (typeof s == "string" || s instanceof RegExp ? p = Array.prototype.slice.call(arguments, 2) : (p = Array.prototype.slice.call(arguments, 1), s = l, l = null), typeof s != "string" && !(s instanceof RegExp) && (!Array.isArray(s) || s.length === 0))
        throw new Error(
          `You have to provide a path when adding a ${f} handler`
        );
      const m = {
        name: l,
        pathAsRegExp: s instanceof RegExp
      };
      return this.register(s, [f], p, { ...this.opts, ...m }), this;
    };
  return c.prototype.del = c.prototype.delete, router$1 = c, router$1;
}
var routerExports = requireRouter();
const KoaRouter = /* @__PURE__ */ getDefaultExportFromCjs(routerExports), DOCTYPE = "<!DOCTYPE html>", escapeHtml = (e) => String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
function createElement(e, t, ...r) {
  t = t || {};
  const a = r.flat(1 / 0).filter((u) => u !== !1 && u !== null && u !== void 0);
  return {
    type: e,
    props: t,
    children: a
  };
}
class Component {
  props;
  state;
  constructor(t) {
    this.props = t, this.state = {};
  }
  setState(t) {
    this.state = Object.assign({}, this.state, t);
  }
  render() {
    return "";
  }
  // 修复：使用 this（子类）来创建实例，而不是固定的 Component
  static renderToString() {
    return renderToString(createElement(this, null));
  }
  static renderToHtml() {
    return DOCTYPE + this.renderToString();
  }
}
function attrsToString(e = {}) {
  const t = [];
  for (const r of Object.keys(e)) {
    if (r === "children")
      continue;
    const a = e[r];
    if (!(a === !1 || a === void 0 || a === null)) {
      if (r === "className") {
        t.push(`class="${escapeHtml(String(a))}"`);
        continue;
      }
      if (r === "style" && typeof a == "object") {
        const u = Object.entries(a).map(([n, o]) => `${n.replace(/[A-Z]/g, (c) => "-" + c.toLowerCase())}:${o}`).join(";");
        t.push(`style="${escapeHtml(u)}"`);
        continue;
      }
      if (a === !0) {
        t.push(`${r}`);
        continue;
      }
      t.push(`${r}="${escapeHtml(String(a))}"`);
    }
  }
  return t.length ? " " + t.join(" ") : "";
}
const voidTags = /* @__PURE__ */ new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]);
function renderToString(e) {
  if (e == null || e === !1)
    return "";
  if (typeof e == "string" || typeof e == "number")
    return escapeHtml(String(e));
  if (typeof e == "object" && e.type === void 0)
    return (e.children ?? []).map(renderToString).join("");
  if (typeof e.type == "function") {
    const n = e.type;
    if (n.prototype && typeof n.prototype.render == "function") {
      const c = new n(Object.assign({}, e.props, { children: e.children })).render();
      return renderToString(c);
    } else {
      const o = n(Object.assign({}, e.props, { children: e.children }));
      return renderToString(o);
    }
  }
  const t = String(e.type), r = e.props ?? {};
  if (r?.dangerouslySetInnerHTML && typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML.__html !== null) {
    const n = attrsToString(r), o = String(r.dangerouslySetInnerHTML.__html);
    return `<${t}${n}>${o}</${t}>`;
  }
  const a = attrsToString(r);
  if (voidTags.has(t.toLowerCase()))
    return `<${t}${a} />`;
  const u = (e.children ?? []).map(renderToString).join("");
  return `<${t}${a}>${u}</${t}>`;
}
function makeTag(e) {
  return function(r, ...a) {
    if (r !== null && typeof r == "object" && !Array.isArray(r) && Object.prototype.toString.call(r) === "[object Object]")
      return createElement(e, r, ...a);
    {
      const n = [];
      return r != null && n.push(r), n.push(...a), createElement(e, null, ...n);
    }
  };
}
const Html = makeTag("html"), Head = makeTag("head"), Body = makeTag("body"), Title = makeTag("title"), Style = makeTag("style"), H1 = makeTag("h1"), P = makeTag("p"), A = makeTag("a"), Div = makeTag("div");
class App extends Component {
  render() {
    const r = Head(null, Title("欢迎使用 AlemonJS！"), Style(`
      body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
        background-color: #f8f8f8;
        color: #333;
      }
      h1 {
        color: #0099cc;
        margin-top: 2em;
      }
      .footer {
        margin-top: 3em;
        font-size: 0.9em;
        color: #888;
      }
      a { color: #0099cc; }
    `)), a = Body(
      null,
      H1("AlemonJS 启动成功！"),
      P(null, "已成功通过 ", A({ href: "https://alemonjs.com", target: "_blank" }, "AlemonJS 框架"), " 启动。"),
      Div({ className: "footer" }, "— 感谢选择 AlemonJS。")
    );
    return Html(null, r, a);
  }
}
const hello = App.renderToHtml(), router = new KoaRouter({
  prefix: "/"
});
router.get("/", (e) => {
  e.status = 200, e.set("Content-Type", "text/html; charset=utf-8"), e.body = hello;
});
router.get("api/online", (e) => {
  e.status = 200, e.body = {
    code: 200,
    message: "service online",
    data: null
  };
});
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports, hasRequiredLodash;
function requireLodash() {
  return hasRequiredLodash || (hasRequiredLodash = 1, (function(e, t) {
    (function() {
      var r, a = "4.17.21", u = 200, n = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", c = "Invalid `variable` option passed into `_.template`", f = "__lodash_hash_undefined__", l = 500, s = "__lodash_placeholder__", p = 1, m = 2, g = 4, y = 1, v = 2, E = 1, b = 2, q = 4, O = 8, j = 16, D = 32, G = 64, V = 128, Q = 256, re = 512, ve = 30, te = "...", R = 800, M = 16, h = 1, S = 2, B = 3, T = 1 / 0, k = 9007199254740991, I = 17976931348623157e292, C = NaN, $ = 4294967295, w = $ - 1, U = $ >>> 1, ie = [
        ["ary", V],
        ["bind", E],
        ["bindKey", b],
        ["curry", O],
        ["curryRight", j],
        ["flip", re],
        ["partial", D],
        ["partialRight", G],
        ["rearg", Q]
      ], le = "[object Arguments]", ee = "[object Array]", F = "[object AsyncFunction]", z = "[object Boolean]", se = "[object Date]", he = "[object DOMException]", ae = "[object Error]", X = "[object Function]", be = "[object GeneratorFunction]", Re = "[object Map]", Pe = "[object Number]", Fe = "[object Null]", De = "[object Object]", je = "[object Promise]", Oe = "[object Proxy]", rt = "[object RegExp]", He = "[object Set]", Qe = "[object String]", Je = "[object Symbol]", we = "[object Undefined]", Ae = "[object WeakMap]", ze = "[object WeakSet]", Ue = "[object ArrayBuffer]", Ge = "[object DataView]", Xe = "[object Float32Array]", oe = "[object Float64Array]", L = "[object Int8Array]", H = "[object Int16Array]", ue = "[object Int32Array]", xe = "[object Uint8Array]", pe = "[object Uint8ClampedArray]", ce = "[object Uint16Array]", Y = "[object Uint32Array]", Te = /\b__p \+= '';/g, Ne = /\b(__p \+=) '' \+/g, K = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Se = /&(?:amp|lt|gt|quot|#39);/g, Ce = /[&<>"']/g, de = RegExp(Se.source), _e = RegExp(Ce.source), Me = /<%-([\s\S]+?)%>/g, tt = /<%([\s\S]+?)%>/g, We = /<%=([\s\S]+?)%>/g, ne = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, W = /^\w*$/, J = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, me = /[\\^$.*+?()[\]{}|]/g, Ee = RegExp(me.source), ke = /^\s+/, Ie = /\s/, at = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ot = /\{\n\/\* \[wrapped with (.+)\] \*/, it = /,? & /, ct = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, nt = /[()=,{}\[\]\/\s]/, st = /\\(\\)?/g, yt = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, ft = /\w*$/, dt = /^[-+]0x[0-9a-f]+$/i, Ut = /^0b[01]+$/i, Lt = /^\[object .+?Constructor\]$/, Dt = /^0o[0-7]+$/i, Yt = /^(?:0|[1-9]\d*)$/, Kt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Wt = /($^)/, or = /['\n\r\u2028\u2029\\]/g, Gt = "\\ud800-\\udfff", cr = "\\u0300-\\u036f", ur = "\\ufe20-\\ufe2f", lr = "\\u20d0-\\u20ff", er = cr + ur + lr, tr = "\\u2700-\\u27bf", rr = "a-z\\xdf-\\xf6\\xf8-\\xff", fr = "\\xac\\xb1\\xd7\\xf7", pr = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", dr = "\\u2000-\\u206f", Lr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Ir = "A-Z\\xc0-\\xd6\\xd8-\\xde", Na = "\\ufe0e\\ufe0f", ja = fr + pr + dr + Lr, Mn = "['’]", lc = "[" + Gt + "]", Da = "[" + ja + "]", Di = "[" + er + "]", Fa = "\\d+", fc = "[" + tr + "]", Ua = "[" + rr + "]", za = "[^" + Gt + ja + Fa + tr + rr + Ir + "]", Tn = "\\ud83c[\\udffb-\\udfff]", pc = "(?:" + Di + "|" + Tn + ")", Ha = "[^" + Gt + "]", Cn = "(?:\\ud83c[\\udde6-\\uddff]){2}", kn = "[\\ud800-\\udbff][\\udc00-\\udfff]", fi = "[" + Ir + "]", Ka = "\\u200d", Wa = "(?:" + Ua + "|" + za + ")", dc = "(?:" + fi + "|" + za + ")", Ga = "(?:" + Mn + "(?:d|ll|m|re|s|t|ve))?", Va = "(?:" + Mn + "(?:D|LL|M|RE|S|T|VE))?", Za = pc + "?", Ya = "[" + Na + "]?", hc = "(?:" + Ka + "(?:" + [Ha, Cn, kn].join("|") + ")" + Ya + Za + ")*", mc = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", vc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Ja = Ya + Za + hc, gc = "(?:" + [fc, Cn, kn].join("|") + ")" + Ja, bc = "(?:" + [Ha + Di + "?", Di, Cn, kn, lc].join("|") + ")", yc = RegExp(Mn, "g"), xc = RegExp(Di, "g"), Bn = RegExp(Tn + "(?=" + Tn + ")|" + bc + Ja, "g"), wc = RegExp([
        fi + "?" + Ua + "+" + Ga + "(?=" + [Da, fi, "$"].join("|") + ")",
        dc + "+" + Va + "(?=" + [Da, fi + Wa, "$"].join("|") + ")",
        fi + "?" + Wa + "+" + Ga,
        fi + "+" + Va,
        vc,
        mc,
        Fa,
        gc
      ].join("|"), "g"), _c = RegExp("[" + Ka + Gt + er + Na + "]"), Sc = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ec = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Rc = -1, kt = {};
      kt[Xe] = kt[oe] = kt[L] = kt[H] = kt[ue] = kt[xe] = kt[pe] = kt[ce] = kt[Y] = !0, kt[le] = kt[ee] = kt[Ue] = kt[z] = kt[Ge] = kt[se] = kt[ae] = kt[X] = kt[Re] = kt[Pe] = kt[De] = kt[rt] = kt[He] = kt[Qe] = kt[Ae] = !1;
      var Ct = {};
      Ct[le] = Ct[ee] = Ct[Ue] = Ct[Ge] = Ct[z] = Ct[se] = Ct[Xe] = Ct[oe] = Ct[L] = Ct[H] = Ct[ue] = Ct[Re] = Ct[Pe] = Ct[De] = Ct[rt] = Ct[He] = Ct[Qe] = Ct[Je] = Ct[xe] = Ct[pe] = Ct[ce] = Ct[Y] = !0, Ct[ae] = Ct[X] = Ct[Ae] = !1;
      var qc = {
        // Latin-1 Supplement block.
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        // Latin Extended-A block.
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s"
      }, Ac = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, Mc = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, Tc = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Cc = parseFloat, kc = parseInt, Xa = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, Bc = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, zt = Xa || Bc || Function("return this")(), In = t && !t.nodeType && t, ri = In && !0 && e && !e.nodeType && e, Qa = ri && ri.exports === In, $n = Qa && Xa.process, wr = (function() {
        try {
          var $e = ri && ri.require && ri.require("util").types;
          return $e || $n && $n.binding && $n.binding("util");
        } catch {
        }
      })(), es = wr && wr.isArrayBuffer, ts = wr && wr.isDate, rs = wr && wr.isMap, is = wr && wr.isRegExp, ns = wr && wr.isSet, as = wr && wr.isTypedArray;
      function hr($e, Ve, Ke) {
        switch (Ke.length) {
          case 0:
            return $e.call(Ve);
          case 1:
            return $e.call(Ve, Ke[0]);
          case 2:
            return $e.call(Ve, Ke[0], Ke[1]);
          case 3:
            return $e.call(Ve, Ke[0], Ke[1], Ke[2]);
        }
        return $e.apply(Ve, Ke);
      }
      function Ic($e, Ve, Ke, lt) {
        for (var gt = -1, qt = $e == null ? 0 : $e.length; ++gt < qt; ) {
          var Nt = $e[gt];
          Ve(lt, Nt, Ke(Nt), $e);
        }
        return lt;
      }
      function _r($e, Ve) {
        for (var Ke = -1, lt = $e == null ? 0 : $e.length; ++Ke < lt && Ve($e[Ke], Ke, $e) !== !1; )
          ;
        return $e;
      }
      function $c($e, Ve) {
        for (var Ke = $e == null ? 0 : $e.length; Ke-- && Ve($e[Ke], Ke, $e) !== !1; )
          ;
        return $e;
      }
      function ss($e, Ve) {
        for (var Ke = -1, lt = $e == null ? 0 : $e.length; ++Ke < lt; )
          if (!Ve($e[Ke], Ke, $e))
            return !1;
        return !0;
      }
      function Gr($e, Ve) {
        for (var Ke = -1, lt = $e == null ? 0 : $e.length, gt = 0, qt = []; ++Ke < lt; ) {
          var Nt = $e[Ke];
          Ve(Nt, Ke, $e) && (qt[gt++] = Nt);
        }
        return qt;
      }
      function Fi($e, Ve) {
        var Ke = $e == null ? 0 : $e.length;
        return !!Ke && pi($e, Ve, 0) > -1;
      }
      function On($e, Ve, Ke) {
        for (var lt = -1, gt = $e == null ? 0 : $e.length; ++lt < gt; )
          if (Ke(Ve, $e[lt]))
            return !0;
        return !1;
      }
      function Bt($e, Ve) {
        for (var Ke = -1, lt = $e == null ? 0 : $e.length, gt = Array(lt); ++Ke < lt; )
          gt[Ke] = Ve($e[Ke], Ke, $e);
        return gt;
      }
      function Vr($e, Ve) {
        for (var Ke = -1, lt = Ve.length, gt = $e.length; ++Ke < lt; )
          $e[gt + Ke] = Ve[Ke];
        return $e;
      }
      function Pn($e, Ve, Ke, lt) {
        var gt = -1, qt = $e == null ? 0 : $e.length;
        for (lt && qt && (Ke = $e[++gt]); ++gt < qt; )
          Ke = Ve(Ke, $e[gt], gt, $e);
        return Ke;
      }
      function Oc($e, Ve, Ke, lt) {
        var gt = $e == null ? 0 : $e.length;
        for (lt && gt && (Ke = $e[--gt]); gt--; )
          Ke = Ve(Ke, $e[gt], gt, $e);
        return Ke;
      }
      function Ln($e, Ve) {
        for (var Ke = -1, lt = $e == null ? 0 : $e.length; ++Ke < lt; )
          if (Ve($e[Ke], Ke, $e))
            return !0;
        return !1;
      }
      var Pc = Nn("length");
      function Lc($e) {
        return $e.split("");
      }
      function Nc($e) {
        return $e.match(ct) || [];
      }
      function os($e, Ve, Ke) {
        var lt;
        return Ke($e, function(gt, qt, Nt) {
          if (Ve(gt, qt, Nt))
            return lt = qt, !1;
        }), lt;
      }
      function Ui($e, Ve, Ke, lt) {
        for (var gt = $e.length, qt = Ke + (lt ? 1 : -1); lt ? qt-- : ++qt < gt; )
          if (Ve($e[qt], qt, $e))
            return qt;
        return -1;
      }
      function pi($e, Ve, Ke) {
        return Ve === Ve ? Yc($e, Ve, Ke) : Ui($e, cs, Ke);
      }
      function jc($e, Ve, Ke, lt) {
        for (var gt = Ke - 1, qt = $e.length; ++gt < qt; )
          if (lt($e[gt], Ve))
            return gt;
        return -1;
      }
      function cs($e) {
        return $e !== $e;
      }
      function us($e, Ve) {
        var Ke = $e == null ? 0 : $e.length;
        return Ke ? Dn($e, Ve) / Ke : C;
      }
      function Nn($e) {
        return function(Ve) {
          return Ve == null ? r : Ve[$e];
        };
      }
      function jn($e) {
        return function(Ve) {
          return $e == null ? r : $e[Ve];
        };
      }
      function ls($e, Ve, Ke, lt, gt) {
        return gt($e, function(qt, Nt, Tt) {
          Ke = lt ? (lt = !1, qt) : Ve(Ke, qt, Nt, Tt);
        }), Ke;
      }
      function Dc($e, Ve) {
        var Ke = $e.length;
        for ($e.sort(Ve); Ke--; )
          $e[Ke] = $e[Ke].value;
        return $e;
      }
      function Dn($e, Ve) {
        for (var Ke, lt = -1, gt = $e.length; ++lt < gt; ) {
          var qt = Ve($e[lt]);
          qt !== r && (Ke = Ke === r ? qt : Ke + qt);
        }
        return Ke;
      }
      function Fn($e, Ve) {
        for (var Ke = -1, lt = Array($e); ++Ke < $e; )
          lt[Ke] = Ve(Ke);
        return lt;
      }
      function Fc($e, Ve) {
        return Bt(Ve, function(Ke) {
          return [Ke, $e[Ke]];
        });
      }
      function ps($e) {
        return $e && $e.slice(0, gs($e) + 1).replace(ke, "");
      }
      function vr($e) {
        return function(Ve) {
          return $e(Ve);
        };
      }
      function Un($e, Ve) {
        return Bt(Ve, function(Ke) {
          return $e[Ke];
        });
      }
      function Ri($e, Ve) {
        return $e.has(Ve);
      }
      function ds($e, Ve) {
        for (var Ke = -1, lt = $e.length; ++Ke < lt && pi(Ve, $e[Ke], 0) > -1; )
          ;
        return Ke;
      }
      function hs($e, Ve) {
        for (var Ke = $e.length; Ke-- && pi(Ve, $e[Ke], 0) > -1; )
          ;
        return Ke;
      }
      function Uc($e, Ve) {
        for (var Ke = $e.length, lt = 0; Ke--; )
          $e[Ke] === Ve && ++lt;
        return lt;
      }
      var zc = jn(qc), Hc = jn(Ac);
      function Kc($e) {
        return "\\" + Tc[$e];
      }
      function Wc($e, Ve) {
        return $e == null ? r : $e[Ve];
      }
      function di($e) {
        return _c.test($e);
      }
      function Gc($e) {
        return Sc.test($e);
      }
      function Vc($e) {
        for (var Ve, Ke = []; !(Ve = $e.next()).done; )
          Ke.push(Ve.value);
        return Ke;
      }
      function zn($e) {
        var Ve = -1, Ke = Array($e.size);
        return $e.forEach(function(lt, gt) {
          Ke[++Ve] = [gt, lt];
        }), Ke;
      }
      function vs($e, Ve) {
        return function(Ke) {
          return $e(Ve(Ke));
        };
      }
      function Zr($e, Ve) {
        for (var Ke = -1, lt = $e.length, gt = 0, qt = []; ++Ke < lt; ) {
          var Nt = $e[Ke];
          (Nt === Ve || Nt === s) && ($e[Ke] = s, qt[gt++] = Ke);
        }
        return qt;
      }
      function zi($e) {
        var Ve = -1, Ke = Array($e.size);
        return $e.forEach(function(lt) {
          Ke[++Ve] = lt;
        }), Ke;
      }
      function Zc($e) {
        var Ve = -1, Ke = Array($e.size);
        return $e.forEach(function(lt) {
          Ke[++Ve] = [lt, lt];
        }), Ke;
      }
      function Yc($e, Ve, Ke) {
        for (var lt = Ke - 1, gt = $e.length; ++lt < gt; )
          if ($e[lt] === Ve)
            return lt;
        return -1;
      }
      function Jc($e, Ve, Ke) {
        for (var lt = Ke + 1; lt--; )
          if ($e[lt] === Ve)
            return lt;
        return lt;
      }
      function hi($e) {
        return di($e) ? Qc($e) : Pc($e);
      }
      function Tr($e) {
        return di($e) ? eu($e) : Lc($e);
      }
      function gs($e) {
        for (var Ve = $e.length; Ve-- && Ie.test($e.charAt(Ve)); )
          ;
        return Ve;
      }
      var Xc = jn(Mc);
      function Qc($e) {
        for (var Ve = Bn.lastIndex = 0; Bn.test($e); )
          ++Ve;
        return Ve;
      }
      function eu($e) {
        return $e.match(Bn) || [];
      }
      function tu($e) {
        return $e.match(wc) || [];
      }
      var ru = (function $e(Ve) {
        Ve = Ve == null ? zt : mi.defaults(zt.Object(), Ve, mi.pick(zt, Ec));
        var Ke = Ve.Array, lt = Ve.Date, gt = Ve.Error, qt = Ve.Function, Nt = Ve.Math, Tt = Ve.Object, Hn = Ve.RegExp, iu = Ve.String, Sr = Ve.TypeError, Hi = Ke.prototype, nu = qt.prototype, vi = Tt.prototype, Ki = Ve["__core-js_shared__"], Wi = nu.toString, Mt = vi.hasOwnProperty, au = 0, bs = (function() {
          var d = /[^.]+$/.exec(Ki && Ki.keys && Ki.keys.IE_PROTO || "");
          return d ? "Symbol(src)_1." + d : "";
        })(), Gi = vi.toString, su = Wi.call(Tt), ou = zt._, cu = Hn(
          "^" + Wi.call(Mt).replace(me, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), Vi = Qa ? Ve.Buffer : r, Yr = Ve.Symbol, Zi = Ve.Uint8Array, ys = Vi ? Vi.allocUnsafe : r, Yi = vs(Tt.getPrototypeOf, Tt), xs = Tt.create, ws = vi.propertyIsEnumerable, Ji = Hi.splice, _s = Yr ? Yr.isConcatSpreadable : r, qi = Yr ? Yr.iterator : r, ii = Yr ? Yr.toStringTag : r, Xi = (function() {
          try {
            var d = ci(Tt, "defineProperty");
            return d({}, "", {}), d;
          } catch {
          }
        })(), uu = Ve.clearTimeout !== zt.clearTimeout && Ve.clearTimeout, lu = lt && lt.now !== zt.Date.now && lt.now, fu = Ve.setTimeout !== zt.setTimeout && Ve.setTimeout, Qi = Nt.ceil, en = Nt.floor, Kn = Tt.getOwnPropertySymbols, pu = Vi ? Vi.isBuffer : r, Ss = Ve.isFinite, du = Hi.join, hu = vs(Tt.keys, Tt), jt = Nt.max, Vt = Nt.min, mu = lt.now, vu = Ve.parseInt, Es = Nt.random, gu = Hi.reverse, Wn = ci(Ve, "DataView"), Ai = ci(Ve, "Map"), Gn = ci(Ve, "Promise"), gi = ci(Ve, "Set"), Mi = ci(Ve, "WeakMap"), Ti = ci(Tt, "create"), tn = Mi && new Mi(), bi = {}, bu = ui(Wn), yu = ui(Ai), xu = ui(Gn), wu = ui(gi), _u = ui(Mi), rn = Yr ? Yr.prototype : r, Ci = rn ? rn.valueOf : r, Rs = rn ? rn.toString : r;
        function ge(d) {
          if ($t(d) && !bt(d) && !(d instanceof Et)) {
            if (d instanceof Er)
              return d;
            if (Mt.call(d, "__wrapped__"))
              return Ao(d);
          }
          return new Er(d);
        }
        var yi = /* @__PURE__ */ (function() {
          function d() {
          }
          return function(x) {
            if (!It(x))
              return {};
            if (xs)
              return xs(x);
            d.prototype = x;
            var N = new d();
            return d.prototype = r, N;
          };
        })();
        function nn() {
        }
        function Er(d, x) {
          this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!x, this.__index__ = 0, this.__values__ = r;
        }
        ge.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: Me,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: tt,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: We,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: ge
          }
        }, ge.prototype = nn.prototype, ge.prototype.constructor = ge, Er.prototype = yi(nn.prototype), Er.prototype.constructor = Er;
        function Et(d) {
          this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = $, this.__views__ = [];
        }
        function Su() {
          var d = new Et(this.__wrapped__);
          return d.__actions__ = ir(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = ir(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = ir(this.__views__), d;
        }
        function Eu() {
          if (this.__filtered__) {
            var d = new Et(this);
            d.__dir__ = -1, d.__filtered__ = !0;
          } else
            d = this.clone(), d.__dir__ *= -1;
          return d;
        }
        function Ru() {
          var d = this.__wrapped__.value(), x = this.__dir__, N = bt(d), Z = x < 0, fe = N ? d.length : 0, ye = Ll(0, fe, this.__views__), qe = ye.start, Be = ye.end, Le = Be - qe, Ze = Z ? Be : qe - 1, Ye = this.__iteratees__, et = Ye.length, ut = 0, pt = Vt(Le, this.__takeCount__);
          if (!N || !Z && fe == Le && pt == Le)
            return Zs(d, this.__actions__);
          var mt = [];
          e:
            for (; Le-- && ut < pt; ) {
              Ze += x;
              for (var wt = -1, vt = d[Ze]; ++wt < et; ) {
                var St = Ye[wt], Rt = St.iteratee, yr = St.type, Qt = Rt(vt);
                if (yr == S)
                  vt = Qt;
                else if (!Qt) {
                  if (yr == h)
                    continue e;
                  break e;
                }
              }
              mt[ut++] = vt;
            }
          return mt;
        }
        Et.prototype = yi(nn.prototype), Et.prototype.constructor = Et;
        function ni(d) {
          var x = -1, N = d == null ? 0 : d.length;
          for (this.clear(); ++x < N; ) {
            var Z = d[x];
            this.set(Z[0], Z[1]);
          }
        }
        function qu() {
          this.__data__ = Ti ? Ti(null) : {}, this.size = 0;
        }
        function Au(d) {
          var x = this.has(d) && delete this.__data__[d];
          return this.size -= x ? 1 : 0, x;
        }
        function Mu(d) {
          var x = this.__data__;
          if (Ti) {
            var N = x[d];
            return N === f ? r : N;
          }
          return Mt.call(x, d) ? x[d] : r;
        }
        function Tu(d) {
          var x = this.__data__;
          return Ti ? x[d] !== r : Mt.call(x, d);
        }
        function Cu(d, x) {
          var N = this.__data__;
          return this.size += this.has(d) ? 0 : 1, N[d] = Ti && x === r ? f : x, this;
        }
        ni.prototype.clear = qu, ni.prototype.delete = Au, ni.prototype.get = Mu, ni.prototype.has = Tu, ni.prototype.set = Cu;
        function Nr(d) {
          var x = -1, N = d == null ? 0 : d.length;
          for (this.clear(); ++x < N; ) {
            var Z = d[x];
            this.set(Z[0], Z[1]);
          }
        }
        function ku() {
          this.__data__ = [], this.size = 0;
        }
        function Bu(d) {
          var x = this.__data__, N = an(x, d);
          if (N < 0)
            return !1;
          var Z = x.length - 1;
          return N == Z ? x.pop() : Ji.call(x, N, 1), --this.size, !0;
        }
        function Iu(d) {
          var x = this.__data__, N = an(x, d);
          return N < 0 ? r : x[N][1];
        }
        function $u(d) {
          return an(this.__data__, d) > -1;
        }
        function Ou(d, x) {
          var N = this.__data__, Z = an(N, d);
          return Z < 0 ? (++this.size, N.push([d, x])) : N[Z][1] = x, this;
        }
        Nr.prototype.clear = ku, Nr.prototype.delete = Bu, Nr.prototype.get = Iu, Nr.prototype.has = $u, Nr.prototype.set = Ou;
        function jr(d) {
          var x = -1, N = d == null ? 0 : d.length;
          for (this.clear(); ++x < N; ) {
            var Z = d[x];
            this.set(Z[0], Z[1]);
          }
        }
        function Pu() {
          this.size = 0, this.__data__ = {
            hash: new ni(),
            map: new (Ai || Nr)(),
            string: new ni()
          };
        }
        function Lu(d) {
          var x = gn(this, d).delete(d);
          return this.size -= x ? 1 : 0, x;
        }
        function Nu(d) {
          return gn(this, d).get(d);
        }
        function ju(d) {
          return gn(this, d).has(d);
        }
        function Du(d, x) {
          var N = gn(this, d), Z = N.size;
          return N.set(d, x), this.size += N.size == Z ? 0 : 1, this;
        }
        jr.prototype.clear = Pu, jr.prototype.delete = Lu, jr.prototype.get = Nu, jr.prototype.has = ju, jr.prototype.set = Du;
        function ai(d) {
          var x = -1, N = d == null ? 0 : d.length;
          for (this.__data__ = new jr(); ++x < N; )
            this.add(d[x]);
        }
        function Fu(d) {
          return this.__data__.set(d, f), this;
        }
        function Uu(d) {
          return this.__data__.has(d);
        }
        ai.prototype.add = ai.prototype.push = Fu, ai.prototype.has = Uu;
        function Cr(d) {
          var x = this.__data__ = new Nr(d);
          this.size = x.size;
        }
        function zu() {
          this.__data__ = new Nr(), this.size = 0;
        }
        function Hu(d) {
          var x = this.__data__, N = x.delete(d);
          return this.size = x.size, N;
        }
        function Ku(d) {
          return this.__data__.get(d);
        }
        function Wu(d) {
          return this.__data__.has(d);
        }
        function Gu(d, x) {
          var N = this.__data__;
          if (N instanceof Nr) {
            var Z = N.__data__;
            if (!Ai || Z.length < u - 1)
              return Z.push([d, x]), this.size = ++N.size, this;
            N = this.__data__ = new jr(Z);
          }
          return N.set(d, x), this.size = N.size, this;
        }
        Cr.prototype.clear = zu, Cr.prototype.delete = Hu, Cr.prototype.get = Ku, Cr.prototype.has = Wu, Cr.prototype.set = Gu;
        function qs(d, x) {
          var N = bt(d), Z = !N && li(d), fe = !N && !Z && ti(d), ye = !N && !Z && !fe && Si(d), qe = N || Z || fe || ye, Be = qe ? Fn(d.length, iu) : [], Le = Be.length;
          for (var Ze in d)
            (x || Mt.call(d, Ze)) && !(qe && // Safari 9 has enumerable `arguments.length` in strict mode.
            (Ze == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            fe && (Ze == "offset" || Ze == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            ye && (Ze == "buffer" || Ze == "byteLength" || Ze == "byteOffset") || // Skip index properties.
            zr(Ze, Le))) && Be.push(Ze);
          return Be;
        }
        function As(d) {
          var x = d.length;
          return x ? d[na(0, x - 1)] : r;
        }
        function Vu(d, x) {
          return yn(ir(d), si(x, 0, d.length));
        }
        function Zu(d) {
          return yn(ir(d));
        }
        function Vn(d, x, N) {
          (N !== r && !kr(d[x], N) || N === r && !(x in d)) && Dr(d, x, N);
        }
        function ki(d, x, N) {
          var Z = d[x];
          (!(Mt.call(d, x) && kr(Z, N)) || N === r && !(x in d)) && Dr(d, x, N);
        }
        function an(d, x) {
          for (var N = d.length; N--; )
            if (kr(d[N][0], x))
              return N;
          return -1;
        }
        function Yu(d, x, N, Z) {
          return Jr(d, function(fe, ye, qe) {
            x(Z, fe, N(fe), qe);
          }), Z;
        }
        function Ms(d, x) {
          return d && Or(x, Ft(x), d);
        }
        function Ju(d, x) {
          return d && Or(x, ar(x), d);
        }
        function Dr(d, x, N) {
          x == "__proto__" && Xi ? Xi(d, x, {
            configurable: !0,
            enumerable: !0,
            value: N,
            writable: !0
          }) : d[x] = N;
        }
        function Zn(d, x) {
          for (var N = -1, Z = x.length, fe = Ke(Z), ye = d == null; ++N < Z; )
            fe[N] = ye ? r : Ta(d, x[N]);
          return fe;
        }
        function si(d, x, N) {
          return d === d && (N !== r && (d = d <= N ? d : N), x !== r && (d = d >= x ? d : x)), d;
        }
        function Rr(d, x, N, Z, fe, ye) {
          var qe, Be = x & p, Le = x & m, Ze = x & g;
          if (N && (qe = fe ? N(d, Z, fe, ye) : N(d)), qe !== r)
            return qe;
          if (!It(d))
            return d;
          var Ye = bt(d);
          if (Ye) {
            if (qe = jl(d), !Be)
              return ir(d, qe);
          } else {
            var et = Zt(d), ut = et == X || et == be;
            if (ti(d))
              return Xs(d, Be);
            if (et == De || et == le || ut && !fe) {
              if (qe = Le || ut ? {} : bo(d), !Be)
                return Le ? Ml(d, Ju(qe, d)) : Al(d, Ms(qe, d));
            } else {
              if (!Ct[et])
                return fe ? d : {};
              qe = Dl(d, et, Be);
            }
          }
          ye || (ye = new Cr());
          var pt = ye.get(d);
          if (pt)
            return pt;
          ye.set(d, qe), Go(d) ? d.forEach(function(vt) {
            qe.add(Rr(vt, x, N, vt, d, ye));
          }) : Ko(d) && d.forEach(function(vt, St) {
            qe.set(St, Rr(vt, x, N, St, d, ye));
          });
          var mt = Ze ? Le ? ma : ha : Le ? ar : Ft, wt = Ye ? r : mt(d);
          return _r(wt || d, function(vt, St) {
            wt && (St = vt, vt = d[St]), ki(qe, St, Rr(vt, x, N, St, d, ye));
          }), qe;
        }
        function Xu(d) {
          var x = Ft(d);
          return function(N) {
            return Ts(N, d, x);
          };
        }
        function Ts(d, x, N) {
          var Z = N.length;
          if (d == null)
            return !Z;
          for (d = Tt(d); Z--; ) {
            var fe = N[Z], ye = x[fe], qe = d[fe];
            if (qe === r && !(fe in d) || !ye(qe))
              return !1;
          }
          return !0;
        }
        function Cs(d, x, N) {
          if (typeof d != "function")
            throw new Sr(o);
          return Ni(function() {
            d.apply(r, N);
          }, x);
        }
        function Bi(d, x, N, Z) {
          var fe = -1, ye = Fi, qe = !0, Be = d.length, Le = [], Ze = x.length;
          if (!Be)
            return Le;
          N && (x = Bt(x, vr(N))), Z ? (ye = On, qe = !1) : x.length >= u && (ye = Ri, qe = !1, x = new ai(x));
          e:
            for (; ++fe < Be; ) {
              var Ye = d[fe], et = N == null ? Ye : N(Ye);
              if (Ye = Z || Ye !== 0 ? Ye : 0, qe && et === et) {
                for (var ut = Ze; ut--; )
                  if (x[ut] === et)
                    continue e;
                Le.push(Ye);
              } else ye(x, et, Z) || Le.push(Ye);
            }
          return Le;
        }
        var Jr = io($r), ks = io(Jn, !0);
        function Qu(d, x) {
          var N = !0;
          return Jr(d, function(Z, fe, ye) {
            return N = !!x(Z, fe, ye), N;
          }), N;
        }
        function sn(d, x, N) {
          for (var Z = -1, fe = d.length; ++Z < fe; ) {
            var ye = d[Z], qe = x(ye);
            if (qe != null && (Be === r ? qe === qe && !br(qe) : N(qe, Be)))
              var Be = qe, Le = ye;
          }
          return Le;
        }
        function el(d, x, N, Z) {
          var fe = d.length;
          for (N = xt(N), N < 0 && (N = -N > fe ? 0 : fe + N), Z = Z === r || Z > fe ? fe : xt(Z), Z < 0 && (Z += fe), Z = N > Z ? 0 : Zo(Z); N < Z; )
            d[N++] = x;
          return d;
        }
        function Bs(d, x) {
          var N = [];
          return Jr(d, function(Z, fe, ye) {
            x(Z, fe, ye) && N.push(Z);
          }), N;
        }
        function Ht(d, x, N, Z, fe) {
          var ye = -1, qe = d.length;
          for (N || (N = Ul), fe || (fe = []); ++ye < qe; ) {
            var Be = d[ye];
            x > 0 && N(Be) ? x > 1 ? Ht(Be, x - 1, N, Z, fe) : Vr(fe, Be) : Z || (fe[fe.length] = Be);
          }
          return fe;
        }
        var Yn = no(), Is = no(!0);
        function $r(d, x) {
          return d && Yn(d, x, Ft);
        }
        function Jn(d, x) {
          return d && Is(d, x, Ft);
        }
        function on(d, x) {
          return Gr(x, function(N) {
            return Hr(d[N]);
          });
        }
        function oi(d, x) {
          x = Qr(x, d);
          for (var N = 0, Z = x.length; d != null && N < Z; )
            d = d[Pr(x[N++])];
          return N && N == Z ? d : r;
        }
        function $s(d, x, N) {
          var Z = x(d);
          return bt(d) ? Z : Vr(Z, N(d));
        }
        function Jt(d) {
          return d == null ? d === r ? we : Fe : ii && ii in Tt(d) ? Pl(d) : Zl(d);
        }
        function Xn(d, x) {
          return d > x;
        }
        function tl(d, x) {
          return d != null && Mt.call(d, x);
        }
        function rl(d, x) {
          return d != null && x in Tt(d);
        }
        function il(d, x, N) {
          return d >= Vt(x, N) && d < jt(x, N);
        }
        function Qn(d, x, N) {
          for (var Z = N ? On : Fi, fe = d[0].length, ye = d.length, qe = ye, Be = Ke(ye), Le = 1 / 0, Ze = []; qe--; ) {
            var Ye = d[qe];
            qe && x && (Ye = Bt(Ye, vr(x))), Le = Vt(Ye.length, Le), Be[qe] = !N && (x || fe >= 120 && Ye.length >= 120) ? new ai(qe && Ye) : r;
          }
          Ye = d[0];
          var et = -1, ut = Be[0];
          e:
            for (; ++et < fe && Ze.length < Le; ) {
              var pt = Ye[et], mt = x ? x(pt) : pt;
              if (pt = N || pt !== 0 ? pt : 0, !(ut ? Ri(ut, mt) : Z(Ze, mt, N))) {
                for (qe = ye; --qe; ) {
                  var wt = Be[qe];
                  if (!(wt ? Ri(wt, mt) : Z(d[qe], mt, N)))
                    continue e;
                }
                ut && ut.push(mt), Ze.push(pt);
              }
            }
          return Ze;
        }
        function nl(d, x, N, Z) {
          return $r(d, function(fe, ye, qe) {
            x(Z, N(fe), ye, qe);
          }), Z;
        }
        function Ii(d, x, N) {
          x = Qr(x, d), d = _o(d, x);
          var Z = d == null ? d : d[Pr(Ar(x))];
          return Z == null ? r : hr(Z, d, N);
        }
        function Os(d) {
          return $t(d) && Jt(d) == le;
        }
        function al(d) {
          return $t(d) && Jt(d) == Ue;
        }
        function sl(d) {
          return $t(d) && Jt(d) == se;
        }
        function $i(d, x, N, Z, fe) {
          return d === x ? !0 : d == null || x == null || !$t(d) && !$t(x) ? d !== d && x !== x : ol(d, x, N, Z, $i, fe);
        }
        function ol(d, x, N, Z, fe, ye) {
          var qe = bt(d), Be = bt(x), Le = qe ? ee : Zt(d), Ze = Be ? ee : Zt(x);
          Le = Le == le ? De : Le, Ze = Ze == le ? De : Ze;
          var Ye = Le == De, et = Ze == De, ut = Le == Ze;
          if (ut && ti(d)) {
            if (!ti(x))
              return !1;
            qe = !0, Ye = !1;
          }
          if (ut && !Ye)
            return ye || (ye = new Cr()), qe || Si(d) ? mo(d, x, N, Z, fe, ye) : $l(d, x, Le, N, Z, fe, ye);
          if (!(N & y)) {
            var pt = Ye && Mt.call(d, "__wrapped__"), mt = et && Mt.call(x, "__wrapped__");
            if (pt || mt) {
              var wt = pt ? d.value() : d, vt = mt ? x.value() : x;
              return ye || (ye = new Cr()), fe(wt, vt, N, Z, ye);
            }
          }
          return ut ? (ye || (ye = new Cr()), Ol(d, x, N, Z, fe, ye)) : !1;
        }
        function cl(d) {
          return $t(d) && Zt(d) == Re;
        }
        function ea(d, x, N, Z) {
          var fe = N.length, ye = fe, qe = !Z;
          if (d == null)
            return !ye;
          for (d = Tt(d); fe--; ) {
            var Be = N[fe];
            if (qe && Be[2] ? Be[1] !== d[Be[0]] : !(Be[0] in d))
              return !1;
          }
          for (; ++fe < ye; ) {
            Be = N[fe];
            var Le = Be[0], Ze = d[Le], Ye = Be[1];
            if (qe && Be[2]) {
              if (Ze === r && !(Le in d))
                return !1;
            } else {
              var et = new Cr();
              if (Z)
                var ut = Z(Ze, Ye, Le, d, x, et);
              if (!(ut === r ? $i(Ye, Ze, y | v, Z, et) : ut))
                return !1;
            }
          }
          return !0;
        }
        function Ps(d) {
          if (!It(d) || Hl(d))
            return !1;
          var x = Hr(d) ? cu : Lt;
          return x.test(ui(d));
        }
        function ul(d) {
          return $t(d) && Jt(d) == rt;
        }
        function ll(d) {
          return $t(d) && Zt(d) == He;
        }
        function fl(d) {
          return $t(d) && Rn(d.length) && !!kt[Jt(d)];
        }
        function Ls(d) {
          return typeof d == "function" ? d : d == null ? sr : typeof d == "object" ? bt(d) ? Ds(d[0], d[1]) : js(d) : oc(d);
        }
        function ta(d) {
          if (!Li(d))
            return hu(d);
          var x = [];
          for (var N in Tt(d))
            Mt.call(d, N) && N != "constructor" && x.push(N);
          return x;
        }
        function pl(d) {
          if (!It(d))
            return Vl(d);
          var x = Li(d), N = [];
          for (var Z in d)
            Z == "constructor" && (x || !Mt.call(d, Z)) || N.push(Z);
          return N;
        }
        function ra(d, x) {
          return d < x;
        }
        function Ns(d, x) {
          var N = -1, Z = nr(d) ? Ke(d.length) : [];
          return Jr(d, function(fe, ye, qe) {
            Z[++N] = x(fe, ye, qe);
          }), Z;
        }
        function js(d) {
          var x = ga(d);
          return x.length == 1 && x[0][2] ? xo(x[0][0], x[0][1]) : function(N) {
            return N === d || ea(N, d, x);
          };
        }
        function Ds(d, x) {
          return ya(d) && yo(x) ? xo(Pr(d), x) : function(N) {
            var Z = Ta(N, d);
            return Z === r && Z === x ? Ca(N, d) : $i(x, Z, y | v);
          };
        }
        function cn(d, x, N, Z, fe) {
          d !== x && Yn(x, function(ye, qe) {
            if (fe || (fe = new Cr()), It(ye))
              dl(d, x, qe, N, cn, Z, fe);
            else {
              var Be = Z ? Z(wa(d, qe), ye, qe + "", d, x, fe) : r;
              Be === r && (Be = ye), Vn(d, qe, Be);
            }
          }, ar);
        }
        function dl(d, x, N, Z, fe, ye, qe) {
          var Be = wa(d, N), Le = wa(x, N), Ze = qe.get(Le);
          if (Ze) {
            Vn(d, N, Ze);
            return;
          }
          var Ye = ye ? ye(Be, Le, N + "", d, x, qe) : r, et = Ye === r;
          if (et) {
            var ut = bt(Le), pt = !ut && ti(Le), mt = !ut && !pt && Si(Le);
            Ye = Le, ut || pt || mt ? bt(Be) ? Ye = Be : Ot(Be) ? Ye = ir(Be) : pt ? (et = !1, Ye = Xs(Le, !0)) : mt ? (et = !1, Ye = Qs(Le, !0)) : Ye = [] : ji(Le) || li(Le) ? (Ye = Be, li(Be) ? Ye = Yo(Be) : (!It(Be) || Hr(Be)) && (Ye = bo(Le))) : et = !1;
          }
          et && (qe.set(Le, Ye), fe(Ye, Le, Z, ye, qe), qe.delete(Le)), Vn(d, N, Ye);
        }
        function Fs(d, x) {
          var N = d.length;
          if (N)
            return x += x < 0 ? N : 0, zr(x, N) ? d[x] : r;
        }
        function Us(d, x, N) {
          x.length ? x = Bt(x, function(ye) {
            return bt(ye) ? function(qe) {
              return oi(qe, ye.length === 1 ? ye[0] : ye);
            } : ye;
          }) : x = [sr];
          var Z = -1;
          x = Bt(x, vr(ht()));
          var fe = Ns(d, function(ye, qe, Be) {
            var Le = Bt(x, function(Ze) {
              return Ze(ye);
            });
            return { criteria: Le, index: ++Z, value: ye };
          });
          return Dc(fe, function(ye, qe) {
            return ql(ye, qe, N);
          });
        }
        function hl(d, x) {
          return zs(d, x, function(N, Z) {
            return Ca(d, Z);
          });
        }
        function zs(d, x, N) {
          for (var Z = -1, fe = x.length, ye = {}; ++Z < fe; ) {
            var qe = x[Z], Be = oi(d, qe);
            N(Be, qe) && Oi(ye, Qr(qe, d), Be);
          }
          return ye;
        }
        function ml(d) {
          return function(x) {
            return oi(x, d);
          };
        }
        function ia(d, x, N, Z) {
          var fe = Z ? jc : pi, ye = -1, qe = x.length, Be = d;
          for (d === x && (x = ir(x)), N && (Be = Bt(d, vr(N))); ++ye < qe; )
            for (var Le = 0, Ze = x[ye], Ye = N ? N(Ze) : Ze; (Le = fe(Be, Ye, Le, Z)) > -1; )
              Be !== d && Ji.call(Be, Le, 1), Ji.call(d, Le, 1);
          return d;
        }
        function Hs(d, x) {
          for (var N = d ? x.length : 0, Z = N - 1; N--; ) {
            var fe = x[N];
            if (N == Z || fe !== ye) {
              var ye = fe;
              zr(fe) ? Ji.call(d, fe, 1) : oa(d, fe);
            }
          }
          return d;
        }
        function na(d, x) {
          return d + en(Es() * (x - d + 1));
        }
        function vl(d, x, N, Z) {
          for (var fe = -1, ye = jt(Qi((x - d) / (N || 1)), 0), qe = Ke(ye); ye--; )
            qe[Z ? ye : ++fe] = d, d += N;
          return qe;
        }
        function aa(d, x) {
          var N = "";
          if (!d || x < 1 || x > k)
            return N;
          do
            x % 2 && (N += d), x = en(x / 2), x && (d += d);
          while (x);
          return N;
        }
        function _t(d, x) {
          return _a(wo(d, x, sr), d + "");
        }
        function gl(d) {
          return As(Ei(d));
        }
        function bl(d, x) {
          var N = Ei(d);
          return yn(N, si(x, 0, N.length));
        }
        function Oi(d, x, N, Z) {
          if (!It(d))
            return d;
          x = Qr(x, d);
          for (var fe = -1, ye = x.length, qe = ye - 1, Be = d; Be != null && ++fe < ye; ) {
            var Le = Pr(x[fe]), Ze = N;
            if (Le === "__proto__" || Le === "constructor" || Le === "prototype")
              return d;
            if (fe != qe) {
              var Ye = Be[Le];
              Ze = Z ? Z(Ye, Le, Be) : r, Ze === r && (Ze = It(Ye) ? Ye : zr(x[fe + 1]) ? [] : {});
            }
            ki(Be, Le, Ze), Be = Be[Le];
          }
          return d;
        }
        var Ks = tn ? function(d, x) {
          return tn.set(d, x), d;
        } : sr, yl = Xi ? function(d, x) {
          return Xi(d, "toString", {
            configurable: !0,
            enumerable: !1,
            value: Ba(x),
            writable: !0
          });
        } : sr;
        function xl(d) {
          return yn(Ei(d));
        }
        function qr(d, x, N) {
          var Z = -1, fe = d.length;
          x < 0 && (x = -x > fe ? 0 : fe + x), N = N > fe ? fe : N, N < 0 && (N += fe), fe = x > N ? 0 : N - x >>> 0, x >>>= 0;
          for (var ye = Ke(fe); ++Z < fe; )
            ye[Z] = d[Z + x];
          return ye;
        }
        function wl(d, x) {
          var N;
          return Jr(d, function(Z, fe, ye) {
            return N = x(Z, fe, ye), !N;
          }), !!N;
        }
        function un(d, x, N) {
          var Z = 0, fe = d == null ? Z : d.length;
          if (typeof x == "number" && x === x && fe <= U) {
            for (; Z < fe; ) {
              var ye = Z + fe >>> 1, qe = d[ye];
              qe !== null && !br(qe) && (N ? qe <= x : qe < x) ? Z = ye + 1 : fe = ye;
            }
            return fe;
          }
          return sa(d, x, sr, N);
        }
        function sa(d, x, N, Z) {
          var fe = 0, ye = d == null ? 0 : d.length;
          if (ye === 0)
            return 0;
          x = N(x);
          for (var qe = x !== x, Be = x === null, Le = br(x), Ze = x === r; fe < ye; ) {
            var Ye = en((fe + ye) / 2), et = N(d[Ye]), ut = et !== r, pt = et === null, mt = et === et, wt = br(et);
            if (qe)
              var vt = Z || mt;
            else Ze ? vt = mt && (Z || ut) : Be ? vt = mt && ut && (Z || !pt) : Le ? vt = mt && ut && !pt && (Z || !wt) : pt || wt ? vt = !1 : vt = Z ? et <= x : et < x;
            vt ? fe = Ye + 1 : ye = Ye;
          }
          return Vt(ye, w);
        }
        function Ws(d, x) {
          for (var N = -1, Z = d.length, fe = 0, ye = []; ++N < Z; ) {
            var qe = d[N], Be = x ? x(qe) : qe;
            if (!N || !kr(Be, Le)) {
              var Le = Be;
              ye[fe++] = qe === 0 ? 0 : qe;
            }
          }
          return ye;
        }
        function Gs(d) {
          return typeof d == "number" ? d : br(d) ? C : +d;
        }
        function gr(d) {
          if (typeof d == "string")
            return d;
          if (bt(d))
            return Bt(d, gr) + "";
          if (br(d))
            return Rs ? Rs.call(d) : "";
          var x = d + "";
          return x == "0" && 1 / d == -T ? "-0" : x;
        }
        function Xr(d, x, N) {
          var Z = -1, fe = Fi, ye = d.length, qe = !0, Be = [], Le = Be;
          if (N)
            qe = !1, fe = On;
          else if (ye >= u) {
            var Ze = x ? null : Bl(d);
            if (Ze)
              return zi(Ze);
            qe = !1, fe = Ri, Le = new ai();
          } else
            Le = x ? [] : Be;
          e:
            for (; ++Z < ye; ) {
              var Ye = d[Z], et = x ? x(Ye) : Ye;
              if (Ye = N || Ye !== 0 ? Ye : 0, qe && et === et) {
                for (var ut = Le.length; ut--; )
                  if (Le[ut] === et)
                    continue e;
                x && Le.push(et), Be.push(Ye);
              } else fe(Le, et, N) || (Le !== Be && Le.push(et), Be.push(Ye));
            }
          return Be;
        }
        function oa(d, x) {
          return x = Qr(x, d), d = _o(d, x), d == null || delete d[Pr(Ar(x))];
        }
        function Vs(d, x, N, Z) {
          return Oi(d, x, N(oi(d, x)), Z);
        }
        function ln(d, x, N, Z) {
          for (var fe = d.length, ye = Z ? fe : -1; (Z ? ye-- : ++ye < fe) && x(d[ye], ye, d); )
            ;
          return N ? qr(d, Z ? 0 : ye, Z ? ye + 1 : fe) : qr(d, Z ? ye + 1 : 0, Z ? fe : ye);
        }
        function Zs(d, x) {
          var N = d;
          return N instanceof Et && (N = N.value()), Pn(x, function(Z, fe) {
            return fe.func.apply(fe.thisArg, Vr([Z], fe.args));
          }, N);
        }
        function ca(d, x, N) {
          var Z = d.length;
          if (Z < 2)
            return Z ? Xr(d[0]) : [];
          for (var fe = -1, ye = Ke(Z); ++fe < Z; )
            for (var qe = d[fe], Be = -1; ++Be < Z; )
              Be != fe && (ye[fe] = Bi(ye[fe] || qe, d[Be], x, N));
          return Xr(Ht(ye, 1), x, N);
        }
        function Ys(d, x, N) {
          for (var Z = -1, fe = d.length, ye = x.length, qe = {}; ++Z < fe; ) {
            var Be = Z < ye ? x[Z] : r;
            N(qe, d[Z], Be);
          }
          return qe;
        }
        function ua(d) {
          return Ot(d) ? d : [];
        }
        function la(d) {
          return typeof d == "function" ? d : sr;
        }
        function Qr(d, x) {
          return bt(d) ? d : ya(d, x) ? [d] : qo(At(d));
        }
        var _l = _t;
        function ei(d, x, N) {
          var Z = d.length;
          return N = N === r ? Z : N, !x && N >= Z ? d : qr(d, x, N);
        }
        var Js = uu || function(d) {
          return zt.clearTimeout(d);
        };
        function Xs(d, x) {
          if (x)
            return d.slice();
          var N = d.length, Z = ys ? ys(N) : new d.constructor(N);
          return d.copy(Z), Z;
        }
        function fa(d) {
          var x = new d.constructor(d.byteLength);
          return new Zi(x).set(new Zi(d)), x;
        }
        function Sl(d, x) {
          var N = x ? fa(d.buffer) : d.buffer;
          return new d.constructor(N, d.byteOffset, d.byteLength);
        }
        function El(d) {
          var x = new d.constructor(d.source, ft.exec(d));
          return x.lastIndex = d.lastIndex, x;
        }
        function Rl(d) {
          return Ci ? Tt(Ci.call(d)) : {};
        }
        function Qs(d, x) {
          var N = x ? fa(d.buffer) : d.buffer;
          return new d.constructor(N, d.byteOffset, d.length);
        }
        function eo(d, x) {
          if (d !== x) {
            var N = d !== r, Z = d === null, fe = d === d, ye = br(d), qe = x !== r, Be = x === null, Le = x === x, Ze = br(x);
            if (!Be && !Ze && !ye && d > x || ye && qe && Le && !Be && !Ze || Z && qe && Le || !N && Le || !fe)
              return 1;
            if (!Z && !ye && !Ze && d < x || Ze && N && fe && !Z && !ye || Be && N && fe || !qe && fe || !Le)
              return -1;
          }
          return 0;
        }
        function ql(d, x, N) {
          for (var Z = -1, fe = d.criteria, ye = x.criteria, qe = fe.length, Be = N.length; ++Z < qe; ) {
            var Le = eo(fe[Z], ye[Z]);
            if (Le) {
              if (Z >= Be)
                return Le;
              var Ze = N[Z];
              return Le * (Ze == "desc" ? -1 : 1);
            }
          }
          return d.index - x.index;
        }
        function to(d, x, N, Z) {
          for (var fe = -1, ye = d.length, qe = N.length, Be = -1, Le = x.length, Ze = jt(ye - qe, 0), Ye = Ke(Le + Ze), et = !Z; ++Be < Le; )
            Ye[Be] = x[Be];
          for (; ++fe < qe; )
            (et || fe < ye) && (Ye[N[fe]] = d[fe]);
          for (; Ze--; )
            Ye[Be++] = d[fe++];
          return Ye;
        }
        function ro(d, x, N, Z) {
          for (var fe = -1, ye = d.length, qe = -1, Be = N.length, Le = -1, Ze = x.length, Ye = jt(ye - Be, 0), et = Ke(Ye + Ze), ut = !Z; ++fe < Ye; )
            et[fe] = d[fe];
          for (var pt = fe; ++Le < Ze; )
            et[pt + Le] = x[Le];
          for (; ++qe < Be; )
            (ut || fe < ye) && (et[pt + N[qe]] = d[fe++]);
          return et;
        }
        function ir(d, x) {
          var N = -1, Z = d.length;
          for (x || (x = Ke(Z)); ++N < Z; )
            x[N] = d[N];
          return x;
        }
        function Or(d, x, N, Z) {
          var fe = !N;
          N || (N = {});
          for (var ye = -1, qe = x.length; ++ye < qe; ) {
            var Be = x[ye], Le = Z ? Z(N[Be], d[Be], Be, N, d) : r;
            Le === r && (Le = d[Be]), fe ? Dr(N, Be, Le) : ki(N, Be, Le);
          }
          return N;
        }
        function Al(d, x) {
          return Or(d, ba(d), x);
        }
        function Ml(d, x) {
          return Or(d, vo(d), x);
        }
        function fn(d, x) {
          return function(N, Z) {
            var fe = bt(N) ? Ic : Yu, ye = x ? x() : {};
            return fe(N, d, ht(Z, 2), ye);
          };
        }
        function xi(d) {
          return _t(function(x, N) {
            var Z = -1, fe = N.length, ye = fe > 1 ? N[fe - 1] : r, qe = fe > 2 ? N[2] : r;
            for (ye = d.length > 3 && typeof ye == "function" ? (fe--, ye) : r, qe && Xt(N[0], N[1], qe) && (ye = fe < 3 ? r : ye, fe = 1), x = Tt(x); ++Z < fe; ) {
              var Be = N[Z];
              Be && d(x, Be, Z, ye);
            }
            return x;
          });
        }
        function io(d, x) {
          return function(N, Z) {
            if (N == null)
              return N;
            if (!nr(N))
              return d(N, Z);
            for (var fe = N.length, ye = x ? fe : -1, qe = Tt(N); (x ? ye-- : ++ye < fe) && Z(qe[ye], ye, qe) !== !1; )
              ;
            return N;
          };
        }
        function no(d) {
          return function(x, N, Z) {
            for (var fe = -1, ye = Tt(x), qe = Z(x), Be = qe.length; Be--; ) {
              var Le = qe[d ? Be : ++fe];
              if (N(ye[Le], Le, ye) === !1)
                break;
            }
            return x;
          };
        }
        function Tl(d, x, N) {
          var Z = x & E, fe = Pi(d);
          function ye() {
            var qe = this && this !== zt && this instanceof ye ? fe : d;
            return qe.apply(Z ? N : this, arguments);
          }
          return ye;
        }
        function ao(d) {
          return function(x) {
            x = At(x);
            var N = di(x) ? Tr(x) : r, Z = N ? N[0] : x.charAt(0), fe = N ? ei(N, 1).join("") : x.slice(1);
            return Z[d]() + fe;
          };
        }
        function wi(d) {
          return function(x) {
            return Pn(ac(nc(x).replace(yc, "")), d, "");
          };
        }
        function Pi(d) {
          return function() {
            var x = arguments;
            switch (x.length) {
              case 0:
                return new d();
              case 1:
                return new d(x[0]);
              case 2:
                return new d(x[0], x[1]);
              case 3:
                return new d(x[0], x[1], x[2]);
              case 4:
                return new d(x[0], x[1], x[2], x[3]);
              case 5:
                return new d(x[0], x[1], x[2], x[3], x[4]);
              case 6:
                return new d(x[0], x[1], x[2], x[3], x[4], x[5]);
              case 7:
                return new d(x[0], x[1], x[2], x[3], x[4], x[5], x[6]);
            }
            var N = yi(d.prototype), Z = d.apply(N, x);
            return It(Z) ? Z : N;
          };
        }
        function Cl(d, x, N) {
          var Z = Pi(d);
          function fe() {
            for (var ye = arguments.length, qe = Ke(ye), Be = ye, Le = _i(fe); Be--; )
              qe[Be] = arguments[Be];
            var Ze = ye < 3 && qe[0] !== Le && qe[ye - 1] !== Le ? [] : Zr(qe, Le);
            if (ye -= Ze.length, ye < N)
              return lo(
                d,
                x,
                pn,
                fe.placeholder,
                r,
                qe,
                Ze,
                r,
                r,
                N - ye
              );
            var Ye = this && this !== zt && this instanceof fe ? Z : d;
            return hr(Ye, this, qe);
          }
          return fe;
        }
        function so(d) {
          return function(x, N, Z) {
            var fe = Tt(x);
            if (!nr(x)) {
              var ye = ht(N, 3);
              x = Ft(x), N = function(Be) {
                return ye(fe[Be], Be, fe);
              };
            }
            var qe = d(x, N, Z);
            return qe > -1 ? fe[ye ? x[qe] : qe] : r;
          };
        }
        function oo(d) {
          return Ur(function(x) {
            var N = x.length, Z = N, fe = Er.prototype.thru;
            for (d && x.reverse(); Z--; ) {
              var ye = x[Z];
              if (typeof ye != "function")
                throw new Sr(o);
              if (fe && !qe && vn(ye) == "wrapper")
                var qe = new Er([], !0);
            }
            for (Z = qe ? Z : N; ++Z < N; ) {
              ye = x[Z];
              var Be = vn(ye), Le = Be == "wrapper" ? va(ye) : r;
              Le && xa(Le[0]) && Le[1] == (V | O | D | Q) && !Le[4].length && Le[9] == 1 ? qe = qe[vn(Le[0])].apply(qe, Le[3]) : qe = ye.length == 1 && xa(ye) ? qe[Be]() : qe.thru(ye);
            }
            return function() {
              var Ze = arguments, Ye = Ze[0];
              if (qe && Ze.length == 1 && bt(Ye))
                return qe.plant(Ye).value();
              for (var et = 0, ut = N ? x[et].apply(this, Ze) : Ye; ++et < N; )
                ut = x[et].call(this, ut);
              return ut;
            };
          });
        }
        function pn(d, x, N, Z, fe, ye, qe, Be, Le, Ze) {
          var Ye = x & V, et = x & E, ut = x & b, pt = x & (O | j), mt = x & re, wt = ut ? r : Pi(d);
          function vt() {
            for (var St = arguments.length, Rt = Ke(St), yr = St; yr--; )
              Rt[yr] = arguments[yr];
            if (pt)
              var Qt = _i(vt), xr = Uc(Rt, Qt);
            if (Z && (Rt = to(Rt, Z, fe, pt)), ye && (Rt = ro(Rt, ye, qe, pt)), St -= xr, pt && St < Ze) {
              var Pt = Zr(Rt, Qt);
              return lo(
                d,
                x,
                pn,
                vt.placeholder,
                N,
                Rt,
                Pt,
                Be,
                Le,
                Ze - St
              );
            }
            var Br = et ? N : this, Wr = ut ? Br[d] : d;
            return St = Rt.length, Be ? Rt = Yl(Rt, Be) : mt && St > 1 && Rt.reverse(), Ye && Le < St && (Rt.length = Le), this && this !== zt && this instanceof vt && (Wr = wt || Pi(Wr)), Wr.apply(Br, Rt);
          }
          return vt;
        }
        function co(d, x) {
          return function(N, Z) {
            return nl(N, d, x(Z), {});
          };
        }
        function dn(d, x) {
          return function(N, Z) {
            var fe;
            if (N === r && Z === r)
              return x;
            if (N !== r && (fe = N), Z !== r) {
              if (fe === r)
                return Z;
              typeof N == "string" || typeof Z == "string" ? (N = gr(N), Z = gr(Z)) : (N = Gs(N), Z = Gs(Z)), fe = d(N, Z);
            }
            return fe;
          };
        }
        function pa(d) {
          return Ur(function(x) {
            return x = Bt(x, vr(ht())), _t(function(N) {
              var Z = this;
              return d(x, function(fe) {
                return hr(fe, Z, N);
              });
            });
          });
        }
        function hn(d, x) {
          x = x === r ? " " : gr(x);
          var N = x.length;
          if (N < 2)
            return N ? aa(x, d) : x;
          var Z = aa(x, Qi(d / hi(x)));
          return di(x) ? ei(Tr(Z), 0, d).join("") : Z.slice(0, d);
        }
        function kl(d, x, N, Z) {
          var fe = x & E, ye = Pi(d);
          function qe() {
            for (var Be = -1, Le = arguments.length, Ze = -1, Ye = Z.length, et = Ke(Ye + Le), ut = this && this !== zt && this instanceof qe ? ye : d; ++Ze < Ye; )
              et[Ze] = Z[Ze];
            for (; Le--; )
              et[Ze++] = arguments[++Be];
            return hr(ut, fe ? N : this, et);
          }
          return qe;
        }
        function uo(d) {
          return function(x, N, Z) {
            return Z && typeof Z != "number" && Xt(x, N, Z) && (N = Z = r), x = Kr(x), N === r ? (N = x, x = 0) : N = Kr(N), Z = Z === r ? x < N ? 1 : -1 : Kr(Z), vl(x, N, Z, d);
          };
        }
        function mn(d) {
          return function(x, N) {
            return typeof x == "string" && typeof N == "string" || (x = Mr(x), N = Mr(N)), d(x, N);
          };
        }
        function lo(d, x, N, Z, fe, ye, qe, Be, Le, Ze) {
          var Ye = x & O, et = Ye ? qe : r, ut = Ye ? r : qe, pt = Ye ? ye : r, mt = Ye ? r : ye;
          x |= Ye ? D : G, x &= ~(Ye ? G : D), x & q || (x &= -4);
          var wt = [
            d,
            x,
            fe,
            pt,
            et,
            mt,
            ut,
            Be,
            Le,
            Ze
          ], vt = N.apply(r, wt);
          return xa(d) && So(vt, wt), vt.placeholder = Z, Eo(vt, d, x);
        }
        function da(d) {
          var x = Nt[d];
          return function(N, Z) {
            if (N = Mr(N), Z = Z == null ? 0 : Vt(xt(Z), 292), Z && Ss(N)) {
              var fe = (At(N) + "e").split("e"), ye = x(fe[0] + "e" + (+fe[1] + Z));
              return fe = (At(ye) + "e").split("e"), +(fe[0] + "e" + (+fe[1] - Z));
            }
            return x(N);
          };
        }
        var Bl = gi && 1 / zi(new gi([, -0]))[1] == T ? function(d) {
          return new gi(d);
        } : Oa;
        function fo(d) {
          return function(x) {
            var N = Zt(x);
            return N == Re ? zn(x) : N == He ? Zc(x) : Fc(x, d(x));
          };
        }
        function Fr(d, x, N, Z, fe, ye, qe, Be) {
          var Le = x & b;
          if (!Le && typeof d != "function")
            throw new Sr(o);
          var Ze = Z ? Z.length : 0;
          if (Ze || (x &= -97, Z = fe = r), qe = qe === r ? qe : jt(xt(qe), 0), Be = Be === r ? Be : xt(Be), Ze -= fe ? fe.length : 0, x & G) {
            var Ye = Z, et = fe;
            Z = fe = r;
          }
          var ut = Le ? r : va(d), pt = [
            d,
            x,
            N,
            Z,
            fe,
            Ye,
            et,
            ye,
            qe,
            Be
          ];
          if (ut && Gl(pt, ut), d = pt[0], x = pt[1], N = pt[2], Z = pt[3], fe = pt[4], Be = pt[9] = pt[9] === r ? Le ? 0 : d.length : jt(pt[9] - Ze, 0), !Be && x & (O | j) && (x &= -25), !x || x == E)
            var mt = Tl(d, x, N);
          else x == O || x == j ? mt = Cl(d, x, Be) : (x == D || x == (E | D)) && !fe.length ? mt = kl(d, x, N, Z) : mt = pn.apply(r, pt);
          var wt = ut ? Ks : So;
          return Eo(wt(mt, pt), d, x);
        }
        function po(d, x, N, Z) {
          return d === r || kr(d, vi[N]) && !Mt.call(Z, N) ? x : d;
        }
        function ho(d, x, N, Z, fe, ye) {
          return It(d) && It(x) && (ye.set(x, d), cn(d, x, r, ho, ye), ye.delete(x)), d;
        }
        function Il(d) {
          return ji(d) ? r : d;
        }
        function mo(d, x, N, Z, fe, ye) {
          var qe = N & y, Be = d.length, Le = x.length;
          if (Be != Le && !(qe && Le > Be))
            return !1;
          var Ze = ye.get(d), Ye = ye.get(x);
          if (Ze && Ye)
            return Ze == x && Ye == d;
          var et = -1, ut = !0, pt = N & v ? new ai() : r;
          for (ye.set(d, x), ye.set(x, d); ++et < Be; ) {
            var mt = d[et], wt = x[et];
            if (Z)
              var vt = qe ? Z(wt, mt, et, x, d, ye) : Z(mt, wt, et, d, x, ye);
            if (vt !== r) {
              if (vt)
                continue;
              ut = !1;
              break;
            }
            if (pt) {
              if (!Ln(x, function(St, Rt) {
                if (!Ri(pt, Rt) && (mt === St || fe(mt, St, N, Z, ye)))
                  return pt.push(Rt);
              })) {
                ut = !1;
                break;
              }
            } else if (!(mt === wt || fe(mt, wt, N, Z, ye))) {
              ut = !1;
              break;
            }
          }
          return ye.delete(d), ye.delete(x), ut;
        }
        function $l(d, x, N, Z, fe, ye, qe) {
          switch (N) {
            case Ge:
              if (d.byteLength != x.byteLength || d.byteOffset != x.byteOffset)
                return !1;
              d = d.buffer, x = x.buffer;
            case Ue:
              return !(d.byteLength != x.byteLength || !ye(new Zi(d), new Zi(x)));
            case z:
            case se:
            case Pe:
              return kr(+d, +x);
            case ae:
              return d.name == x.name && d.message == x.message;
            case rt:
            case Qe:
              return d == x + "";
            case Re:
              var Be = zn;
            case He:
              var Le = Z & y;
              if (Be || (Be = zi), d.size != x.size && !Le)
                return !1;
              var Ze = qe.get(d);
              if (Ze)
                return Ze == x;
              Z |= v, qe.set(d, x);
              var Ye = mo(Be(d), Be(x), Z, fe, ye, qe);
              return qe.delete(d), Ye;
            case Je:
              if (Ci)
                return Ci.call(d) == Ci.call(x);
          }
          return !1;
        }
        function Ol(d, x, N, Z, fe, ye) {
          var qe = N & y, Be = ha(d), Le = Be.length, Ze = ha(x), Ye = Ze.length;
          if (Le != Ye && !qe)
            return !1;
          for (var et = Le; et--; ) {
            var ut = Be[et];
            if (!(qe ? ut in x : Mt.call(x, ut)))
              return !1;
          }
          var pt = ye.get(d), mt = ye.get(x);
          if (pt && mt)
            return pt == x && mt == d;
          var wt = !0;
          ye.set(d, x), ye.set(x, d);
          for (var vt = qe; ++et < Le; ) {
            ut = Be[et];
            var St = d[ut], Rt = x[ut];
            if (Z)
              var yr = qe ? Z(Rt, St, ut, x, d, ye) : Z(St, Rt, ut, d, x, ye);
            if (!(yr === r ? St === Rt || fe(St, Rt, N, Z, ye) : yr)) {
              wt = !1;
              break;
            }
            vt || (vt = ut == "constructor");
          }
          if (wt && !vt) {
            var Qt = d.constructor, xr = x.constructor;
            Qt != xr && "constructor" in d && "constructor" in x && !(typeof Qt == "function" && Qt instanceof Qt && typeof xr == "function" && xr instanceof xr) && (wt = !1);
          }
          return ye.delete(d), ye.delete(x), wt;
        }
        function Ur(d) {
          return _a(wo(d, r, Co), d + "");
        }
        function ha(d) {
          return $s(d, Ft, ba);
        }
        function ma(d) {
          return $s(d, ar, vo);
        }
        var va = tn ? function(d) {
          return tn.get(d);
        } : Oa;
        function vn(d) {
          for (var x = d.name + "", N = bi[x], Z = Mt.call(bi, x) ? N.length : 0; Z--; ) {
            var fe = N[Z], ye = fe.func;
            if (ye == null || ye == d)
              return fe.name;
          }
          return x;
        }
        function _i(d) {
          var x = Mt.call(ge, "placeholder") ? ge : d;
          return x.placeholder;
        }
        function ht() {
          var d = ge.iteratee || Ia;
          return d = d === Ia ? Ls : d, arguments.length ? d(arguments[0], arguments[1]) : d;
        }
        function gn(d, x) {
          var N = d.__data__;
          return zl(x) ? N[typeof x == "string" ? "string" : "hash"] : N.map;
        }
        function ga(d) {
          for (var x = Ft(d), N = x.length; N--; ) {
            var Z = x[N], fe = d[Z];
            x[N] = [Z, fe, yo(fe)];
          }
          return x;
        }
        function ci(d, x) {
          var N = Wc(d, x);
          return Ps(N) ? N : r;
        }
        function Pl(d) {
          var x = Mt.call(d, ii), N = d[ii];
          try {
            d[ii] = r;
            var Z = !0;
          } catch {
          }
          var fe = Gi.call(d);
          return Z && (x ? d[ii] = N : delete d[ii]), fe;
        }
        var ba = Kn ? function(d) {
          return d == null ? [] : (d = Tt(d), Gr(Kn(d), function(x) {
            return ws.call(d, x);
          }));
        } : Pa, vo = Kn ? function(d) {
          for (var x = []; d; )
            Vr(x, ba(d)), d = Yi(d);
          return x;
        } : Pa, Zt = Jt;
        (Wn && Zt(new Wn(new ArrayBuffer(1))) != Ge || Ai && Zt(new Ai()) != Re || Gn && Zt(Gn.resolve()) != je || gi && Zt(new gi()) != He || Mi && Zt(new Mi()) != Ae) && (Zt = function(d) {
          var x = Jt(d), N = x == De ? d.constructor : r, Z = N ? ui(N) : "";
          if (Z)
            switch (Z) {
              case bu:
                return Ge;
              case yu:
                return Re;
              case xu:
                return je;
              case wu:
                return He;
              case _u:
                return Ae;
            }
          return x;
        });
        function Ll(d, x, N) {
          for (var Z = -1, fe = N.length; ++Z < fe; ) {
            var ye = N[Z], qe = ye.size;
            switch (ye.type) {
              case "drop":
                d += qe;
                break;
              case "dropRight":
                x -= qe;
                break;
              case "take":
                x = Vt(x, d + qe);
                break;
              case "takeRight":
                d = jt(d, x - qe);
                break;
            }
          }
          return { start: d, end: x };
        }
        function Nl(d) {
          var x = d.match(ot);
          return x ? x[1].split(it) : [];
        }
        function go(d, x, N) {
          x = Qr(x, d);
          for (var Z = -1, fe = x.length, ye = !1; ++Z < fe; ) {
            var qe = Pr(x[Z]);
            if (!(ye = d != null && N(d, qe)))
              break;
            d = d[qe];
          }
          return ye || ++Z != fe ? ye : (fe = d == null ? 0 : d.length, !!fe && Rn(fe) && zr(qe, fe) && (bt(d) || li(d)));
        }
        function jl(d) {
          var x = d.length, N = new d.constructor(x);
          return x && typeof d[0] == "string" && Mt.call(d, "index") && (N.index = d.index, N.input = d.input), N;
        }
        function bo(d) {
          return typeof d.constructor == "function" && !Li(d) ? yi(Yi(d)) : {};
        }
        function Dl(d, x, N) {
          var Z = d.constructor;
          switch (x) {
            case Ue:
              return fa(d);
            case z:
            case se:
              return new Z(+d);
            case Ge:
              return Sl(d, N);
            case Xe:
            case oe:
            case L:
            case H:
            case ue:
            case xe:
            case pe:
            case ce:
            case Y:
              return Qs(d, N);
            case Re:
              return new Z();
            case Pe:
            case Qe:
              return new Z(d);
            case rt:
              return El(d);
            case He:
              return new Z();
            case Je:
              return Rl(d);
          }
        }
        function Fl(d, x) {
          var N = x.length;
          if (!N)
            return d;
          var Z = N - 1;
          return x[Z] = (N > 1 ? "& " : "") + x[Z], x = x.join(N > 2 ? ", " : " "), d.replace(at, `{
/* [wrapped with ` + x + `] */
`);
        }
        function Ul(d) {
          return bt(d) || li(d) || !!(_s && d && d[_s]);
        }
        function zr(d, x) {
          var N = typeof d;
          return x = x ?? k, !!x && (N == "number" || N != "symbol" && Yt.test(d)) && d > -1 && d % 1 == 0 && d < x;
        }
        function Xt(d, x, N) {
          if (!It(N))
            return !1;
          var Z = typeof x;
          return (Z == "number" ? nr(N) && zr(x, N.length) : Z == "string" && x in N) ? kr(N[x], d) : !1;
        }
        function ya(d, x) {
          if (bt(d))
            return !1;
          var N = typeof d;
          return N == "number" || N == "symbol" || N == "boolean" || d == null || br(d) ? !0 : W.test(d) || !ne.test(d) || x != null && d in Tt(x);
        }
        function zl(d) {
          var x = typeof d;
          return x == "string" || x == "number" || x == "symbol" || x == "boolean" ? d !== "__proto__" : d === null;
        }
        function xa(d) {
          var x = vn(d), N = ge[x];
          if (typeof N != "function" || !(x in Et.prototype))
            return !1;
          if (d === N)
            return !0;
          var Z = va(N);
          return !!Z && d === Z[0];
        }
        function Hl(d) {
          return !!bs && bs in d;
        }
        var Kl = Ki ? Hr : La;
        function Li(d) {
          var x = d && d.constructor, N = typeof x == "function" && x.prototype || vi;
          return d === N;
        }
        function yo(d) {
          return d === d && !It(d);
        }
        function xo(d, x) {
          return function(N) {
            return N == null ? !1 : N[d] === x && (x !== r || d in Tt(N));
          };
        }
        function Wl(d) {
          var x = Sn(d, function(Z) {
            return N.size === l && N.clear(), Z;
          }), N = x.cache;
          return x;
        }
        function Gl(d, x) {
          var N = d[1], Z = x[1], fe = N | Z, ye = fe < (E | b | V), qe = Z == V && N == O || Z == V && N == Q && d[7].length <= x[8] || Z == (V | Q) && x[7].length <= x[8] && N == O;
          if (!(ye || qe))
            return d;
          Z & E && (d[2] = x[2], fe |= N & E ? 0 : q);
          var Be = x[3];
          if (Be) {
            var Le = d[3];
            d[3] = Le ? to(Le, Be, x[4]) : Be, d[4] = Le ? Zr(d[3], s) : x[4];
          }
          return Be = x[5], Be && (Le = d[5], d[5] = Le ? ro(Le, Be, x[6]) : Be, d[6] = Le ? Zr(d[5], s) : x[6]), Be = x[7], Be && (d[7] = Be), Z & V && (d[8] = d[8] == null ? x[8] : Vt(d[8], x[8])), d[9] == null && (d[9] = x[9]), d[0] = x[0], d[1] = fe, d;
        }
        function Vl(d) {
          var x = [];
          if (d != null)
            for (var N in Tt(d))
              x.push(N);
          return x;
        }
        function Zl(d) {
          return Gi.call(d);
        }
        function wo(d, x, N) {
          return x = jt(x === r ? d.length - 1 : x, 0), function() {
            for (var Z = arguments, fe = -1, ye = jt(Z.length - x, 0), qe = Ke(ye); ++fe < ye; )
              qe[fe] = Z[x + fe];
            fe = -1;
            for (var Be = Ke(x + 1); ++fe < x; )
              Be[fe] = Z[fe];
            return Be[x] = N(qe), hr(d, this, Be);
          };
        }
        function _o(d, x) {
          return x.length < 2 ? d : oi(d, qr(x, 0, -1));
        }
        function Yl(d, x) {
          for (var N = d.length, Z = Vt(x.length, N), fe = ir(d); Z--; ) {
            var ye = x[Z];
            d[Z] = zr(ye, N) ? fe[ye] : r;
          }
          return d;
        }
        function wa(d, x) {
          if (!(x === "constructor" && typeof d[x] == "function") && x != "__proto__")
            return d[x];
        }
        var So = Ro(Ks), Ni = fu || function(d, x) {
          return zt.setTimeout(d, x);
        }, _a = Ro(yl);
        function Eo(d, x, N) {
          var Z = x + "";
          return _a(d, Fl(Z, Jl(Nl(Z), N)));
        }
        function Ro(d) {
          var x = 0, N = 0;
          return function() {
            var Z = mu(), fe = M - (Z - N);
            if (N = Z, fe > 0) {
              if (++x >= R)
                return arguments[0];
            } else
              x = 0;
            return d.apply(r, arguments);
          };
        }
        function yn(d, x) {
          var N = -1, Z = d.length, fe = Z - 1;
          for (x = x === r ? Z : x; ++N < x; ) {
            var ye = na(N, fe), qe = d[ye];
            d[ye] = d[N], d[N] = qe;
          }
          return d.length = x, d;
        }
        var qo = Wl(function(d) {
          var x = [];
          return d.charCodeAt(0) === 46 && x.push(""), d.replace(J, function(N, Z, fe, ye) {
            x.push(fe ? ye.replace(st, "$1") : Z || N);
          }), x;
        });
        function Pr(d) {
          if (typeof d == "string" || br(d))
            return d;
          var x = d + "";
          return x == "0" && 1 / d == -T ? "-0" : x;
        }
        function ui(d) {
          if (d != null) {
            try {
              return Wi.call(d);
            } catch {
            }
            try {
              return d + "";
            } catch {
            }
          }
          return "";
        }
        function Jl(d, x) {
          return _r(ie, function(N) {
            var Z = "_." + N[0];
            x & N[1] && !Fi(d, Z) && d.push(Z);
          }), d.sort();
        }
        function Ao(d) {
          if (d instanceof Et)
            return d.clone();
          var x = new Er(d.__wrapped__, d.__chain__);
          return x.__actions__ = ir(d.__actions__), x.__index__ = d.__index__, x.__values__ = d.__values__, x;
        }
        function Xl(d, x, N) {
          (N ? Xt(d, x, N) : x === r) ? x = 1 : x = jt(xt(x), 0);
          var Z = d == null ? 0 : d.length;
          if (!Z || x < 1)
            return [];
          for (var fe = 0, ye = 0, qe = Ke(Qi(Z / x)); fe < Z; )
            qe[ye++] = qr(d, fe, fe += x);
          return qe;
        }
        function Ql(d) {
          for (var x = -1, N = d == null ? 0 : d.length, Z = 0, fe = []; ++x < N; ) {
            var ye = d[x];
            ye && (fe[Z++] = ye);
          }
          return fe;
        }
        function ef() {
          var d = arguments.length;
          if (!d)
            return [];
          for (var x = Ke(d - 1), N = arguments[0], Z = d; Z--; )
            x[Z - 1] = arguments[Z];
          return Vr(bt(N) ? ir(N) : [N], Ht(x, 1));
        }
        var tf = _t(function(d, x) {
          return Ot(d) ? Bi(d, Ht(x, 1, Ot, !0)) : [];
        }), rf = _t(function(d, x) {
          var N = Ar(x);
          return Ot(N) && (N = r), Ot(d) ? Bi(d, Ht(x, 1, Ot, !0), ht(N, 2)) : [];
        }), nf = _t(function(d, x) {
          var N = Ar(x);
          return Ot(N) && (N = r), Ot(d) ? Bi(d, Ht(x, 1, Ot, !0), r, N) : [];
        });
        function af(d, x, N) {
          var Z = d == null ? 0 : d.length;
          return Z ? (x = N || x === r ? 1 : xt(x), qr(d, x < 0 ? 0 : x, Z)) : [];
        }
        function sf(d, x, N) {
          var Z = d == null ? 0 : d.length;
          return Z ? (x = N || x === r ? 1 : xt(x), x = Z - x, qr(d, 0, x < 0 ? 0 : x)) : [];
        }
        function of(d, x) {
          return d && d.length ? ln(d, ht(x, 3), !0, !0) : [];
        }
        function cf(d, x) {
          return d && d.length ? ln(d, ht(x, 3), !0) : [];
        }
        function uf(d, x, N, Z) {
          var fe = d == null ? 0 : d.length;
          return fe ? (N && typeof N != "number" && Xt(d, x, N) && (N = 0, Z = fe), el(d, x, N, Z)) : [];
        }
        function Mo(d, x, N) {
          var Z = d == null ? 0 : d.length;
          if (!Z)
            return -1;
          var fe = N == null ? 0 : xt(N);
          return fe < 0 && (fe = jt(Z + fe, 0)), Ui(d, ht(x, 3), fe);
        }
        function To(d, x, N) {
          var Z = d == null ? 0 : d.length;
          if (!Z)
            return -1;
          var fe = Z - 1;
          return N !== r && (fe = xt(N), fe = N < 0 ? jt(Z + fe, 0) : Vt(fe, Z - 1)), Ui(d, ht(x, 3), fe, !0);
        }
        function Co(d) {
          var x = d == null ? 0 : d.length;
          return x ? Ht(d, 1) : [];
        }
        function lf(d) {
          var x = d == null ? 0 : d.length;
          return x ? Ht(d, T) : [];
        }
        function ff(d, x) {
          var N = d == null ? 0 : d.length;
          return N ? (x = x === r ? 1 : xt(x), Ht(d, x)) : [];
        }
        function pf(d) {
          for (var x = -1, N = d == null ? 0 : d.length, Z = {}; ++x < N; ) {
            var fe = d[x];
            Z[fe[0]] = fe[1];
          }
          return Z;
        }
        function ko(d) {
          return d && d.length ? d[0] : r;
        }
        function df(d, x, N) {
          var Z = d == null ? 0 : d.length;
          if (!Z)
            return -1;
          var fe = N == null ? 0 : xt(N);
          return fe < 0 && (fe = jt(Z + fe, 0)), pi(d, x, fe);
        }
        function hf(d) {
          var x = d == null ? 0 : d.length;
          return x ? qr(d, 0, -1) : [];
        }
        var mf = _t(function(d) {
          var x = Bt(d, ua);
          return x.length && x[0] === d[0] ? Qn(x) : [];
        }), vf = _t(function(d) {
          var x = Ar(d), N = Bt(d, ua);
          return x === Ar(N) ? x = r : N.pop(), N.length && N[0] === d[0] ? Qn(N, ht(x, 2)) : [];
        }), gf = _t(function(d) {
          var x = Ar(d), N = Bt(d, ua);
          return x = typeof x == "function" ? x : r, x && N.pop(), N.length && N[0] === d[0] ? Qn(N, r, x) : [];
        });
        function bf(d, x) {
          return d == null ? "" : du.call(d, x);
        }
        function Ar(d) {
          var x = d == null ? 0 : d.length;
          return x ? d[x - 1] : r;
        }
        function yf(d, x, N) {
          var Z = d == null ? 0 : d.length;
          if (!Z)
            return -1;
          var fe = Z;
          return N !== r && (fe = xt(N), fe = fe < 0 ? jt(Z + fe, 0) : Vt(fe, Z - 1)), x === x ? Jc(d, x, fe) : Ui(d, cs, fe, !0);
        }
        function xf(d, x) {
          return d && d.length ? Fs(d, xt(x)) : r;
        }
        var wf = _t(Bo);
        function Bo(d, x) {
          return d && d.length && x && x.length ? ia(d, x) : d;
        }
        function _f(d, x, N) {
          return d && d.length && x && x.length ? ia(d, x, ht(N, 2)) : d;
        }
        function Sf(d, x, N) {
          return d && d.length && x && x.length ? ia(d, x, r, N) : d;
        }
        var Ef = Ur(function(d, x) {
          var N = d == null ? 0 : d.length, Z = Zn(d, x);
          return Hs(d, Bt(x, function(fe) {
            return zr(fe, N) ? +fe : fe;
          }).sort(eo)), Z;
        });
        function Rf(d, x) {
          var N = [];
          if (!(d && d.length))
            return N;
          var Z = -1, fe = [], ye = d.length;
          for (x = ht(x, 3); ++Z < ye; ) {
            var qe = d[Z];
            x(qe, Z, d) && (N.push(qe), fe.push(Z));
          }
          return Hs(d, fe), N;
        }
        function Sa(d) {
          return d == null ? d : gu.call(d);
        }
        function qf(d, x, N) {
          var Z = d == null ? 0 : d.length;
          return Z ? (N && typeof N != "number" && Xt(d, x, N) ? (x = 0, N = Z) : (x = x == null ? 0 : xt(x), N = N === r ? Z : xt(N)), qr(d, x, N)) : [];
        }
        function Af(d, x) {
          return un(d, x);
        }
        function Mf(d, x, N) {
          return sa(d, x, ht(N, 2));
        }
        function Tf(d, x) {
          var N = d == null ? 0 : d.length;
          if (N) {
            var Z = un(d, x);
            if (Z < N && kr(d[Z], x))
              return Z;
          }
          return -1;
        }
        function Cf(d, x) {
          return un(d, x, !0);
        }
        function kf(d, x, N) {
          return sa(d, x, ht(N, 2), !0);
        }
        function Bf(d, x) {
          var N = d == null ? 0 : d.length;
          if (N) {
            var Z = un(d, x, !0) - 1;
            if (kr(d[Z], x))
              return Z;
          }
          return -1;
        }
        function If(d) {
          return d && d.length ? Ws(d) : [];
        }
        function $f(d, x) {
          return d && d.length ? Ws(d, ht(x, 2)) : [];
        }
        function Of(d) {
          var x = d == null ? 0 : d.length;
          return x ? qr(d, 1, x) : [];
        }
        function Pf(d, x, N) {
          return d && d.length ? (x = N || x === r ? 1 : xt(x), qr(d, 0, x < 0 ? 0 : x)) : [];
        }
        function Lf(d, x, N) {
          var Z = d == null ? 0 : d.length;
          return Z ? (x = N || x === r ? 1 : xt(x), x = Z - x, qr(d, x < 0 ? 0 : x, Z)) : [];
        }
        function Nf(d, x) {
          return d && d.length ? ln(d, ht(x, 3), !1, !0) : [];
        }
        function jf(d, x) {
          return d && d.length ? ln(d, ht(x, 3)) : [];
        }
        var Df = _t(function(d) {
          return Xr(Ht(d, 1, Ot, !0));
        }), Ff = _t(function(d) {
          var x = Ar(d);
          return Ot(x) && (x = r), Xr(Ht(d, 1, Ot, !0), ht(x, 2));
        }), Uf = _t(function(d) {
          var x = Ar(d);
          return x = typeof x == "function" ? x : r, Xr(Ht(d, 1, Ot, !0), r, x);
        });
        function zf(d) {
          return d && d.length ? Xr(d) : [];
        }
        function Hf(d, x) {
          return d && d.length ? Xr(d, ht(x, 2)) : [];
        }
        function Kf(d, x) {
          return x = typeof x == "function" ? x : r, d && d.length ? Xr(d, r, x) : [];
        }
        function Ea(d) {
          if (!(d && d.length))
            return [];
          var x = 0;
          return d = Gr(d, function(N) {
            if (Ot(N))
              return x = jt(N.length, x), !0;
          }), Fn(x, function(N) {
            return Bt(d, Nn(N));
          });
        }
        function Io(d, x) {
          if (!(d && d.length))
            return [];
          var N = Ea(d);
          return x == null ? N : Bt(N, function(Z) {
            return hr(x, r, Z);
          });
        }
        var Wf = _t(function(d, x) {
          return Ot(d) ? Bi(d, x) : [];
        }), Gf = _t(function(d) {
          return ca(Gr(d, Ot));
        }), Vf = _t(function(d) {
          var x = Ar(d);
          return Ot(x) && (x = r), ca(Gr(d, Ot), ht(x, 2));
        }), Zf = _t(function(d) {
          var x = Ar(d);
          return x = typeof x == "function" ? x : r, ca(Gr(d, Ot), r, x);
        }), Yf = _t(Ea);
        function Jf(d, x) {
          return Ys(d || [], x || [], ki);
        }
        function Xf(d, x) {
          return Ys(d || [], x || [], Oi);
        }
        var Qf = _t(function(d) {
          var x = d.length, N = x > 1 ? d[x - 1] : r;
          return N = typeof N == "function" ? (d.pop(), N) : r, Io(d, N);
        });
        function $o(d) {
          var x = ge(d);
          return x.__chain__ = !0, x;
        }
        function ep(d, x) {
          return x(d), d;
        }
        function xn(d, x) {
          return x(d);
        }
        var tp = Ur(function(d) {
          var x = d.length, N = x ? d[0] : 0, Z = this.__wrapped__, fe = function(ye) {
            return Zn(ye, d);
          };
          return x > 1 || this.__actions__.length || !(Z instanceof Et) || !zr(N) ? this.thru(fe) : (Z = Z.slice(N, +N + (x ? 1 : 0)), Z.__actions__.push({
            func: xn,
            args: [fe],
            thisArg: r
          }), new Er(Z, this.__chain__).thru(function(ye) {
            return x && !ye.length && ye.push(r), ye;
          }));
        });
        function rp() {
          return $o(this);
        }
        function ip() {
          return new Er(this.value(), this.__chain__);
        }
        function np() {
          this.__values__ === r && (this.__values__ = Vo(this.value()));
          var d = this.__index__ >= this.__values__.length, x = d ? r : this.__values__[this.__index__++];
          return { done: d, value: x };
        }
        function ap() {
          return this;
        }
        function sp(d) {
          for (var x, N = this; N instanceof nn; ) {
            var Z = Ao(N);
            Z.__index__ = 0, Z.__values__ = r, x ? fe.__wrapped__ = Z : x = Z;
            var fe = Z;
            N = N.__wrapped__;
          }
          return fe.__wrapped__ = d, x;
        }
        function op() {
          var d = this.__wrapped__;
          if (d instanceof Et) {
            var x = d;
            return this.__actions__.length && (x = new Et(this)), x = x.reverse(), x.__actions__.push({
              func: xn,
              args: [Sa],
              thisArg: r
            }), new Er(x, this.__chain__);
          }
          return this.thru(Sa);
        }
        function cp() {
          return Zs(this.__wrapped__, this.__actions__);
        }
        var up = fn(function(d, x, N) {
          Mt.call(d, N) ? ++d[N] : Dr(d, N, 1);
        });
        function lp(d, x, N) {
          var Z = bt(d) ? ss : Qu;
          return N && Xt(d, x, N) && (x = r), Z(d, ht(x, 3));
        }
        function fp(d, x) {
          var N = bt(d) ? Gr : Bs;
          return N(d, ht(x, 3));
        }
        var pp = so(Mo), dp = so(To);
        function hp(d, x) {
          return Ht(wn(d, x), 1);
        }
        function mp(d, x) {
          return Ht(wn(d, x), T);
        }
        function vp(d, x, N) {
          return N = N === r ? 1 : xt(N), Ht(wn(d, x), N);
        }
        function Oo(d, x) {
          var N = bt(d) ? _r : Jr;
          return N(d, ht(x, 3));
        }
        function Po(d, x) {
          var N = bt(d) ? $c : ks;
          return N(d, ht(x, 3));
        }
        var gp = fn(function(d, x, N) {
          Mt.call(d, N) ? d[N].push(x) : Dr(d, N, [x]);
        });
        function bp(d, x, N, Z) {
          d = nr(d) ? d : Ei(d), N = N && !Z ? xt(N) : 0;
          var fe = d.length;
          return N < 0 && (N = jt(fe + N, 0)), qn(d) ? N <= fe && d.indexOf(x, N) > -1 : !!fe && pi(d, x, N) > -1;
        }
        var yp = _t(function(d, x, N) {
          var Z = -1, fe = typeof x == "function", ye = nr(d) ? Ke(d.length) : [];
          return Jr(d, function(qe) {
            ye[++Z] = fe ? hr(x, qe, N) : Ii(qe, x, N);
          }), ye;
        }), xp = fn(function(d, x, N) {
          Dr(d, N, x);
        });
        function wn(d, x) {
          var N = bt(d) ? Bt : Ns;
          return N(d, ht(x, 3));
        }
        function wp(d, x, N, Z) {
          return d == null ? [] : (bt(x) || (x = x == null ? [] : [x]), N = Z ? r : N, bt(N) || (N = N == null ? [] : [N]), Us(d, x, N));
        }
        var _p = fn(function(d, x, N) {
          d[N ? 0 : 1].push(x);
        }, function() {
          return [[], []];
        });
        function Sp(d, x, N) {
          var Z = bt(d) ? Pn : ls, fe = arguments.length < 3;
          return Z(d, ht(x, 4), N, fe, Jr);
        }
        function Ep(d, x, N) {
          var Z = bt(d) ? Oc : ls, fe = arguments.length < 3;
          return Z(d, ht(x, 4), N, fe, ks);
        }
        function Rp(d, x) {
          var N = bt(d) ? Gr : Bs;
          return N(d, En(ht(x, 3)));
        }
        function qp(d) {
          var x = bt(d) ? As : gl;
          return x(d);
        }
        function Ap(d, x, N) {
          (N ? Xt(d, x, N) : x === r) ? x = 1 : x = xt(x);
          var Z = bt(d) ? Vu : bl;
          return Z(d, x);
        }
        function Mp(d) {
          var x = bt(d) ? Zu : xl;
          return x(d);
        }
        function Tp(d) {
          if (d == null)
            return 0;
          if (nr(d))
            return qn(d) ? hi(d) : d.length;
          var x = Zt(d);
          return x == Re || x == He ? d.size : ta(d).length;
        }
        function Cp(d, x, N) {
          var Z = bt(d) ? Ln : wl;
          return N && Xt(d, x, N) && (x = r), Z(d, ht(x, 3));
        }
        var kp = _t(function(d, x) {
          if (d == null)
            return [];
          var N = x.length;
          return N > 1 && Xt(d, x[0], x[1]) ? x = [] : N > 2 && Xt(x[0], x[1], x[2]) && (x = [x[0]]), Us(d, Ht(x, 1), []);
        }), _n = lu || function() {
          return zt.Date.now();
        };
        function Bp(d, x) {
          if (typeof x != "function")
            throw new Sr(o);
          return d = xt(d), function() {
            if (--d < 1)
              return x.apply(this, arguments);
          };
        }
        function Lo(d, x, N) {
          return x = N ? r : x, x = d && x == null ? d.length : x, Fr(d, V, r, r, r, r, x);
        }
        function No(d, x) {
          var N;
          if (typeof x != "function")
            throw new Sr(o);
          return d = xt(d), function() {
            return --d > 0 && (N = x.apply(this, arguments)), d <= 1 && (x = r), N;
          };
        }
        var Ra = _t(function(d, x, N) {
          var Z = E;
          if (N.length) {
            var fe = Zr(N, _i(Ra));
            Z |= D;
          }
          return Fr(d, Z, x, N, fe);
        }), jo = _t(function(d, x, N) {
          var Z = E | b;
          if (N.length) {
            var fe = Zr(N, _i(jo));
            Z |= D;
          }
          return Fr(x, Z, d, N, fe);
        });
        function Do(d, x, N) {
          x = N ? r : x;
          var Z = Fr(d, O, r, r, r, r, r, x);
          return Z.placeholder = Do.placeholder, Z;
        }
        function Fo(d, x, N) {
          x = N ? r : x;
          var Z = Fr(d, j, r, r, r, r, r, x);
          return Z.placeholder = Fo.placeholder, Z;
        }
        function Uo(d, x, N) {
          var Z, fe, ye, qe, Be, Le, Ze = 0, Ye = !1, et = !1, ut = !0;
          if (typeof d != "function")
            throw new Sr(o);
          x = Mr(x) || 0, It(N) && (Ye = !!N.leading, et = "maxWait" in N, ye = et ? jt(Mr(N.maxWait) || 0, x) : ye, ut = "trailing" in N ? !!N.trailing : ut);
          function pt(Pt) {
            var Br = Z, Wr = fe;
            return Z = fe = r, Ze = Pt, qe = d.apply(Wr, Br), qe;
          }
          function mt(Pt) {
            return Ze = Pt, Be = Ni(St, x), Ye ? pt(Pt) : qe;
          }
          function wt(Pt) {
            var Br = Pt - Le, Wr = Pt - Ze, cc = x - Br;
            return et ? Vt(cc, ye - Wr) : cc;
          }
          function vt(Pt) {
            var Br = Pt - Le, Wr = Pt - Ze;
            return Le === r || Br >= x || Br < 0 || et && Wr >= ye;
          }
          function St() {
            var Pt = _n();
            if (vt(Pt))
              return Rt(Pt);
            Be = Ni(St, wt(Pt));
          }
          function Rt(Pt) {
            return Be = r, ut && Z ? pt(Pt) : (Z = fe = r, qe);
          }
          function yr() {
            Be !== r && Js(Be), Ze = 0, Z = Le = fe = Be = r;
          }
          function Qt() {
            return Be === r ? qe : Rt(_n());
          }
          function xr() {
            var Pt = _n(), Br = vt(Pt);
            if (Z = arguments, fe = this, Le = Pt, Br) {
              if (Be === r)
                return mt(Le);
              if (et)
                return Js(Be), Be = Ni(St, x), pt(Le);
            }
            return Be === r && (Be = Ni(St, x)), qe;
          }
          return xr.cancel = yr, xr.flush = Qt, xr;
        }
        var Ip = _t(function(d, x) {
          return Cs(d, 1, x);
        }), $p = _t(function(d, x, N) {
          return Cs(d, Mr(x) || 0, N);
        });
        function Op(d) {
          return Fr(d, re);
        }
        function Sn(d, x) {
          if (typeof d != "function" || x != null && typeof x != "function")
            throw new Sr(o);
          var N = function() {
            var Z = arguments, fe = x ? x.apply(this, Z) : Z[0], ye = N.cache;
            if (ye.has(fe))
              return ye.get(fe);
            var qe = d.apply(this, Z);
            return N.cache = ye.set(fe, qe) || ye, qe;
          };
          return N.cache = new (Sn.Cache || jr)(), N;
        }
        Sn.Cache = jr;
        function En(d) {
          if (typeof d != "function")
            throw new Sr(o);
          return function() {
            var x = arguments;
            switch (x.length) {
              case 0:
                return !d.call(this);
              case 1:
                return !d.call(this, x[0]);
              case 2:
                return !d.call(this, x[0], x[1]);
              case 3:
                return !d.call(this, x[0], x[1], x[2]);
            }
            return !d.apply(this, x);
          };
        }
        function Pp(d) {
          return No(2, d);
        }
        var Lp = _l(function(d, x) {
          x = x.length == 1 && bt(x[0]) ? Bt(x[0], vr(ht())) : Bt(Ht(x, 1), vr(ht()));
          var N = x.length;
          return _t(function(Z) {
            for (var fe = -1, ye = Vt(Z.length, N); ++fe < ye; )
              Z[fe] = x[fe].call(this, Z[fe]);
            return hr(d, this, Z);
          });
        }), qa = _t(function(d, x) {
          var N = Zr(x, _i(qa));
          return Fr(d, D, r, x, N);
        }), zo = _t(function(d, x) {
          var N = Zr(x, _i(zo));
          return Fr(d, G, r, x, N);
        }), Np = Ur(function(d, x) {
          return Fr(d, Q, r, r, r, x);
        });
        function jp(d, x) {
          if (typeof d != "function")
            throw new Sr(o);
          return x = x === r ? x : xt(x), _t(d, x);
        }
        function Dp(d, x) {
          if (typeof d != "function")
            throw new Sr(o);
          return x = x == null ? 0 : jt(xt(x), 0), _t(function(N) {
            var Z = N[x], fe = ei(N, 0, x);
            return Z && Vr(fe, Z), hr(d, this, fe);
          });
        }
        function Fp(d, x, N) {
          var Z = !0, fe = !0;
          if (typeof d != "function")
            throw new Sr(o);
          return It(N) && (Z = "leading" in N ? !!N.leading : Z, fe = "trailing" in N ? !!N.trailing : fe), Uo(d, x, {
            leading: Z,
            maxWait: x,
            trailing: fe
          });
        }
        function Up(d) {
          return Lo(d, 1);
        }
        function zp(d, x) {
          return qa(la(x), d);
        }
        function Hp() {
          if (!arguments.length)
            return [];
          var d = arguments[0];
          return bt(d) ? d : [d];
        }
        function Kp(d) {
          return Rr(d, g);
        }
        function Wp(d, x) {
          return x = typeof x == "function" ? x : r, Rr(d, g, x);
        }
        function Gp(d) {
          return Rr(d, p | g);
        }
        function Vp(d, x) {
          return x = typeof x == "function" ? x : r, Rr(d, p | g, x);
        }
        function Zp(d, x) {
          return x == null || Ts(d, x, Ft(x));
        }
        function kr(d, x) {
          return d === x || d !== d && x !== x;
        }
        var Yp = mn(Xn), Jp = mn(function(d, x) {
          return d >= x;
        }), li = Os(/* @__PURE__ */ (function() {
          return arguments;
        })()) ? Os : function(d) {
          return $t(d) && Mt.call(d, "callee") && !ws.call(d, "callee");
        }, bt = Ke.isArray, Xp = es ? vr(es) : al;
        function nr(d) {
          return d != null && Rn(d.length) && !Hr(d);
        }
        function Ot(d) {
          return $t(d) && nr(d);
        }
        function Qp(d) {
          return d === !0 || d === !1 || $t(d) && Jt(d) == z;
        }
        var ti = pu || La, ed = ts ? vr(ts) : sl;
        function td(d) {
          return $t(d) && d.nodeType === 1 && !ji(d);
        }
        function rd(d) {
          if (d == null)
            return !0;
          if (nr(d) && (bt(d) || typeof d == "string" || typeof d.splice == "function" || ti(d) || Si(d) || li(d)))
            return !d.length;
          var x = Zt(d);
          if (x == Re || x == He)
            return !d.size;
          if (Li(d))
            return !ta(d).length;
          for (var N in d)
            if (Mt.call(d, N))
              return !1;
          return !0;
        }
        function id(d, x) {
          return $i(d, x);
        }
        function nd(d, x, N) {
          N = typeof N == "function" ? N : r;
          var Z = N ? N(d, x) : r;
          return Z === r ? $i(d, x, r, N) : !!Z;
        }
        function Aa(d) {
          if (!$t(d))
            return !1;
          var x = Jt(d);
          return x == ae || x == he || typeof d.message == "string" && typeof d.name == "string" && !ji(d);
        }
        function ad(d) {
          return typeof d == "number" && Ss(d);
        }
        function Hr(d) {
          if (!It(d))
            return !1;
          var x = Jt(d);
          return x == X || x == be || x == F || x == Oe;
        }
        function Ho(d) {
          return typeof d == "number" && d == xt(d);
        }
        function Rn(d) {
          return typeof d == "number" && d > -1 && d % 1 == 0 && d <= k;
        }
        function It(d) {
          var x = typeof d;
          return d != null && (x == "object" || x == "function");
        }
        function $t(d) {
          return d != null && typeof d == "object";
        }
        var Ko = rs ? vr(rs) : cl;
        function sd(d, x) {
          return d === x || ea(d, x, ga(x));
        }
        function od(d, x, N) {
          return N = typeof N == "function" ? N : r, ea(d, x, ga(x), N);
        }
        function cd(d) {
          return Wo(d) && d != +d;
        }
        function ud(d) {
          if (Kl(d))
            throw new gt(n);
          return Ps(d);
        }
        function ld(d) {
          return d === null;
        }
        function fd(d) {
          return d == null;
        }
        function Wo(d) {
          return typeof d == "number" || $t(d) && Jt(d) == Pe;
        }
        function ji(d) {
          if (!$t(d) || Jt(d) != De)
            return !1;
          var x = Yi(d);
          if (x === null)
            return !0;
          var N = Mt.call(x, "constructor") && x.constructor;
          return typeof N == "function" && N instanceof N && Wi.call(N) == su;
        }
        var Ma = is ? vr(is) : ul;
        function pd(d) {
          return Ho(d) && d >= -k && d <= k;
        }
        var Go = ns ? vr(ns) : ll;
        function qn(d) {
          return typeof d == "string" || !bt(d) && $t(d) && Jt(d) == Qe;
        }
        function br(d) {
          return typeof d == "symbol" || $t(d) && Jt(d) == Je;
        }
        var Si = as ? vr(as) : fl;
        function dd(d) {
          return d === r;
        }
        function hd(d) {
          return $t(d) && Zt(d) == Ae;
        }
        function md(d) {
          return $t(d) && Jt(d) == ze;
        }
        var vd = mn(ra), gd = mn(function(d, x) {
          return d <= x;
        });
        function Vo(d) {
          if (!d)
            return [];
          if (nr(d))
            return qn(d) ? Tr(d) : ir(d);
          if (qi && d[qi])
            return Vc(d[qi]());
          var x = Zt(d), N = x == Re ? zn : x == He ? zi : Ei;
          return N(d);
        }
        function Kr(d) {
          if (!d)
            return d === 0 ? d : 0;
          if (d = Mr(d), d === T || d === -T) {
            var x = d < 0 ? -1 : 1;
            return x * I;
          }
          return d === d ? d : 0;
        }
        function xt(d) {
          var x = Kr(d), N = x % 1;
          return x === x ? N ? x - N : x : 0;
        }
        function Zo(d) {
          return d ? si(xt(d), 0, $) : 0;
        }
        function Mr(d) {
          if (typeof d == "number")
            return d;
          if (br(d))
            return C;
          if (It(d)) {
            var x = typeof d.valueOf == "function" ? d.valueOf() : d;
            d = It(x) ? x + "" : x;
          }
          if (typeof d != "string")
            return d === 0 ? d : +d;
          d = ps(d);
          var N = Ut.test(d);
          return N || Dt.test(d) ? kc(d.slice(2), N ? 2 : 8) : dt.test(d) ? C : +d;
        }
        function Yo(d) {
          return Or(d, ar(d));
        }
        function bd(d) {
          return d ? si(xt(d), -k, k) : d === 0 ? d : 0;
        }
        function At(d) {
          return d == null ? "" : gr(d);
        }
        var yd = xi(function(d, x) {
          if (Li(x) || nr(x)) {
            Or(x, Ft(x), d);
            return;
          }
          for (var N in x)
            Mt.call(x, N) && ki(d, N, x[N]);
        }), Jo = xi(function(d, x) {
          Or(x, ar(x), d);
        }), An = xi(function(d, x, N, Z) {
          Or(x, ar(x), d, Z);
        }), xd = xi(function(d, x, N, Z) {
          Or(x, Ft(x), d, Z);
        }), wd = Ur(Zn);
        function _d(d, x) {
          var N = yi(d);
          return x == null ? N : Ms(N, x);
        }
        var Sd = _t(function(d, x) {
          d = Tt(d);
          var N = -1, Z = x.length, fe = Z > 2 ? x[2] : r;
          for (fe && Xt(x[0], x[1], fe) && (Z = 1); ++N < Z; )
            for (var ye = x[N], qe = ar(ye), Be = -1, Le = qe.length; ++Be < Le; ) {
              var Ze = qe[Be], Ye = d[Ze];
              (Ye === r || kr(Ye, vi[Ze]) && !Mt.call(d, Ze)) && (d[Ze] = ye[Ze]);
            }
          return d;
        }), Ed = _t(function(d) {
          return d.push(r, ho), hr(Xo, r, d);
        });
        function Rd(d, x) {
          return os(d, ht(x, 3), $r);
        }
        function qd(d, x) {
          return os(d, ht(x, 3), Jn);
        }
        function Ad(d, x) {
          return d == null ? d : Yn(d, ht(x, 3), ar);
        }
        function Md(d, x) {
          return d == null ? d : Is(d, ht(x, 3), ar);
        }
        function Td(d, x) {
          return d && $r(d, ht(x, 3));
        }
        function Cd(d, x) {
          return d && Jn(d, ht(x, 3));
        }
        function kd(d) {
          return d == null ? [] : on(d, Ft(d));
        }
        function Bd(d) {
          return d == null ? [] : on(d, ar(d));
        }
        function Ta(d, x, N) {
          var Z = d == null ? r : oi(d, x);
          return Z === r ? N : Z;
        }
        function Id(d, x) {
          return d != null && go(d, x, tl);
        }
        function Ca(d, x) {
          return d != null && go(d, x, rl);
        }
        var $d = co(function(d, x, N) {
          x != null && typeof x.toString != "function" && (x = Gi.call(x)), d[x] = N;
        }, Ba(sr)), Od = co(function(d, x, N) {
          x != null && typeof x.toString != "function" && (x = Gi.call(x)), Mt.call(d, x) ? d[x].push(N) : d[x] = [N];
        }, ht), Pd = _t(Ii);
        function Ft(d) {
          return nr(d) ? qs(d) : ta(d);
        }
        function ar(d) {
          return nr(d) ? qs(d, !0) : pl(d);
        }
        function Ld(d, x) {
          var N = {};
          return x = ht(x, 3), $r(d, function(Z, fe, ye) {
            Dr(N, x(Z, fe, ye), Z);
          }), N;
        }
        function Nd(d, x) {
          var N = {};
          return x = ht(x, 3), $r(d, function(Z, fe, ye) {
            Dr(N, fe, x(Z, fe, ye));
          }), N;
        }
        var jd = xi(function(d, x, N) {
          cn(d, x, N);
        }), Xo = xi(function(d, x, N, Z) {
          cn(d, x, N, Z);
        }), Dd = Ur(function(d, x) {
          var N = {};
          if (d == null)
            return N;
          var Z = !1;
          x = Bt(x, function(ye) {
            return ye = Qr(ye, d), Z || (Z = ye.length > 1), ye;
          }), Or(d, ma(d), N), Z && (N = Rr(N, p | m | g, Il));
          for (var fe = x.length; fe--; )
            oa(N, x[fe]);
          return N;
        });
        function Fd(d, x) {
          return Qo(d, En(ht(x)));
        }
        var Ud = Ur(function(d, x) {
          return d == null ? {} : hl(d, x);
        });
        function Qo(d, x) {
          if (d == null)
            return {};
          var N = Bt(ma(d), function(Z) {
            return [Z];
          });
          return x = ht(x), zs(d, N, function(Z, fe) {
            return x(Z, fe[0]);
          });
        }
        function zd(d, x, N) {
          x = Qr(x, d);
          var Z = -1, fe = x.length;
          for (fe || (fe = 1, d = r); ++Z < fe; ) {
            var ye = d == null ? r : d[Pr(x[Z])];
            ye === r && (Z = fe, ye = N), d = Hr(ye) ? ye.call(d) : ye;
          }
          return d;
        }
        function Hd(d, x, N) {
          return d == null ? d : Oi(d, x, N);
        }
        function Kd(d, x, N, Z) {
          return Z = typeof Z == "function" ? Z : r, d == null ? d : Oi(d, x, N, Z);
        }
        var tc = fo(Ft), rc = fo(ar);
        function Wd(d, x, N) {
          var Z = bt(d), fe = Z || ti(d) || Si(d);
          if (x = ht(x, 4), N == null) {
            var ye = d && d.constructor;
            fe ? N = Z ? new ye() : [] : It(d) ? N = Hr(ye) ? yi(Yi(d)) : {} : N = {};
          }
          return (fe ? _r : $r)(d, function(qe, Be, Le) {
            return x(N, qe, Be, Le);
          }), N;
        }
        function Gd(d, x) {
          return d == null ? !0 : oa(d, x);
        }
        function Vd(d, x, N) {
          return d == null ? d : Vs(d, x, la(N));
        }
        function Zd(d, x, N, Z) {
          return Z = typeof Z == "function" ? Z : r, d == null ? d : Vs(d, x, la(N), Z);
        }
        function Ei(d) {
          return d == null ? [] : Un(d, Ft(d));
        }
        function Yd(d) {
          return d == null ? [] : Un(d, ar(d));
        }
        function Jd(d, x, N) {
          return N === r && (N = x, x = r), N !== r && (N = Mr(N), N = N === N ? N : 0), x !== r && (x = Mr(x), x = x === x ? x : 0), si(Mr(d), x, N);
        }
        function Xd(d, x, N) {
          return x = Kr(x), N === r ? (N = x, x = 0) : N = Kr(N), d = Mr(d), il(d, x, N);
        }
        function Qd(d, x, N) {
          if (N && typeof N != "boolean" && Xt(d, x, N) && (x = N = r), N === r && (typeof x == "boolean" ? (N = x, x = r) : typeof d == "boolean" && (N = d, d = r)), d === r && x === r ? (d = 0, x = 1) : (d = Kr(d), x === r ? (x = d, d = 0) : x = Kr(x)), d > x) {
            var Z = d;
            d = x, x = Z;
          }
          if (N || d % 1 || x % 1) {
            var fe = Es();
            return Vt(d + fe * (x - d + Cc("1e-" + ((fe + "").length - 1))), x);
          }
          return na(d, x);
        }
        var eh = wi(function(d, x, N) {
          return x = x.toLowerCase(), d + (N ? ic(x) : x);
        });
        function ic(d) {
          return ka(At(d).toLowerCase());
        }
        function nc(d) {
          return d = At(d), d && d.replace(Kt, zc).replace(xc, "");
        }
        function th(d, x, N) {
          d = At(d), x = gr(x);
          var Z = d.length;
          N = N === r ? Z : si(xt(N), 0, Z);
          var fe = N;
          return N -= x.length, N >= 0 && d.slice(N, fe) == x;
        }
        function rh(d) {
          return d = At(d), d && _e.test(d) ? d.replace(Ce, Hc) : d;
        }
        function ih(d) {
          return d = At(d), d && Ee.test(d) ? d.replace(me, "\\$&") : d;
        }
        var nh = wi(function(d, x, N) {
          return d + (N ? "-" : "") + x.toLowerCase();
        }), ah = wi(function(d, x, N) {
          return d + (N ? " " : "") + x.toLowerCase();
        }), sh = ao("toLowerCase");
        function oh(d, x, N) {
          d = At(d), x = xt(x);
          var Z = x ? hi(d) : 0;
          if (!x || Z >= x)
            return d;
          var fe = (x - Z) / 2;
          return hn(en(fe), N) + d + hn(Qi(fe), N);
        }
        function ch(d, x, N) {
          d = At(d), x = xt(x);
          var Z = x ? hi(d) : 0;
          return x && Z < x ? d + hn(x - Z, N) : d;
        }
        function uh(d, x, N) {
          d = At(d), x = xt(x);
          var Z = x ? hi(d) : 0;
          return x && Z < x ? hn(x - Z, N) + d : d;
        }
        function lh(d, x, N) {
          return N || x == null ? x = 0 : x && (x = +x), vu(At(d).replace(ke, ""), x || 0);
        }
        function fh(d, x, N) {
          return (N ? Xt(d, x, N) : x === r) ? x = 1 : x = xt(x), aa(At(d), x);
        }
        function ph() {
          var d = arguments, x = At(d[0]);
          return d.length < 3 ? x : x.replace(d[1], d[2]);
        }
        var hh = wi(function(d, x, N) {
          return d + (N ? "_" : "") + x.toLowerCase();
        });
        function mh(d, x, N) {
          return N && typeof N != "number" && Xt(d, x, N) && (x = N = r), N = N === r ? $ : N >>> 0, N ? (d = At(d), d && (typeof x == "string" || x != null && !Ma(x)) && (x = gr(x), !x && di(d)) ? ei(Tr(d), 0, N) : d.split(x, N)) : [];
        }
        var vh = wi(function(d, x, N) {
          return d + (N ? " " : "") + ka(x);
        });
        function gh(d, x, N) {
          return d = At(d), N = N == null ? 0 : si(xt(N), 0, d.length), x = gr(x), d.slice(N, N + x.length) == x;
        }
        function bh(d, x, N) {
          var Z = ge.templateSettings;
          N && Xt(d, x, N) && (x = r), d = At(d), x = An({}, x, Z, po);
          var fe = An({}, x.imports, Z.imports, po), ye = Ft(fe), qe = Un(fe, ye), Be, Le, Ze = 0, Ye = x.interpolate || Wt, et = "__p += '", ut = Hn(
            (x.escape || Wt).source + "|" + Ye.source + "|" + (Ye === We ? yt : Wt).source + "|" + (x.evaluate || Wt).source + "|$",
            "g"
          ), pt = "//# sourceURL=" + (Mt.call(x, "sourceURL") ? (x.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Rc + "]") + `
`;
          d.replace(ut, function(vt, St, Rt, yr, Qt, xr) {
            return Rt || (Rt = yr), et += d.slice(Ze, xr).replace(or, Kc), St && (Be = !0, et += `' +
__e(` + St + `) +
'`), Qt && (Le = !0, et += `';
` + Qt + `;
__p += '`), Rt && (et += `' +
((__t = (` + Rt + `)) == null ? '' : __t) +
'`), Ze = xr + vt.length, vt;
          }), et += `';
`;
          var mt = Mt.call(x, "variable") && x.variable;
          if (!mt)
            et = `with (obj) {
` + et + `
}
`;
          else if (nt.test(mt))
            throw new gt(c);
          et = (Le ? et.replace(Te, "") : et).replace(Ne, "$1").replace(K, "$1;"), et = "function(" + (mt || "obj") + `) {
` + (mt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Be ? ", __e = _.escape" : "") + (Le ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + et + `return __p
}`;
          var wt = sc(function() {
            return qt(ye, pt + "return " + et).apply(r, qe);
          });
          if (wt.source = et, Aa(wt))
            throw wt;
          return wt;
        }
        function yh(d) {
          return At(d).toLowerCase();
        }
        function xh(d) {
          return At(d).toUpperCase();
        }
        function wh(d, x, N) {
          if (d = At(d), d && (N || x === r))
            return ps(d);
          if (!d || !(x = gr(x)))
            return d;
          var Z = Tr(d), fe = Tr(x), ye = ds(Z, fe), qe = hs(Z, fe) + 1;
          return ei(Z, ye, qe).join("");
        }
        function _h(d, x, N) {
          if (d = At(d), d && (N || x === r))
            return d.slice(0, gs(d) + 1);
          if (!d || !(x = gr(x)))
            return d;
          var Z = Tr(d), fe = hs(Z, Tr(x)) + 1;
          return ei(Z, 0, fe).join("");
        }
        function Sh(d, x, N) {
          if (d = At(d), d && (N || x === r))
            return d.replace(ke, "");
          if (!d || !(x = gr(x)))
            return d;
          var Z = Tr(d), fe = ds(Z, Tr(x));
          return ei(Z, fe).join("");
        }
        function Eh(d, x) {
          var N = ve, Z = te;
          if (It(x)) {
            var fe = "separator" in x ? x.separator : fe;
            N = "length" in x ? xt(x.length) : N, Z = "omission" in x ? gr(x.omission) : Z;
          }
          d = At(d);
          var ye = d.length;
          if (di(d)) {
            var qe = Tr(d);
            ye = qe.length;
          }
          if (N >= ye)
            return d;
          var Be = N - hi(Z);
          if (Be < 1)
            return Z;
          var Le = qe ? ei(qe, 0, Be).join("") : d.slice(0, Be);
          if (fe === r)
            return Le + Z;
          if (qe && (Be += Le.length - Be), Ma(fe)) {
            if (d.slice(Be).search(fe)) {
              var Ze, Ye = Le;
              for (fe.global || (fe = Hn(fe.source, At(ft.exec(fe)) + "g")), fe.lastIndex = 0; Ze = fe.exec(Ye); )
                var et = Ze.index;
              Le = Le.slice(0, et === r ? Be : et);
            }
          } else if (d.indexOf(gr(fe), Be) != Be) {
            var ut = Le.lastIndexOf(fe);
            ut > -1 && (Le = Le.slice(0, ut));
          }
          return Le + Z;
        }
        function Rh(d) {
          return d = At(d), d && de.test(d) ? d.replace(Se, Xc) : d;
        }
        var qh = wi(function(d, x, N) {
          return d + (N ? " " : "") + x.toUpperCase();
        }), ka = ao("toUpperCase");
        function ac(d, x, N) {
          return d = At(d), x = N ? r : x, x === r ? Gc(d) ? tu(d) : Nc(d) : d.match(x) || [];
        }
        var sc = _t(function(d, x) {
          try {
            return hr(d, r, x);
          } catch (N) {
            return Aa(N) ? N : new gt(N);
          }
        }), Ah = Ur(function(d, x) {
          return _r(x, function(N) {
            N = Pr(N), Dr(d, N, Ra(d[N], d));
          }), d;
        });
        function Mh(d) {
          var x = d == null ? 0 : d.length, N = ht();
          return d = x ? Bt(d, function(Z) {
            if (typeof Z[1] != "function")
              throw new Sr(o);
            return [N(Z[0]), Z[1]];
          }) : [], _t(function(Z) {
            for (var fe = -1; ++fe < x; ) {
              var ye = d[fe];
              if (hr(ye[0], this, Z))
                return hr(ye[1], this, Z);
            }
          });
        }
        function Th(d) {
          return Xu(Rr(d, p));
        }
        function Ba(d) {
          return function() {
            return d;
          };
        }
        function Ch(d, x) {
          return d == null || d !== d ? x : d;
        }
        var kh = oo(), Bh = oo(!0);
        function sr(d) {
          return d;
        }
        function Ia(d) {
          return Ls(typeof d == "function" ? d : Rr(d, p));
        }
        function Ih(d) {
          return js(Rr(d, p));
        }
        function $h(d, x) {
          return Ds(d, Rr(x, p));
        }
        var Oh = _t(function(d, x) {
          return function(N) {
            return Ii(N, d, x);
          };
        }), Ph = _t(function(d, x) {
          return function(N) {
            return Ii(d, N, x);
          };
        });
        function $a(d, x, N) {
          var Z = Ft(x), fe = on(x, Z);
          N == null && !(It(x) && (fe.length || !Z.length)) && (N = x, x = d, d = this, fe = on(x, Ft(x)));
          var ye = !(It(N) && "chain" in N) || !!N.chain, qe = Hr(d);
          return _r(fe, function(Be) {
            var Le = x[Be];
            d[Be] = Le, qe && (d.prototype[Be] = function() {
              var Ze = this.__chain__;
              if (ye || Ze) {
                var Ye = d(this.__wrapped__), et = Ye.__actions__ = ir(this.__actions__);
                return et.push({ func: Le, args: arguments, thisArg: d }), Ye.__chain__ = Ze, Ye;
              }
              return Le.apply(d, Vr([this.value()], arguments));
            });
          }), d;
        }
        function Lh() {
          return zt._ === this && (zt._ = ou), this;
        }
        function Oa() {
        }
        function Nh(d) {
          return d = xt(d), _t(function(x) {
            return Fs(x, d);
          });
        }
        var jh = pa(Bt), Dh = pa(ss), Fh = pa(Ln);
        function oc(d) {
          return ya(d) ? Nn(Pr(d)) : ml(d);
        }
        function Uh(d) {
          return function(x) {
            return d == null ? r : oi(d, x);
          };
        }
        var zh = uo(), Hh = uo(!0);
        function Pa() {
          return [];
        }
        function La() {
          return !1;
        }
        function Kh() {
          return {};
        }
        function Wh() {
          return "";
        }
        function Gh() {
          return !0;
        }
        function Vh(d, x) {
          if (d = xt(d), d < 1 || d > k)
            return [];
          var N = $, Z = Vt(d, $);
          x = ht(x), d -= $;
          for (var fe = Fn(Z, x); ++N < d; )
            x(N);
          return fe;
        }
        function Zh(d) {
          return bt(d) ? Bt(d, Pr) : br(d) ? [d] : ir(qo(At(d)));
        }
        function Yh(d) {
          var x = ++au;
          return At(d) + x;
        }
        var Jh = dn(function(d, x) {
          return d + x;
        }, 0), Xh = da("ceil"), Qh = dn(function(d, x) {
          return d / x;
        }, 1), em = da("floor");
        function tm(d) {
          return d && d.length ? sn(d, sr, Xn) : r;
        }
        function rm(d, x) {
          return d && d.length ? sn(d, ht(x, 2), Xn) : r;
        }
        function im(d) {
          return us(d, sr);
        }
        function nm(d, x) {
          return us(d, ht(x, 2));
        }
        function am(d) {
          return d && d.length ? sn(d, sr, ra) : r;
        }
        function sm(d, x) {
          return d && d.length ? sn(d, ht(x, 2), ra) : r;
        }
        var om = dn(function(d, x) {
          return d * x;
        }, 1), cm = da("round"), um = dn(function(d, x) {
          return d - x;
        }, 0);
        function lm(d) {
          return d && d.length ? Dn(d, sr) : 0;
        }
        function fm(d, x) {
          return d && d.length ? Dn(d, ht(x, 2)) : 0;
        }
        return ge.after = Bp, ge.ary = Lo, ge.assign = yd, ge.assignIn = Jo, ge.assignInWith = An, ge.assignWith = xd, ge.at = wd, ge.before = No, ge.bind = Ra, ge.bindAll = Ah, ge.bindKey = jo, ge.castArray = Hp, ge.chain = $o, ge.chunk = Xl, ge.compact = Ql, ge.concat = ef, ge.cond = Mh, ge.conforms = Th, ge.constant = Ba, ge.countBy = up, ge.create = _d, ge.curry = Do, ge.curryRight = Fo, ge.debounce = Uo, ge.defaults = Sd, ge.defaultsDeep = Ed, ge.defer = Ip, ge.delay = $p, ge.difference = tf, ge.differenceBy = rf, ge.differenceWith = nf, ge.drop = af, ge.dropRight = sf, ge.dropRightWhile = of, ge.dropWhile = cf, ge.fill = uf, ge.filter = fp, ge.flatMap = hp, ge.flatMapDeep = mp, ge.flatMapDepth = vp, ge.flatten = Co, ge.flattenDeep = lf, ge.flattenDepth = ff, ge.flip = Op, ge.flow = kh, ge.flowRight = Bh, ge.fromPairs = pf, ge.functions = kd, ge.functionsIn = Bd, ge.groupBy = gp, ge.initial = hf, ge.intersection = mf, ge.intersectionBy = vf, ge.intersectionWith = gf, ge.invert = $d, ge.invertBy = Od, ge.invokeMap = yp, ge.iteratee = Ia, ge.keyBy = xp, ge.keys = Ft, ge.keysIn = ar, ge.map = wn, ge.mapKeys = Ld, ge.mapValues = Nd, ge.matches = Ih, ge.matchesProperty = $h, ge.memoize = Sn, ge.merge = jd, ge.mergeWith = Xo, ge.method = Oh, ge.methodOf = Ph, ge.mixin = $a, ge.negate = En, ge.nthArg = Nh, ge.omit = Dd, ge.omitBy = Fd, ge.once = Pp, ge.orderBy = wp, ge.over = jh, ge.overArgs = Lp, ge.overEvery = Dh, ge.overSome = Fh, ge.partial = qa, ge.partialRight = zo, ge.partition = _p, ge.pick = Ud, ge.pickBy = Qo, ge.property = oc, ge.propertyOf = Uh, ge.pull = wf, ge.pullAll = Bo, ge.pullAllBy = _f, ge.pullAllWith = Sf, ge.pullAt = Ef, ge.range = zh, ge.rangeRight = Hh, ge.rearg = Np, ge.reject = Rp, ge.remove = Rf, ge.rest = jp, ge.reverse = Sa, ge.sampleSize = Ap, ge.set = Hd, ge.setWith = Kd, ge.shuffle = Mp, ge.slice = qf, ge.sortBy = kp, ge.sortedUniq = If, ge.sortedUniqBy = $f, ge.split = mh, ge.spread = Dp, ge.tail = Of, ge.take = Pf, ge.takeRight = Lf, ge.takeRightWhile = Nf, ge.takeWhile = jf, ge.tap = ep, ge.throttle = Fp, ge.thru = xn, ge.toArray = Vo, ge.toPairs = tc, ge.toPairsIn = rc, ge.toPath = Zh, ge.toPlainObject = Yo, ge.transform = Wd, ge.unary = Up, ge.union = Df, ge.unionBy = Ff, ge.unionWith = Uf, ge.uniq = zf, ge.uniqBy = Hf, ge.uniqWith = Kf, ge.unset = Gd, ge.unzip = Ea, ge.unzipWith = Io, ge.update = Vd, ge.updateWith = Zd, ge.values = Ei, ge.valuesIn = Yd, ge.without = Wf, ge.words = ac, ge.wrap = zp, ge.xor = Gf, ge.xorBy = Vf, ge.xorWith = Zf, ge.zip = Yf, ge.zipObject = Jf, ge.zipObjectDeep = Xf, ge.zipWith = Qf, ge.entries = tc, ge.entriesIn = rc, ge.extend = Jo, ge.extendWith = An, $a(ge, ge), ge.add = Jh, ge.attempt = sc, ge.camelCase = eh, ge.capitalize = ic, ge.ceil = Xh, ge.clamp = Jd, ge.clone = Kp, ge.cloneDeep = Gp, ge.cloneDeepWith = Vp, ge.cloneWith = Wp, ge.conformsTo = Zp, ge.deburr = nc, ge.defaultTo = Ch, ge.divide = Qh, ge.endsWith = th, ge.eq = kr, ge.escape = rh, ge.escapeRegExp = ih, ge.every = lp, ge.find = pp, ge.findIndex = Mo, ge.findKey = Rd, ge.findLast = dp, ge.findLastIndex = To, ge.findLastKey = qd, ge.floor = em, ge.forEach = Oo, ge.forEachRight = Po, ge.forIn = Ad, ge.forInRight = Md, ge.forOwn = Td, ge.forOwnRight = Cd, ge.get = Ta, ge.gt = Yp, ge.gte = Jp, ge.has = Id, ge.hasIn = Ca, ge.head = ko, ge.identity = sr, ge.includes = bp, ge.indexOf = df, ge.inRange = Xd, ge.invoke = Pd, ge.isArguments = li, ge.isArray = bt, ge.isArrayBuffer = Xp, ge.isArrayLike = nr, ge.isArrayLikeObject = Ot, ge.isBoolean = Qp, ge.isBuffer = ti, ge.isDate = ed, ge.isElement = td, ge.isEmpty = rd, ge.isEqual = id, ge.isEqualWith = nd, ge.isError = Aa, ge.isFinite = ad, ge.isFunction = Hr, ge.isInteger = Ho, ge.isLength = Rn, ge.isMap = Ko, ge.isMatch = sd, ge.isMatchWith = od, ge.isNaN = cd, ge.isNative = ud, ge.isNil = fd, ge.isNull = ld, ge.isNumber = Wo, ge.isObject = It, ge.isObjectLike = $t, ge.isPlainObject = ji, ge.isRegExp = Ma, ge.isSafeInteger = pd, ge.isSet = Go, ge.isString = qn, ge.isSymbol = br, ge.isTypedArray = Si, ge.isUndefined = dd, ge.isWeakMap = hd, ge.isWeakSet = md, ge.join = bf, ge.kebabCase = nh, ge.last = Ar, ge.lastIndexOf = yf, ge.lowerCase = ah, ge.lowerFirst = sh, ge.lt = vd, ge.lte = gd, ge.max = tm, ge.maxBy = rm, ge.mean = im, ge.meanBy = nm, ge.min = am, ge.minBy = sm, ge.stubArray = Pa, ge.stubFalse = La, ge.stubObject = Kh, ge.stubString = Wh, ge.stubTrue = Gh, ge.multiply = om, ge.nth = xf, ge.noConflict = Lh, ge.noop = Oa, ge.now = _n, ge.pad = oh, ge.padEnd = ch, ge.padStart = uh, ge.parseInt = lh, ge.random = Qd, ge.reduce = Sp, ge.reduceRight = Ep, ge.repeat = fh, ge.replace = ph, ge.result = zd, ge.round = cm, ge.runInContext = $e, ge.sample = qp, ge.size = Tp, ge.snakeCase = hh, ge.some = Cp, ge.sortedIndex = Af, ge.sortedIndexBy = Mf, ge.sortedIndexOf = Tf, ge.sortedLastIndex = Cf, ge.sortedLastIndexBy = kf, ge.sortedLastIndexOf = Bf, ge.startCase = vh, ge.startsWith = gh, ge.subtract = um, ge.sum = lm, ge.sumBy = fm, ge.template = bh, ge.times = Vh, ge.toFinite = Kr, ge.toInteger = xt, ge.toLength = Zo, ge.toLower = yh, ge.toNumber = Mr, ge.toSafeInteger = bd, ge.toString = At, ge.toUpper = xh, ge.trim = wh, ge.trimEnd = _h, ge.trimStart = Sh, ge.truncate = Eh, ge.unescape = Rh, ge.uniqueId = Yh, ge.upperCase = qh, ge.upperFirst = ka, ge.each = Oo, ge.eachRight = Po, ge.first = ko, $a(ge, (function() {
          var d = {};
          return $r(ge, function(x, N) {
            Mt.call(ge.prototype, N) || (d[N] = x);
          }), d;
        })(), { chain: !1 }), ge.VERSION = a, _r(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(d) {
          ge[d].placeholder = ge;
        }), _r(["drop", "take"], function(d, x) {
          Et.prototype[d] = function(N) {
            N = N === r ? 1 : jt(xt(N), 0);
            var Z = this.__filtered__ && !x ? new Et(this) : this.clone();
            return Z.__filtered__ ? Z.__takeCount__ = Vt(N, Z.__takeCount__) : Z.__views__.push({
              size: Vt(N, $),
              type: d + (Z.__dir__ < 0 ? "Right" : "")
            }), Z;
          }, Et.prototype[d + "Right"] = function(N) {
            return this.reverse()[d](N).reverse();
          };
        }), _r(["filter", "map", "takeWhile"], function(d, x) {
          var N = x + 1, Z = N == h || N == B;
          Et.prototype[d] = function(fe) {
            var ye = this.clone();
            return ye.__iteratees__.push({
              iteratee: ht(fe, 3),
              type: N
            }), ye.__filtered__ = ye.__filtered__ || Z, ye;
          };
        }), _r(["head", "last"], function(d, x) {
          var N = "take" + (x ? "Right" : "");
          Et.prototype[d] = function() {
            return this[N](1).value()[0];
          };
        }), _r(["initial", "tail"], function(d, x) {
          var N = "drop" + (x ? "" : "Right");
          Et.prototype[d] = function() {
            return this.__filtered__ ? new Et(this) : this[N](1);
          };
        }), Et.prototype.compact = function() {
          return this.filter(sr);
        }, Et.prototype.find = function(d) {
          return this.filter(d).head();
        }, Et.prototype.findLast = function(d) {
          return this.reverse().find(d);
        }, Et.prototype.invokeMap = _t(function(d, x) {
          return typeof d == "function" ? new Et(this) : this.map(function(N) {
            return Ii(N, d, x);
          });
        }), Et.prototype.reject = function(d) {
          return this.filter(En(ht(d)));
        }, Et.prototype.slice = function(d, x) {
          d = xt(d);
          var N = this;
          return N.__filtered__ && (d > 0 || x < 0) ? new Et(N) : (d < 0 ? N = N.takeRight(-d) : d && (N = N.drop(d)), x !== r && (x = xt(x), N = x < 0 ? N.dropRight(-x) : N.take(x - d)), N);
        }, Et.prototype.takeRightWhile = function(d) {
          return this.reverse().takeWhile(d).reverse();
        }, Et.prototype.toArray = function() {
          return this.take($);
        }, $r(Et.prototype, function(d, x) {
          var N = /^(?:filter|find|map|reject)|While$/.test(x), Z = /^(?:head|last)$/.test(x), fe = ge[Z ? "take" + (x == "last" ? "Right" : "") : x], ye = Z || /^find/.test(x);
          fe && (ge.prototype[x] = function() {
            var qe = this.__wrapped__, Be = Z ? [1] : arguments, Le = qe instanceof Et, Ze = Be[0], Ye = Le || bt(qe), et = function(St) {
              var Rt = fe.apply(ge, Vr([St], Be));
              return Z && ut ? Rt[0] : Rt;
            };
            Ye && N && typeof Ze == "function" && Ze.length != 1 && (Le = Ye = !1);
            var ut = this.__chain__, pt = !!this.__actions__.length, mt = ye && !ut, wt = Le && !pt;
            if (!ye && Ye) {
              qe = wt ? qe : new Et(this);
              var vt = d.apply(qe, Be);
              return vt.__actions__.push({ func: xn, args: [et], thisArg: r }), new Er(vt, ut);
            }
            return mt && wt ? d.apply(this, Be) : (vt = this.thru(et), mt ? Z ? vt.value()[0] : vt.value() : vt);
          });
        }), _r(["pop", "push", "shift", "sort", "splice", "unshift"], function(d) {
          var x = Hi[d], N = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru", Z = /^(?:pop|shift)$/.test(d);
          ge.prototype[d] = function() {
            var fe = arguments;
            if (Z && !this.__chain__) {
              var ye = this.value();
              return x.apply(bt(ye) ? ye : [], fe);
            }
            return this[N](function(qe) {
              return x.apply(bt(qe) ? qe : [], fe);
            });
          };
        }), $r(Et.prototype, function(d, x) {
          var N = ge[x];
          if (N) {
            var Z = N.name + "";
            Mt.call(bi, Z) || (bi[Z] = []), bi[Z].push({ name: x, func: N });
          }
        }), bi[pn(r, b).name] = [{
          name: "wrapper",
          func: r
        }], Et.prototype.clone = Su, Et.prototype.reverse = Eu, Et.prototype.value = Ru, ge.prototype.at = tp, ge.prototype.chain = rp, ge.prototype.commit = ip, ge.prototype.next = np, ge.prototype.plant = sp, ge.prototype.reverse = op, ge.prototype.toJSON = ge.prototype.valueOf = ge.prototype.value = cp, ge.prototype.first = ge.prototype.head, qi && (ge.prototype[qi] = ap), ge;
      }), mi = ru();
      ri ? ((ri.exports = mi)._ = mi, In._ = mi) : zt._ = mi;
    }).call(lodash);
  })(lodash$1, lodash$1.exports)), lodash$1.exports;
}
var lodashExports = requireLodash();
const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports), createTestOneController = (e, t) => {
  const r = pathBrowserifyExports.join(process$1.cwd(), "testone");
  existsSync(r) || mkdirSync(r);
  const a = watch(r), u = pathBrowserifyExports.join(r, "commands.json"), n = _.debounce(() => {
    existsSync(u);
  }, 1e3), o = pathBrowserifyExports.join(r, "users.json"), c = _.debounce(() => {
    existsSync(o);
  }, 1e3), f = pathBrowserifyExports.join(r, "channels.json"), l = _.debounce(() => {
    existsSync(f);
  }, 1e3), s = pathBrowserifyExports.join(r, "user.json"), p = _.debounce(() => {
    existsSync(s);
  }, 1e3), m = pathBrowserifyExports.join(r, "bot.json"), g = _.debounce(() => {
    existsSync(m);
  }, 1e3), y = pathBrowserifyExports.join(r, ".cache", "private.message.json"), v = pathBrowserifyExports.join(r, ".cache", "public.message.json"), E = pathBrowserifyExports.dirname(y);
  mkdirSync(E);
  const b = () => {
    try {
      const D = existsSync(u) ? JSON.parse(readFileSync(u, "utf-8")) : [], G = existsSync(o) ? JSON.parse(readFileSync(o, "utf-8")) : [], V = existsSync(f) ? JSON.parse(readFileSync(f, "utf-8")) : [], Q = existsSync(s) ? JSON.parse(readFileSync(s, "utf-8")) : null, re = existsSync(m) ? JSON.parse(readFileSync(m, "utf-8")) : null, ve = existsSync(y) ? JSON.parse(readFileSync(y, "utf-8")) : [], te = existsSync(v) ? JSON.parse(readFileSync(v, "utf-8")) : [];
      e?.send(
        stringify({
          type: "init.data",
          payload: {
            commands: D,
            users: G,
            channels: V,
            user: Q,
            bot: re,
            privateMessage: ve,
            publicMessage: te
          }
        })
      );
    } catch (D) {
      logger.error({
        code: ResultCode.Fail,
        message: "初始化数据失败",
        data: D
      });
    }
  }, q = (D, G) => {
    existsSync(D === "private" ? y : v);
  }, O = (D, G) => {
    const V = D === "private" ? y : v, Q = existsSync(V) ? JSON.parse(readFileSync(V)) : [];
    Q.push(G), writeFile(V, JSON.stringify(Q, null, 2), (re) => {
      re && logger.error({
        code: ResultCode.Fail,
        message: `写入 ${D} 消息失败`,
        data: re
      });
    });
  };
  return {
    onMessage: (D) => {
      D.type === "init.data" ? b() : D.type === "commands" ? n() : D.type === "users" ? c() : D.type === "channels" ? l() : D.type === "user" ? p() : D.type === "bot" ? g() : D.type === "private.message.delete" ? (D.payload.CreateAt, q("private")) : D.type === "public.message.delete" ? (D.payload.CreateAt, q("public")) : D.type === "private.message.save" ? O("private", D.payload) : D.type === "public.message.save" && O("public", D.payload);
    },
    close: () => {
      logger.info({
        code: ResultCode.Ok,
        message: "WebSocket connection closed",
        data: null
      }), a.close();
    },
    error: (D) => {
      logger.error({
        code: ResultCode.Fail,
        message: "WebSocket error:",
        data: D
      }), a.close();
    }
  };
}, handleApi = (e, t) => {
  if (childrenClient.has(e)) {
    const r = childrenClient.get(e);
    r && r.readyState === browserExports.WebSocket.OPEN ? r.send(t) : childrenClient.delete(e);
  } else if (fullClient.has(e)) {
    const r = fullClient.get(e);
    r && r.readyState === browserExports.WebSocket.OPEN ? r.send(t) : fullClient.delete(e);
  }
}, handleAction = (e, t) => {
  if (childrenClient.has(e)) {
    const r = childrenClient.get(e);
    r && r.readyState === browserExports.WebSocket.OPEN ? r.send(t) : childrenClient.delete(e);
  } else if (fullClient.has(e)) {
    const r = fullClient.get(e);
    r && r.readyState === browserExports.WebSocket.OPEN ? r.send(t) : fullClient.delete(e);
  }
}, handleEvent = (e, t) => {
  if (fullClient.forEach((n, o) => {
    n.readyState === browserExports.WebSocket.OPEN ? n.send(e) : childrenClient.delete(o);
  }), !t) {
    logger.error({
      code: ResultCode.Fail,
      message: "消息缺少标识符 ID",
      data: null
    });
    return;
  }
  const r = () => {
    if (childrenClient.size === 0)
      return;
    if (childrenClient.size === 1) {
      const [c, f] = childrenClient.entries().next().value;
      childrenBind.set(t, c), f.send(e);
      return;
    }
    let n = 1 / 0, o = null;
    if (childrenClient.forEach((c, f) => {
      const l = Array.from(childrenBind.values()).filter((s) => s === f).length;
      l < n && (n = l, o = f);
    }), o) {
      const c = childrenClient.get(o);
      c && c.readyState === browserExports.WebSocket.OPEN ? (childrenBind.set(t, o), c.send(e)) : (childrenClient.delete(o), r());
    } else
      logger.error({
        code: ResultCode.Fail,
        message: "服务端出现意外，无法绑定客户端",
        data: null
      });
  };
  if (!childrenBind.has(t)) {
    r();
    return;
  }
  const a = childrenBind.get(t);
  if (!childrenClient.has(a)) {
    r();
    return;
  }
  const u = childrenClient.get(a);
  if (!u || u.readyState !== browserExports.WebSocket.OPEN) {
    childrenClient.delete(a), r();
    return;
  }
  u.send(e);
}, setChildrenClient = (e, t) => {
  childrenClient.set(e, t), t.on("message", (r) => {
    if (globalThis.sandbox) {
      globalThis.testoneClient && globalThis.testoneClient.readyState === browserExports.WebSocket.OPEN && globalThis.testoneClient.send(r.toString());
      return;
    }
    platformClient.size > 0 && platformClient.forEach((a, u) => {
      a.readyState === browserExports.WebSocket.OPEN ? a.send(r) : platformClient.delete(u);
    });
  }), t.on("close", () => {
    childrenClient.delete(e), logger.debug({
      code: ResultCode.Fail,
      message: `Client ${e} disconnected`,
      data: null
    });
  }), t.on("error", (r) => {
    logger.error({
      code: ResultCode.Fail,
      message: `Client ${e} error`,
      data: r
    });
  });
}, setFullClient = (e, t) => {
  fullClient.set(e, t), t.on("message", (r) => {
    if (globalThis.sandbox) {
      globalThis.testoneClient && globalThis.testoneClient.readyState === browserExports.WebSocket.OPEN && globalThis.testoneClient.send(r.toString());
      return;
    }
    platformClient.size > 0 && platformClient.forEach((a, u) => {
      a.readyState === browserExports.WebSocket.OPEN ? a.send(r) : platformClient.delete(u);
    });
  }), t.on("close", () => {
    fullClient.delete(e), logger.debug({
      code: ResultCode.Fail,
      message: `Client ${e} disconnected`,
      data: null
    });
  });
}, setPlatformClient = (e, t) => {
  if (platformClient.size > 0) {
    logger.error({
      code: ResultCode.Fail,
      message: `平台连接已存在: ${e}`,
      data: null
    }), t.close();
    return;
  }
  platformClient.set(e, t), t.on("message", (r) => {
    try {
      const a = parse$2(r.toString());
      if (logger.debug({
        code: ResultCode.Ok,
        message: "服务端接收到消息",
        data: a
      }), a.apiId) {
        const u = a.DeviceId;
        handleApi(u, r);
      } else if (a?.actionId) {
        const u = a.DeviceId;
        handleAction(u, r);
      } else if (a?.name) {
        const u = a.ChannelId || a.GuildId || a.DeviceId;
        handleEvent(r, u);
      }
    } catch (a) {
      logger.error({
        code: ResultCode.Fail,
        message: "服务端解析平台消息失败",
        data: a
      });
    }
  }), t.on("close", () => {
    platformClient.delete(e), logger.debug({
      code: ResultCode.Fail,
      message: `Client ${e} disconnected`,
      data: null
    });
  }), t.on("error", (r) => {
    logger.error({
      code: ResultCode.Fail,
      message: `Client ${e} error`,
      data: r
    });
  });
}, setTestOnePlatformClient = (e) => {
  globalThis.testoneClient && delete globalThis.testoneClient, globalThis.testoneClient = e;
  const t = createTestOneController(e);
  e.on("message", (r) => {
    try {
      const a = parse$2(r.toString());
      if (logger.debug({
        code: ResultCode.Ok,
        message: "测试端接收到消息",
        data: a
      }), a.apiId) {
        const u = a.DeviceId;
        handleApi(u, r);
      } else if (a?.actionId) {
        const u = a.DeviceId;
        handleAction(u, r);
      } else if (a?.name) {
        const u = a.ChannelId || a.GuildId || a.DeviceId;
        handleEvent(r, u);
      } else
        t.onMessage(a);
    } catch (a) {
      logger.error({
        code: ResultCode.Fail,
        message: "测试端解析平台消息失败",
        data: a
      });
    }
  }), e.on("close", () => {
    t.close();
  }), e.on("error", (r) => {
    t.error(r);
  });
}, cbpServer = (e, t) => {
  globalThis.chatbotServer && delete globalThis.chatbotServer;
  let r = 0;
  const a = () => {
    r++;
    const n = r > 3 ? 1e3 * 6 : 1e3 * 1;
    let o = r > 6 ? 1e3 * r * 2 : n;
    o >= 1e3 * 60 * 10 && (o = 1e3 * 60 * 10);
    const c = (o / 1e3 / 60).toFixed(2);
    return logger.info(`[alemonjs][CBP Server] 第 ${r} 次重连，等待 ${c} 分钟后重新连接`), o;
  }, u = () => {
    try {
      const n = new mod();
      n.use(router.routes()), n.use(router.allowedMethods()), n.use(
        koaCors({
          origin: "*",
          // 允许所有来源
          allowMethods: ["GET", "POST", "PUT", "DELETE"]
          // 允许的 HTTP 方法
        })
      );
      const o = n.listen(e, t);
      globalThis.chatbotServer = new browserExports.WebSocketServer({ server: o }), globalThis.chatbotServer.on("connection", (c, f) => {
        if (f.url === "/testone") {
          if (!globalThis.sandbox) {
            c.close(4e3, "Sandbox mode required");
            return;
          }
          setTestOnePlatformClient(c);
          return;
        }
        const l = f.headers, s = l[USER_AGENT_HEADER] || USER_AGENT_HEADER_VALUE_MAP.client, p = l[DEVICE_ID_HEADER];
        if (!p) {
          c.close(4e3, "Missing Device ID");
          return;
        }
        if (logger.debug({
          code: ResultCode.Ok,
          message: `Client ${p} connected`,
          data: null
        }), s === USER_AGENT_HEADER_VALUE_MAP.platform) {
          setPlatformClient(p, c);
          return;
        } else s === USER_AGENT_HEADER_VALUE_MAP.client && c.send(
          stringify({
            active: "sync",
            payload: {
              value: getConfig().value,
              args: getConfig().argv,
              package: {
                version: getConfig().package?.version
              },
              env: {
                login: process$1.env.login,
                platform: process$1.env.platform,
                port: process$1.env.port
              }
            },
            // 主动消息
            activeId: p
          })
        );
        if (l[FULL_RECEIVE_HEADER] === "1") {
          setFullClient(p, c);
          return;
        }
        setChildrenClient(p, c);
      }), chatbotServer.on("error", (c) => {
        if (platformClient.clear(), childrenClient.clear(), fullClient.clear(), delete globalThis.testoneClient, c.code === "EADDRINUSE") {
          logger.error({
            code: ResultCode.FailInternal,
            message: `端口 ${e} 已被占用，请检查是否有其他服务在运行`,
            data: c.message
          });
          const f = a();
          setTimeout(() => {
            u();
          }, f);
        } else
          logger.error({
            code: ResultCode.FailInternal,
            message: "WebSocket server error",
            data: c.message || "Unknown error"
          });
      }), chatbotServer.on("close", () => {
        logger.warn({
          code: ResultCode.Ok,
          message: "WebSocket server closed",
          data: null
        }), platformClient.clear(), childrenClient.clear(), fullClient.clear();
      });
    } catch (n) {
      logger.error({
        code: ResultCode.FailInternal,
        message: "创建 CBP 服务器失败",
        data: n
      });
    }
  };
  u();
}, initRequire$1 = () => {
};
initRequire$1.resolve = () => "";
const require$2 = initRequire$1;
function startPlatformAdapterWithFallback() {
  const t = getConfigValue()?.process ?? {}, r = {
    // 重启延迟时间
    RESTART_DELAY: t?.restart_delay ?? 3e3,
    // 定时器，等待子进程 ready 消息的时间
    FORK_TIMEOUT: t?.fork_timeout ?? 6e3,
    // 重新启动延迟时间
    FORK_RESTART_DELAY: t?.fork_restart_delay ?? 5e3
  }, a = process$1.env.platform;
  if (!a) {
    logger?.error?.({
      code: ResultCode.Fail,
      message: "未配置平台连接路径",
      data: null
    });
    return;
  }
  let u = "", n = !1, o = !1;
  try {
    u = require$2.resolve(a);
  } catch {
    logger?.warn?.({
      code: ResultCode.Fail,
      message: "平台连接包未支持 require",
      data: null
    });
    return;
  }
  const c = async () => {
    if (!o) {
      o = !0, n = !0;
      try {
        const s = await import(u.startsWith("file://") ? u : `file://${u}`);
        typeof s.default == "function" ? (await s.default(), logger?.debug?.({
          code: ResultCode.Ok,
          message: "通过 import 启动平台连接完成",
          data: null
        })) : logger?.warn?.({
          code: ResultCode.Fail,
          message: "通过 import 启动平台连接，但未找到默认导出函数",
          data: null
        });
      } catch (l) {
        logger?.error?.({
          code: ResultCode.Fail,
          message: "import 启动平台连接失败",
          data: l
        });
      }
    }
  }, f = () => {
    if (o || n)
      return;
    const l = {
      restarted: !1,
      ready: !1,
      isKilling: !1
      // 初始化标记
    }, s = () => {
      l.timer && (clearTimeout(l.timer), l.timer = void 0), l.child && l.child.removeAllListeners();
    }, p = () => {
      l.restarted || o || (l.restarted = !0, s(), setTimeout(() => {
        !o && !n && f();
      }, r.RESTART_DELAY));
    }, m = (y) => {
      o || (n = !0, s(), logger?.warn?.({
        code: ResultCode.Fail,
        message: "fork 启动平台连接失败，将尝试 import 加载",
        data: y
      }), c());
    }, g = () => {
      if (!l.ready && !o) {
        logger?.warn?.({
          code: ResultCode.Fail,
          message: "平台连接未及时响应（未发送 ready 消息），降级为 import 加载, 请升级对应的平台连接包以提高进程稳定性",
          data: null
        }), l.isKilling = !0;
        try {
          l.child?.kill();
        } catch {
        }
        m();
      }
    };
    try {
      l.child = empty.fork(u, [], {
        execArgv: process$1.execArgv
      }), l.timer = setTimeout(g, r.FORK_TIMEOUT), l.child.on("exit", (y, v) => {
        s(), !l.isKilling && (o || (logger?.warn?.({
          code: ResultCode.Fail,
          message: `平台连接子进程已退出，code=${y}, signal=${v}，${r.FORK_RESTART_DELAY / 1e3}秒后自动重启`,
          data: null
        }), p()));
      }), l.child.on("message", (y) => {
        try {
          (typeof y == "string" ? JSON.parse(y) : y)?.type === "ready" && (l.ready = !0, l.timer && (clearTimeout(l.timer), l.timer = void 0), logger?.debug?.({
            code: ResultCode.Ok,
            message: "平台连接已就绪（子进程 fork 模式）",
            data: null
          }), l.child?.send?.({ type: "start" }));
        } catch (v) {
          logger?.error?.({
            code: ResultCode.Fail,
            message: "平台连接进程通信数据格式错误",
            data: v
          });
        }
      }), l.child.on("error", (y) => {
        m(y);
      });
    } catch (y) {
      m(y);
    }
  };
  f();
}
const initRequire = () => {
};
initRequire.resolve = () => "";
const require$1 = initRequire;
function startModuleAdapter() {
  const t = getConfigValue()?.process ?? {};
  let r = "";
  const a = {
    RESTART_DELAY: t?.restart_delay ?? 3e3,
    FORK_TIMEOUT: t?.fork_timeout ?? 6e3
    // 6秒默认超时
  };
  try {
    r = require$1.resolve("../client.js");
  } catch (n) {
    logger?.warn?.({
      code: ResultCode.Fail,
      message: "模块加载进程启动失败",
      data: n
    });
    return;
  }
  const u = () => {
    const n = {
      restarted: !1,
      ready: !1
    }, o = () => {
      n.timer && (clearTimeout(n.timer), n.timer = void 0), n.child && n.child.removeAllListeners();
    }, c = () => {
      n.restarted || (n.restarted = !0, o(), setTimeout(() => {
        u();
      }, a.RESTART_DELAY));
    }, f = () => {
      if (!n.ready) {
        logger?.error?.({
          code: ResultCode.Fail,
          message: "模块加载未及时响应（未发送 ready 消息）",
          data: null
        });
        try {
          n.child?.kill();
        } catch {
        }
      }
    };
    try {
      n.child = empty.fork(r, [], {
        execArgv: process$1.execArgv
      }), n.timer = setTimeout(f, a.FORK_TIMEOUT), n.child.on("exit", (l, s) => {
        o(), logger?.warn?.({
          code: ResultCode.Fail,
          message: `模块加载子进程已退出，code=${l}, signal=${s}，${a.RESTART_DELAY / 1e3}秒后自动重启`,
          data: null
        }), c();
      }), n.child.on("message", (l) => {
        try {
          (typeof l == "string" ? JSON.parse(l) : l)?.type === "ready" && (n.ready = !0, o(), logger?.debug?.({
            code: ResultCode.Ok,
            message: "模块加载已就绪（子进程 fork 模式）",
            data: null
          }), n.child?.send?.({ type: "start" }));
        } catch (s) {
          logger?.error?.({
            code: ResultCode.Fail,
            message: "模块加载进程通信数据格式错误",
            data: s
          });
        }
      }), n.child.on("error", (l) => {
        logger?.error?.({
          code: ResultCode.Fail,
          message: "模块加载子进程发生错误",
          data: l
        });
      });
    } catch (l) {
      logger?.warn?.({
        code: ResultCode.Fail,
        message: "fork 启动模块加载失败",
        data: l
      }), setTimeout(() => {
        u();
      }, a.RESTART_DELAY);
    }
  };
  u();
}
const createOptionsByKey = (e, t, r) => {
  const a = getConfig();
  return e?.[t] ?? a.argv?.[t] ?? a.value?.[t] ?? r;
}, startPlatform = (e) => {
  const t = createOptionsByKey(e, "platform", ""), r = createOptionsByKey(e, "login", "");
  if (!t && !r) {
    globalThis.sandbox = !0;
    return;
  }
  if (t) {
    const a = filePrefixCommon;
    a.test(t) ? (process$1.env.platform = t, process$1.env.login = t.replace(a, "")) : (process$1.env.platform = t, process$1.env.login = t);
  } else
    process$1.env.platform = `${defaultPlatformCommonPrefix}${r}`, process$1.env.login = r;
  r && (process$1.env.login = r), startPlatformAdapterWithFallback();
}, startClient = (e) => {
  process$1.env.input = createOptionsByKey(e, "input", ""), process$1.env.output = createOptionsByKey(e, "output", ""), process$1.env.is_full_receive = String(createOptionsByKey(e, "is_full_receive", !0)), process$1.env.port = String(createOptionsByKey(e, "port", defaultPort)), process$1.env.url = createOptionsByKey(e, "url", ""), startModuleAdapter();
}, start = (e = {}) => {
  typeof e == "string" && (e = { input: e });
  const t = createOptionsByKey(e, "port", defaultPort), r = createOptionsByKey(e, "serverPort", "");
  process$1.env.port = t, process$1.env.serverPort = r, cbpServer(t, () => {
    const a = `http://127.0.0.1:${t}`, u = `ws://127.0.0.1:${t}`;
    logger.info(`[CBP server started at ${a}]`), logger.info(`[CBP server started at ${u}]`), startClient(e), startPlatform(e);
  });
};
export {
  ActionsEventEnum,
  Ark,
  BT,
  ChildrenApp,
  ConfigCore,
  Core,
  Image,
  ImageFile,
  ImageURL,
  Link,
  Logger,
  MD,
  Mention,
  Middleware,
  MiddlewareRouter,
  OnMiddleware,
  OnProcessor,
  OnResponse,
  ProcessorEventAutoClearMap,
  ProcessorEventUserAudoClearMap,
  Response$1 as Response,
  ResponseMiddleware,
  ResponseRouter,
  ResultCode,
  State,
  StateSubscribe,
  SubscribeList,
  Text,
  cbpClient,
  cbpPlatform,
  cbpServer,
  core,
  createDataFormat,
  createEventName,
  createEventValue,
  createHash,
  createResult,
  createSelects,
  defineChildren,
  defineMiddleware,
  defineResponse,
  expendCycle,
  expendEvent,
  expendMiddleware,
  expendSubscribe,
  expendSubscribeCreate,
  expendSubscribeMount,
  expendSubscribeUnmount,
  format,
  getConfig,
  getConfigValue,
  getInputExportPath,
  getRecursiveDirFiles,
  lazy,
  loadChildren,
  loadChildrenFile,
  loadModels,
  logger$1 as logger,
  onGroup,
  onMiddleware,
  onProcessor,
  onResponse,
  onSelects,
  onState,
  run,
  sendToChannel,
  sendToUser,
  showErrorModule,
  start,
  stringToNumber,
  unChildren,
  unState,
  useChannel,
  useClient,
  useMenber,
  useMention,
  useMessage,
  useObserver,
  useSend,
  useSends,
  useState,
  useSubscribe,
  useUserHashKey
};
